//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmediaservices

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// AacAudio - Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudio struct {
	Audio
	// The encoding profile to be used when encoding audio with AAC.
	Profile *AacAudioProfile `json:"profile,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AacAudio.
func (a AacAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Audio.marshalInternal(objectMap, "#Microsoft.Media.AacAudio")
	populate(objectMap, "profile", a.Profile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AacAudio.
func (a *AacAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "profile":
			err = unpopulate(val, &a.Profile)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Audio.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AbsoluteClipTime - Specifies the clip time as an absolute time position in the media file. The absolute time can point to a different position depending
// on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTime struct {
	ClipTime
	// REQUIRED; The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time *string `json:"time,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AbsoluteClipTime.
func (a AbsoluteClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ClipTime.marshalInternal(objectMap, "#Microsoft.Media.AbsoluteClipTime")
	populate(objectMap, "time", a.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "time":
			err = unpopulate(val, &a.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ClipTime.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type AccessControl struct {
	// The behavior for IP access control in Key Delivery.
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
	IPAllowList []*string `json:"ipAllowList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessControl.
func (a AccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", a.DefaultAction)
	populate(objectMap, "ipAllowList", a.IPAllowList)
	return json.Marshal(objectMap)
}

type AccountEncryption struct {
	// REQUIRED; The type of key used to encrypt the Account Key.
	Type *AccountEncryptionKeyType `json:"type,omitempty"`

	// The Key Vault identity.
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// READ-ONLY; The current status of the Key Vault mapping.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// AccountFilter - An Account Filter.
type AccountFilter struct {
	ProxyResource
	// The Media Filter properties.
	Properties *MediaFilterProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilter.
func (a AccountFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	return json.Marshal(objectMap)
}

// AccountFilterCollection - A collection of AccountFilter items.
type AccountFilterCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of AccountFilter items.
	Value []*AccountFilter `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilterCollection.
func (a AccountFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccountFiltersCreateOrUpdateOptions contains the optional parameters for the AccountFilters.CreateOrUpdate method.
type AccountFiltersCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersDeleteOptions contains the optional parameters for the AccountFilters.Delete method.
type AccountFiltersDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersGetOptions contains the optional parameters for the AccountFilters.Get method.
type AccountFiltersGetOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersListOptions contains the optional parameters for the AccountFilters.List method.
type AccountFiltersListOptions struct {
	// placeholder for future optional parameters
}

// AccountFiltersUpdateOptions contains the optional parameters for the AccountFilters.Update method.
type AccountFiltersUpdateOptions struct {
	// placeholder for future optional parameters
}

// AkamaiAccessControl - Akamai access control
type AkamaiAccessControl struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []*AkamaiSignatureHeaderAuthenticationKey `json:"akamaiSignatureHeaderAuthenticationKeyList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiAccessControl.
func (a AkamaiAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "akamaiSignatureHeaderAuthenticationKeyList", a.AkamaiSignatureHeaderAuthenticationKeyList)
	return json.Marshal(objectMap)
}

// AkamaiSignatureHeaderAuthenticationKey - Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKey struct {
	// authentication key
	Base64Key *string `json:"base64Key,omitempty"`

	// The expiration time of the authentication key.
	Expiration *time.Time `json:"expiration,omitempty"`

	// identifier of the key
	Identifier *string `json:"identifier,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a AkamaiSignatureHeaderAuthenticationKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64Key", a.Base64Key)
	populate(objectMap, "expiration", (*timeRFC3339)(a.Expiration))
	populate(objectMap, "identifier", a.Identifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a *AkamaiSignatureHeaderAuthenticationKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base64Key":
			err = unpopulate(val, &a.Base64Key)
			delete(rawMsg, key)
		case "expiration":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.Expiration = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, &a.Identifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Asset - An Asset.
type Asset struct {
	ProxyResource
	// The resource properties.
	Properties *AssetProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	return json.Marshal(objectMap)
}

// AssetCollection - A collection of Asset items.
type AssetCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Asset items.
	Value []*Asset `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetCollection.
func (a AssetCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AssetContainerSas - The Asset Storage container SAS URLs.
type AssetContainerSas struct {
	// The list of Asset container SAS URLs.
	AssetContainerSasUrls []*string `json:"assetContainerSasUrls,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetContainerSas.
func (a AssetContainerSas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetContainerSasUrls", a.AssetContainerSasUrls)
	return json.Marshal(objectMap)
}

// AssetFileEncryptionMetadata - The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadata struct {
	// REQUIRED; The Asset File Id.
	AssetFileID *string `json:"assetFileId,omitempty"`

	// The Asset File name.
	AssetFileName *string `json:"assetFileName,omitempty"`

	// The Asset File initialization vector.
	InitializationVector *string `json:"initializationVector,omitempty"`
}

// AssetFilter - An Asset Filter.
type AssetFilter struct {
	ProxyResource
	// The Media Filter properties.
	Properties *MediaFilterProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilter.
func (a AssetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	return json.Marshal(objectMap)
}

// AssetFilterCollection - A collection of AssetFilter items.
type AssetFilterCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of AssetFilter items.
	Value []*AssetFilter `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilterCollection.
func (a AssetFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AssetFiltersCreateOrUpdateOptions contains the optional parameters for the AssetFilters.CreateOrUpdate method.
type AssetFiltersCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersDeleteOptions contains the optional parameters for the AssetFilters.Delete method.
type AssetFiltersDeleteOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersGetOptions contains the optional parameters for the AssetFilters.Get method.
type AssetFiltersGetOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersListOptions contains the optional parameters for the AssetFilters.List method.
type AssetFiltersListOptions struct {
	// placeholder for future optional parameters
}

// AssetFiltersUpdateOptions contains the optional parameters for the AssetFilters.Update method.
type AssetFiltersUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetProperties - The Asset properties.
type AssetProperties struct {
	// The alternate ID of the Asset.
	AlternateID *string `json:"alternateId,omitempty"`

	// The name of the asset blob container.
	Container *string `json:"container,omitempty"`

	// The Asset description.
	Description *string `json:"description,omitempty"`

	// The name of the storage account.
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// READ-ONLY; The Asset ID.
	AssetID *string `json:"assetId,omitempty" azure:"ro"`

	// READ-ONLY; The creation date of the Asset.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified date of the Asset.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The Asset encryption format. One of None or MediaStorageEncryption.
	StorageEncryptionFormat *AssetStorageEncryptionFormat `json:"storageEncryptionFormat,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetProperties.
func (a AssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateId", a.AlternateID)
	populate(objectMap, "assetId", a.AssetID)
	populate(objectMap, "container", a.Container)
	populate(objectMap, "created", (*timeRFC3339)(a.Created))
	populate(objectMap, "description", a.Description)
	populate(objectMap, "lastModified", (*timeRFC3339)(a.LastModified))
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageEncryptionFormat", a.StorageEncryptionFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetProperties.
func (a *AssetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateId":
			err = unpopulate(val, &a.AlternateID)
			delete(rawMsg, key)
		case "assetId":
			err = unpopulate(val, &a.AssetID)
			delete(rawMsg, key)
		case "container":
			err = unpopulate(val, &a.Container)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageEncryptionFormat":
			err = unpopulate(val, &a.StorageEncryptionFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AssetStreamingLocator - Properties of the Streaming Locator.
type AssetStreamingLocator struct {
	// READ-ONLY; Asset Name.
	AssetName *string `json:"assetName,omitempty" azure:"ro"`

	// READ-ONLY; The creation time of the Streaming Locator.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty" azure:"ro"`

	// READ-ONLY; The end time of the Streaming Locator.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; Streaming Locator name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the Streaming Locator.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *string `json:"streamingLocatorId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the Streaming Policy used by this Streaming Locator.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AssetStreamingLocator.
func (a AssetStreamingLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", a.AssetName)
	populate(objectMap, "created", (*timeRFC3339)(a.Created))
	populate(objectMap, "defaultContentKeyPolicyName", a.DefaultContentKeyPolicyName)
	populate(objectMap, "endTime", (*timeRFC3339)(a.EndTime))
	populate(objectMap, "name", a.Name)
	populate(objectMap, "startTime", (*timeRFC3339)(a.StartTime))
	populate(objectMap, "streamingLocatorId", a.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", a.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetStreamingLocator.
func (a *AssetStreamingLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &a.AssetName)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &a.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &a.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &a.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AssetsCreateOrUpdateOptions contains the optional parameters for the Assets.CreateOrUpdate method.
type AssetsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AssetsDeleteOptions contains the optional parameters for the Assets.Delete method.
type AssetsDeleteOptions struct {
	// placeholder for future optional parameters
}

// AssetsGetEncryptionKeyOptions contains the optional parameters for the Assets.GetEncryptionKey method.
type AssetsGetEncryptionKeyOptions struct {
	// placeholder for future optional parameters
}

// AssetsGetOptions contains the optional parameters for the Assets.Get method.
type AssetsGetOptions struct {
	// placeholder for future optional parameters
}

// AssetsListContainerSasOptions contains the optional parameters for the Assets.ListContainerSas method.
type AssetsListContainerSasOptions struct {
	// placeholder for future optional parameters
}

// AssetsListOptions contains the optional parameters for the Assets.List method.
type AssetsListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to
	// but not greater than the specified value n.
	Top *int32
}

// AssetsListStreamingLocatorsOptions contains the optional parameters for the Assets.ListStreamingLocators method.
type AssetsListStreamingLocatorsOptions struct {
	// placeholder for future optional parameters
}

// AssetsUpdateOptions contains the optional parameters for the Assets.Update method.
type AssetsUpdateOptions struct {
	// placeholder for future optional parameters
}

// AudioClassification provides polymorphic access to related types.
// Call the interface's GetAudio() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AacAudio, *Audio
type AudioClassification interface {
	CodecClassification
	// GetAudio returns the Audio content of the underlying type.
	GetAudio() *Audio
}

// Audio - Defines the common properties for all audio codecs.
type Audio struct {
	Codec
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// The number of channels in the audio.
	Channels *int32 `json:"channels,omitempty"`

	// The sampling rate to use for encoding in hertz.
	SamplingRate *int32 `json:"samplingRate,omitempty"`
}

// GetAudio implements the AudioClassification interface for type Audio.
func (a *Audio) GetAudio() *Audio { return a }

// MarshalJSON implements the json.Marshaller interface for type Audio.
func (a Audio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap, "#Microsoft.Media.Audio")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Audio.
func (a *Audio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a Audio) marshalInternal(objectMap map[string]interface{}, discValue string) {
	a.Codec.marshalInternal(objectMap, discValue)
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "samplingRate", a.SamplingRate)
}

func (a *Audio) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, &a.Channels)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Codec.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AudioAnalyzerPresetClassification provides polymorphic access to related types.
// Call the interface's GetAudioAnalyzerPreset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioAnalyzerPreset, *VideoAnalyzerPreset
type AudioAnalyzerPresetClassification interface {
	PresetClassification
	// GetAudioAnalyzerPreset returns the AudioAnalyzerPreset content of the underlying type.
	GetAudioAnalyzerPreset() *AudioAnalyzerPreset
}

// AudioAnalyzerPreset - The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently,
// the preset supports processing of content with a single audio track.
type AudioAnalyzerPreset struct {
	Preset
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content,
	// it is recommended that you specify it. The
	// language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language
	// isn't specified or set to null, automatic language
	// detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support
	// dynamically switching between languages after the
	// first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to
	// find the language, transcription would fallback to
	// 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `json:"audioLanguage,omitempty"`

	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions,omitempty"`

	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *AudioAnalysisMode `json:"mode,omitempty"`
}

// GetAudioAnalyzerPreset implements the AudioAnalyzerPresetClassification interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) GetAudioAnalyzerPreset() *AudioAnalyzerPreset { return a }

// MarshalJSON implements the json.Marshaller interface for type AudioAnalyzerPreset.
func (a AudioAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap, "#Microsoft.Media.AudioAnalyzerPreset")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AudioAnalyzerPreset) marshalInternal(objectMap map[string]interface{}, discValue string) {
	a.Preset.marshalInternal(objectMap, discValue)
	populate(objectMap, "audioLanguage", a.AudioLanguage)
	populate(objectMap, "experimentalOptions", a.ExperimentalOptions)
	populate(objectMap, "mode", a.Mode)
}

func (a *AudioAnalyzerPreset) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, &a.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &a.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &a.Mode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Preset.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AudioOverlay - Describes the properties of an audio overlay.
type AudioOverlay struct {
	Overlay
}

// MarshalJSON implements the json.Marshaller interface for type AudioOverlay.
func (a AudioOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Overlay.marshalInternal(objectMap, "#Microsoft.Media.AudioOverlay")
	return json.Marshal(objectMap)
}

// AudioTrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetAudioTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioTrackDescriptor, *SelectAudioTrackByAttribute, *SelectAudioTrackById
type AudioTrackDescriptorClassification interface {
	TrackDescriptorClassification
	// GetAudioTrackDescriptor returns the AudioTrackDescriptor content of the underlying type.
	GetAudioTrackDescriptor() *AudioTrackDescriptor
}

// AudioTrackDescriptor - A TrackSelection to select audio tracks.
type AudioTrackDescriptor struct {
	TrackDescriptor
	// Optional designation for single channel audio tracks. Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *ChannelMapping `json:"channelMapping,omitempty"`
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) GetAudioTrackDescriptor() *AudioTrackDescriptor { return a }

// MarshalJSON implements the json.Marshaller interface for type AudioTrackDescriptor.
func (a AudioTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap, "#Microsoft.Media.AudioTrackDescriptor")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AudioTrackDescriptor) marshalInternal(objectMap map[string]interface{}, discValue string) {
	a.TrackDescriptor.marshalInternal(objectMap, discValue)
	populate(objectMap, "channelMapping", a.ChannelMapping)
}

func (a *AudioTrackDescriptor) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, &a.ChannelMapping)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.TrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BuiltInStandardEncoderPreset - Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPreset struct {
	Preset
	// REQUIRED; The built-in preset to be used for encoding videos.
	PresetName *EncoderNamedPreset `json:"presetName,omitempty"`

	// PresetConfigurations are only supported for the ContentAwareEncoding and H265ContentAwareEncoding built-in presets. These settings will not affect other
	// built-in or custom defined presets.
	Configurations *PresetConfigurations `json:"configurations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BuiltInStandardEncoderPreset.
func (b BuiltInStandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.Preset.marshalInternal(objectMap, "#Microsoft.Media.BuiltInStandardEncoderPreset")
	populate(objectMap, "configurations", b.Configurations)
	populate(objectMap, "presetName", b.PresetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurations":
			err = unpopulate(val, &b.Configurations)
			delete(rawMsg, key)
		case "presetName":
			err = unpopulate(val, &b.PresetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.Preset.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CbcsDrmConfiguration - Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfiguration struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfiguration `json:"fairPlay,omitempty"`

	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`

	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CencDrmConfiguration - Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfiguration struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`

	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CheckNameAvailabilityInput - The input to the check name availability request.
type CheckNameAvailabilityInput struct {
	// The account name.
	Name *string `json:"name,omitempty"`

	// The account type. For a Media Services account, this should be 'MediaServices'.
	Type *string `json:"type,omitempty"`
}

// ClipTimeClassification provides polymorphic access to related types.
// Call the interface's GetClipTime() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AbsoluteClipTime, *ClipTime, *UtcClipTime
type ClipTimeClassification interface {
	// GetClipTime returns the ClipTime content of the underlying type.
	GetClipTime() *ClipTime
}

// ClipTime - Base class for specifying a clip time. Use sub classes of this class to specify the time position in the media.
type ClipTime struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetClipTime implements the ClipTimeClassification interface for type ClipTime.
func (c *ClipTime) GetClipTime() *ClipTime { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type ClipTime.
func (c *ClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ClipTime) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *ClipTime) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CodecClassification provides polymorphic access to related types.
// Call the interface's GetCodec() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AacAudio, *Audio, *Codec, *CopyAudio, *CopyVideo, *H264Video, *H265Video, *Image, *JpgImage, *PngImage, *Video
type CodecClassification interface {
	// GetCodec returns the Codec content of the underlying type.
	GetCodec() *Codec
}

// Codec - Describes the basic properties of all codecs.
type Codec struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
}

// GetCodec implements the CodecClassification interface for type Codec.
func (c *Codec) GetCodec() *Codec { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type Codec.
func (c *Codec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c Codec) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "label", c.Label)
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *Codec) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommonEncryptionCbcs - Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcs struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfiguration `json:"drm,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCbcs.
func (c CommonEncryptionCbcs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// CommonEncryptionCenc - Class for envelope encryption scheme
type CommonEncryptionCenc struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfiguration `json:"drm,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCenc.
func (c CommonEncryptionCenc) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// ContentKeyPoliciesCreateOrUpdateOptions contains the optional parameters for the ContentKeyPolicies.CreateOrUpdate method.
type ContentKeyPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesDeleteOptions contains the optional parameters for the ContentKeyPolicies.Delete method.
type ContentKeyPoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesGetOptions contains the optional parameters for the ContentKeyPolicies.Get method.
type ContentKeyPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesGetPolicyPropertiesWithSecretsOptions contains the optional parameters for the ContentKeyPolicies.GetPolicyPropertiesWithSecrets method.
type ContentKeyPoliciesGetPolicyPropertiesWithSecretsOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPoliciesListOptions contains the optional parameters for the ContentKeyPolicies.List method.
type ContentKeyPoliciesListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to
	// but not greater than the specified value n.
	Top *int32
}

// ContentKeyPoliciesUpdateOptions contains the optional parameters for the ContentKeyPolicies.Update method.
type ContentKeyPoliciesUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContentKeyPolicy - A Content Key Policy resource.
type ContentKeyPolicy struct {
	ProxyResource
	// The properties of the Content Key Policy.
	Properties *ContentKeyPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicy.
func (c ContentKeyPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	return json.Marshal(objectMap)
}

// ContentKeyPolicyClearKeyConfiguration - Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfiguration struct {
	ContentKeyPolicyConfiguration
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c ContentKeyPolicyClearKeyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyConfiguration.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration")
	return json.Marshal(objectMap)
}

// ContentKeyPolicyCollection - A collection of ContentKeyPolicy items.
type ContentKeyPolicyCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of ContentKeyPolicy items.
	Value []*ContentKeyPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyCollection.
func (c ContentKeyPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", c.ODataNextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ContentKeyPolicyConfigurationClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyConfiguration() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyClearKeyConfiguration, *ContentKeyPolicyConfiguration, *ContentKeyPolicyFairPlayConfiguration, *ContentKeyPolicyPlayReadyConfiguration,
// - *ContentKeyPolicyUnknownConfiguration, *ContentKeyPolicyWidevineConfiguration
type ContentKeyPolicyConfigurationClassification interface {
	// GetContentKeyPolicyConfiguration returns the ContentKeyPolicyConfiguration content of the underlying type.
	GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration
}

// ContentKeyPolicyConfiguration - Base class for Content Key Policy configuration. A derived class must be used to create a configuration.
type ContentKeyPolicyConfiguration struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyConfiguration.
func (c *ContentKeyPolicyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyConfiguration.
func (c *ContentKeyPolicyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ContentKeyPolicyConfiguration) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *ContentKeyPolicyConfiguration) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyFairPlayConfiguration - Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfiguration struct {
	ContentKeyPolicyConfiguration
	// REQUIRED; The key that must be used as FairPlay Application Secret key.
	Ask []byte `json:"ask,omitempty"`

	// REQUIRED; The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx *string `json:"fairPlayPfx,omitempty"`

	// REQUIRED; The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword *string `json:"fairPlayPfxPassword,omitempty"`

	// REQUIRED; The rental and lease key type.
	RentalAndLeaseKeyType *ContentKeyPolicyFairPlayRentalAndLeaseKeyType `json:"rentalAndLeaseKeyType,omitempty"`

	// REQUIRED; The rental duration. Must be greater than or equal to 0.
	RentalDuration *int64 `json:"rentalDuration,omitempty"`

	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfiguration `json:"offlineRentalConfiguration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c ContentKeyPolicyFairPlayConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyConfiguration.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration")
	populateByteArray(objectMap, "ask", c.Ask, runtime.Base64StdFormat)
	populate(objectMap, "fairPlayPfx", c.FairPlayPfx)
	populate(objectMap, "fairPlayPfxPassword", c.FairPlayPfxPassword)
	populate(objectMap, "offlineRentalConfiguration", c.OfflineRentalConfiguration)
	populate(objectMap, "rentalAndLeaseKeyType", c.RentalAndLeaseKeyType)
	populate(objectMap, "rentalDuration", c.RentalDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ask":
			err = runtime.DecodeByteArray(string(val), &c.Ask, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "fairPlayPfx":
			err = unpopulate(val, &c.FairPlayPfx)
			delete(rawMsg, key)
		case "fairPlayPfxPassword":
			err = unpopulate(val, &c.FairPlayPfxPassword)
			delete(rawMsg, key)
		case "offlineRentalConfiguration":
			err = unpopulate(val, &c.OfflineRentalConfiguration)
			delete(rawMsg, key)
		case "rentalAndLeaseKeyType":
			err = unpopulate(val, &c.RentalAndLeaseKeyType)
			delete(rawMsg, key)
		case "rentalDuration":
			err = unpopulate(val, &c.RentalDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyConfiguration.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type ContentKeyPolicyFairPlayOfflineRentalConfiguration struct {
	// REQUIRED; Playback duration
	PlaybackDurationSeconds *int64 `json:"playbackDurationSeconds,omitempty"`

	// REQUIRED; Storage duration
	StorageDurationSeconds *int64 `json:"storageDurationSeconds,omitempty"`
}

// ContentKeyPolicyOpenRestriction - Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestriction struct {
	ContentKeyPolicyRestriction
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOpenRestriction.
func (c ContentKeyPolicyOpenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestriction.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyOpenRestriction")
	return json.Marshal(objectMap)
}

// ContentKeyPolicyOption - Represents a policy option.
type ContentKeyPolicyOption struct {
	// REQUIRED; The key delivery configuration.
	Configuration ContentKeyPolicyConfigurationClassification `json:"configuration,omitempty"`

	// REQUIRED; The requirements that must be met to deliver keys with this configuration
	Restriction ContentKeyPolicyRestrictionClassification `json:"restriction,omitempty"`

	// The Policy Option description.
	Name *string `json:"name,omitempty"`

	// READ-ONLY; The legacy Policy Option ID.
	PolicyOptionID *string `json:"policyOptionId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOption.
func (c ContentKeyPolicyOption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configuration", c.Configuration)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "policyOptionId", c.PolicyOptionID)
	populate(objectMap, "restriction", c.Restriction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOption.
func (c *ContentKeyPolicyOption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			c.Configuration, err = unmarshalContentKeyPolicyConfigurationClassification(val)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "policyOptionId":
			err = unpopulate(val, &c.PolicyOptionID)
			delete(rawMsg, key)
		case "restriction":
			c.Restriction, err = unmarshalContentKeyPolicyRestrictionClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyConfiguration - Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfiguration struct {
	ContentKeyPolicyConfiguration
	// REQUIRED; The PlayReady licenses.
	Licenses []*ContentKeyPolicyPlayReadyLicense `json:"licenses,omitempty"`

	// The custom response data.
	ResponseCustomData *string `json:"responseCustomData,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c ContentKeyPolicyPlayReadyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyConfiguration.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration")
	populate(objectMap, "licenses", c.Licenses)
	populate(objectMap, "responseCustomData", c.ResponseCustomData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenses":
			err = unpopulate(val, &c.Licenses)
			delete(rawMsg, key)
		case "responseCustomData":
			err = unpopulate(val, &c.ResponseCustomData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyConfiguration.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader - Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader struct {
	ContentKeyPolicyPlayReadyContentKeyLocation
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyPlayReadyContentKeyLocation.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader")
	return json.Marshal(objectMap)
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier - Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier struct {
	ContentKeyPolicyPlayReadyContentKeyLocation
	// REQUIRED; The content key ID.
	KeyID *string `json:"keyId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyPlayReadyContentKeyLocation.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier")
	populate(objectMap, "keyId", c.KeyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyId":
			err = unpopulate(val, &c.KeyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyPlayReadyContentKeyLocation.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicyPlayReadyContentKeyLocationClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyPlayReadyContentKeyLocation() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier,
// - *ContentKeyPolicyPlayReadyContentKeyLocation
type ContentKeyPolicyPlayReadyContentKeyLocationClassification interface {
	// GetContentKeyPolicyPlayReadyContentKeyLocation returns the ContentKeyPolicyPlayReadyContentKeyLocation content of the underlying type.
	GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation
}

// ContentKeyPolicyPlayReadyContentKeyLocation - Base class for content key ID location. A derived class must be used to represent the location.
type ContentKeyPolicyPlayReadyContentKeyLocation struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification interface for type ContentKeyPolicyPlayReadyContentKeyLocation.
func (c *ContentKeyPolicyPlayReadyContentKeyLocation) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentKeyLocation.
func (c *ContentKeyPolicyPlayReadyContentKeyLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ContentKeyPolicyPlayReadyContentKeyLocation) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *ContentKeyPolicyPlayReadyContentKeyLocation) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction - Configures the Explicit Analog Television Output Restriction control bits. For further
// details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction struct {
	// REQUIRED; Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort *bool `json:"bestEffort,omitempty"`

	// REQUIRED; Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData *int32 `json:"configurationData,omitempty"`
}

// ContentKeyPolicyPlayReadyLicense - The PlayReady license
type ContentKeyPolicyPlayReadyLicense struct {
	// REQUIRED; A flag indicating whether test devices can use the license.
	AllowTestDevices *bool `json:"allowTestDevices,omitempty"`

	// REQUIRED; The content key location.
	ContentKeyLocation ContentKeyPolicyPlayReadyContentKeyLocationClassification `json:"contentKeyLocation,omitempty"`

	// REQUIRED; The PlayReady content type.
	ContentType *ContentKeyPolicyPlayReadyContentType `json:"contentType,omitempty"`

	// REQUIRED; The license type.
	LicenseType *ContentKeyPolicyPlayReadyLicenseType `json:"licenseType,omitempty"`

	// The begin date of license
	BeginDate *time.Time `json:"beginDate,omitempty"`

	// The expiration date of license.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	// The grace period of license.
	GracePeriod *string `json:"gracePeriod,omitempty"`

	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRight `json:"playRight,omitempty"`

	// The relative begin date of license.
	RelativeBeginDate *string `json:"relativeBeginDate,omitempty"`

	// The relative expiration date of license.
	RelativeExpirationDate *string `json:"relativeExpirationDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c ContentKeyPolicyPlayReadyLicense) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowTestDevices", c.AllowTestDevices)
	populate(objectMap, "beginDate", (*timeRFC3339)(c.BeginDate))
	populate(objectMap, "contentKeyLocation", c.ContentKeyLocation)
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "expirationDate", (*timeRFC3339)(c.ExpirationDate))
	populate(objectMap, "gracePeriod", c.GracePeriod)
	populate(objectMap, "licenseType", c.LicenseType)
	populate(objectMap, "playRight", c.PlayRight)
	populate(objectMap, "relativeBeginDate", c.RelativeBeginDate)
	populate(objectMap, "relativeExpirationDate", c.RelativeExpirationDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c *ContentKeyPolicyPlayReadyLicense) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTestDevices":
			err = unpopulate(val, &c.AllowTestDevices)
			delete(rawMsg, key)
		case "beginDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.BeginDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "contentKeyLocation":
			c.ContentKeyLocation, err = unmarshalContentKeyPolicyPlayReadyContentKeyLocationClassification(val)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &c.ContentType)
			delete(rawMsg, key)
		case "expirationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.ExpirationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "gracePeriod":
			err = unpopulate(val, &c.GracePeriod)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &c.LicenseType)
			delete(rawMsg, key)
		case "playRight":
			err = unpopulate(val, &c.PlayRight)
			delete(rawMsg, key)
		case "relativeBeginDate":
			err = unpopulate(val, &c.RelativeBeginDate)
			delete(rawMsg, key)
		case "relativeExpirationDate":
			err = unpopulate(val, &c.RelativeExpirationDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyPlayReadyPlayRight - Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRight struct {
	// REQUIRED; Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput *ContentKeyPolicyPlayReadyUnknownOutputPassingOption `json:"allowPassingVideoContentToUnknownOutput,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction *bool `json:"digitalVideoOnlyContentRestriction,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction *bool `json:"imageConstraintForAnalogComponentVideoRestriction,omitempty"`

	// REQUIRED; Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction *bool `json:"imageConstraintForAnalogComputerMonitorRestriction,omitempty"`

	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int32 `json:"agcAndColorStripeRestriction,omitempty"`

	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int32 `json:"analogVideoOpl,omitempty"`

	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int32 `json:"compressedDigitalAudioOpl,omitempty"`

	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int32 `json:"compressedDigitalVideoOpl,omitempty"`

	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction `json:"explicitAnalogTelevisionOutputRestriction,omitempty"`

	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `json:"firstPlayExpiration,omitempty"`

	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int32 `json:"scmsRestriction,omitempty"`

	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int32 `json:"uncompressedDigitalAudioOpl,omitempty"`

	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int32 `json:"uncompressedDigitalVideoOpl,omitempty"`
}

// ContentKeyPolicyProperties - The properties of the Content Key Policy.
type ContentKeyPolicyProperties struct {
	// REQUIRED; The Key Policy options.
	Options []*ContentKeyPolicyOption `json:"options,omitempty"`

	// A description for the Policy.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; The creation date of the Policy
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified date of the Policy
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The legacy Policy ID.
	PolicyID *string `json:"policyId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyProperties.
func (c ContentKeyPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "created", (*timeRFC3339)(c.Created))
	populate(objectMap, "description", c.Description)
	populate(objectMap, "lastModified", (*timeRFC3339)(c.LastModified))
	populate(objectMap, "options", c.Options)
	populate(objectMap, "policyId", c.PolicyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyProperties.
func (c *ContentKeyPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, &c.Options)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, &c.PolicyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyRestrictionClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyRestriction() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyOpenRestriction, *ContentKeyPolicyRestriction, *ContentKeyPolicyTokenRestriction, *ContentKeyPolicyUnknownRestriction
type ContentKeyPolicyRestrictionClassification interface {
	// GetContentKeyPolicyRestriction returns the ContentKeyPolicyRestriction content of the underlying type.
	GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction
}

// ContentKeyPolicyRestriction - Base class for Content Key Policy restrictions. A derived class must be used to create a restriction.
type ContentKeyPolicyRestriction struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyRestriction.
func (c *ContentKeyPolicyRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRestriction.
func (c *ContentKeyPolicyRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ContentKeyPolicyRestriction) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *ContentKeyPolicyRestriction) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyRestrictionTokenKeyClassification provides polymorphic access to related types.
// Call the interface's GetContentKeyPolicyRestrictionTokenKey() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContentKeyPolicyRestrictionTokenKey, *ContentKeyPolicyRsaTokenKey, *ContentKeyPolicySymmetricTokenKey, *ContentKeyPolicyX509CertificateTokenKey
type ContentKeyPolicyRestrictionTokenKeyClassification interface {
	// GetContentKeyPolicyRestrictionTokenKey returns the ContentKeyPolicyRestrictionTokenKey content of the underlying type.
	GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey
}

// ContentKeyPolicyRestrictionTokenKey - Base class for Content Key Policy key for token validation. A derived class must be used to create a token key.
type ContentKeyPolicyRestrictionTokenKey struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type ContentKeyPolicyRestrictionTokenKey.
func (c *ContentKeyPolicyRestrictionTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRestrictionTokenKey.
func (c *ContentKeyPolicyRestrictionTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ContentKeyPolicyRestrictionTokenKey) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.ODataType = &discValue
	objectMap["@odata.type"] = c.ODataType
}

func (c *ContentKeyPolicyRestrictionTokenKey) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContentKeyPolicyRsaTokenKey - Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKey struct {
	ContentKeyPolicyRestrictionTokenKey
	// REQUIRED; The RSA Parameter exponent
	Exponent []byte `json:"exponent,omitempty"`

	// REQUIRED; The RSA Parameter modulus
	Modulus []byte `json:"modulus,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c ContentKeyPolicyRsaTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestrictionTokenKey.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyRsaTokenKey")
	populateByteArray(objectMap, "exponent", c.Exponent, runtime.Base64StdFormat)
	populateByteArray(objectMap, "modulus", c.Modulus, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exponent":
			err = runtime.DecodeByteArray(string(val), &c.Exponent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "modulus":
			err = runtime.DecodeByteArray(string(val), &c.Modulus, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyRestrictionTokenKey.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicySymmetricTokenKey - Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKey struct {
	ContentKeyPolicyRestrictionTokenKey
	// REQUIRED; The key value of the key
	KeyValue []byte `json:"keyValue,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c ContentKeyPolicySymmetricTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestrictionTokenKey.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey")
	populateByteArray(objectMap, "keyValue", c.KeyValue, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyValue":
			err = runtime.DecodeByteArray(string(val), &c.KeyValue, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyRestrictionTokenKey.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicyTokenClaim - Represents a token claim.
type ContentKeyPolicyTokenClaim struct {
	// Token claim type.
	ClaimType *string `json:"claimType,omitempty"`

	// Token claim value.
	ClaimValue *string `json:"claimValue,omitempty"`
}

// ContentKeyPolicyTokenRestriction - Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestriction struct {
	ContentKeyPolicyRestriction
	// REQUIRED; The audience for the token.
	Audience *string `json:"audience,omitempty"`

	// REQUIRED; The token issuer.
	Issuer *string `json:"issuer,omitempty"`

	// REQUIRED; The primary verification key.
	PrimaryVerificationKey ContentKeyPolicyRestrictionTokenKeyClassification `json:"primaryVerificationKey,omitempty"`

	// REQUIRED; The type of token.
	RestrictionTokenType *ContentKeyPolicyRestrictionTokenType `json:"restrictionTokenType,omitempty"`

	// A list of alternative verification keys.
	AlternateVerificationKeys []ContentKeyPolicyRestrictionTokenKeyClassification `json:"alternateVerificationKeys,omitempty"`

	// The OpenID connect discovery document.
	OpenIDConnectDiscoveryDocument *string `json:"openIdConnectDiscoveryDocument,omitempty"`

	// A list of required token claims.
	RequiredClaims []*ContentKeyPolicyTokenClaim `json:"requiredClaims,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyTokenRestriction.
func (c ContentKeyPolicyTokenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestriction.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyTokenRestriction")
	populate(objectMap, "alternateVerificationKeys", c.AlternateVerificationKeys)
	populate(objectMap, "audience", c.Audience)
	populate(objectMap, "issuer", c.Issuer)
	populate(objectMap, "openIdConnectDiscoveryDocument", c.OpenIDConnectDiscoveryDocument)
	populate(objectMap, "primaryVerificationKey", c.PrimaryVerificationKey)
	populate(objectMap, "requiredClaims", c.RequiredClaims)
	populate(objectMap, "restrictionTokenType", c.RestrictionTokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateVerificationKeys":
			c.AlternateVerificationKeys, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassificationArray(val)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, &c.Audience)
			delete(rawMsg, key)
		case "issuer":
			err = unpopulate(val, &c.Issuer)
			delete(rawMsg, key)
		case "openIdConnectDiscoveryDocument":
			err = unpopulate(val, &c.OpenIDConnectDiscoveryDocument)
			delete(rawMsg, key)
		case "primaryVerificationKey":
			c.PrimaryVerificationKey, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassification(val)
			delete(rawMsg, key)
		case "requiredClaims":
			err = unpopulate(val, &c.RequiredClaims)
			delete(rawMsg, key)
		case "restrictionTokenType":
			err = unpopulate(val, &c.RestrictionTokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyRestriction.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicyUnknownConfiguration - Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfiguration struct {
	ContentKeyPolicyConfiguration
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c ContentKeyPolicyUnknownConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyConfiguration.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration")
	return json.Marshal(objectMap)
}

// ContentKeyPolicyUnknownRestriction - Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestriction struct {
	ContentKeyPolicyRestriction
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c ContentKeyPolicyUnknownRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestriction.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyUnknownRestriction")
	return json.Marshal(objectMap)
}

// ContentKeyPolicyWidevineConfiguration - Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfiguration struct {
	ContentKeyPolicyConfiguration
	// REQUIRED; The Widevine template.
	WidevineTemplate *string `json:"widevineTemplate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c ContentKeyPolicyWidevineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyConfiguration.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration")
	populate(objectMap, "widevineTemplate", c.WidevineTemplate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "widevineTemplate":
			err = unpopulate(val, &c.WidevineTemplate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyConfiguration.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContentKeyPolicyX509CertificateTokenKey - Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKey struct {
	ContentKeyPolicyRestrictionTokenKey
	// REQUIRED; The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody []byte `json:"rawBody,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c ContentKeyPolicyX509CertificateTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ContentKeyPolicyRestrictionTokenKey.marshalInternal(objectMap, "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey")
	populateByteArray(objectMap, "rawBody", c.RawBody, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rawBody":
			err = runtime.DecodeByteArray(string(val), &c.RawBody, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ContentKeyPolicyRestrictionTokenKey.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CopyAudio - A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudio struct {
	Codec
}

// MarshalJSON implements the json.Marshaller interface for type CopyAudio.
func (c CopyAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Codec.marshalInternal(objectMap, "#Microsoft.Media.CopyAudio")
	return json.Marshal(objectMap)
}

// CopyVideo - A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideo struct {
	Codec
}

// MarshalJSON implements the json.Marshaller interface for type CopyVideo.
func (c CopyVideo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Codec.marshalInternal(objectMap, "#Microsoft.Media.CopyVideo")
	return json.Marshal(objectMap)
}

// CrossSiteAccessPolicies - The client access policy.
type CrossSiteAccessPolicies struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty"`

	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty"`
}

// DefaultKey - Class to specify properties of default content key for each encryption scheme
type DefaultKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`

	// Policy used by Default Key
	PolicyName *string `json:"policyName,omitempty"`
}

// Deinterlace - Describes the de-interlacing settings.
type Deinterlace struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *DeinterlaceMode `json:"mode,omitempty"`

	// The field parity for de-interlacing, defaults to Auto.
	Parity *DeinterlaceParity `json:"parity,omitempty"`
}

type EdgePolicies struct {
	UsageDataCollectionPolicy *EdgeUsageDataCollectionPolicy `json:"usageDataCollectionPolicy,omitempty"`
}

type EdgeUsageDataCollectionPolicy struct {
	// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataCollectionFrequency *string `json:"dataCollectionFrequency,omitempty"`

	// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataReportingFrequency *string `json:"dataReportingFrequency,omitempty"`

	// Details of Event Hub where the usage will be reported.
	EventHubDetails *EdgeUsageDataEventHub `json:"eventHubDetails,omitempty"`

	// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
	MaxAllowedUnreportedUsageDuration *string `json:"maxAllowedUnreportedUsageDuration,omitempty"`
}

type EdgeUsageDataEventHub struct {
	// Name of the Event Hub where usage will be reported.
	Name *string `json:"name,omitempty"`

	// Namespace of the Event Hub where usage will be reported.
	Namespace *string `json:"namespace,omitempty"`

	// SAS token needed to interact with Event Hub.
	Token *string `json:"token,omitempty"`
}

// EnabledProtocols - Class to specify which protocols are enabled
type EnabledProtocols struct {
	// REQUIRED; Enable DASH protocol or not
	Dash *bool `json:"dash,omitempty"`

	// REQUIRED; Enable Download protocol or not
	Download *bool `json:"download,omitempty"`

	// REQUIRED; Enable HLS protocol or not
	Hls *bool `json:"hls,omitempty"`

	// REQUIRED; Enable SmoothStreaming protocol or not
	SmoothStreaming *bool `json:"smoothStreaming,omitempty"`
}

// EntityNameAvailabilityCheckOutput - The response from the check name availability request.
type EntityNameAvailabilityCheckOutput struct {
	// REQUIRED; Specifies if the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// Specifies the detailed reason if the name is not available.
	Message *string `json:"message,omitempty"`

	// Specifies the reason if the name is not available.
	Reason *string `json:"reason,omitempty"`
}

// EnvelopeEncryption - Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryption struct {
	// Representing which tracks should not be encrypted
	ClearTracks []*TrackSelection `json:"clearTracks,omitempty"`

	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`

	// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services for issuing keys. The template
	// supports replaceable tokens that the service
	// will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with
	// the value of StreamingLocatorId.AlternativeMediaId,
	// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionURLTemplate *string `json:"customKeyAcquisitionUrlTemplate,omitempty"`

	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EnvelopeEncryption.
func (e EnvelopeEncryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", e.ClearTracks)
	populate(objectMap, "contentKeys", e.ContentKeys)
	populate(objectMap, "customKeyAcquisitionUrlTemplate", e.CustomKeyAcquisitionURLTemplate)
	populate(objectMap, "enabledProtocols", e.EnabledProtocols)
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// FaceDetectorPreset - Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPreset struct {
	Preset
	// Blur type
	BlurType *BlurType `json:"blurType,omitempty"`

	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions,omitempty"`

	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking
	// appearances of faces throughout the
	// video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact -
	// This enables a 2-pass process, allowing for
	// selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected
	// subset of IDs that require redaction.
	Mode *FaceRedactorMode `json:"mode,omitempty"`

	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its
	// original resolution when analyzed. Using
	// "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video
	// is of higher resolution. For example, a 1920x1080
	// input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video.
	// It may also reduce the cost of using this
	// component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in
	// the resized video may not be detected.
	Resolution *AnalysisResolution `json:"resolution,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FaceDetectorPreset.
func (f FaceDetectorPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.Preset.marshalInternal(objectMap, "#Microsoft.Media.FaceDetectorPreset")
	populate(objectMap, "blurType", f.BlurType)
	populate(objectMap, "experimentalOptions", f.ExperimentalOptions)
	populate(objectMap, "mode", f.Mode)
	populate(objectMap, "resolution", f.Resolution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blurType":
			err = unpopulate(val, &f.BlurType)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &f.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &f.Mode)
			delete(rawMsg, key)
		case "resolution":
			err = unpopulate(val, &f.Resolution)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := f.Preset.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// FilterTrackPropertyCondition - The class to specify one track property condition.
type FilterTrackPropertyCondition struct {
	// REQUIRED; The track property condition operation.
	Operation *FilterTrackPropertyCompareOperation `json:"operation,omitempty"`

	// REQUIRED; The track property type.
	Property *FilterTrackPropertyType `json:"property,omitempty"`

	// REQUIRED; The track property value.
	Value *string `json:"value,omitempty"`
}

// FilterTrackSelection - Representing a list of FilterTrackPropertyConditions to select a track. The filters are combined using a logical AND operation.
type FilterTrackSelection struct {
	// REQUIRED; The track selections.
	TrackSelections []*FilterTrackPropertyCondition `json:"trackSelections,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FilterTrackSelection.
func (f FilterTrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", f.TrackSelections)
	return json.Marshal(objectMap)
}

// Filters - Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type Filters struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *Rectangle `json:"crop,omitempty"`

	// The de-interlacing settings.
	Deinterlace *Deinterlace `json:"deinterlace,omitempty"`

	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []OverlayClassification `json:"overlays,omitempty"`

	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *Rotation `json:"rotation,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Filters.
func (f Filters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crop", f.Crop)
	populate(objectMap, "deinterlace", f.Deinterlace)
	populate(objectMap, "overlays", f.Overlays)
	populate(objectMap, "rotation", f.Rotation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Filters.
func (f *Filters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crop":
			err = unpopulate(val, &f.Crop)
			delete(rawMsg, key)
		case "deinterlace":
			err = unpopulate(val, &f.Deinterlace)
			delete(rawMsg, key)
		case "overlays":
			f.Overlays, err = unmarshalOverlayClassificationArray(val)
			delete(rawMsg, key)
		case "rotation":
			err = unpopulate(val, &f.Rotation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FirstQuality - Filter First Quality
type FirstQuality struct {
	// REQUIRED; The first quality bitrate.
	Bitrate *int32 `json:"bitrate,omitempty"`
}

// FormatClassification provides polymorphic access to related types.
// Call the interface's GetFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Format, *ImageFormat, *JpgFormat, *Mp4Format, *MultiBitrateFormat, *PngFormat, *TransportStreamFormat
type FormatClassification interface {
	// GetFormat returns the Format content of the underlying type.
	GetFormat() *Format
}

// Format - Base class for output.
type Format struct {
	// REQUIRED; The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion
	// macro that will use the name of the input video file. If
	// the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used.
	// If the length of base name of the input video
	// file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format.
	// {Label} - The label assigned to the
	// codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails.
	// {Codec} - The type of the audio/video codec.
	// {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetFormat implements the FormatClassification interface for type Format.
func (f *Format) GetFormat() *Format { return f }

// UnmarshalJSON implements the json.Unmarshaller interface for type Format.
func (f *Format) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return f.unmarshalInternal(rawMsg)
}

func (f Format) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "filenamePattern", f.FilenamePattern)
	f.ODataType = &discValue
	objectMap["@odata.type"] = f.ODataType
}

func (f *Format) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &f.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FromAllInputFile - An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally
// used with the AudioTrackByAttribute and VideoTrackByAttribute to
// allow selection of a single track across a set of input files.
type FromAllInputFile struct {
	InputDefinition
}

// MarshalJSON implements the json.Marshaller interface for type FromAllInputFile.
func (f FromAllInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.InputDefinition.marshalInternal(objectMap, "#Microsoft.Media.FromAllInputFile")
	return json.Marshal(objectMap)
}

// FromEachInputFile - An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used
// with the AudioTrackByAttribute and VideoTrackByAttribute to select
// tracks from each file given.
type FromEachInputFile struct {
	InputDefinition
}

// MarshalJSON implements the json.Marshaller interface for type FromEachInputFile.
func (f FromEachInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	f.InputDefinition.marshalInternal(objectMap, "#Microsoft.Media.FromEachInputFile")
	return json.Marshal(objectMap)
}

// H264Layer - Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264Layer struct {
	VideoLayer
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for
	// example, PT5S).
	BufferWindow *string `json:"bufferWindow,omitempty"`

	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode *EntropyMode `json:"entropyMode,omitempty"`

	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which
	// lets the encoder choose the Level that is
	// appropriate for this layer.
	Level *string `json:"level,omitempty"`

	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *H264VideoProfile `json:"profile,omitempty"`

	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder
	// complexity setting.
	ReferenceFrames *int32 `json:"referenceFrames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type H264Layer.
func (h H264Layer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.VideoLayer.marshalInternal(objectMap, "#Microsoft.Media.H264Layer")
	populate(objectMap, "bufferWindow", h.BufferWindow)
	populate(objectMap, "entropyMode", h.EntropyMode)
	populate(objectMap, "level", h.Level)
	populate(objectMap, "profile", h.Profile)
	populate(objectMap, "referenceFrames", h.ReferenceFrames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Layer.
func (h *H264Layer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bufferWindow":
			err = unpopulate(val, &h.BufferWindow)
			delete(rawMsg, key)
		case "entropyMode":
			err = unpopulate(val, &h.EntropyMode)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &h.Level)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &h.Profile)
			delete(rawMsg, key)
		case "referenceFrames":
			err = unpopulate(val, &h.ReferenceFrames)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.VideoLayer.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// H264Video - Describes all the properties for encoding a video with the H.264 codec.
type H264Video struct {
	Video
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *H264Complexity `json:"complexity,omitempty"`

	// The collection of output H.264 layers to be produced by the encoder.
	Layers []*H264Layer `json:"layers,omitempty"`

	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when
	// the encoder is being configured to produce a
	// single output video.
	SceneChangeDetection *bool `json:"sceneChangeDetection,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type H264Video.
func (h H264Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.Video.marshalInternal(objectMap, "#Microsoft.Media.H264Video")
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "layers", h.Layers)
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Video.
func (h *H264Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.Video.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// H265Layer - Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265Layer struct {
	H265VideoLayer
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for
	// example, PT5S).
	BufferWindow *string `json:"bufferWindow,omitempty"`

	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which
	// lets the encoder choose the Level that is
	// appropriate for this layer.
	Level *string `json:"level,omitempty"`

	// We currently support Main. Default is Auto.
	Profile *H265VideoProfile `json:"profile,omitempty"`

	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder
	// complexity setting.
	ReferenceFrames *int32 `json:"referenceFrames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type H265Layer.
func (h H265Layer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.H265VideoLayer.marshalInternal(objectMap, "#Microsoft.Media.H265Layer")
	populate(objectMap, "bufferWindow", h.BufferWindow)
	populate(objectMap, "level", h.Level)
	populate(objectMap, "profile", h.Profile)
	populate(objectMap, "referenceFrames", h.ReferenceFrames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Layer.
func (h *H265Layer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bufferWindow":
			err = unpopulate(val, &h.BufferWindow)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &h.Level)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &h.Profile)
			delete(rawMsg, key)
		case "referenceFrames":
			err = unpopulate(val, &h.ReferenceFrames)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.H265VideoLayer.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// H265Video - Describes all the properties for encoding a video with the H.265 codec.
type H265Video struct {
	Video
	// Tells the encoder how to choose its encoding settings. Quality will provide for a higher compression ratio but at a higher cost and longer compute time.
	// Speed will produce a relatively larger file but
	// is faster and more economical. The default value is Balanced.
	Complexity *H265Complexity `json:"complexity,omitempty"`

	// The collection of output H.265 layers to be produced by the encoder.
	Layers []*H265Layer `json:"layers,omitempty"`

	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true
	// only when the encoder is being configured to
	// produce a single output video.
	SceneChangeDetection *bool `json:"sceneChangeDetection,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type H265Video.
func (h H265Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.Video.marshalInternal(objectMap, "#Microsoft.Media.H265Video")
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "layers", h.Layers)
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Video.
func (h *H265Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.Video.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// H265VideoLayerClassification provides polymorphic access to related types.
// Call the interface's GetH265VideoLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H265Layer, *H265VideoLayer
type H265VideoLayerClassification interface {
	LayerClassification
	// GetH265VideoLayer returns the H265VideoLayer content of the underlying type.
	GetH265VideoLayer() *H265VideoLayer
}

// H265VideoLayer - Describes the settings to be used when encoding the input video into a desired output bitrate layer.
type H265VideoLayer struct {
	Layer
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps
	// or 3Mbps means this value should be 3000000 This is a
	// required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video
	// profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number based on the video profile and
	// level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001),
	// or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the
	// same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each
	// frame.
	Slices *int32 `json:"slices,omitempty"`
}

// GetH265VideoLayer implements the H265VideoLayerClassification interface for type H265VideoLayer.
func (h *H265VideoLayer) GetH265VideoLayer() *H265VideoLayer { return h }

// MarshalJSON implements the json.Marshaller interface for type H265VideoLayer.
func (h H265VideoLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.marshalInternal(objectMap, "#Microsoft.Media.H265VideoLayer")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265VideoLayer.
func (h *H265VideoLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return h.unmarshalInternal(rawMsg)
}

func (h H265VideoLayer) marshalInternal(objectMap map[string]interface{}, discValue string) {
	h.Layer.marshalInternal(objectMap, discValue)
	populate(objectMap, "adaptiveBFrame", h.AdaptiveBFrame)
	populate(objectMap, "bFrames", h.BFrames)
	populate(objectMap, "bitrate", h.Bitrate)
	populate(objectMap, "frameRate", h.FrameRate)
	populate(objectMap, "maxBitrate", h.MaxBitrate)
	populate(objectMap, "slices", h.Slices)
}

func (h *H265VideoLayer) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &h.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &h.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &h.Bitrate)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &h.FrameRate)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &h.MaxBitrate)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &h.Slices)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.Layer.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Hls - HTTP Live Streaming (HLS) packing setting for the live output.
type Hls struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for
	// HLS CMAF output.
	FragmentsPerTsSegment *int32 `json:"fragmentsPerTsSegment,omitempty"`
}

// IPAccessControl - The IP access control.
type IPAccessControl struct {
	// The IP allow list.
	Allow []*IPRange `json:"allow,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPAccessControl.
func (i IPAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allow", i.Allow)
	return json.Marshal(objectMap)
}

// IPRange - The IP address range in the CIDR scheme.
type IPRange struct {
	// The IP address.
	Address *string `json:"address,omitempty"`

	// The friendly name for the IP address range.
	Name *string `json:"name,omitempty"`

	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int32 `json:"subnetPrefixLength,omitempty"`
}

// ImageClassification provides polymorphic access to related types.
// Call the interface's GetImage() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Image, *JpgImage, *PngImage
type ImageClassification interface {
	VideoClassification
	// GetImage returns the Image content of the underlying type.
	GetImage() *Image
}

// Image - Describes the basic properties for generating thumbnails from the input video
type Image struct {
	Video
	// REQUIRED; The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start
	// at 5 seconds), or a frame count (For example, 10 to start at
	// the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells
	// the encoder to select the best thumbnail from
	// the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro
	// {Best}.
	Start *string `json:"start,omitempty"`

	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For
	// example, PT5M30S to stop at 5 minutes and 30
	// seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only
	// producing one thumbnail at start time), or a
	// relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to
	// stop at the end of the stream.
	Range *string `json:"range,omitempty"`

	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count
	// (For example, 30 for one image every 30
	// frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first
	// generated thumbnail, which may not be exactly the
	// one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position
	// from start time as the first output. As the
	// default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try
	// to select reasonable value for Step if the first
	// thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `json:"step,omitempty"`
}

// GetImage implements the ImageClassification interface for type Image.
func (i *Image) GetImage() *Image { return i }

// MarshalJSON implements the json.Marshaller interface for type Image.
func (i Image) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.marshalInternal(objectMap, "#Microsoft.Media.Image")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Image.
func (i *Image) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i Image) marshalInternal(objectMap map[string]interface{}, discValue string) {
	i.Video.marshalInternal(objectMap, discValue)
	populate(objectMap, "range", i.Range)
	populate(objectMap, "start", i.Start)
	populate(objectMap, "step", i.Step)
}

func (i *Image) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "range":
			err = unpopulate(val, &i.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &i.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &i.Step)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.Video.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ImageFormatClassification provides polymorphic access to related types.
// Call the interface's GetImageFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ImageFormat, *JpgFormat, *PngFormat
type ImageFormatClassification interface {
	FormatClassification
	// GetImageFormat returns the ImageFormat content of the underlying type.
	GetImageFormat() *ImageFormat
}

// ImageFormat - Describes the properties for an output image file.
type ImageFormat struct {
	Format
}

// GetImageFormat implements the ImageFormatClassification interface for type ImageFormat.
func (i *ImageFormat) GetImageFormat() *ImageFormat { return i }

// MarshalJSON implements the json.Marshaller interface for type ImageFormat.
func (i ImageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.marshalInternal(objectMap, "#Microsoft.Media.ImageFormat")
	return json.Marshal(objectMap)
}

func (i ImageFormat) marshalInternal(objectMap map[string]interface{}, discValue string) {
	i.Format.marshalInternal(objectMap, discValue)
}

func (i *ImageFormat) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := i.Format.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// InputDefinitionClassification provides polymorphic access to related types.
// Call the interface's GetInputDefinition() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FromAllInputFile, *FromEachInputFile, *InputDefinition, *InputFile
type InputDefinitionClassification interface {
	// GetInputDefinition returns the InputDefinition content of the underlying type.
	GetInputDefinition() *InputDefinition
}

// InputDefinition - Base class for defining an input. Use sub classes of this class to specify tracks selections and related metadata.
type InputDefinition struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []TrackDescriptorClassification `json:"includedTracks,omitempty"`
}

// GetInputDefinition implements the InputDefinitionClassification interface for type InputDefinition.
func (i *InputDefinition) GetInputDefinition() *InputDefinition { return i }

// UnmarshalJSON implements the json.Unmarshaller interface for type InputDefinition.
func (i *InputDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i InputDefinition) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "includedTracks", i.IncludedTracks)
	i.ODataType = &discValue
	objectMap["@odata.type"] = i.ODataType
}

func (i *InputDefinition) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InputFile - An InputDefinition for a single file. TrackSelections are scoped to the file specified.
type InputFile struct {
	InputDefinition
	// Name of the file that this input definition applies to.
	Filename *string `json:"filename,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InputFile.
func (i InputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.InputDefinition.marshalInternal(objectMap, "#Microsoft.Media.InputFile")
	populate(objectMap, "filename", i.Filename)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputFile.
func (i *InputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filename":
			err = unpopulate(val, &i.Filename)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.InputDefinition.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Job - A Job resource type. The progress and state can be obtained by polling a Job or subscribing to events using EventGrid.
type Job struct {
	ProxyResource
	// The resource properties.
	Properties *JobProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	return json.Marshal(objectMap)
}

// JobCollection - A collection of Job items.
type JobCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Job items.
	Value []*Job `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobCollection.
func (j JobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", j.ODataNextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobError - Details of JobOutput errors.
type JobError struct {
	// READ-ONLY; Helps with categorization of errors.
	Category *JobErrorCategory `json:"category,omitempty" azure:"ro"`

	// READ-ONLY; Error code describing the error.
	Code *JobErrorCode `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; An array of details about specific errors that led to this reported error.
	Details []*JobErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; A human-readable language-dependent representation of the error.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
	Retry *JobRetry `json:"retry,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobError.
func (j JobError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", j.Category)
	populate(objectMap, "code", j.Code)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "retry", j.Retry)
	return json.Marshal(objectMap)
}

// JobErrorDetail - Details of JobOutput errors.
type JobErrorDetail struct {
	// READ-ONLY; Code describing the error detail.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; A human-readable representation of the error.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// JobInputClassification provides polymorphic access to related types.
// Call the interface's GetJobInput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobInput, *JobInputAsset, *JobInputClip, *JobInputHttp, *JobInputSequence, *JobInputs
type JobInputClassification interface {
	// GetJobInput returns the JobInput content of the underlying type.
	GetJobInput() *JobInput
}

// JobInput - Base class for inputs to a Job.
type JobInput struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetJobInput implements the JobInputClassification interface for type JobInput.
func (j *JobInput) GetJobInput() *JobInput { return j }

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInput.
func (j *JobInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return j.unmarshalInternal(rawMsg)
}

func (j JobInput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	j.ODataType = &discValue
	objectMap["@odata.type"] = j.ODataType
}

func (j *JobInput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobInputAsset - Represents an Asset for input into a Job.
type JobInputAsset struct {
	JobInputClip
	// REQUIRED; The name of the input Asset.
	AssetName *string `json:"assetName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobInputAsset.
func (j JobInputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.JobInputClip.marshalInternal(objectMap, "#Microsoft.Media.JobInputAsset")
	populate(objectMap, "assetName", j.AssetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputAsset.
func (j *JobInputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobInputClip.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobInputClipClassification provides polymorphic access to related types.
// Call the interface's GetJobInputClip() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobInputAsset, *JobInputClip, *JobInputHttp
type JobInputClipClassification interface {
	JobInputClassification
	// GetJobInputClip returns the JobInputClip content of the underlying type.
	GetJobInputClip() *JobInputClip
}

// JobInputClip - Represents input files for a Job.
type JobInputClip struct {
	JobInput
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End ClipTimeClassification `json:"end,omitempty"`

	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive
	// data exposure.
	Files []*string `json:"files,omitempty"`

	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []InputDefinitionClassification `json:"inputDefinitions,omitempty"`

	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as
	// to take an image file with the label 'xyz' and
	// apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it
	// should have the label 'xyz'.
	Label *string `json:"label,omitempty"`

	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start ClipTimeClassification `json:"start,omitempty"`
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputClip.
func (j *JobInputClip) GetJobInputClip() *JobInputClip { return j }

// MarshalJSON implements the json.Marshaller interface for type JobInputClip.
func (j JobInputClip) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.marshalInternal(objectMap, "#Microsoft.Media.JobInputClip")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputClip.
func (j *JobInputClip) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return j.unmarshalInternal(rawMsg)
}

func (j JobInputClip) marshalInternal(objectMap map[string]interface{}, discValue string) {
	j.JobInput.marshalInternal(objectMap, discValue)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	populate(objectMap, "start", j.Start)
}

func (j *JobInputClip) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobInput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobInputHTTP - Represents HTTPS job input.
type JobInputHTTP struct {
	JobInputClip
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be
	// fully qualified uris. Maximum length of 4000
	// characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
	BaseURI *string `json:"baseUri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobInputHTTP.
func (j JobInputHTTP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.JobInputClip.marshalInternal(objectMap, "#Microsoft.Media.JobInputHttp")
	populate(objectMap, "baseUri", j.BaseURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputHTTP.
func (j *JobInputHTTP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
			err = unpopulate(val, &j.BaseURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobInputClip.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobInputSequence - A Sequence contains an ordered list of Clips where each clip is a JobInput. The Sequence will be treated as a single input.
type JobInputSequence struct {
	JobInput
	// JobInputs that make up the timeline.
	Inputs []JobInputClipClassification `json:"inputs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobInputSequence.
func (j JobInputSequence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.JobInput.marshalInternal(objectMap, "#Microsoft.Media.JobInputSequence")
	populate(objectMap, "inputs", j.Inputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputSequence.
func (j *JobInputSequence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClipClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobInput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobInputs - Describes a list of inputs to a Job.
type JobInputs struct {
	JobInput
	// List of inputs to a Job.
	Inputs []JobInputClassification `json:"inputs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobInputs.
func (j JobInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.JobInput.marshalInternal(objectMap, "#Microsoft.Media.JobInputs")
	populate(objectMap, "inputs", j.Inputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputs.
func (j *JobInputs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobInput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobOutputClassification provides polymorphic access to related types.
// Call the interface's GetJobOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *JobOutput, *JobOutputAsset
type JobOutputClassification interface {
	// GetJobOutput returns the JobOutput content of the underlying type.
	GetJobOutput() *JobOutput
}

// JobOutput - Describes all the properties of a JobOutput.
type JobOutput struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput,
	// whereby your Job has more than one JobOutput. In
	// such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when
	// you retrieve the Job, either through events or on a
	// GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will
	// be used, where the preset name is the name of the
	// preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is
	// the same as the relative index of the corresponding
	// TransformOutput within its Transform.
	Label *string `json:"label,omitempty"`

	// A preset used to override the preset in the corresponding transform output.
	PresetOverride PresetClassification `json:"presetOverride,omitempty"`

	// READ-ONLY; The UTC date and time at which this Job Output finished processing.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in the Error state, it contains the details of the error.
	Error *JobError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used
	// to predict Job completion times. To determine if the
	// JobOutput is complete, use the State property.
	Progress *int32 `json:"progress,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job Output began processing.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Describes the state of the JobOutput.
	State *JobState `json:"state,omitempty" azure:"ro"`
}

// GetJobOutput implements the JobOutputClassification interface for type JobOutput.
func (j *JobOutput) GetJobOutput() *JobOutput { return j }

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutput.
func (j *JobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return j.unmarshalInternal(rawMsg)
}

func (j JobOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "endTime", (*timeRFC3339)(j.EndTime))
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	j.ODataType = &discValue
	objectMap["@odata.type"] = j.ODataType
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "state", j.State)
}

func (j *JobOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobOutputAsset - Represents an Asset used as a JobOutput.
type JobOutputAsset struct {
	JobOutput
	// REQUIRED; The name of the output Asset.
	AssetName *string `json:"assetName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobOutputAsset.
func (j JobOutputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.JobOutput.marshalInternal(objectMap, "#Microsoft.Media.JobOutputAsset")
	populate(objectMap, "assetName", j.AssetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutputAsset.
func (j *JobOutputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.JobOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobProperties - Properties of the Job.
type JobProperties struct {
	// REQUIRED; The inputs for the Job.
	Input JobInputClassification `json:"input,omitempty"`

	// REQUIRED; The outputs for the Job.
	Outputs []JobOutputClassification `json:"outputs,omitempty"`

	// Customer provided key, value pairs that will be returned in Job and JobOutput state events.
	CorrelationData map[string]*string `json:"correlationData,omitempty"`

	// Optional customer supplied description of the Job.
	Description *string `json:"description,omitempty"`

	// Priority with which the job should be processed. Higher priority jobs are processed before lower priority jobs. If not set, the default is normal.
	Priority *Priority `json:"priority,omitempty"`

	// READ-ONLY; The UTC date and time when the customer has created the Job, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job finished processing.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time when the customer has last updated the Job, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time at which this Job began processing.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the job.
	State *JobState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "correlationData", j.CorrelationData)
	populate(objectMap, "created", (*timeRFC3339)(j.Created))
	populate(objectMap, "description", j.Description)
	populate(objectMap, "endTime", (*timeRFC3339)(j.EndTime))
	populate(objectMap, "input", j.Input)
	populate(objectMap, "lastModified", (*timeRFC3339)(j.LastModified))
	populate(objectMap, "outputs", j.Outputs)
	populate(objectMap, "priority", j.Priority)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationData":
			err = unpopulate(val, &j.CorrelationData)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "input":
			j.Input, err = unmarshalJobInputClassification(val)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "outputs":
			j.Outputs, err = unmarshalJobOutputClassificationArray(val)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, &j.Priority)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobsCancelJobOptions contains the optional parameters for the Jobs.CancelJob method.
type JobsCancelJobOptions struct {
	// placeholder for future optional parameters
}

// JobsCreateOptions contains the optional parameters for the Jobs.Create method.
type JobsCreateOptions struct {
	// placeholder for future optional parameters
}

// JobsDeleteOptions contains the optional parameters for the Jobs.Delete method.
type JobsDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobsGetOptions contains the optional parameters for the Jobs.Get method.
type JobsGetOptions struct {
	// placeholder for future optional parameters
}

// JobsListOptions contains the optional parameters for the Jobs.List method.
type JobsListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
}

// JobsUpdateOptions contains the optional parameters for the Jobs.Update method.
type JobsUpdateOptions struct {
	// placeholder for future optional parameters
}

// JpgFormat - Describes the settings for producing JPEG thumbnails.
type JpgFormat struct {
	ImageFormat
}

// MarshalJSON implements the json.Marshaller interface for type JpgFormat.
func (j JpgFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.ImageFormat.marshalInternal(objectMap, "#Microsoft.Media.JpgFormat")
	return json.Marshal(objectMap)
}

// JpgImage - Describes the properties for producing a series of JPEG images from the input video.
type JpgImage struct {
	Image
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []*JpgLayer `json:"layers,omitempty"`

	// Sets the number of columns used in thumbnail sprite image. The number of rows are automatically calculated and a VTT file is generated with the coordinate
	// mappings for each thumbnail in the sprite.
	// Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel
	// resolution limit 65535x65535.
	SpriteColumn *int32 `json:"spriteColumn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JpgImage.
func (j JpgImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.Image.marshalInternal(objectMap, "#Microsoft.Media.JpgImage")
	populate(objectMap, "layers", j.Layers)
	populate(objectMap, "spriteColumn", j.SpriteColumn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgImage.
func (j *JpgImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "layers":
			err = unpopulate(val, &j.Layers)
			delete(rawMsg, key)
		case "spriteColumn":
			err = unpopulate(val, &j.SpriteColumn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.Image.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JpgLayer - Describes the settings to produce a JPEG image from the input video.
type JpgLayer struct {
	Layer
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int32 `json:"quality,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JpgLayer.
func (j JpgLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.Layer.marshalInternal(objectMap, "#Microsoft.Media.JpgLayer")
	populate(objectMap, "quality", j.Quality)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgLayer.
func (j *JpgLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "quality":
			err = unpopulate(val, &j.Quality)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.Layer.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type KeyDelivery struct {
	// The access control properties for Key Delivery.
	AccessControl *AccessControl `json:"accessControl,omitempty"`
}

type KeyVaultProperties struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference
	// a key without a version (for example
	// https://vault/keys/mykey).
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// READ-ONLY; The current key used to encrypt the Media Services account, including the key version.
	CurrentKeyIdentifier *string `json:"currentKeyIdentifier,omitempty" azure:"ro"`
}

// LayerClassification provides polymorphic access to related types.
// Call the interface's GetLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Layer, *H265Layer, *H265VideoLayer, *JpgLayer, *Layer, *PngLayer, *VideoLayer
type LayerClassification interface {
	// GetLayer returns the Layer content of the underlying type.
	GetLayer() *Layer
}

// Layer - The encoder can be configured to produce video and/or images (thumbnails) at different resolutions, by specifying a layer for each desired resolution.
// A layer represents the properties for the video
// or image at a resolution.
type Layer struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video
	// has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`

	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`

	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video
	// has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
}

// GetLayer implements the LayerClassification interface for type Layer.
func (l *Layer) GetLayer() *Layer { return l }

// UnmarshalJSON implements the json.Unmarshaller interface for type Layer.
func (l *Layer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return l.unmarshalInternal(rawMsg)
}

func (l Layer) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "height", l.Height)
	populate(objectMap, "label", l.Label)
	l.ODataType = &discValue
	objectMap["@odata.type"] = l.ODataType
	populate(objectMap, "width", l.Width)
}

func (l *Layer) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "height":
			err = unpopulate(val, &l.Height)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &l.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &l.ODataType)
			delete(rawMsg, key)
		case "width":
			err = unpopulate(val, &l.Width)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ListContainerSasInput - The parameters to the list SAS request.
type ListContainerSasInput struct {
	// The SAS URL expiration time. This must be less than 24 hours from the current time.
	ExpiryTime *time.Time `json:"expiryTime,omitempty"`

	// The permissions to set on the SAS URL.
	Permissions *AssetContainerPermission `json:"permissions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListContainerSasInput.
func (l ListContainerSasInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expiryTime", (*timeRFC3339)(l.ExpiryTime))
	populate(objectMap, "permissions", l.Permissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListContainerSasInput.
func (l *ListContainerSasInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			l.ExpiryTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, &l.Permissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ListContentKeysResponse - Class of response for listContentKeys action
type ListContentKeysResponse struct {
	// ContentKeys used by current Streaming Locator
	ContentKeys []*StreamingLocatorContentKey `json:"contentKeys,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListContentKeysResponse.
func (l ListContentKeysResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentKeys", l.ContentKeys)
	return json.Marshal(objectMap)
}

type ListEdgePoliciesInput struct {
	// Unique identifier of the edge device.
	DeviceID *string `json:"deviceId,omitempty"`
}

// ListPathsResponse - Class of response for listPaths action
type ListPathsResponse struct {
	// Download Paths supported by current Streaming Locator
	DownloadPaths []*string `json:"downloadPaths,omitempty"`

	// Streaming Paths supported by current Streaming Locator
	StreamingPaths []*StreamingPath `json:"streamingPaths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListPathsResponse.
func (l ListPathsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "downloadPaths", l.DownloadPaths)
	populate(objectMap, "streamingPaths", l.StreamingPaths)
	return json.Marshal(objectMap)
}

// ListStreamingLocatorsResponse - The Streaming Locators associated with this Asset.
type ListStreamingLocatorsResponse struct {
	// READ-ONLY; The list of Streaming Locators.
	StreamingLocators []*AssetStreamingLocator `json:"streamingLocators,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListStreamingLocatorsResponse.
func (l ListStreamingLocatorsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "streamingLocators", l.StreamingLocators)
	return json.Marshal(objectMap)
}

// LiveEvent - The live event.
type LiveEvent struct {
	TrackedResource
	// The live event properties.
	Properties *LiveEventProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEvent.
func (l LiveEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	return json.Marshal(objectMap)
}

// LiveEventActionInput - The LiveEvent action input parameter definition.
type LiveEventActionInput struct {
	// The flag indicates whether live outputs are automatically deleted when live event is being stopped. Deleting live outputs do not delete the underlying
	// assets.
	RemoveOutputsOnStop *bool `json:"removeOutputsOnStop,omitempty"`
}

// LiveEventEncoding - Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncoding struct {
	// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio
	// layer(s) to the output. When encodingType is set to
	// Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101
	// for more information. This property cannot
	// be modified after the live event is created.
	EncodingType *LiveEventEncodingType `json:"encodingType,omitempty"`

	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event.
	// For example, use PT2S to indicate 2 seconds. For
	// the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event,
	// the fragment duration defaults to 2 seconds.
	// The value cannot be set for pass-through live events.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType
	// is set to Standard, then the default preset
	// name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `json:"presetName,omitempty"`

	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *StretchMode `json:"stretchMode,omitempty"`
}

// LiveEventEndpoint - The live event endpoint.
type LiveEventEndpoint struct {
	// The endpoint protocol.
	Protocol *string `json:"protocol,omitempty"`

	// The endpoint URL.
	URL *string `json:"url,omitempty"`
}

// LiveEventInput - The live event input.
type LiveEventInput struct {
	// REQUIRED; The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol *LiveEventInputProtocol `json:"streamingProtocol,omitempty"`

	// Access control for live event input.
	AccessControl *LiveEventInputAccessControl `json:"accessControl,omitempty"`

	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate
	// a unique value.
	AccessToken *string `json:"accessToken,omitempty"`

	// The input endpoints for the live event.
	Endpoints []*LiveEventEndpoint `json:"endpoints,omitempty"`

	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example,
	// use PT2S to indicate 2 seconds. Leave the
	// value empty for encoding live events.
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventInput.
func (l LiveEventInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "accessToken", l.AccessToken)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "keyFrameIntervalDuration", l.KeyFrameIntervalDuration)
	populate(objectMap, "streamingProtocol", l.StreamingProtocol)
	return json.Marshal(objectMap)
}

// LiveEventInputAccessControl - The IP access control for live event input.
type LiveEventInputAccessControl struct {
	// The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventInputTrackSelection - A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelection struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `json:"operation,omitempty"`

	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `json:"property,omitempty"`

	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `json:"value,omitempty"`
}

// LiveEventListResult - The LiveEvent list result.
type LiveEventListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of live outputs.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List Live Event operation.
	Value []*LiveEvent `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventListResult.
func (l LiveEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LiveEventOutputTranscriptionTrack - Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This
// property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrack struct {
	// REQUIRED; The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName *string `json:"trackName,omitempty"`
}

// LiveEventPreview - Live event preview settings.
type LiveEventPreview struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControl `json:"accessControl,omitempty"`

	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be
	// updated. The identifier can be used in the
	// CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`

	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []*LiveEventEndpoint `json:"endpoints,omitempty"`

	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event
	// is created. If omitted, the service will
	// generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `json:"previewLocator,omitempty"`

	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventPreview.
func (l LiveEventPreview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "alternativeMediaId", l.AlternativeMediaID)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "previewLocator", l.PreviewLocator)
	populate(objectMap, "streamingPolicyName", l.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// LiveEventPreviewAccessControl - The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControl struct {
	// The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventProperties - The live event properties.
type LiveEventProperties struct {
	// REQUIRED; Live event input settings. It defines how the live event receives input from a contribution encoder.
	Input *LiveEventInput `json:"input,omitempty"`

	// Live event cross site access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`

	// A description for the live event.
	Description *string `json:"description,omitempty"`

	// Encoding settings for the live event. It configures whether a live encoder is used for the live event and settings for the live encoder if it is used.
	Encoding *LiveEventEncoding `json:"encoding,omitempty"`

	// When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the hostname assigned to the live event preview and ingest endpoints.
	// The final hostname would be a combination of
	// this prefix, the media service account name and a short code for the Azure Media Services data center.
	HostnamePrefix *string `json:"hostnamePrefix,omitempty"`

	// Live event preview settings. Preview allows live event producers to preview the live streaming content without creating any live output.
	Preview *LiveEventPreview `json:"preview,omitempty"`

	// The options to use for the LiveEvent. This value is specified at creation time and cannot be updated. The valid values for the array entry values are
	// 'Default' and 'LowLatency'.
	StreamOptions []*StreamOptionsFlag `json:"streamOptions,omitempty"`

	// Live transcription settings for the live event. See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription
	// feature.
	Transcriptions []*LiveEventTranscription `json:"transcriptions,omitempty"`

	// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. This value can only be updated if the live event
	// is in Standby state
	UseStaticHostname *bool `json:"useStaticHostname,omitempty"`

	// READ-ONLY; The creation time for the live event
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The last modified time of the live event.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the live event.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the live event. See https://go.microsoft.com/fwlink/?linkid=2139012 for more information.
	ResourceState *LiveEventResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventProperties.
func (l LiveEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "created", (*timeRFC3339)(l.Created))
	populate(objectMap, "crossSiteAccessPolicies", l.CrossSiteAccessPolicies)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "encoding", l.Encoding)
	populate(objectMap, "hostnamePrefix", l.HostnamePrefix)
	populate(objectMap, "input", l.Input)
	populate(objectMap, "lastModified", (*timeRFC3339)(l.LastModified))
	populate(objectMap, "preview", l.Preview)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	populate(objectMap, "streamOptions", l.StreamOptions)
	populate(objectMap, "transcriptions", l.Transcriptions)
	populate(objectMap, "useStaticHostname", l.UseStaticHostname)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveEventProperties.
func (l *LiveEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			l.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &l.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "encoding":
			err = unpopulate(val, &l.Encoding)
			delete(rawMsg, key)
		case "hostnamePrefix":
			err = unpopulate(val, &l.HostnamePrefix)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &l.Input)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			l.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "preview":
			err = unpopulate(val, &l.Preview)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		case "streamOptions":
			err = unpopulate(val, &l.StreamOptions)
			delete(rawMsg, key)
		case "transcriptions":
			err = unpopulate(val, &l.Transcriptions)
			delete(rawMsg, key)
		case "useStaticHostname":
			err = unpopulate(val, &l.UseStaticHostname)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LiveEventTranscription - Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property
// is reserved for future use, any value set on this property will be
// ignored.
type LiveEventTranscription struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for
	// future use, any value set on this property will
	// be ignored.
	InputTrackSelection []*LiveEventInputTrackSelection `json:"inputTrackSelection,omitempty"`

	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should
	// be in BCP-47 format (e.g: 'en-US'). See
	// https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language *string `json:"language,omitempty"`

	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use,
	// any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrack `json:"outputTranscriptionTrack,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventTranscription.
func (l LiveEventTranscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputTrackSelection", l.InputTrackSelection)
	populate(objectMap, "language", l.Language)
	populate(objectMap, "outputTranscriptionTrack", l.OutputTranscriptionTrack)
	return json.Marshal(objectMap)
}

// LiveEventsBeginAllocateOptions contains the optional parameters for the LiveEvents.BeginAllocate method.
type LiveEventsBeginAllocateOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsBeginCreateOptions contains the optional parameters for the LiveEvents.BeginCreate method.
type LiveEventsBeginCreateOptions struct {
	// The flag indicates if the resource should be automatically started on creation.
	AutoStart *bool
}

// LiveEventsBeginDeleteOptions contains the optional parameters for the LiveEvents.BeginDelete method.
type LiveEventsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsBeginResetOptions contains the optional parameters for the LiveEvents.BeginReset method.
type LiveEventsBeginResetOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsBeginStartOptions contains the optional parameters for the LiveEvents.BeginStart method.
type LiveEventsBeginStartOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsBeginStopOptions contains the optional parameters for the LiveEvents.BeginStop method.
type LiveEventsBeginStopOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsBeginUpdateOptions contains the optional parameters for the LiveEvents.BeginUpdate method.
type LiveEventsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsGetOptions contains the optional parameters for the LiveEvents.Get method.
type LiveEventsGetOptions struct {
	// placeholder for future optional parameters
}

// LiveEventsListOptions contains the optional parameters for the LiveEvents.List method.
type LiveEventsListOptions struct {
	// placeholder for future optional parameters
}

// LiveOutput - The Live Output.
type LiveOutput struct {
	ProxyResource
	// Live output properties.
	Properties *LiveOutputProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutput.
func (l LiveOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	return json.Marshal(objectMap)
}

// LiveOutputListResult - The LiveOutput list result.
type LiveOutputListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of live outputs.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List LiveOutput operation.
	Value []*LiveOutput `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputListResult.
func (l LiveOutputListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LiveOutputProperties - The JSON object that contains the properties required to create a live output.
type LiveOutputProperties struct {
	// REQUIRED; ISO 8601 time between 1 minute to 25 hours to indicate the maximum content length that can be archived in the asset for this live output. This
	// also sets the maximum content length for the rewind
	// window. For example, use PT1H30M to indicate 1 hour and 30 minutes of archive window.
	ArchiveWindowLength *string `json:"archiveWindowLength,omitempty"`

	// REQUIRED; The asset that the live output will write to.
	AssetName *string `json:"assetName,omitempty"`

	// The description of the live output.
	Description *string `json:"description,omitempty"`

	// HTTP Live Streaming (HLS) packing setting for the live output.
	Hls *Hls `json:"hls,omitempty"`

	// The manifest file name. If not provided, the service will generate one automatically.
	ManifestName *string `json:"manifestName,omitempty"`

	// The initial timestamp that the live output will start at, any content before this value will not be archived.
	OutputSnapTime *int64 `json:"outputSnapTime,omitempty"`

	// READ-ONLY; The creation time the live output.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The time the live output was last modified.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the live output.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the live output.
	ResourceState *LiveOutputResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputProperties.
func (l LiveOutputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveWindowLength", l.ArchiveWindowLength)
	populate(objectMap, "assetName", l.AssetName)
	populate(objectMap, "created", (*timeRFC3339)(l.Created))
	populate(objectMap, "description", l.Description)
	populate(objectMap, "hls", l.Hls)
	populate(objectMap, "lastModified", (*timeRFC3339)(l.LastModified))
	populate(objectMap, "manifestName", l.ManifestName)
	populate(objectMap, "outputSnapTime", l.OutputSnapTime)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveOutputProperties.
func (l *LiveOutputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archiveWindowLength":
			err = unpopulate(val, &l.ArchiveWindowLength)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &l.AssetName)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			l.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "hls":
			err = unpopulate(val, &l.Hls)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			l.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "manifestName":
			err = unpopulate(val, &l.ManifestName)
			delete(rawMsg, key)
		case "outputSnapTime":
			err = unpopulate(val, &l.OutputSnapTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LiveOutputsBeginCreateOptions contains the optional parameters for the LiveOutputs.BeginCreate method.
type LiveOutputsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsBeginDeleteOptions contains the optional parameters for the LiveOutputs.BeginDelete method.
type LiveOutputsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsGetOptions contains the optional parameters for the LiveOutputs.Get method.
type LiveOutputsGetOptions struct {
	// placeholder for future optional parameters
}

// LiveOutputsListOptions contains the optional parameters for the LiveOutputs.List method.
type LiveOutputsListOptions struct {
	// placeholder for future optional parameters
}

// LocationsCheckNameAvailabilityOptions contains the optional parameters for the Locations.CheckNameAvailability method.
type LocationsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// LogSpecification - A diagnostic log emitted by service.
type LogSpecification struct {
	// READ-ONLY; The time range for requests in each blob.
	BlobDuration *string `json:"blobDuration,omitempty" azure:"ro"`

	// READ-ONLY; The diagnostic log category display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The diagnostic log category name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MediaFilterProperties - The Media Filter properties.
type MediaFilterProperties struct {
	// The first quality.
	FirstQuality *FirstQuality `json:"firstQuality,omitempty"`

	// The presentation time range.
	PresentationTimeRange *PresentationTimeRange `json:"presentationTimeRange,omitempty"`

	// The tracks selection conditions.
	Tracks []*FilterTrackSelection `json:"tracks,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaFilterProperties.
func (m MediaFilterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstQuality", m.FirstQuality)
	populate(objectMap, "presentationTimeRange", m.PresentationTimeRange)
	populate(objectMap, "tracks", m.Tracks)
	return json.Marshal(objectMap)
}

// MediaService - A Media Services account.
type MediaService struct {
	TrackedResource
	// The Managed Identity for the Media Services account.
	Identity *MediaServiceIdentity `json:"identity,omitempty"`

	// The resource properties.
	Properties *MediaServiceProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaService.
func (m MediaService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	return json.Marshal(objectMap)
}

// MediaServiceCollection - A collection of MediaService items.
type MediaServiceCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of MediaService items.
	Value []*MediaService `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceCollection.
func (m MediaServiceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", m.ODataNextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

type MediaServiceIdentity struct {
	// REQUIRED; The identity type.
	Type *string `json:"type,omitempty"`

	// The user assigned managed identities.
	UserAssignedIdentities map[string]*UserAssignedManagedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The Principal ID of the identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The Tenant ID of the identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceIdentity.
func (m MediaServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MediaServiceProperties - Properties of the Media Services account.
type MediaServiceProperties struct {
	// The account encryption properties.
	Encryption *AccountEncryption `json:"encryption,omitempty"`

	// The Key Delivery properties for Media Services account.
	KeyDelivery *KeyDelivery `json:"keyDelivery,omitempty"`

	// Whether or not public network access is allowed for resources under the Media Services account.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// The storage accounts for this resource.
	StorageAccounts       []*StorageAccount      `json:"storageAccounts,omitempty"`
	StorageAuthentication *StorageAuthentication `json:"storageAuthentication,omitempty"`

	// READ-ONLY; The Media Services account ID.
	MediaServiceID *string `json:"mediaServiceId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceProperties.
func (m MediaServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryption", m.Encryption)
	populate(objectMap, "keyDelivery", m.KeyDelivery)
	populate(objectMap, "mediaServiceId", m.MediaServiceID)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "storageAccounts", m.StorageAccounts)
	populate(objectMap, "storageAuthentication", m.StorageAuthentication)
	return json.Marshal(objectMap)
}

// MediaServiceUpdate - A Media Services account update.
type MediaServiceUpdate struct {
	// The Managed Identity for the Media Services account.
	Identity *MediaServiceIdentity `json:"identity,omitempty"`

	// The resource properties.
	Properties *MediaServiceProperties `json:"properties,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceUpdate.
func (m MediaServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MediaservicesCreateOrUpdateOptions contains the optional parameters for the Mediaservices.CreateOrUpdate method.
type MediaservicesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesDeleteOptions contains the optional parameters for the Mediaservices.Delete method.
type MediaservicesDeleteOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesGetOptions contains the optional parameters for the Mediaservices.Get method.
type MediaservicesGetOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesListBySubscriptionOptions contains the optional parameters for the Mediaservices.ListBySubscription method.
type MediaservicesListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesListEdgePoliciesOptions contains the optional parameters for the Mediaservices.ListEdgePolicies method.
type MediaservicesListEdgePoliciesOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesListOptions contains the optional parameters for the Mediaservices.List method.
type MediaservicesListOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesSyncStorageKeysOptions contains the optional parameters for the Mediaservices.SyncStorageKeys method.
type MediaservicesSyncStorageKeysOptions struct {
	// placeholder for future optional parameters
}

// MediaservicesUpdateOptions contains the optional parameters for the Mediaservices.Update method.
type MediaservicesUpdateOptions struct {
	// placeholder for future optional parameters
}

// MetricDimension - A metric dimension.
type MetricDimension struct {
	// READ-ONLY; The display name for the dimension.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The metric dimension name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Whether to export metric to shoebox.
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty" azure:"ro"`
}

// MetricSpecification - A metric emitted by service.
type MetricSpecification struct {
	// Supported aggregation types.
	SupportedAggregationTypes []*string `json:"supportedAggregationTypes,omitempty"`

	// READ-ONLY; The metric aggregation type
	AggregationType *MetricAggregationType `json:"aggregationType,omitempty" azure:"ro"`

	// READ-ONLY; The metric dimensions.
	Dimensions []*MetricDimension `json:"dimensions,omitempty" azure:"ro"`

	// READ-ONLY; The metric display description.
	DisplayDescription *string `json:"displayDescription,omitempty" azure:"ro"`

	// READ-ONLY; The metric display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether regional MDM account is enabled.
	EnableRegionalMdmAccount *bool `json:"enableRegionalMdmAccount,omitempty" azure:"ro"`

	// READ-ONLY; The metric lock aggregation type
	LockAggregationType *MetricAggregationType `json:"lockAggregationType,omitempty" azure:"ro"`

	// READ-ONLY; The metric name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The source MDM account.
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty" azure:"ro"`

	// READ-ONLY; The source MDM namespace.
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty" azure:"ro"`

	// READ-ONLY; The supported time grain types.
	SupportedTimeGrainTypes []*string `json:"supportedTimeGrainTypes,omitempty" azure:"ro"`

	// READ-ONLY; The metric unit
	Unit *MetricUnit `json:"unit,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricSpecification.
func (m MetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", m.AggregationType)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", m.EnableRegionalMdmAccount)
	populate(objectMap, "lockAggregationType", m.LockAggregationType)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceMdmAccount", m.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", m.SourceMdmNamespace)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "supportedTimeGrainTypes", m.SupportedTimeGrainTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// Mp4Format - Describes the properties for an output ISO MP4 file.
type Mp4Format struct {
	MultiBitrateFormat
}

// MarshalJSON implements the json.Marshaller interface for type Mp4Format.
func (m Mp4Format) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MultiBitrateFormat.marshalInternal(objectMap, "#Microsoft.Media.Mp4Format")
	return json.Marshal(objectMap)
}

// MultiBitrateFormatClassification provides polymorphic access to related types.
// Call the interface's GetMultiBitrateFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Mp4Format, *MultiBitrateFormat, *TransportStreamFormat
type MultiBitrateFormatClassification interface {
	FormatClassification
	// GetMultiBitrateFormat returns the MultiBitrateFormat content of the underlying type.
	GetMultiBitrateFormat() *MultiBitrateFormat
}

// MultiBitrateFormat - Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output
// file for each video layer which is muxed together with all the
// audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormat struct {
	Format
	// The list of output files to produce. Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []*OutputFile `json:"outputFiles,omitempty"`
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) GetMultiBitrateFormat() *MultiBitrateFormat { return m }

// MarshalJSON implements the json.Marshaller interface for type MultiBitrateFormat.
func (m MultiBitrateFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.marshalInternal(objectMap, "#Microsoft.Media.MultiBitrateFormat")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MultiBitrateFormat) marshalInternal(objectMap map[string]interface{}, discValue string) {
	m.Format.marshalInternal(objectMap, discValue)
	populate(objectMap, "outputFiles", m.OutputFiles)
}

func (m *MultiBitrateFormat) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "outputFiles":
			err = unpopulate(val, &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.Format.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NoEncryption - Class for NoEncryption scheme
type NoEncryption struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// Operation - An operation.
type Operation struct {
	// REQUIRED; The operation name.
	Name *string `json:"name,omitempty"`

	// Indicates the action type.
	ActionType *ActionType `json:"actionType,omitempty"`

	// The operation display name.
	Display *OperationDisplay `json:"display,omitempty"`

	// Whether the operation applies to data-plane.
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Origin of the operation.
	Origin *string `json:"origin,omitempty"`

	// Operation properties format.
	Properties *Properties `json:"properties,omitempty"`
}

// OperationCollection - A collection of Operation items.
type OperationCollection struct {
	// A collection of Operation items.
	Value []*Operation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationCollection.
func (o OperationCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationDisplay - Operation details.
type OperationDisplay struct {
	// The operation description.
	Description *string `json:"description,omitempty"`

	// The operation type.
	Operation *string `json:"operation,omitempty"`

	// The service provider.
	Provider *string `json:"provider,omitempty"`

	// Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OutputFile - Represents an output file produced.
type OutputFile struct {
	// REQUIRED; The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing
	// two video layers with labels v1 and v2, and one audio
	// layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track
	// represented by a1.
	Labels []*string `json:"labels,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "labels", o.Labels)
	return json.Marshal(objectMap)
}

// OverlayClassification provides polymorphic access to related types.
// Call the interface's GetOverlay() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioOverlay, *Overlay, *VideoOverlay
type OverlayClassification interface {
	// GetOverlay returns the Overlay content of the underlying type.
	GetOverlay() *Overlay
}

// Overlay - Base type for all overlays - image, audio or video.
type Overlay struct {
	// REQUIRED; The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG,
	// PNG, GIF or BMP format, or an audio file (such as a WAV,
	// MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel *string `json:"inputLabel,omitempty"`

	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`

	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`

	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the
	// overlay at 30 seconds into the input video. If not
	// specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration
	// is greater than the input video duration,
	// else the overlay will last as long as the overlay media duration.
	End *string `json:"end,omitempty"`

	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior
	// is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`

	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior
	// is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`

	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start
	// the overlay at 5 seconds into the input video.
	// If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
}

// GetOverlay implements the OverlayClassification interface for type Overlay.
func (o *Overlay) GetOverlay() *Overlay { return o }

// UnmarshalJSON implements the json.Unmarshaller interface for type Overlay.
func (o *Overlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return o.unmarshalInternal(rawMsg)
}

func (o Overlay) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "audioGainLevel", o.AudioGainLevel)
	populate(objectMap, "end", o.End)
	populate(objectMap, "fadeInDuration", o.FadeInDuration)
	populate(objectMap, "fadeOutDuration", o.FadeOutDuration)
	populate(objectMap, "inputLabel", o.InputLabel)
	o.ODataType = &discValue
	objectMap["@odata.type"] = o.ODataType
	populate(objectMap, "start", o.Start)
}

func (o *Overlay) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, &o.AudioGainLevel)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, &o.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, &o.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, &o.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, &o.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &o.ODataType)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &o.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PNGFormat - Describes the settings for producing PNG thumbnails.
type PNGFormat struct {
	ImageFormat
}

// MarshalJSON implements the json.Marshaller interface for type PNGFormat.
func (p PNGFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ImageFormat.marshalInternal(objectMap, "#Microsoft.Media.PngFormat")
	return json.Marshal(objectMap)
}

// PNGImage - Describes the properties for producing a series of PNG images from the input video.
type PNGImage struct {
	Image
	// A collection of output PNG image layers to be produced by the encoder.
	Layers []*PNGLayer `json:"layers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PNGImage.
func (p PNGImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Image.marshalInternal(objectMap, "#Microsoft.Media.PngImage")
	populate(objectMap, "layers", p.Layers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGImage.
func (p *PNGImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "layers":
			err = unpopulate(val, &p.Layers)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Image.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PNGLayer - Describes the settings to produce a PNG image from the input video.
type PNGLayer struct {
	Layer
}

// MarshalJSON implements the json.Marshaller interface for type PNGLayer.
func (p PNGLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Layer.marshalInternal(objectMap, "#Microsoft.Media.PngLayer")
	return json.Marshal(objectMap)
}

// PresentationTimeRange - The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRange struct {
	// The absolute end time boundary.
	EndTimestamp *int64 `json:"endTimestamp,omitempty"`

	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `json:"forceEndTimestamp,omitempty"`

	// The relative to end right edge.
	LiveBackoffDuration *int64 `json:"liveBackoffDuration,omitempty"`

	// The relative to end sliding window.
	PresentationWindowDuration *int64 `json:"presentationWindowDuration,omitempty"`

	// The absolute start time boundary.
	StartTimestamp *int64 `json:"startTimestamp,omitempty"`

	// The time scale of time stamps.
	Timescale *int64 `json:"timescale,omitempty"`
}

// PresetClassification provides polymorphic access to related types.
// Call the interface's GetPreset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioAnalyzerPreset, *BuiltInStandardEncoderPreset, *FaceDetectorPreset, *Preset, *StandardEncoderPreset, *VideoAnalyzerPreset
type PresetClassification interface {
	// GetPreset returns the Preset content of the underlying type.
	GetPreset() *Preset
}

// Preset - Base type for all Presets, which define the recipe or instructions on how the input media files should be processed.
type Preset struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetPreset implements the PresetClassification interface for type Preset.
func (p *Preset) GetPreset() *Preset { return p }

// UnmarshalJSON implements the json.Unmarshaller interface for type Preset.
func (p *Preset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return p.unmarshalInternal(rawMsg)
}

func (p Preset) marshalInternal(objectMap map[string]interface{}, discValue string) {
	p.ODataType = &discValue
	objectMap["@odata.type"] = p.ODataType
}

func (p *Preset) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PresetConfigurations - An object of optional configuration settings for encoder.
type PresetConfigurations struct {
	// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but
	// less compression efficiency.
	Complexity *Complexity `json:"complexity,omitempty"`

	// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput
	// to produce audio-only and video-only
	// outputs in separate MP4 files.
	InterleaveOutput *InterleaveOutput `json:"interleaveOutput,omitempty"`

	// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
	KeyFrameIntervalInSeconds *float32 `json:"keyFrameIntervalInSeconds,omitempty"`

	// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate
	// outputs for contents with high complexity.
	MaxBitrateBps *int32 `json:"maxBitrateBps,omitempty"`

	// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
	MaxHeight *int32 `json:"maxHeight,omitempty"`

	// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost
	// of the encoding job.
	MaxLayers *int32 `json:"maxLayers,omitempty"`

	// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers
	// users with low network bandwidth.
	MinBitrateBps *int32 `json:"minBitrateBps,omitempty"`

	// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
	MinHeight *int32 `json:"minHeight,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	Resource
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionListResult - List of private endpoint connection associated with the specified storage account
type PrivateEndpointConnectionListResult struct {
	// Array of private endpoint connections
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// REQUIRED; A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// READ-ONLY; The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnections.CreateOrUpdate method.
type PrivateEndpointConnectionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsDeleteOptions contains the optional parameters for the PrivateEndpointConnections.Delete method.
type PrivateEndpointConnectionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	Resource
	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource Private link DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`

	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesGetOptions contains the optional parameters for the PrivateLinkResources.Get method.
type PrivateLinkResourcesGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesListOptions contains the optional parameters for the PrivateLinkResources.List method.
type PrivateLinkResourcesListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// Properties - The service specification property.
type Properties struct {
	// READ-ONLY; The service specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty" azure:"ro"`
}

// ProxyResource - The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location
type ProxyResource struct {
	Resource
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	p.Resource.marshalInternal(objectMap)
}

// Rectangle - Describes the properties of a rectangular window applied to the input media before processing it.
type Rectangle struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `json:"height,omitempty"`

	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `json:"left,omitempty"`

	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `json:"top,omitempty"`

	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `json:"width,omitempty"`
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

type ResourceIdentity struct {
	// REQUIRED; Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
	UseSystemAssignedIdentity *bool `json:"useSystemAssignedIdentity,omitempty"`

	// The user assigned managed identity's ARM ID to use when accessing a resource.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// SelectAudioTrackByAttribute - Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttribute struct {
	AudioTrackDescriptor
	// REQUIRED; The TrackAttribute to filter the tracks by.
	Attribute *TrackAttribute `json:"attribute,omitempty"`

	// REQUIRED; The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter *AttributeFilter `json:"filter,omitempty"`

	// The value to filter the tracks by. Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `json:"filterValue,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByAttribute.
func (s SelectAudioTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AudioTrackDescriptor.marshalInternal(objectMap, "#Microsoft.Media.SelectAudioTrackByAttribute")
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AudioTrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SelectAudioTrackByID - Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByID struct {
	AudioTrackDescriptor
	// REQUIRED; Track identifier to select
	TrackID *int64 `json:"trackId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByID.
func (s SelectAudioTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AudioTrackDescriptor.marshalInternal(objectMap, "#Microsoft.Media.SelectAudioTrackById")
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AudioTrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SelectVideoTrackByAttribute - Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttribute struct {
	VideoTrackDescriptor
	// REQUIRED; The TrackAttribute to filter the tracks by.
	Attribute *TrackAttribute `json:"attribute,omitempty"`

	// REQUIRED; The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter *AttributeFilter `json:"filter,omitempty"`

	// The value to filter the tracks by. Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this
	// should be an integer value in bits per second (e.g:
	// '1500000'). The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `json:"filterValue,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByAttribute.
func (s SelectVideoTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.VideoTrackDescriptor.marshalInternal(objectMap, "#Microsoft.Media.SelectVideoTrackByAttribute")
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.VideoTrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SelectVideoTrackByID - Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByID struct {
	VideoTrackDescriptor
	// REQUIRED; Track identifier to select
	TrackID *int64 `json:"trackId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByID.
func (s SelectVideoTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.VideoTrackDescriptor.marshalInternal(objectMap, "#Microsoft.Media.SelectVideoTrackById")
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.VideoTrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceSpecification - The service metric specifications.
type ServiceSpecification struct {
	// READ-ONLY; List of log specifications.
	LogSpecifications []*LogSpecification `json:"logSpecifications,omitempty" azure:"ro"`

	// READ-ONLY; List of metric specifications.
	MetricSpecifications []*MetricSpecification `json:"metricSpecifications,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", s.LogSpecifications)
	populate(objectMap, "metricSpecifications", s.MetricSpecifications)
	return json.Marshal(objectMap)
}

// StandardEncoderPreset - Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPreset struct {
	Preset
	// REQUIRED; The list of codecs to be used when encoding the input video.
	Codecs []CodecClassification `json:"codecs,omitempty"`

	// REQUIRED; The list of outputs to be produced by the encoder.
	Formats []FormatClassification `json:"formats,omitempty"`

	// One or more filtering operations that are applied to the input media before encoding.
	Filters *Filters `json:"filters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StandardEncoderPreset.
func (s StandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.Preset.marshalInternal(objectMap, "#Microsoft.Media.StandardEncoderPreset")
	populate(objectMap, "codecs", s.Codecs)
	populate(objectMap, "filters", s.Filters)
	populate(objectMap, "formats", s.Formats)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codecs":
			s.Codecs, err = unmarshalCodecClassificationArray(val)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "formats":
			s.Formats, err = unmarshalFormatClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.Preset.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageAccount - The storage account details.
type StorageAccount struct {
	// REQUIRED; The type of the storage account.
	Type *StorageAccountType `json:"type,omitempty"`

	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard
	// Storage account (either Microsoft.ClassicStorage
	// or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	ID *string `json:"id,omitempty"`

	// The storage account identity.
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// READ-ONLY; The current status of the storage account mapping.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// StorageEncryptedAssetDecryptionData - Data needed to decrypt asset files encrypted with legacy storage encryption.
type StorageEncryptedAssetDecryptionData struct {
	// Asset File encryption metadata.
	AssetFileEncryptionMetadata []*AssetFileEncryptionMetadata `json:"assetFileEncryptionMetadata,omitempty"`

	// The Asset File storage encryption key.
	Key []byte `json:"key,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageEncryptedAssetDecryptionData.
func (s StorageEncryptedAssetDecryptionData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetFileEncryptionMetadata", s.AssetFileEncryptionMetadata)
	populateByteArray(objectMap, "key", s.Key, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageEncryptedAssetDecryptionData.
func (s *StorageEncryptedAssetDecryptionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetFileEncryptionMetadata":
			err = unpopulate(val, &s.AssetFileEncryptionMetadata)
			delete(rawMsg, key)
		case "key":
			err = runtime.DecodeByteArray(string(val), &s.Key, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingEndpoint - The streaming endpoint.
type StreamingEndpoint struct {
	TrackedResource
	// The streaming endpoint properties.
	Properties *StreamingEndpointProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpoint.
func (s StreamingEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// StreamingEndpointAccessControl - Streaming endpoint access control definition.
type StreamingEndpointAccessControl struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControl `json:"akamai,omitempty"`

	// The IP access control of the streaming endpoint.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// StreamingEndpointListResult - The streaming endpoint list result.
type StreamingEndpointListResult struct {
	// The number of result.
	ODataCount *int32 `json:"@odata.count,omitempty"`

	// The link to the next set of results. Not empty if value contains incomplete list of streaming endpoints.
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// The result of the List StreamingEndpoint operation.
	Value []*StreamingEndpoint `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointListResult.
func (s StreamingEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", s.ODataCount)
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingEndpointProperties - The streaming endpoint properties.
type StreamingEndpointProperties struct {
	// REQUIRED; The number of scale units. Use the Scale operation to adjust this value.
	ScaleUnits *int32 `json:"scaleUnits,omitempty"`

	// The access control definition of the streaming endpoint.
	AccessControl *StreamingEndpointAccessControl `json:"accessControl,omitempty"`

	// This feature is deprecated, do not set a value for this property.
	AvailabilitySetName *string `json:"availabilitySetName,omitempty"`

	// The CDN enabled flag.
	CdnEnabled *bool `json:"cdnEnabled,omitempty"`

	// The CDN profile name.
	CdnProfile *string `json:"cdnProfile,omitempty"`

	// The CDN provider name.
	CdnProvider *string `json:"cdnProvider,omitempty"`

	// The streaming endpoint access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`

	// The custom host names of the streaming endpoint
	CustomHostNames []*string `json:"customHostNames,omitempty"`

	// The streaming endpoint description.
	Description *string `json:"description,omitempty"`

	// Max cache age
	MaxCacheAge *int64 `json:"maxCacheAge,omitempty"`

	// READ-ONLY; The exact time the streaming endpoint was created.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The free trial expiration time.
	FreeTrialEndTime *time.Time `json:"freeTrialEndTime,omitempty" azure:"ro"`

	// READ-ONLY; The streaming endpoint host name.
	HostName *string `json:"hostName,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the streaming endpoint was last modified.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the streaming endpoint.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The resource state of the streaming endpoint.
	ResourceState *StreamingEndpointResourceState `json:"resourceState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointProperties.
func (s StreamingEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", s.AccessControl)
	populate(objectMap, "availabilitySetName", s.AvailabilitySetName)
	populate(objectMap, "cdnEnabled", s.CdnEnabled)
	populate(objectMap, "cdnProfile", s.CdnProfile)
	populate(objectMap, "cdnProvider", s.CdnProvider)
	populate(objectMap, "created", (*timeRFC3339)(s.Created))
	populate(objectMap, "crossSiteAccessPolicies", s.CrossSiteAccessPolicies)
	populate(objectMap, "customHostNames", s.CustomHostNames)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "freeTrialEndTime", (*timeRFC3339)(s.FreeTrialEndTime))
	populate(objectMap, "hostName", s.HostName)
	populate(objectMap, "lastModified", (*timeRFC3339)(s.LastModified))
	populate(objectMap, "maxCacheAge", s.MaxCacheAge)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resourceState", s.ResourceState)
	populate(objectMap, "scaleUnits", s.ScaleUnits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingEndpointProperties.
func (s *StreamingEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessControl":
			err = unpopulate(val, &s.AccessControl)
			delete(rawMsg, key)
		case "availabilitySetName":
			err = unpopulate(val, &s.AvailabilitySetName)
			delete(rawMsg, key)
		case "cdnEnabled":
			err = unpopulate(val, &s.CdnEnabled)
			delete(rawMsg, key)
		case "cdnProfile":
			err = unpopulate(val, &s.CdnProfile)
			delete(rawMsg, key)
		case "cdnProvider":
			err = unpopulate(val, &s.CdnProvider)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &s.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "customHostNames":
			err = unpopulate(val, &s.CustomHostNames)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "freeTrialEndTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.FreeTrialEndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &s.HostName)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "maxCacheAge":
			err = unpopulate(val, &s.MaxCacheAge)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &s.ResourceState)
			delete(rawMsg, key)
		case "scaleUnits":
			err = unpopulate(val, &s.ScaleUnits)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingEndpointsBeginCreateOptions contains the optional parameters for the StreamingEndpoints.BeginCreate method.
type StreamingEndpointsBeginCreateOptions struct {
	// The flag indicates if the resource should be automatically started on creation.
	AutoStart *bool
}

// StreamingEndpointsBeginDeleteOptions contains the optional parameters for the StreamingEndpoints.BeginDelete method.
type StreamingEndpointsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsBeginScaleOptions contains the optional parameters for the StreamingEndpoints.BeginScale method.
type StreamingEndpointsBeginScaleOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsBeginStartOptions contains the optional parameters for the StreamingEndpoints.BeginStart method.
type StreamingEndpointsBeginStartOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsBeginStopOptions contains the optional parameters for the StreamingEndpoints.BeginStop method.
type StreamingEndpointsBeginStopOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsBeginUpdateOptions contains the optional parameters for the StreamingEndpoints.BeginUpdate method.
type StreamingEndpointsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsGetOptions contains the optional parameters for the StreamingEndpoints.Get method.
type StreamingEndpointsGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingEndpointsListOptions contains the optional parameters for the StreamingEndpoints.List method.
type StreamingEndpointsListOptions struct {
	// placeholder for future optional parameters
}

// StreamingEntityScaleUnit - scale units definition
type StreamingEntityScaleUnit struct {
	// The scale unit number of the streaming endpoint.
	ScaleUnit *int32 `json:"scaleUnit,omitempty"`
}

// StreamingLocator - A Streaming Locator resource
type StreamingLocator struct {
	ProxyResource
	// Properties of the Streaming Locator.
	Properties *StreamingLocatorProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocator.
func (s StreamingLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// StreamingLocatorCollection - A collection of StreamingLocator items.
type StreamingLocatorCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of StreamingLocator items.
	Value []*StreamingLocator `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorCollection.
func (s StreamingLocatorCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingLocatorContentKey - Class for content key in Streaming Locator
type StreamingLocatorContentKey struct {
	// REQUIRED; ID of Content Key
	ID *string `json:"id,omitempty"`

	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `json:"labelReferenceInStreamingPolicy,omitempty"`

	// Value of Content Key
	Value *string `json:"value,omitempty"`

	// READ-ONLY; ContentKeyPolicy used by Content Key
	PolicyName *string `json:"policyName,omitempty" azure:"ro"`

	// READ-ONLY; Tracks which use this Content Key
	Tracks []*TrackSelection `json:"tracks,omitempty" azure:"ro"`

	// READ-ONLY; Encryption type of Content Key
	Type *StreamingLocatorContentKeyType `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorContentKey.
func (s StreamingLocatorContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "labelReferenceInStreamingPolicy", s.LabelReferenceInStreamingPolicy)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingLocatorProperties - Properties of the Streaming Locator.
type StreamingLocatorProperties struct {
	// REQUIRED; Asset Name
	AssetName *string `json:"assetName,omitempty"`

	// REQUIRED; Name of the Streaming Policy used by this Streaming Locator. Either specify the name of Streaming Policy you created or use one of the predefined
	// Streaming Policies. The predefined Streaming Policies
	// available are: 'PredefinedDownloadOnly', 'PredefinedClearStreamingOnly', 'PredefinedDownloadAndClearStreaming', 'PredefinedClearKey', 'PredefinedMultiDrmCencStreaming'
	// and 'Predefined
	// MultiDrmStreaming'
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`

	// Alternative Media ID of this Streaming Locator
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`

	// The ContentKeys used by this Streaming Locator.
	ContentKeys []*StreamingLocatorContentKey `json:"contentKeys,omitempty"`

	// Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`

	// The end time of the Streaming Locator.
	EndTime *time.Time `json:"endTime,omitempty"`

	// A list of asset or account filters which apply to this streaming locator
	Filters []*string `json:"filters,omitempty"`

	// The start time of the Streaming Locator.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *string `json:"streamingLocatorId,omitempty"`

	// READ-ONLY; The creation time of the Streaming Locator.
	Created *time.Time `json:"created,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorProperties.
func (s StreamingLocatorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternativeMediaId", s.AlternativeMediaID)
	populate(objectMap, "assetName", s.AssetName)
	populate(objectMap, "contentKeys", s.ContentKeys)
	populate(objectMap, "created", (*timeRFC3339)(s.Created))
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populate(objectMap, "endTime", (*timeRFC3339)(s.EndTime))
	populate(objectMap, "filters", s.Filters)
	populate(objectMap, "startTime", (*timeRFC3339)(s.StartTime))
	populate(objectMap, "streamingLocatorId", s.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", s.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingLocatorProperties.
func (s *StreamingLocatorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternativeMediaId":
			err = unpopulate(val, &s.AlternativeMediaID)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &s.AssetName)
			delete(rawMsg, key)
		case "contentKeys":
			err = unpopulate(val, &s.ContentKeys)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &s.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &s.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingLocatorsCreateOptions contains the optional parameters for the StreamingLocators.Create method.
type StreamingLocatorsCreateOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsDeleteOptions contains the optional parameters for the StreamingLocators.Delete method.
type StreamingLocatorsDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsGetOptions contains the optional parameters for the StreamingLocators.Get method.
type StreamingLocatorsGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsListContentKeysOptions contains the optional parameters for the StreamingLocators.ListContentKeys method.
type StreamingLocatorsListContentKeysOptions struct {
	// placeholder for future optional parameters
}

// StreamingLocatorsListOptions contains the optional parameters for the StreamingLocators.List method.
type StreamingLocatorsListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to
	// but not greater than the specified value n.
	Top *int32
}

// StreamingLocatorsListPathsOptions contains the optional parameters for the StreamingLocators.ListPaths method.
type StreamingLocatorsListPathsOptions struct {
	// placeholder for future optional parameters
}

// StreamingPath - Class of paths for streaming
type StreamingPath struct {
	// REQUIRED; Encryption scheme
	EncryptionScheme *EncryptionScheme `json:"encryptionScheme,omitempty"`

	// REQUIRED; Streaming protocol
	StreamingProtocol *StreamingPolicyStreamingProtocol `json:"streamingProtocol,omitempty"`

	// Streaming paths for each protocol and encryptionScheme pair
	Paths []*string `json:"paths,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPath.
func (s StreamingPath) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptionScheme", s.EncryptionScheme)
	populate(objectMap, "paths", s.Paths)
	populate(objectMap, "streamingProtocol", s.StreamingProtocol)
	return json.Marshal(objectMap)
}

// StreamingPoliciesCreateOptions contains the optional parameters for the StreamingPolicies.Create method.
type StreamingPoliciesCreateOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesDeleteOptions contains the optional parameters for the StreamingPolicies.Delete method.
type StreamingPoliciesDeleteOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesGetOptions contains the optional parameters for the StreamingPolicies.Get method.
type StreamingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// StreamingPoliciesListOptions contains the optional parameters for the StreamingPolicies.List method.
type StreamingPoliciesListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
	// Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to
	// but not greater than the specified value n.
	Top *int32
}

// StreamingPolicy - A Streaming Policy resource
type StreamingPolicy struct {
	ProxyResource
	// Class to specify properties of Streaming Policy
	Properties *StreamingPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicy.
func (s StreamingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	return json.Marshal(objectMap)
}

// StreamingPolicyCollection - A collection of StreamingPolicy items.
type StreamingPolicyCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of StreamingPolicy items.
	Value []*StreamingPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyCollection.
func (s StreamingPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StreamingPolicyContentKey - Class to specify properties of content key
type StreamingPolicyContentKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`

	// Policy used by Content Key
	PolicyName *string `json:"policyName,omitempty"`

	// Tracks which use this content key
	Tracks []*TrackSelection `json:"tracks,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKey.
func (s StreamingPolicyContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", s.Label)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	return json.Marshal(objectMap)
}

// StreamingPolicyContentKeys - Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeys struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKey `json:"defaultKey,omitempty"`

	// Representing tracks needs separate content key
	KeyToTrackMappings []*StreamingPolicyContentKey `json:"keyToTrackMappings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKeys.
func (s StreamingPolicyContentKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultKey", s.DefaultKey)
	populate(objectMap, "keyToTrackMappings", s.KeyToTrackMappings)
	return json.Marshal(objectMap)
}

// StreamingPolicyFairPlayConfiguration - Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfiguration struct {
	// REQUIRED; All license to be persistent or not
	AllowPersistentLicense *bool `json:"allowPersistentLicense,omitempty"`

	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses.
	// The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced
	// with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
}

// StreamingPolicyPlayReadyConfiguration - Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses.
	// The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced
	// with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`

	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `json:"playReadyCustomAttributes,omitempty"`
}

// StreamingPolicyProperties - Class to specify properties of Streaming Policy
type StreamingPolicyProperties struct {
	// Configuration of CommonEncryptionCbcs
	CommonEncryptionCbcs *CommonEncryptionCbcs `json:"commonEncryptionCbcs,omitempty"`

	// Configuration of CommonEncryptionCenc
	CommonEncryptionCenc *CommonEncryptionCenc `json:"commonEncryptionCenc,omitempty"`

	// Default ContentKey used by current Streaming Policy
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`

	// Configuration of EnvelopeEncryption
	EnvelopeEncryption *EnvelopeEncryption `json:"envelopeEncryption,omitempty"`

	// Configurations of NoEncryption
	NoEncryption *NoEncryption `json:"noEncryption,omitempty"`

	// READ-ONLY; Creation time of Streaming Policy
	Created *time.Time `json:"created,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyProperties.
func (s StreamingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commonEncryptionCbcs", s.CommonEncryptionCbcs)
	populate(objectMap, "commonEncryptionCenc", s.CommonEncryptionCenc)
	populate(objectMap, "created", (*timeRFC3339)(s.Created))
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populate(objectMap, "envelopeEncryption", s.EnvelopeEncryption)
	populate(objectMap, "noEncryption", s.NoEncryption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingPolicyProperties.
func (s *StreamingPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonEncryptionCbcs":
			err = unpopulate(val, &s.CommonEncryptionCbcs)
			delete(rawMsg, key)
		case "commonEncryptionCenc":
			err = unpopulate(val, &s.CommonEncryptionCenc)
			delete(rawMsg, key)
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "envelopeEncryption":
			err = unpopulate(val, &s.EnvelopeEncryption)
			delete(rawMsg, key)
		case "noEncryption":
			err = unpopulate(val, &s.NoEncryption)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StreamingPolicyWidevineConfiguration - Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses.
	// The template supports replaceable tokens that the
	// service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced
	// with the value of
	// StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
}

// SyncStorageKeysInput - The input to the sync storage keys request.
type SyncStorageKeysInput struct {
	// The ID of the storage account resource.
	ID *string `json:"id,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populate(objectMap, "lastModifiedAt", (*timeRFC3339)(s.LastModifiedAt))
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastModifiedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AudioTrackDescriptor, *SelectAudioTrackByAttribute, *SelectAudioTrackById, *SelectVideoTrackByAttribute, *SelectVideoTrackById,
// - *TrackDescriptor, *VideoTrackDescriptor
type TrackDescriptorClassification interface {
	// GetTrackDescriptor returns the TrackDescriptor content of the underlying type.
	GetTrackDescriptor() *TrackDescriptor
}

// TrackDescriptor - Base type for all TrackDescriptor types, which define the metadata and selection for tracks that should be processed by a Job
type TrackDescriptor struct {
	// REQUIRED; The discriminator for derived types.
	ODataType *string `json:"@odata.type,omitempty"`
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type TrackDescriptor.
func (t *TrackDescriptor) GetTrackDescriptor() *TrackDescriptor { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackDescriptor.
func (t *TrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TrackDescriptor) marshalInternal(objectMap map[string]interface{}, discValue string) {
	t.ODataType = &discValue
	objectMap["@odata.type"] = t.ODataType
}

func (t *TrackDescriptor) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &t.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TrackPropertyCondition - Class to specify one track property condition
type TrackPropertyCondition struct {
	// REQUIRED; Track property condition operation
	Operation *TrackPropertyCompareOperation `json:"operation,omitempty"`

	// REQUIRED; Track property type
	Property *TrackPropertyType `json:"property,omitempty"`

	// Track property value
	Value *string `json:"value,omitempty"`
}

// TrackSelection - Class to select a track
type TrackSelection struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []*TrackPropertyCondition `json:"trackSelections,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackSelection.
func (t TrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", t.TrackSelections)
	return json.Marshal(objectMap)
}

// TrackedResource - The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
type TrackedResource struct {
	Resource
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

// Transform - A Transform encapsulates the rules or instructions for generating desired outputs from input media, such as by transcoding or by extracting
// insights. After the Transform is created, it can be applied
// to input media by creating Jobs.
type Transform struct {
	ProxyResource
	// The resource properties.
	Properties *TransformProperties `json:"properties,omitempty"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Transform.
func (t Transform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	return json.Marshal(objectMap)
}

// TransformCollection - A collection of Transform items.
type TransformCollection struct {
	// A link to the next page of the collection (when the collection contains too many results to return in one response).
	ODataNextLink *string `json:"@odata.nextLink,omitempty"`

	// A collection of Transform items.
	Value []*Transform `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformCollection.
func (t TransformCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", t.ODataNextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TransformOutput - Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutput struct {
	// REQUIRED; Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset PresetClassification `json:"preset,omitempty"`

	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other
	// outputs, or, stop the other outputs. The overall
	// Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *OnErrorType `json:"onError,omitempty"`

	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs.
	// The default priority is Normal.
	RelativePriority *Priority `json:"relativePriority,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformOutput.
func (t TransformOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "onError", t.OnError)
	populate(objectMap, "preset", t.Preset)
	populate(objectMap, "relativePriority", t.RelativePriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformOutput.
func (t *TransformOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "onError":
			err = unpopulate(val, &t.OnError)
			delete(rawMsg, key)
		case "preset":
			t.Preset, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "relativePriority":
			err = unpopulate(val, &t.RelativePriority)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TransformProperties - A Transform.
type TransformProperties struct {
	// REQUIRED; An array of one or more TransformOutputs that the Transform should generate.
	Outputs []*TransformOutput `json:"outputs,omitempty"`

	// An optional verbose description of the Transform.
	Description *string `json:"description,omitempty"`

	// READ-ONLY; The UTC date and time when the Transform was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The UTC date and time when the Transform was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TransformProperties.
func (t TransformProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "created", (*timeRFC3339)(t.Created))
	populate(objectMap, "description", t.Description)
	populate(objectMap, "lastModified", (*timeRFC3339)(t.LastModified))
	populate(objectMap, "outputs", t.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformProperties.
func (t *TransformProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.Created = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			t.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, &t.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TransformsCreateOrUpdateOptions contains the optional parameters for the Transforms.CreateOrUpdate method.
type TransformsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TransformsDeleteOptions contains the optional parameters for the Transforms.Delete method.
type TransformsDeleteOptions struct {
	// placeholder for future optional parameters
}

// TransformsGetOptions contains the optional parameters for the Transforms.Get method.
type TransformsGetOptions struct {
	// placeholder for future optional parameters
}

// TransformsListOptions contains the optional parameters for the Transforms.List method.
type TransformsListOptions struct {
	// Restricts the set of items returned.
	Filter *string
	// Specifies the key by which the result collection should be ordered.
	Orderby *string
}

// TransformsUpdateOptions contains the optional parameters for the Transforms.Update method.
type TransformsUpdateOptions struct {
	// placeholder for future optional parameters
}

// TransportStreamFormat - Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormat struct {
	MultiBitrateFormat
}

// MarshalJSON implements the json.Marshaller interface for type TransportStreamFormat.
func (t TransportStreamFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.MultiBitrateFormat.marshalInternal(objectMap, "#Microsoft.Media.TransportStreamFormat")
	return json.Marshal(objectMap)
}

// UTCClipTime - Specifies the clip time as a Utc time position in the media file. The Utc time can point to a different position depending on whether the
// media file starts from a timestamp of zero or not.
type UTCClipTime struct {
	ClipTime
	// REQUIRED; The time position on the timeline of the input media based on Utc time.
	Time *time.Time `json:"time,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UTCClipTime.
func (u UTCClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.ClipTime.marshalInternal(objectMap, "#Microsoft.Media.UtcClipTime")
	populate(objectMap, "time", (*timeRFC3339)(u.Time))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UTCClipTime.
func (u *UTCClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "time":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			u.Time = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.ClipTime.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type UserAssignedManagedIdentity struct {
	// READ-ONLY; The client ID.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal ID.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// VideoClassification provides polymorphic access to related types.
// Call the interface's GetVideo() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Video, *H265Video, *Image, *JpgImage, *PngImage, *Video
type VideoClassification interface {
	CodecClassification
	// GetVideo returns the Video content of the underlying type.
	GetVideo() *Video
}

// Video - Describes the basic properties for encoding the input video.
type Video struct {
	Codec
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S).
	// Note that this setting is ignored if
	// VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`

	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *StretchMode `json:"stretchMode,omitempty"`

	// The Video Sync Mode
	SyncMode *VideoSyncMode `json:"syncMode,omitempty"`
}

// GetVideo implements the VideoClassification interface for type Video.
func (v *Video) GetVideo() *Video { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type Video.
func (v *Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v Video) marshalInternal(objectMap map[string]interface{}, discValue string) {
	v.Codec.marshalInternal(objectMap, discValue)
	populate(objectMap, "keyFrameInterval", v.KeyFrameInterval)
	populate(objectMap, "stretchMode", v.StretchMode)
	populate(objectMap, "syncMode", v.SyncMode)
}

func (v *Video) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &v.KeyFrameInterval)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &v.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &v.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.Codec.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VideoAnalyzerPreset - A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPreset struct {
	AudioAnalyzerPreset
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'.
	// The default is AllInsights. If you set this to
	// AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated.
	// It is recommended that you not use
	// AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your
	// Jobs in such conditions would error out.
	InsightsToExtract *InsightsType `json:"insightsToExtract,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VideoAnalyzerPreset.
func (v VideoAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.AudioAnalyzerPreset.marshalInternal(objectMap, "#Microsoft.Media.VideoAnalyzerPreset")
	populate(objectMap, "insightsToExtract", v.InsightsToExtract)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "insightsToExtract":
			err = unpopulate(val, &v.InsightsToExtract)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.AudioAnalyzerPreset.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VideoLayerClassification provides polymorphic access to related types.
// Call the interface's GetVideoLayer() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *H264Layer, *VideoLayer
type VideoLayerClassification interface {
	LayerClassification
	// GetVideoLayer returns the VideoLayer content of the underlying type.
	GetVideoLayer() *VideoLayer
}

// VideoLayer - Describes the settings to be used when encoding the input video into a desired output bitrate layer.
type VideoLayer struct {
	Layer
	// REQUIRED; The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate *int32 `json:"bitrate,omitempty"`

	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits
	// its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`

	// The number of B-frames to be used when encoding this layer. If not specified, the encoder chooses an appropriate number based on the video profile and
	// level.
	BFrames *int32 `json:"bFrames,omitempty"`

	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001),
	// or in the form of a number (For example,
	// 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the
	// same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`

	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`

	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each
	// frame.
	Slices *int32 `json:"slices,omitempty"`
}

// GetVideoLayer implements the VideoLayerClassification interface for type VideoLayer.
func (v *VideoLayer) GetVideoLayer() *VideoLayer { return v }

// MarshalJSON implements the json.Marshaller interface for type VideoLayer.
func (v VideoLayer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.marshalInternal(objectMap, "#Microsoft.Media.VideoLayer")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoLayer.
func (v *VideoLayer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v VideoLayer) marshalInternal(objectMap map[string]interface{}, discValue string) {
	v.Layer.marshalInternal(objectMap, discValue)
	populate(objectMap, "adaptiveBFrame", v.AdaptiveBFrame)
	populate(objectMap, "bFrames", v.BFrames)
	populate(objectMap, "bitrate", v.Bitrate)
	populate(objectMap, "frameRate", v.FrameRate)
	populate(objectMap, "maxBitrate", v.MaxBitrate)
	populate(objectMap, "slices", v.Slices)
}

func (v *VideoLayer) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptiveBFrame":
			err = unpopulate(val, &v.AdaptiveBFrame)
			delete(rawMsg, key)
		case "bFrames":
			err = unpopulate(val, &v.BFrames)
			delete(rawMsg, key)
		case "bitrate":
			err = unpopulate(val, &v.Bitrate)
			delete(rawMsg, key)
		case "frameRate":
			err = unpopulate(val, &v.FrameRate)
			delete(rawMsg, key)
		case "maxBitrate":
			err = unpopulate(val, &v.MaxBitrate)
			delete(rawMsg, key)
		case "slices":
			err = unpopulate(val, &v.Slices)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.Layer.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VideoOverlay - Describes the properties of a video overlay.
type VideoOverlay struct {
	Overlay
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *Rectangle `json:"cropRectangle,omitempty"`

	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `json:"opacity,omitempty"`

	// The location in the input video where the overlay is applied.
	Position *Rectangle `json:"position,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VideoOverlay.
func (v VideoOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.Overlay.marshalInternal(objectMap, "#Microsoft.Media.VideoOverlay")
	populate(objectMap, "cropRectangle", v.CropRectangle)
	populate(objectMap, "opacity", v.Opacity)
	populate(objectMap, "position", v.Position)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoOverlay.
func (v *VideoOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cropRectangle":
			err = unpopulate(val, &v.CropRectangle)
			delete(rawMsg, key)
		case "opacity":
			err = unpopulate(val, &v.Opacity)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, &v.Position)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.Overlay.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VideoTrackDescriptorClassification provides polymorphic access to related types.
// Call the interface's GetVideoTrackDescriptor() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SelectVideoTrackByAttribute, *SelectVideoTrackById, *VideoTrackDescriptor
type VideoTrackDescriptorClassification interface {
	TrackDescriptorClassification
	// GetVideoTrackDescriptor returns the VideoTrackDescriptor content of the underlying type.
	GetVideoTrackDescriptor() *VideoTrackDescriptor
}

// VideoTrackDescriptor - A TrackSelection to select video tracks.
type VideoTrackDescriptor struct {
	TrackDescriptor
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) GetVideoTrackDescriptor() *VideoTrackDescriptor { return v }

// MarshalJSON implements the json.Marshaller interface for type VideoTrackDescriptor.
func (v VideoTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.marshalInternal(objectMap, "#Microsoft.Media.VideoTrackDescriptor")
	return json.Marshal(objectMap)
}

func (v VideoTrackDescriptor) marshalInternal(objectMap map[string]interface{}, discValue string) {
	v.TrackDescriptor.marshalInternal(objectMap, discValue)
}

func (v *VideoTrackDescriptor) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := v.TrackDescriptor.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
