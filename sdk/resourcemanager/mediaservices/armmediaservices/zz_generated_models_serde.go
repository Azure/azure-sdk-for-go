//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmediaservices

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AacAudio.
func (a AacAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.AacAudio"
	populate(objectMap, "profile", a.Profile)
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AacAudio.
func (a *AacAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, "Bitrate", &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, "Channels", &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, "Profile", &a.Profile)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, "SamplingRate", &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AbsoluteClipTime.
func (a AbsoluteClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.AbsoluteClipTime"
	populate(objectMap, "time", a.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulate(val, "Time", &a.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControl.
func (a AccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", a.DefaultAction)
	populate(objectMap, "ipAllowList", a.IPAllowList)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilter.
func (a AccountFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiAccessControl.
func (a AkamaiAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "akamaiSignatureHeaderAuthenticationKeyList", a.AkamaiSignatureHeaderAuthenticationKeyList)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a AkamaiSignatureHeaderAuthenticationKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64Key", a.Base64Key)
	populateTimeRFC3339(objectMap, "expiration", a.Expiration)
	populate(objectMap, "identifier", a.Identifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a *AkamaiSignatureHeaderAuthenticationKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base64Key":
			err = unpopulate(val, "Base64Key", &a.Base64Key)
			delete(rawMsg, key)
		case "expiration":
			err = unpopulateTimeRFC3339(val, "Expiration", &a.Expiration)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, "Identifier", &a.Identifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilter.
func (a AssetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetProperties.
func (a AssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateId", a.AlternateID)
	populate(objectMap, "assetId", a.AssetID)
	populate(objectMap, "container", a.Container)
	populateTimeRFC3339(objectMap, "created", a.Created)
	populate(objectMap, "description", a.Description)
	populateTimeRFC3339(objectMap, "lastModified", a.LastModified)
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageEncryptionFormat", a.StorageEncryptionFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetProperties.
func (a *AssetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateId":
			err = unpopulate(val, "AlternateID", &a.AlternateID)
			delete(rawMsg, key)
		case "assetId":
			err = unpopulate(val, "AssetID", &a.AssetID)
			delete(rawMsg, key)
		case "container":
			err = unpopulate(val, "Container", &a.Container)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &a.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &a.LastModified)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, "StorageAccountName", &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageEncryptionFormat":
			err = unpopulate(val, "StorageEncryptionFormat", &a.StorageEncryptionFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetStreamingLocator.
func (a *AssetStreamingLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, "AssetName", &a.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &a.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, "DefaultContentKeyPolicyName", &a.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, "StreamingLocatorID", &a.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, "StreamingPolicyName", &a.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrack.
func (a AssetTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetTrackOperationStatus.
func (a *AssetTrackOperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &a.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrackProperties.
func (a AssetTrackProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "track", a.Track)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetTrackProperties.
func (a *AssetTrackProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "track":
			a.Track, err = unmarshalTrackBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Audio.
func (a Audio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Audio"
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Audio.
func (a *Audio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, "Bitrate", &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, "Channels", &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, "SamplingRate", &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioAnalyzerPreset.
func (a AudioAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", a.AudioLanguage)
	populate(objectMap, "experimentalOptions", a.ExperimentalOptions)
	populate(objectMap, "mode", a.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, "AudioLanguage", &a.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, "ExperimentalOptions", &a.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &a.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioOverlay.
func (a AudioOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", a.AudioGainLevel)
	populate(objectMap, "end", a.End)
	populate(objectMap, "fadeInDuration", a.FadeInDuration)
	populate(objectMap, "fadeOutDuration", a.FadeOutDuration)
	populate(objectMap, "inputLabel", a.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioOverlay"
	populate(objectMap, "start", a.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioOverlay.
func (a *AudioOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, "AudioGainLevel", &a.AudioGainLevel)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, "End", &a.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, "FadeInDuration", &a.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, "FadeOutDuration", &a.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, "InputLabel", &a.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &a.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTrack.
func (a AudioTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.AudioTrack"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrack.
func (a *AudioTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AudioTrackDescriptor.
func (a AudioTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", a.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, "ChannelMapping", &a.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BuiltInStandardEncoderPreset.
func (b BuiltInStandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configurations", b.Configurations)
	objectMap["@odata.type"] = "#Microsoft.Media.BuiltInStandardEncoderPreset"
	populate(objectMap, "presetName", b.PresetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurations":
			err = unpopulate(val, "Configurations", &b.Configurations)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &b.ODataType)
			delete(rawMsg, key)
		case "presetName":
			err = unpopulate(val, "PresetName", &b.PresetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCbcs.
func (c CommonEncryptionCbcs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCenc.
func (c CommonEncryptionCenc) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicy.
func (c ContentKeyPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c ContentKeyPolicyClearKeyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c *ContentKeyPolicyClearKeyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c ContentKeyPolicyFairPlayConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "ask", c.Ask, runtime.Base64StdFormat)
	populate(objectMap, "fairPlayPfx", c.FairPlayPfx)
	populate(objectMap, "fairPlayPfxPassword", c.FairPlayPfxPassword)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration"
	populate(objectMap, "offlineRentalConfiguration", c.OfflineRentalConfiguration)
	populate(objectMap, "rentalAndLeaseKeyType", c.RentalAndLeaseKeyType)
	populate(objectMap, "rentalDuration", c.RentalDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ask":
			err = runtime.DecodeByteArray(string(val), &c.Ask, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "fairPlayPfx":
			err = unpopulate(val, "FairPlayPfx", &c.FairPlayPfx)
			delete(rawMsg, key)
		case "fairPlayPfxPassword":
			err = unpopulate(val, "FairPlayPfxPassword", &c.FairPlayPfxPassword)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "offlineRentalConfiguration":
			err = unpopulate(val, "OfflineRentalConfiguration", &c.OfflineRentalConfiguration)
			delete(rawMsg, key)
		case "rentalAndLeaseKeyType":
			err = unpopulate(val, "RentalAndLeaseKeyType", &c.RentalAndLeaseKeyType)
			delete(rawMsg, key)
		case "rentalDuration":
			err = unpopulate(val, "RentalDuration", &c.RentalDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOpenRestriction.
func (c ContentKeyPolicyOpenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyOpenRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOpenRestriction.
func (c *ContentKeyPolicyOpenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOption.
func (c ContentKeyPolicyOption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configuration", c.Configuration)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "policyOptionId", c.PolicyOptionID)
	populate(objectMap, "restriction", c.Restriction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOption.
func (c *ContentKeyPolicyOption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			c.Configuration, err = unmarshalContentKeyPolicyConfigurationClassification(val)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "policyOptionId":
			err = unpopulate(val, "PolicyOptionID", &c.PolicyOptionID)
			delete(rawMsg, key)
		case "restriction":
			c.Restriction, err = unmarshalContentKeyPolicyRestrictionClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c ContentKeyPolicyPlayReadyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "licenses", c.Licenses)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration"
	populate(objectMap, "responseCustomData", c.ResponseCustomData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenses":
			err = unpopulate(val, "Licenses", &c.Licenses)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "responseCustomData":
			err = unpopulate(val, "ResponseCustomData", &c.ResponseCustomData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyId", c.KeyID)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyId":
			err = unpopulate(val, "KeyID", &c.KeyID)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c ContentKeyPolicyPlayReadyLicense) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowTestDevices", c.AllowTestDevices)
	populateTimeRFC3339(objectMap, "beginDate", c.BeginDate)
	populate(objectMap, "contentKeyLocation", c.ContentKeyLocation)
	populate(objectMap, "contentType", c.ContentType)
	populateTimeRFC3339(objectMap, "expirationDate", c.ExpirationDate)
	populate(objectMap, "gracePeriod", c.GracePeriod)
	populate(objectMap, "licenseType", c.LicenseType)
	populate(objectMap, "playRight", c.PlayRight)
	populate(objectMap, "relativeBeginDate", c.RelativeBeginDate)
	populate(objectMap, "relativeExpirationDate", c.RelativeExpirationDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c *ContentKeyPolicyPlayReadyLicense) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTestDevices":
			err = unpopulate(val, "AllowTestDevices", &c.AllowTestDevices)
			delete(rawMsg, key)
		case "beginDate":
			err = unpopulateTimeRFC3339(val, "BeginDate", &c.BeginDate)
			delete(rawMsg, key)
		case "contentKeyLocation":
			c.ContentKeyLocation, err = unmarshalContentKeyPolicyPlayReadyContentKeyLocationClassification(val)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, "ContentType", &c.ContentType)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, "ExpirationDate", &c.ExpirationDate)
			delete(rawMsg, key)
		case "gracePeriod":
			err = unpopulate(val, "GracePeriod", &c.GracePeriod)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, "LicenseType", &c.LicenseType)
			delete(rawMsg, key)
		case "playRight":
			err = unpopulate(val, "PlayRight", &c.PlayRight)
			delete(rawMsg, key)
		case "relativeBeginDate":
			err = unpopulate(val, "RelativeBeginDate", &c.RelativeBeginDate)
			delete(rawMsg, key)
		case "relativeExpirationDate":
			err = unpopulate(val, "RelativeExpirationDate", &c.RelativeExpirationDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyProperties.
func (c ContentKeyPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", c.Created)
	populate(objectMap, "description", c.Description)
	populateTimeRFC3339(objectMap, "lastModified", c.LastModified)
	populate(objectMap, "options", c.Options)
	populate(objectMap, "policyId", c.PolicyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyProperties.
func (c *ContentKeyPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &c.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &c.LastModified)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, "Options", &c.Options)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &c.PolicyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c ContentKeyPolicyRsaTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "exponent", c.Exponent, runtime.Base64StdFormat)
	populateByteArray(objectMap, "modulus", c.Modulus, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyRsaTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exponent":
			err = runtime.DecodeByteArray(string(val), &c.Exponent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "modulus":
			err = runtime.DecodeByteArray(string(val), &c.Modulus, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c ContentKeyPolicySymmetricTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "keyValue", c.KeyValue, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyValue":
			err = runtime.DecodeByteArray(string(val), &c.KeyValue, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyTokenRestriction.
func (c ContentKeyPolicyTokenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateVerificationKeys", c.AlternateVerificationKeys)
	populate(objectMap, "audience", c.Audience)
	populate(objectMap, "issuer", c.Issuer)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyTokenRestriction"
	populate(objectMap, "openIdConnectDiscoveryDocument", c.OpenIDConnectDiscoveryDocument)
	populate(objectMap, "primaryVerificationKey", c.PrimaryVerificationKey)
	populate(objectMap, "requiredClaims", c.RequiredClaims)
	populate(objectMap, "restrictionTokenType", c.RestrictionTokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateVerificationKeys":
			c.AlternateVerificationKeys, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassificationArray(val)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, "Audience", &c.Audience)
			delete(rawMsg, key)
		case "issuer":
			err = unpopulate(val, "Issuer", &c.Issuer)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "openIdConnectDiscoveryDocument":
			err = unpopulate(val, "OpenIDConnectDiscoveryDocument", &c.OpenIDConnectDiscoveryDocument)
			delete(rawMsg, key)
		case "primaryVerificationKey":
			c.PrimaryVerificationKey, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassification(val)
			delete(rawMsg, key)
		case "requiredClaims":
			err = unpopulate(val, "RequiredClaims", &c.RequiredClaims)
			delete(rawMsg, key)
		case "restrictionTokenType":
			err = unpopulate(val, "RestrictionTokenType", &c.RestrictionTokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c ContentKeyPolicyUnknownConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c *ContentKeyPolicyUnknownConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c ContentKeyPolicyUnknownRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c *ContentKeyPolicyUnknownRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c ContentKeyPolicyWidevineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration"
	populate(objectMap, "widevineTemplate", c.WidevineTemplate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "widevineTemplate":
			err = unpopulate(val, "WidevineTemplate", &c.WidevineTemplate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c ContentKeyPolicyX509CertificateTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey"
	populateByteArray(objectMap, "rawBody", c.RawBody, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "rawBody":
			err = runtime.DecodeByteArray(string(val), &c.RawBody, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyAudio.
func (c CopyAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyAudio"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyAudio.
func (c *CopyAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, "Label", &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CopyVideo.
func (c CopyVideo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyVideo"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyVideo.
func (c *CopyVideo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, "Label", &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvelopeEncryption.
func (e EnvelopeEncryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", e.ClearTracks)
	populate(objectMap, "contentKeys", e.ContentKeys)
	populate(objectMap, "customKeyAcquisitionUrlTemplate", e.CustomKeyAcquisitionURLTemplate)
	populate(objectMap, "enabledProtocols", e.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FaceDetectorPreset.
func (f FaceDetectorPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blurType", f.BlurType)
	populate(objectMap, "experimentalOptions", f.ExperimentalOptions)
	populate(objectMap, "mode", f.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.FaceDetectorPreset"
	populate(objectMap, "resolution", f.Resolution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blurType":
			err = unpopulate(val, "BlurType", &f.BlurType)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, "ExperimentalOptions", &f.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &f.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &f.ODataType)
			delete(rawMsg, key)
		case "resolution":
			err = unpopulate(val, "Resolution", &f.Resolution)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FilterTrackSelection.
func (f FilterTrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", f.TrackSelections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Filters.
func (f Filters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crop", f.Crop)
	populate(objectMap, "deinterlace", f.Deinterlace)
	populate(objectMap, "overlays", f.Overlays)
	populate(objectMap, "rotation", f.Rotation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Filters.
func (f *Filters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crop":
			err = unpopulate(val, "Crop", &f.Crop)
			delete(rawMsg, key)
		case "deinterlace":
			err = unpopulate(val, "Deinterlace", &f.Deinterlace)
			delete(rawMsg, key)
		case "overlays":
			f.Overlays, err = unmarshalOverlayClassificationArray(val)
			delete(rawMsg, key)
		case "rotation":
			err = unpopulate(val, "Rotation", &f.Rotation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FromAllInputFile.
func (f FromAllInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromAllInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromAllInputFile.
func (f *FromAllInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FromEachInputFile.
func (f FromEachInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromEachInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromEachInputFile.
func (f *FromEachInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type H264Video.
func (h H264Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H264Video"
	populate(objectMap, "rateControlMode", h.RateControlMode)
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Video.
func (h *H264Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, "Complexity", &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &h.ODataType)
			delete(rawMsg, key)
		case "rateControlMode":
			err = unpopulate(val, "RateControlMode", &h.RateControlMode)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, "SceneChangeDetection", &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type H265Video.
func (h H265Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H265Video"
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Video.
func (h *H265Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, "Complexity", &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &h.ODataType)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, "SceneChangeDetection", &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPAccessControl.
func (i IPAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allow", i.Allow)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Image.
func (i Image) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", i.KeyFrameInterval)
	populate(objectMap, "label", i.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Image"
	populate(objectMap, "range", i.Range)
	populate(objectMap, "start", i.Start)
	populate(objectMap, "step", i.Step)
	populate(objectMap, "stretchMode", i.StretchMode)
	populate(objectMap, "syncMode", i.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Image.
func (i *Image) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &i.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &i.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, "Range", &i.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &i.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, "Step", &i.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &i.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &i.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageFormat.
func (i ImageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", i.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.ImageFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageFormat.
func (i *ImageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &i.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InputDefinition.
func (i InputDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = i.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputDefinition.
func (i *InputDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InputFile.
func (i InputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filename", i.Filename)
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.InputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputFile.
func (i *InputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filename":
			err = unpopulate(val, "Filename", &i.Filename)
			delete(rawMsg, key)
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JobError.
func (j JobError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", j.Category)
	populate(objectMap, "code", j.Code)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "retry", j.Retry)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JobInputAsset.
func (j JobInputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputAsset"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputAsset.
func (j *JobInputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, "AssetName", &j.AssetName)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, "Files", &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobInputClip.
func (j JobInputClip) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputClip"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputClip.
func (j *JobInputClip) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, "Files", &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobInputHTTP.
func (j JobInputHTTP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", j.BaseURI)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputHttp"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputHTTP.
func (j *JobInputHTTP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
			err = unpopulate(val, "BaseURI", &j.BaseURI)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, "Files", &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobInputSequence.
func (j JobInputSequence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputSequence"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputSequence.
func (j *JobInputSequence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClipClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobInputs.
func (j JobInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputs"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputs.
func (j *JobInputs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobOutput.
func (j JobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = j.ODataType
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutput.
func (j *JobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, "Progress", &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobOutputAsset.
func (j JobOutputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobOutputAsset"
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutputAsset.
func (j *JobOutputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, "AssetName", &j.AssetName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, "Progress", &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "correlationData", j.CorrelationData)
	populateTimeRFC3339(objectMap, "created", j.Created)
	populate(objectMap, "description", j.Description)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "input", j.Input)
	populateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "outputs", j.Outputs)
	populate(objectMap, "priority", j.Priority)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationData":
			err = unpopulate(val, "CorrelationData", &j.CorrelationData)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &j.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &j.Description)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "input":
			j.Input, err = unmarshalJobInputClassification(val)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &j.LastModified)
			delete(rawMsg, key)
		case "outputs":
			j.Outputs, err = unmarshalJobOutputClassificationArray(val)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &j.Priority)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JpgFormat.
func (j JpgFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", j.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgFormat.
func (j *JpgFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &j.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JpgImage.
func (j JpgImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", j.KeyFrameInterval)
	populate(objectMap, "label", j.Label)
	populate(objectMap, "layers", j.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgImage"
	populate(objectMap, "range", j.Range)
	populate(objectMap, "spriteColumn", j.SpriteColumn)
	populate(objectMap, "start", j.Start)
	populate(objectMap, "step", j.Step)
	populate(objectMap, "stretchMode", j.StretchMode)
	populate(objectMap, "syncMode", j.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgImage.
func (j *JpgImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &j.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &j.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &j.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &j.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, "Range", &j.Range)
			delete(rawMsg, key)
		case "spriteColumn":
			err = unpopulate(val, "SpriteColumn", &j.SpriteColumn)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &j.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, "Step", &j.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &j.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &j.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListContainerSasInput.
func (l ListContainerSasInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiryTime", l.ExpiryTime)
	populate(objectMap, "permissions", l.Permissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListContainerSasInput.
func (l *ListContainerSasInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, "ExpiryTime", &l.ExpiryTime)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, "Permissions", &l.Permissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LiveEvent.
func (l LiveEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventInput.
func (l LiveEventInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "accessToken", l.AccessToken)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "keyFrameIntervalDuration", l.KeyFrameIntervalDuration)
	populate(objectMap, "streamingProtocol", l.StreamingProtocol)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventPreview.
func (l LiveEventPreview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "alternativeMediaId", l.AlternativeMediaID)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "previewLocator", l.PreviewLocator)
	populate(objectMap, "streamingPolicyName", l.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventProperties.
func (l LiveEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "crossSiteAccessPolicies", l.CrossSiteAccessPolicies)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "encoding", l.Encoding)
	populate(objectMap, "hostnamePrefix", l.HostnamePrefix)
	populate(objectMap, "input", l.Input)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "preview", l.Preview)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	populate(objectMap, "streamOptions", l.StreamOptions)
	populate(objectMap, "transcriptions", l.Transcriptions)
	populate(objectMap, "useStaticHostname", l.UseStaticHostname)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveEventProperties.
func (l *LiveEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &l.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, "CrossSiteAccessPolicies", &l.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "encoding":
			err = unpopulate(val, "Encoding", &l.Encoding)
			delete(rawMsg, key)
		case "hostnamePrefix":
			err = unpopulate(val, "HostnamePrefix", &l.HostnamePrefix)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, "Input", &l.Input)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &l.LastModified)
			delete(rawMsg, key)
		case "preview":
			err = unpopulate(val, "Preview", &l.Preview)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, "ResourceState", &l.ResourceState)
			delete(rawMsg, key)
		case "streamOptions":
			err = unpopulate(val, "StreamOptions", &l.StreamOptions)
			delete(rawMsg, key)
		case "transcriptions":
			err = unpopulate(val, "Transcriptions", &l.Transcriptions)
			delete(rawMsg, key)
		case "useStaticHostname":
			err = unpopulate(val, "UseStaticHostname", &l.UseStaticHostname)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventTranscription.
func (l LiveEventTranscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputTrackSelection", l.InputTrackSelection)
	populate(objectMap, "language", l.Language)
	populate(objectMap, "outputTranscriptionTrack", l.OutputTranscriptionTrack)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputProperties.
func (l LiveOutputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveWindowLength", l.ArchiveWindowLength)
	populate(objectMap, "assetName", l.AssetName)
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "hls", l.Hls)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "manifestName", l.ManifestName)
	populate(objectMap, "outputSnapTime", l.OutputSnapTime)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveOutputProperties.
func (l *LiveOutputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archiveWindowLength":
			err = unpopulate(val, "ArchiveWindowLength", &l.ArchiveWindowLength)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, "AssetName", &l.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &l.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "hls":
			err = unpopulate(val, "Hls", &l.Hls)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &l.LastModified)
			delete(rawMsg, key)
		case "manifestName":
			err = unpopulate(val, "ManifestName", &l.ManifestName)
			delete(rawMsg, key)
		case "outputSnapTime":
			err = unpopulate(val, "OutputSnapTime", &l.OutputSnapTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, "ResourceState", &l.ResourceState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MediaFilterProperties.
func (m MediaFilterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstQuality", m.FirstQuality)
	populate(objectMap, "presentationTimeRange", m.PresentationTimeRange)
	populate(objectMap, "tracks", m.Tracks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaService.
func (m MediaService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceIdentity.
func (m MediaServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceProperties.
func (m MediaServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryption", m.Encryption)
	populate(objectMap, "keyDelivery", m.KeyDelivery)
	populate(objectMap, "mediaServiceId", m.MediaServiceID)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "storageAccounts", m.StorageAccounts)
	populate(objectMap, "storageAuthentication", m.StorageAuthentication)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceUpdate.
func (m MediaServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Mp4Format.
func (m Mp4Format) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.Mp4Format"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Mp4Format.
func (m *Mp4Format) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultiBitrateFormat.
func (m MultiBitrateFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.MultiBitrateFormat"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "labels", o.Labels)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PNGFormat.
func (p PNGFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", p.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.PngFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGFormat.
func (p *PNGFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &p.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PNGImage.
func (p PNGImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", p.KeyFrameInterval)
	populate(objectMap, "label", p.Label)
	populate(objectMap, "layers", p.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.PngImage"
	populate(objectMap, "range", p.Range)
	populate(objectMap, "start", p.Start)
	populate(objectMap, "step", p.Step)
	populate(objectMap, "stretchMode", p.StretchMode)
	populate(objectMap, "syncMode", p.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGImage.
func (p *PNGImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &p.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &p.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, "Layers", &p.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, "Range", &p.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &p.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, "Step", &p.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &p.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &p.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByAttribute.
func (s SelectAudioTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "channelMapping", s.ChannelMapping)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, "Attribute", &s.Attribute)
			delete(rawMsg, key)
		case "channelMapping":
			err = unpopulate(val, "ChannelMapping", &s.ChannelMapping)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, "FilterValue", &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByID.
func (s SelectAudioTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", s.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, "ChannelMapping", &s.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, "TrackID", &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByAttribute.
func (s SelectVideoTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, "Attribute", &s.Attribute)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, "Filter", &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, "FilterValue", &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByID.
func (s SelectVideoTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, "TrackID", &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StandardEncoderPreset.
func (s StandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codecs", s.Codecs)
	populate(objectMap, "filters", s.Filters)
	populate(objectMap, "formats", s.Formats)
	objectMap["@odata.type"] = "#Microsoft.Media.StandardEncoderPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codecs":
			s.Codecs, err = unmarshalCodecClassificationArray(val)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, "Filters", &s.Filters)
			delete(rawMsg, key)
		case "formats":
			s.Formats, err = unmarshalFormatClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageEncryptedAssetDecryptionData.
func (s *StorageEncryptedAssetDecryptionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetFileEncryptionMetadata":
			err = unpopulate(val, "AssetFileEncryptionMetadata", &s.AssetFileEncryptionMetadata)
			delete(rawMsg, key)
		case "key":
			err = runtime.DecodeByteArray(string(val), &s.Key, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpoint.
func (s StreamingEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointProperties.
func (s StreamingEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", s.AccessControl)
	populate(objectMap, "availabilitySetName", s.AvailabilitySetName)
	populate(objectMap, "cdnEnabled", s.CdnEnabled)
	populate(objectMap, "cdnProfile", s.CdnProfile)
	populate(objectMap, "cdnProvider", s.CdnProvider)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "crossSiteAccessPolicies", s.CrossSiteAccessPolicies)
	populate(objectMap, "customHostNames", s.CustomHostNames)
	populate(objectMap, "description", s.Description)
	populateTimeRFC3339(objectMap, "freeTrialEndTime", s.FreeTrialEndTime)
	populate(objectMap, "hostName", s.HostName)
	populateTimeRFC3339(objectMap, "lastModified", s.LastModified)
	populate(objectMap, "maxCacheAge", s.MaxCacheAge)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resourceState", s.ResourceState)
	populate(objectMap, "scaleUnits", s.ScaleUnits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingEndpointProperties.
func (s *StreamingEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessControl":
			err = unpopulate(val, "AccessControl", &s.AccessControl)
			delete(rawMsg, key)
		case "availabilitySetName":
			err = unpopulate(val, "AvailabilitySetName", &s.AvailabilitySetName)
			delete(rawMsg, key)
		case "cdnEnabled":
			err = unpopulate(val, "CdnEnabled", &s.CdnEnabled)
			delete(rawMsg, key)
		case "cdnProfile":
			err = unpopulate(val, "CdnProfile", &s.CdnProfile)
			delete(rawMsg, key)
		case "cdnProvider":
			err = unpopulate(val, "CdnProvider", &s.CdnProvider)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &s.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, "CrossSiteAccessPolicies", &s.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "customHostNames":
			err = unpopulate(val, "CustomHostNames", &s.CustomHostNames)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "freeTrialEndTime":
			err = unpopulateTimeRFC3339(val, "FreeTrialEndTime", &s.FreeTrialEndTime)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, "HostName", &s.HostName)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &s.LastModified)
			delete(rawMsg, key)
		case "maxCacheAge":
			err = unpopulate(val, "MaxCacheAge", &s.MaxCacheAge)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, "ResourceState", &s.ResourceState)
			delete(rawMsg, key)
		case "scaleUnits":
			err = unpopulate(val, "ScaleUnits", &s.ScaleUnits)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorContentKey.
func (s StreamingLocatorContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "labelReferenceInStreamingPolicy", s.LabelReferenceInStreamingPolicy)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorProperties.
func (s StreamingLocatorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternativeMediaId", s.AlternativeMediaID)
	populate(objectMap, "assetName", s.AssetName)
	populate(objectMap, "contentKeys", s.ContentKeys)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "filters", s.Filters)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "streamingLocatorId", s.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", s.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingLocatorProperties.
func (s *StreamingLocatorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternativeMediaId":
			err = unpopulate(val, "AlternativeMediaID", &s.AlternativeMediaID)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, "AssetName", &s.AssetName)
			delete(rawMsg, key)
		case "contentKeys":
			err = unpopulate(val, "ContentKeys", &s.ContentKeys)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, "DefaultContentKeyPolicyName", &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, "Filters", &s.Filters)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, "StreamingLocatorID", &s.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, "StreamingPolicyName", &s.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKey.
func (s StreamingPolicyContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", s.Label)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKeys.
func (s StreamingPolicyContentKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultKey", s.DefaultKey)
	populate(objectMap, "keyToTrackMappings", s.KeyToTrackMappings)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyProperties.
func (s StreamingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commonEncryptionCbcs", s.CommonEncryptionCbcs)
	populate(objectMap, "commonEncryptionCenc", s.CommonEncryptionCenc)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populate(objectMap, "envelopeEncryption", s.EnvelopeEncryption)
	populate(objectMap, "noEncryption", s.NoEncryption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingPolicyProperties.
func (s *StreamingPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonEncryptionCbcs":
			err = unpopulate(val, "CommonEncryptionCbcs", &s.CommonEncryptionCbcs)
			delete(rawMsg, key)
		case "commonEncryptionCenc":
			err = unpopulate(val, "CommonEncryptionCenc", &s.CommonEncryptionCenc)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, "DefaultContentKeyPolicyName", &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "envelopeEncryption":
			err = unpopulate(val, "EnvelopeEncryption", &s.EnvelopeEncryption)
			delete(rawMsg, key)
		case "noEncryption":
			err = unpopulate(val, "NoEncryption", &s.NoEncryption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextTrack.
func (t TextTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "fileName", t.FileName)
	populate(objectMap, "hlsSettings", t.HlsSettings)
	populate(objectMap, "languageCode", t.LanguageCode)
	objectMap["@odata.type"] = "#Microsoft.Media.TextTrack"
	populate(objectMap, "playerVisibility", t.PlayerVisibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextTrack.
func (t *TextTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, "FileName", &t.FileName)
			delete(rawMsg, key)
		case "hlsSettings":
			err = unpopulate(val, "HlsSettings", &t.HlsSettings)
			delete(rawMsg, key)
		case "languageCode":
			err = unpopulate(val, "LanguageCode", &t.LanguageCode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &t.ODataType)
			delete(rawMsg, key)
		case "playerVisibility":
			err = unpopulate(val, "PlayerVisibility", &t.PlayerVisibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackSelection.
func (t TrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", t.TrackSelections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Transform.
func (t Transform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TransformOutput.
func (t TransformOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "onError", t.OnError)
	populate(objectMap, "preset", t.Preset)
	populate(objectMap, "relativePriority", t.RelativePriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformOutput.
func (t *TransformOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "onError":
			err = unpopulate(val, "OnError", &t.OnError)
			delete(rawMsg, key)
		case "preset":
			t.Preset, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "relativePriority":
			err = unpopulate(val, "RelativePriority", &t.RelativePriority)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TransformProperties.
func (t TransformProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", t.Created)
	populate(objectMap, "description", t.Description)
	populateTimeRFC3339(objectMap, "lastModified", t.LastModified)
	populate(objectMap, "outputs", t.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformProperties.
func (t *TransformProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, "Created", &t.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, "LastModified", &t.LastModified)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, "Outputs", &t.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TransportStreamFormat.
func (t TransportStreamFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", t.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.TransportStreamFormat"
	populate(objectMap, "outputFiles", t.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransportStreamFormat.
func (t *TransportStreamFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, "FilenamePattern", &t.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &t.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, "OutputFiles", &t.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UTCClipTime.
func (u UTCClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.UtcClipTime"
	populateTimeRFC3339(objectMap, "time", u.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UTCClipTime.
func (u *UTCClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &u.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, "Time", &u.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Video.
func (v Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", v.KeyFrameInterval)
	populate(objectMap, "label", v.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Video"
	populate(objectMap, "stretchMode", v.StretchMode)
	populate(objectMap, "syncMode", v.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Video.
func (v *Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, "KeyFrameInterval", &v.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &v.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &v.ODataType)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, "StretchMode", &v.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, "SyncMode", &v.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VideoAnalyzerPreset.
func (v VideoAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", v.AudioLanguage)
	populate(objectMap, "experimentalOptions", v.ExperimentalOptions)
	populate(objectMap, "insightsToExtract", v.InsightsToExtract)
	populate(objectMap, "mode", v.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, "AudioLanguage", &v.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, "ExperimentalOptions", &v.ExperimentalOptions)
			delete(rawMsg, key)
		case "insightsToExtract":
			err = unpopulate(val, "InsightsToExtract", &v.InsightsToExtract)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &v.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VideoOverlay.
func (v VideoOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", v.AudioGainLevel)
	populate(objectMap, "cropRectangle", v.CropRectangle)
	populate(objectMap, "end", v.End)
	populate(objectMap, "fadeInDuration", v.FadeInDuration)
	populate(objectMap, "fadeOutDuration", v.FadeOutDuration)
	populate(objectMap, "inputLabel", v.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoOverlay"
	populate(objectMap, "opacity", v.Opacity)
	populate(objectMap, "position", v.Position)
	populate(objectMap, "start", v.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoOverlay.
func (v *VideoOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, "AudioGainLevel", &v.AudioGainLevel)
			delete(rawMsg, key)
		case "cropRectangle":
			err = unpopulate(val, "CropRectangle", &v.CropRectangle)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, "End", &v.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, "FadeInDuration", &v.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, "FadeOutDuration", &v.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, "InputLabel", &v.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, "ODataType", &v.ODataType)
			delete(rawMsg, key)
		case "opacity":
			err = unpopulate(val, "Opacity", &v.Opacity)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, "Position", &v.Position)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, "Start", &v.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VideoTrack.
func (v VideoTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.VideoTrack"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoTrack.
func (v *VideoTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VideoTrackDescriptor.
func (v VideoTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.VideoTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, "ODataType", &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
