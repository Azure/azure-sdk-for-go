//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmediaservices

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
)

// GetAudio implements the AudioClassification interface for type AacAudio.
func (a *AacAudio) GetAudio() *Audio {
	return &Audio{
		Channels:     a.Channels,
		SamplingRate: a.SamplingRate,
		Bitrate:      a.Bitrate,
		ODataType:    a.ODataType,
		Label:        a.Label,
	}
}

// GetCodec implements the CodecClassification interface for type AacAudio.
func (a *AacAudio) GetCodec() *Codec {
	return &Codec{
		ODataType: a.ODataType,
		Label:     a.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AacAudio.
func (a AacAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.AacAudio"
	populate(objectMap, "profile", a.Profile)
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AacAudio.
func (a *AacAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "profile":
			err = unpopulate(val, &a.Profile)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetClipTime implements the ClipTimeClassification interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) GetClipTime() *ClipTime {
	return &ClipTime{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AbsoluteClipTime.
func (a AbsoluteClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.AbsoluteClipTime"
	populate(objectMap, "time", a.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AbsoluteClipTime.
func (a *AbsoluteClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulate(val, &a.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccessControl.
func (a AccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", a.DefaultAction)
	populate(objectMap, "ipAllowList", a.IPAllowList)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilter.
func (a AccountFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AccountFilterCollection.
func (a AccountFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiAccessControl.
func (a AkamaiAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "akamaiSignatureHeaderAuthenticationKeyList", a.AkamaiSignatureHeaderAuthenticationKeyList)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a AkamaiSignatureHeaderAuthenticationKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64Key", a.Base64Key)
	populateTimeRFC3339(objectMap, "expiration", a.Expiration)
	populate(objectMap, "identifier", a.Identifier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AkamaiSignatureHeaderAuthenticationKey.
func (a *AkamaiSignatureHeaderAuthenticationKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base64Key":
			err = unpopulate(val, &a.Base64Key)
			delete(rawMsg, key)
		case "expiration":
			err = unpopulateTimeRFC3339(val, &a.Expiration)
			delete(rawMsg, key)
		case "identifier":
			err = unpopulate(val, &a.Identifier)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetCollection.
func (a AssetCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetContainerSas.
func (a AssetContainerSas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetContainerSasUrls", a.AssetContainerSasUrls)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilter.
func (a AssetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetFilterCollection.
func (a AssetFilterCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", a.ODataNextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetProperties.
func (a AssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateId", a.AlternateID)
	populate(objectMap, "assetId", a.AssetID)
	populate(objectMap, "container", a.Container)
	populateTimeRFC3339(objectMap, "created", a.Created)
	populate(objectMap, "description", a.Description)
	populateTimeRFC3339(objectMap, "lastModified", a.LastModified)
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageEncryptionFormat", a.StorageEncryptionFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetProperties.
func (a *AssetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateId":
			err = unpopulate(val, &a.AlternateID)
			delete(rawMsg, key)
		case "assetId":
			err = unpopulate(val, &a.AssetID)
			delete(rawMsg, key)
		case "container":
			err = unpopulate(val, &a.Container)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &a.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &a.LastModified)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageEncryptionFormat":
			err = unpopulate(val, &a.StorageEncryptionFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetStreamingLocator.
func (a AssetStreamingLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", a.AssetName)
	populateTimeRFC3339(objectMap, "created", a.Created)
	populate(objectMap, "defaultContentKeyPolicyName", a.DefaultContentKeyPolicyName)
	populateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "name", a.Name)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "streamingLocatorId", a.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", a.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetStreamingLocator.
func (a *AssetStreamingLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &a.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &a.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &a.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &a.EndTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &a.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &a.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &a.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrack.
func (a AssetTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrackCollection.
func (a AssetTrackCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrackOperationStatus.
func (a AssetTrackOperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "error", a.Error)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetTrackOperationStatus.
func (a *AssetTrackOperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &a.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &a.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssetTrackProperties.
func (a AssetTrackProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "track", a.Track)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssetTrackProperties.
func (a *AssetTrackProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		case "track":
			a.Track, err = unmarshalTrackBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAudio implements the AudioClassification interface for type Audio.
func (a *Audio) GetAudio() *Audio { return a }

// GetCodec implements the CodecClassification interface for type Audio.
func (a *Audio) GetCodec() *Codec {
	return &Codec{
		ODataType: a.ODataType,
		Label:     a.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Audio.
func (a Audio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bitrate", a.Bitrate)
	populate(objectMap, "channels", a.Channels)
	populate(objectMap, "label", a.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Audio"
	populate(objectMap, "samplingRate", a.SamplingRate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Audio.
func (a *Audio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bitrate":
			err = unpopulate(val, &a.Bitrate)
			delete(rawMsg, key)
		case "channels":
			err = unpopulate(val, &a.Channels)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &a.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "samplingRate":
			err = unpopulate(val, &a.SamplingRate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAudioAnalyzerPreset implements the AudioAnalyzerPresetClassification interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) GetAudioAnalyzerPreset() *AudioAnalyzerPreset { return a }

// GetPreset implements the PresetClassification interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioAnalyzerPreset.
func (a AudioAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", a.AudioLanguage)
	populate(objectMap, "experimentalOptions", a.ExperimentalOptions)
	populate(objectMap, "mode", a.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioAnalyzerPreset.
func (a *AudioAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, &a.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &a.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &a.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOverlay implements the OverlayClassification interface for type AudioOverlay.
func (a *AudioOverlay) GetOverlay() *Overlay {
	return &Overlay{
		ODataType:       a.ODataType,
		InputLabel:      a.InputLabel,
		Start:           a.Start,
		End:             a.End,
		FadeInDuration:  a.FadeInDuration,
		FadeOutDuration: a.FadeOutDuration,
		AudioGainLevel:  a.AudioGainLevel,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioOverlay.
func (a AudioOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", a.AudioGainLevel)
	populate(objectMap, "end", a.End)
	populate(objectMap, "fadeInDuration", a.FadeInDuration)
	populate(objectMap, "fadeOutDuration", a.FadeOutDuration)
	populate(objectMap, "inputLabel", a.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioOverlay"
	populate(objectMap, "start", a.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioOverlay.
func (a *AudioOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, &a.AudioGainLevel)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, &a.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, &a.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, &a.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, &a.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &a.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackBase implements the TrackBaseClassification interface for type AudioTrack.
func (a *AudioTrack) GetTrackBase() *TrackBase {
	return &TrackBase{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioTrack.
func (a AudioTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.AudioTrack"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrack.
func (a *AudioTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) GetAudioTrackDescriptor() *AudioTrackDescriptor { return a }

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AudioTrackDescriptor.
func (a AudioTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", a.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.AudioTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AudioTrackDescriptor.
func (a *AudioTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, &a.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetPreset implements the PresetClassification interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: b.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BuiltInStandardEncoderPreset.
func (b BuiltInStandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configurations", b.Configurations)
	objectMap["@odata.type"] = "#Microsoft.Media.BuiltInStandardEncoderPreset"
	populate(objectMap, "presetName", b.PresetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BuiltInStandardEncoderPreset.
func (b *BuiltInStandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurations":
			err = unpopulate(val, &b.Configurations)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &b.ODataType)
			delete(rawMsg, key)
		case "presetName":
			err = unpopulate(val, &b.PresetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetClipTime implements the ClipTimeClassification interface for type ClipTime.
func (c *ClipTime) GetClipTime() *ClipTime { return c }

// GetCodec implements the CodecClassification interface for type Codec.
func (c *Codec) GetCodec() *Codec { return c }

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCbcs.
func (c CommonEncryptionCbcs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommonEncryptionCenc.
func (c CommonEncryptionCenc) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", c.ClearTracks)
	populate(objectMap, "contentKeys", c.ContentKeys)
	populate(objectMap, "drm", c.Drm)
	populate(objectMap, "enabledProtocols", c.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicy.
func (c ContentKeyPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyClearKeyConfiguration.
func (c *ContentKeyPolicyClearKeyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c ContentKeyPolicyClearKeyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyClearKeyConfiguration.
func (c *ContentKeyPolicyClearKeyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyCollection.
func (c ContentKeyPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", c.ODataNextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyConfiguration.
func (c *ContentKeyPolicyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return c
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c ContentKeyPolicyFairPlayConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "ask", c.Ask, runtime.Base64StdFormat)
	populate(objectMap, "fairPlayPfx", c.FairPlayPfx)
	populate(objectMap, "fairPlayPfxPassword", c.FairPlayPfxPassword)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration"
	populate(objectMap, "offlineRentalConfiguration", c.OfflineRentalConfiguration)
	populate(objectMap, "rentalAndLeaseKeyType", c.RentalAndLeaseKeyType)
	populate(objectMap, "rentalDuration", c.RentalDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyFairPlayConfiguration.
func (c *ContentKeyPolicyFairPlayConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ask":
			err = runtime.DecodeByteArray(string(val), &c.Ask, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "fairPlayPfx":
			err = unpopulate(val, &c.FairPlayPfx)
			delete(rawMsg, key)
		case "fairPlayPfxPassword":
			err = unpopulate(val, &c.FairPlayPfxPassword)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "offlineRentalConfiguration":
			err = unpopulate(val, &c.OfflineRentalConfiguration)
			delete(rawMsg, key)
		case "rentalAndLeaseKeyType":
			err = unpopulate(val, &c.RentalAndLeaseKeyType)
			delete(rawMsg, key)
		case "rentalDuration":
			err = unpopulate(val, &c.RentalDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyOpenRestriction.
func (c *ContentKeyPolicyOpenRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOpenRestriction.
func (c ContentKeyPolicyOpenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyOpenRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOpenRestriction.
func (c *ContentKeyPolicyOpenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyOption.
func (c ContentKeyPolicyOption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configuration", c.Configuration)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "policyOptionId", c.PolicyOptionID)
	populate(objectMap, "restriction", c.Restriction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyOption.
func (c *ContentKeyPolicyOption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			c.Configuration, err = unmarshalContentKeyPolicyConfigurationClassification(val)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "policyOptionId":
			err = unpopulate(val, &c.PolicyOptionID)
			delete(rawMsg, key)
		case "restriction":
			c.Restriction, err = unmarshalContentKeyPolicyRestrictionClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c ContentKeyPolicyPlayReadyConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "licenses", c.Licenses)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration"
	populate(objectMap, "responseCustomData", c.ResponseCustomData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyConfiguration.
func (c *ContentKeyPolicyPlayReadyConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenses":
			err = unpopulate(val, &c.Licenses)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "responseCustomData":
			err = unpopulate(val, &c.ResponseCustomData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return &ContentKeyPolicyPlayReadyContentKeyLocation{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return &ContentKeyPolicyPlayReadyContentKeyLocation{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyId", c.KeyID)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (c *ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyId":
			err = unpopulate(val, &c.KeyID)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyPlayReadyContentKeyLocation implements the ContentKeyPolicyPlayReadyContentKeyLocationClassification
// interface for type ContentKeyPolicyPlayReadyContentKeyLocation.
func (c *ContentKeyPolicyPlayReadyContentKeyLocation) GetContentKeyPolicyPlayReadyContentKeyLocation() *ContentKeyPolicyPlayReadyContentKeyLocation {
	return c
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c ContentKeyPolicyPlayReadyLicense) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowTestDevices", c.AllowTestDevices)
	populateTimeRFC3339(objectMap, "beginDate", c.BeginDate)
	populate(objectMap, "contentKeyLocation", c.ContentKeyLocation)
	populate(objectMap, "contentType", c.ContentType)
	populateTimeRFC3339(objectMap, "expirationDate", c.ExpirationDate)
	populate(objectMap, "gracePeriod", c.GracePeriod)
	populate(objectMap, "licenseType", c.LicenseType)
	populate(objectMap, "playRight", c.PlayRight)
	populate(objectMap, "relativeBeginDate", c.RelativeBeginDate)
	populate(objectMap, "relativeExpirationDate", c.RelativeExpirationDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyPlayReadyLicense.
func (c *ContentKeyPolicyPlayReadyLicense) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTestDevices":
			err = unpopulate(val, &c.AllowTestDevices)
			delete(rawMsg, key)
		case "beginDate":
			err = unpopulateTimeRFC3339(val, &c.BeginDate)
			delete(rawMsg, key)
		case "contentKeyLocation":
			c.ContentKeyLocation, err = unmarshalContentKeyPolicyPlayReadyContentKeyLocationClassification(val)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &c.ContentType)
			delete(rawMsg, key)
		case "expirationDate":
			err = unpopulateTimeRFC3339(val, &c.ExpirationDate)
			delete(rawMsg, key)
		case "gracePeriod":
			err = unpopulate(val, &c.GracePeriod)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &c.LicenseType)
			delete(rawMsg, key)
		case "playRight":
			err = unpopulate(val, &c.PlayRight)
			delete(rawMsg, key)
		case "relativeBeginDate":
			err = unpopulate(val, &c.RelativeBeginDate)
			delete(rawMsg, key)
		case "relativeExpirationDate":
			err = unpopulate(val, &c.RelativeExpirationDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyProperties.
func (c ContentKeyPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", c.Created)
	populate(objectMap, "description", c.Description)
	populateTimeRFC3339(objectMap, "lastModified", c.LastModified)
	populate(objectMap, "options", c.Options)
	populate(objectMap, "policyId", c.PolicyID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyProperties.
func (c *ContentKeyPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &c.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &c.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &c.LastModified)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, &c.Options)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, &c.PolicyID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyRestriction.
func (c *ContentKeyPolicyRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return c
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyRestrictionTokenKey.
func (c *ContentKeyPolicyRestrictionTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return c
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c ContentKeyPolicyRsaTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "exponent", c.Exponent, runtime.Base64StdFormat)
	populateByteArray(objectMap, "modulus", c.Modulus, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyRsaTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyRsaTokenKey.
func (c *ContentKeyPolicyRsaTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exponent":
			err = runtime.DecodeByteArray(string(val), &c.Exponent, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "modulus":
			err = runtime.DecodeByteArray(string(val), &c.Modulus, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c ContentKeyPolicySymmetricTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "keyValue", c.KeyValue, runtime.Base64StdFormat)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicySymmetricTokenKey.
func (c *ContentKeyPolicySymmetricTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyValue":
			err = runtime.DecodeByteArray(string(val), &c.KeyValue, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyTokenRestriction.
func (c ContentKeyPolicyTokenRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateVerificationKeys", c.AlternateVerificationKeys)
	populate(objectMap, "audience", c.Audience)
	populate(objectMap, "issuer", c.Issuer)
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyTokenRestriction"
	populate(objectMap, "openIdConnectDiscoveryDocument", c.OpenIDConnectDiscoveryDocument)
	populate(objectMap, "primaryVerificationKey", c.PrimaryVerificationKey)
	populate(objectMap, "requiredClaims", c.RequiredClaims)
	populate(objectMap, "restrictionTokenType", c.RestrictionTokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyTokenRestriction.
func (c *ContentKeyPolicyTokenRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateVerificationKeys":
			c.AlternateVerificationKeys, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassificationArray(val)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, &c.Audience)
			delete(rawMsg, key)
		case "issuer":
			err = unpopulate(val, &c.Issuer)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "openIdConnectDiscoveryDocument":
			err = unpopulate(val, &c.OpenIDConnectDiscoveryDocument)
			delete(rawMsg, key)
		case "primaryVerificationKey":
			c.PrimaryVerificationKey, err = unmarshalContentKeyPolicyRestrictionTokenKeyClassification(val)
			delete(rawMsg, key)
		case "requiredClaims":
			err = unpopulate(val, &c.RequiredClaims)
			delete(rawMsg, key)
		case "restrictionTokenType":
			err = unpopulate(val, &c.RestrictionTokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyUnknownConfiguration.
func (c *ContentKeyPolicyUnknownConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c ContentKeyPolicyUnknownConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownConfiguration.
func (c *ContentKeyPolicyUnknownConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestriction implements the ContentKeyPolicyRestrictionClassification interface for type ContentKeyPolicyUnknownRestriction.
func (c *ContentKeyPolicyUnknownRestriction) GetContentKeyPolicyRestriction() *ContentKeyPolicyRestriction {
	return &ContentKeyPolicyRestriction{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c ContentKeyPolicyUnknownRestriction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyUnknownRestriction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyUnknownRestriction.
func (c *ContentKeyPolicyUnknownRestriction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyConfiguration implements the ContentKeyPolicyConfigurationClassification interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) GetContentKeyPolicyConfiguration() *ContentKeyPolicyConfiguration {
	return &ContentKeyPolicyConfiguration{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c ContentKeyPolicyWidevineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration"
	populate(objectMap, "widevineTemplate", c.WidevineTemplate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyWidevineConfiguration.
func (c *ContentKeyPolicyWidevineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "widevineTemplate":
			err = unpopulate(val, &c.WidevineTemplate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetContentKeyPolicyRestrictionTokenKey implements the ContentKeyPolicyRestrictionTokenKeyClassification interface for type
// ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) GetContentKeyPolicyRestrictionTokenKey() *ContentKeyPolicyRestrictionTokenKey {
	return &ContentKeyPolicyRestrictionTokenKey{
		ODataType: c.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c ContentKeyPolicyX509CertificateTokenKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey"
	populateByteArray(objectMap, "rawBody", c.RawBody, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContentKeyPolicyX509CertificateTokenKey.
func (c *ContentKeyPolicyX509CertificateTokenKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		case "rawBody":
			err = runtime.DecodeByteArray(string(val), &c.RawBody, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type CopyAudio.
func (c *CopyAudio) GetCodec() *Codec {
	return &Codec{
		ODataType: c.ODataType,
		Label:     c.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CopyAudio.
func (c CopyAudio) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyAudio"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyAudio.
func (c *CopyAudio) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type CopyVideo.
func (c *CopyVideo) GetCodec() *Codec {
	return &Codec{
		ODataType: c.ODataType,
		Label:     c.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CopyVideo.
func (c CopyVideo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", c.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.CopyVideo"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyVideo.
func (c *CopyVideo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "label":
			err = unpopulate(val, &c.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvelopeEncryption.
func (e EnvelopeEncryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clearTracks", e.ClearTracks)
	populate(objectMap, "contentKeys", e.ContentKeys)
	populate(objectMap, "customKeyAcquisitionUrlTemplate", e.CustomKeyAcquisitionURLTemplate)
	populate(objectMap, "enabledProtocols", e.EnabledProtocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// GetPreset implements the PresetClassification interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: f.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FaceDetectorPreset.
func (f FaceDetectorPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blurType", f.BlurType)
	populate(objectMap, "experimentalOptions", f.ExperimentalOptions)
	populate(objectMap, "mode", f.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.FaceDetectorPreset"
	populate(objectMap, "resolution", f.Resolution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaceDetectorPreset.
func (f *FaceDetectorPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blurType":
			err = unpopulate(val, &f.BlurType)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &f.ExperimentalOptions)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &f.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		case "resolution":
			err = unpopulate(val, &f.Resolution)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FilterTrackSelection.
func (f FilterTrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", f.TrackSelections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Filters.
func (f Filters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crop", f.Crop)
	populate(objectMap, "deinterlace", f.Deinterlace)
	populate(objectMap, "overlays", f.Overlays)
	populate(objectMap, "rotation", f.Rotation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Filters.
func (f *Filters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crop":
			err = unpopulate(val, &f.Crop)
			delete(rawMsg, key)
		case "deinterlace":
			err = unpopulate(val, &f.Deinterlace)
			delete(rawMsg, key)
		case "overlays":
			f.Overlays, err = unmarshalOverlayClassificationArray(val)
			delete(rawMsg, key)
		case "rotation":
			err = unpopulate(val, &f.Rotation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFormat implements the FormatClassification interface for type Format.
func (f *Format) GetFormat() *Format { return f }

// GetInputDefinition implements the InputDefinitionClassification interface for type FromAllInputFile.
func (f *FromAllInputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      f.ODataType,
		IncludedTracks: f.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FromAllInputFile.
func (f FromAllInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromAllInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromAllInputFile.
func (f *FromAllInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetInputDefinition implements the InputDefinitionClassification interface for type FromEachInputFile.
func (f *FromEachInputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      f.ODataType,
		IncludedTracks: f.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FromEachInputFile.
func (f FromEachInputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", f.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.FromEachInputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FromEachInputFile.
func (f *FromEachInputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			f.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &f.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type H264Video.
func (h *H264Video) GetCodec() *Codec {
	return &Codec{
		ODataType: h.ODataType,
		Label:     h.Label,
	}
}

// GetVideo implements the VideoClassification interface for type H264Video.
func (h *H264Video) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: h.KeyFrameInterval,
		StretchMode:      h.StretchMode,
		SyncMode:         h.SyncMode,
		ODataType:        h.ODataType,
		Label:            h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H264Video.
func (h H264Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H264Video"
	populate(objectMap, "rateControlMode", h.RateControlMode)
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H264Video.
func (h *H264Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "rateControlMode":
			err = unpopulate(val, &h.RateControlMode)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type H265Video.
func (h *H265Video) GetCodec() *Codec {
	return &Codec{
		ODataType: h.ODataType,
		Label:     h.Label,
	}
}

// GetVideo implements the VideoClassification interface for type H265Video.
func (h *H265Video) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: h.KeyFrameInterval,
		StretchMode:      h.StretchMode,
		SyncMode:         h.SyncMode,
		ODataType:        h.ODataType,
		Label:            h.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type H265Video.
func (h H265Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complexity", h.Complexity)
	populate(objectMap, "keyFrameInterval", h.KeyFrameInterval)
	populate(objectMap, "label", h.Label)
	populate(objectMap, "layers", h.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.H265Video"
	populate(objectMap, "sceneChangeDetection", h.SceneChangeDetection)
	populate(objectMap, "stretchMode", h.StretchMode)
	populate(objectMap, "syncMode", h.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type H265Video.
func (h *H265Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complexity":
			err = unpopulate(val, &h.Complexity)
			delete(rawMsg, key)
		case "keyFrameInterval":
			err = unpopulate(val, &h.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &h.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &h.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &h.ODataType)
			delete(rawMsg, key)
		case "sceneChangeDetection":
			err = unpopulate(val, &h.SceneChangeDetection)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &h.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &h.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPAccessControl.
func (i IPAccessControl) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allow", i.Allow)
	return json.Marshal(objectMap)
}

// GetCodec implements the CodecClassification interface for type Image.
func (i *Image) GetCodec() *Codec {
	return &Codec{
		ODataType: i.ODataType,
		Label:     i.Label,
	}
}

// GetImage implements the ImageClassification interface for type Image.
func (i *Image) GetImage() *Image { return i }

// GetVideo implements the VideoClassification interface for type Image.
func (i *Image) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: i.KeyFrameInterval,
		StretchMode:      i.StretchMode,
		SyncMode:         i.SyncMode,
		ODataType:        i.ODataType,
		Label:            i.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Image.
func (i Image) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", i.KeyFrameInterval)
	populate(objectMap, "label", i.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Image"
	populate(objectMap, "range", i.Range)
	populate(objectMap, "start", i.Start)
	populate(objectMap, "step", i.Step)
	populate(objectMap, "stretchMode", i.StretchMode)
	populate(objectMap, "syncMode", i.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Image.
func (i *Image) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &i.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &i.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &i.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &i.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &i.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &i.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &i.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFormat implements the FormatClassification interface for type ImageFormat.
func (i *ImageFormat) GetFormat() *Format {
	return &Format{
		ODataType:       i.ODataType,
		FilenamePattern: i.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type ImageFormat.
func (i *ImageFormat) GetImageFormat() *ImageFormat { return i }

// MarshalJSON implements the json.Marshaller interface for type ImageFormat.
func (i ImageFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", i.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.ImageFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageFormat.
func (i *ImageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &i.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetInputDefinition implements the InputDefinitionClassification interface for type InputDefinition.
func (i *InputDefinition) GetInputDefinition() *InputDefinition { return i }

// MarshalJSON implements the json.Marshaller interface for type InputDefinition.
func (i InputDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = i.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputDefinition.
func (i *InputDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetInputDefinition implements the InputDefinitionClassification interface for type InputFile.
func (i *InputFile) GetInputDefinition() *InputDefinition {
	return &InputDefinition{
		ODataType:      i.ODataType,
		IncludedTracks: i.IncludedTracks,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InputFile.
func (i InputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filename", i.Filename)
	populate(objectMap, "includedTracks", i.IncludedTracks)
	objectMap["@odata.type"] = "#Microsoft.Media.InputFile"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputFile.
func (i *InputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filename":
			err = unpopulate(val, &i.Filename)
			delete(rawMsg, key)
		case "includedTracks":
			i.IncludedTracks, err = unmarshalTrackDescriptorClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JobCollection.
func (j JobCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", j.ODataNextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JobError.
func (j JobError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", j.Category)
	populate(objectMap, "code", j.Code)
	populate(objectMap, "details", j.Details)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "retry", j.Retry)
	return json.Marshal(objectMap)
}

// GetJobInput implements the JobInputClassification interface for type JobInput.
func (j *JobInput) GetJobInput() *JobInput { return j }

// GetJobInput implements the JobInputClassification interface for type JobInputAsset.
func (j *JobInputAsset) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputAsset.
func (j *JobInputAsset) GetJobInputClip() *JobInputClip {
	return &JobInputClip{
		Files:            j.Files,
		Start:            j.Start,
		End:              j.End,
		Label:            j.Label,
		InputDefinitions: j.InputDefinitions,
		ODataType:        j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputAsset.
func (j JobInputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputAsset"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputAsset.
func (j *JobInputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobInput implements the JobInputClassification interface for type JobInputClip.
func (j *JobInputClip) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputClip.
func (j *JobInputClip) GetJobInputClip() *JobInputClip { return j }

// MarshalJSON implements the json.Marshaller interface for type JobInputClip.
func (j JobInputClip) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputClip"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputClip.
func (j *JobInputClip) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobInput implements the JobInputClassification interface for type JobInputHTTP.
func (j *JobInputHTTP) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// GetJobInputClip implements the JobInputClipClassification interface for type JobInputHTTP.
func (j *JobInputHTTP) GetJobInputClip() *JobInputClip {
	return &JobInputClip{
		Files:            j.Files,
		Start:            j.Start,
		End:              j.End,
		Label:            j.Label,
		InputDefinitions: j.InputDefinitions,
		ODataType:        j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputHTTP.
func (j JobInputHTTP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", j.BaseURI)
	populate(objectMap, "end", j.End)
	populate(objectMap, "files", j.Files)
	populate(objectMap, "inputDefinitions", j.InputDefinitions)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputHttp"
	populate(objectMap, "start", j.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputHTTP.
func (j *JobInputHTTP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
			err = unpopulate(val, &j.BaseURI)
			delete(rawMsg, key)
		case "end":
			j.End, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		case "files":
			err = unpopulate(val, &j.Files)
			delete(rawMsg, key)
		case "inputDefinitions":
			j.InputDefinitions, err = unmarshalInputDefinitionClassificationArray(val)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "start":
			j.Start, err = unmarshalClipTimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobInput implements the JobInputClassification interface for type JobInputSequence.
func (j *JobInputSequence) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputSequence.
func (j JobInputSequence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputSequence"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputSequence.
func (j *JobInputSequence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClipClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobInput implements the JobInputClassification interface for type JobInputs.
func (j *JobInputs) GetJobInput() *JobInput {
	return &JobInput{
		ODataType: j.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobInputs.
func (j JobInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputs", j.Inputs)
	objectMap["@odata.type"] = "#Microsoft.Media.JobInputs"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobInputs.
func (j *JobInputs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			j.Inputs, err = unmarshalJobInputClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobOutput implements the JobOutputClassification interface for type JobOutput.
func (j *JobOutput) GetJobOutput() *JobOutput { return j }

// MarshalJSON implements the json.Marshaller interface for type JobOutput.
func (j JobOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = j.ODataType
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutput.
func (j *JobOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetJobOutput implements the JobOutputClassification interface for type JobOutputAsset.
func (j *JobOutputAsset) GetJobOutput() *JobOutput {
	return &JobOutput{
		ODataType:      j.ODataType,
		Error:          j.Error,
		PresetOverride: j.PresetOverride,
		State:          j.State,
		Progress:       j.Progress,
		Label:          j.Label,
		StartTime:      j.StartTime,
		EndTime:        j.EndTime,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JobOutputAsset.
func (j JobOutputAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetName", j.AssetName)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "error", j.Error)
	populate(objectMap, "label", j.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.JobOutputAsset"
	populate(objectMap, "presetOverride", j.PresetOverride)
	populate(objectMap, "progress", j.Progress)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobOutputAsset.
func (j *JobOutputAsset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetName":
			err = unpopulate(val, &j.AssetName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "presetOverride":
			j.PresetOverride, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "progress":
			err = unpopulate(val, &j.Progress)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "correlationData", j.CorrelationData)
	populateTimeRFC3339(objectMap, "created", j.Created)
	populate(objectMap, "description", j.Description)
	populateTimeRFC3339(objectMap, "endTime", j.EndTime)
	populate(objectMap, "input", j.Input)
	populateTimeRFC3339(objectMap, "lastModified", j.LastModified)
	populate(objectMap, "outputs", j.Outputs)
	populate(objectMap, "priority", j.Priority)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationData":
			err = unpopulate(val, &j.CorrelationData)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &j.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &j.EndTime)
			delete(rawMsg, key)
		case "input":
			j.Input, err = unmarshalJobInputClassification(val)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &j.LastModified)
			delete(rawMsg, key)
		case "outputs":
			j.Outputs, err = unmarshalJobOutputClassificationArray(val)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, &j.Priority)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFormat implements the FormatClassification interface for type JpgFormat.
func (j *JpgFormat) GetFormat() *Format {
	return &Format{
		ODataType:       j.ODataType,
		FilenamePattern: j.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type JpgFormat.
func (j *JpgFormat) GetImageFormat() *ImageFormat {
	return &ImageFormat{
		ODataType:       j.ODataType,
		FilenamePattern: j.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JpgFormat.
func (j JpgFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", j.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgFormat.
func (j *JpgFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &j.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type JpgImage.
func (j *JpgImage) GetCodec() *Codec {
	return &Codec{
		ODataType: j.ODataType,
		Label:     j.Label,
	}
}

// GetImage implements the ImageClassification interface for type JpgImage.
func (j *JpgImage) GetImage() *Image {
	return &Image{
		Start:            j.Start,
		Step:             j.Step,
		Range:            j.Range,
		KeyFrameInterval: j.KeyFrameInterval,
		StretchMode:      j.StretchMode,
		SyncMode:         j.SyncMode,
		ODataType:        j.ODataType,
		Label:            j.Label,
	}
}

// GetVideo implements the VideoClassification interface for type JpgImage.
func (j *JpgImage) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: j.KeyFrameInterval,
		StretchMode:      j.StretchMode,
		SyncMode:         j.SyncMode,
		ODataType:        j.ODataType,
		Label:            j.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JpgImage.
func (j JpgImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", j.KeyFrameInterval)
	populate(objectMap, "label", j.Label)
	populate(objectMap, "layers", j.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.JpgImage"
	populate(objectMap, "range", j.Range)
	populate(objectMap, "spriteColumn", j.SpriteColumn)
	populate(objectMap, "start", j.Start)
	populate(objectMap, "step", j.Step)
	populate(objectMap, "stretchMode", j.StretchMode)
	populate(objectMap, "syncMode", j.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JpgImage.
func (j *JpgImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &j.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &j.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &j.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &j.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &j.Range)
			delete(rawMsg, key)
		case "spriteColumn":
			err = unpopulate(val, &j.SpriteColumn)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &j.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &j.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &j.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &j.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListContainerSasInput.
func (l ListContainerSasInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiryTime", l.ExpiryTime)
	populate(objectMap, "permissions", l.Permissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListContainerSasInput.
func (l *ListContainerSasInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, &l.ExpiryTime)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, &l.Permissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListContentKeysResponse.
func (l ListContentKeysResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentKeys", l.ContentKeys)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ListPathsResponse.
func (l ListPathsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "downloadPaths", l.DownloadPaths)
	populate(objectMap, "streamingPaths", l.StreamingPaths)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ListStreamingLocatorsResponse.
func (l ListStreamingLocatorsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "streamingLocators", l.StreamingLocators)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEvent.
func (l LiveEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "systemData", l.SystemData)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventInput.
func (l LiveEventInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "accessToken", l.AccessToken)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "keyFrameIntervalDuration", l.KeyFrameIntervalDuration)
	populate(objectMap, "streamingProtocol", l.StreamingProtocol)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventListResult.
func (l LiveEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventPreview.
func (l LiveEventPreview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", l.AccessControl)
	populate(objectMap, "alternativeMediaId", l.AlternativeMediaID)
	populate(objectMap, "endpoints", l.Endpoints)
	populate(objectMap, "previewLocator", l.PreviewLocator)
	populate(objectMap, "streamingPolicyName", l.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventProperties.
func (l LiveEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "crossSiteAccessPolicies", l.CrossSiteAccessPolicies)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "encoding", l.Encoding)
	populate(objectMap, "hostnamePrefix", l.HostnamePrefix)
	populate(objectMap, "input", l.Input)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "preview", l.Preview)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	populate(objectMap, "streamOptions", l.StreamOptions)
	populate(objectMap, "transcriptions", l.Transcriptions)
	populate(objectMap, "useStaticHostname", l.UseStaticHostname)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveEventProperties.
func (l *LiveEventProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &l.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &l.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "encoding":
			err = unpopulate(val, &l.Encoding)
			delete(rawMsg, key)
		case "hostnamePrefix":
			err = unpopulate(val, &l.HostnamePrefix)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &l.Input)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &l.LastModified)
			delete(rawMsg, key)
		case "preview":
			err = unpopulate(val, &l.Preview)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		case "streamOptions":
			err = unpopulate(val, &l.StreamOptions)
			delete(rawMsg, key)
		case "transcriptions":
			err = unpopulate(val, &l.Transcriptions)
			delete(rawMsg, key)
		case "useStaticHostname":
			err = unpopulate(val, &l.UseStaticHostname)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LiveEventTranscription.
func (l LiveEventTranscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "inputTrackSelection", l.InputTrackSelection)
	populate(objectMap, "language", l.Language)
	populate(objectMap, "outputTranscriptionTrack", l.OutputTranscriptionTrack)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputListResult.
func (l LiveOutputListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", l.ODataCount)
	populate(objectMap, "@odata.nextLink", l.ODataNextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LiveOutputProperties.
func (l LiveOutputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveWindowLength", l.ArchiveWindowLength)
	populate(objectMap, "assetName", l.AssetName)
	populateTimeRFC3339(objectMap, "created", l.Created)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "hls", l.Hls)
	populateTimeRFC3339(objectMap, "lastModified", l.LastModified)
	populate(objectMap, "manifestName", l.ManifestName)
	populate(objectMap, "outputSnapTime", l.OutputSnapTime)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "resourceState", l.ResourceState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LiveOutputProperties.
func (l *LiveOutputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archiveWindowLength":
			err = unpopulate(val, &l.ArchiveWindowLength)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &l.AssetName)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &l.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "hls":
			err = unpopulate(val, &l.Hls)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &l.LastModified)
			delete(rawMsg, key)
		case "manifestName":
			err = unpopulate(val, &l.ManifestName)
			delete(rawMsg, key)
		case "outputSnapTime":
			err = unpopulate(val, &l.OutputSnapTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &l.ResourceState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MediaFilterProperties.
func (m MediaFilterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "firstQuality", m.FirstQuality)
	populate(objectMap, "presentationTimeRange", m.PresentationTimeRange)
	populate(objectMap, "tracks", m.Tracks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaService.
func (m MediaService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceCollection.
func (m MediaServiceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", m.ODataNextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceIdentity.
func (m MediaServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceProperties.
func (m MediaServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryption", m.Encryption)
	populate(objectMap, "keyDelivery", m.KeyDelivery)
	populate(objectMap, "mediaServiceId", m.MediaServiceID)
	populate(objectMap, "publicNetworkAccess", m.PublicNetworkAccess)
	populate(objectMap, "storageAccounts", m.StorageAccounts)
	populate(objectMap, "storageAuthentication", m.StorageAuthentication)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MediaServiceUpdate.
func (m MediaServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricSpecification.
func (m MetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", m.AggregationType)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", m.EnableRegionalMdmAccount)
	populate(objectMap, "lockAggregationType", m.LockAggregationType)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceMdmAccount", m.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", m.SourceMdmNamespace)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "supportedTimeGrainTypes", m.SupportedTimeGrainTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// GetFormat implements the FormatClassification interface for type Mp4Format.
func (m *Mp4Format) GetFormat() *Format {
	return &Format{
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type Mp4Format.
func (m *Mp4Format) GetMultiBitrateFormat() *MultiBitrateFormat {
	return &MultiBitrateFormat{
		OutputFiles:     m.OutputFiles,
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Mp4Format.
func (m Mp4Format) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.Mp4Format"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Mp4Format.
func (m *Mp4Format) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFormat implements the FormatClassification interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) GetFormat() *Format {
	return &Format{
		ODataType:       m.ODataType,
		FilenamePattern: m.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) GetMultiBitrateFormat() *MultiBitrateFormat { return m }

// MarshalJSON implements the json.Marshaller interface for type MultiBitrateFormat.
func (m MultiBitrateFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", m.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.MultiBitrateFormat"
	populate(objectMap, "outputFiles", m.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiBitrateFormat.
func (m *MultiBitrateFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &m.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &m.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationCollection.
func (o OperationCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "labels", o.Labels)
	return json.Marshal(objectMap)
}

// GetOverlay implements the OverlayClassification interface for type Overlay.
func (o *Overlay) GetOverlay() *Overlay { return o }

// GetFormat implements the FormatClassification interface for type PNGFormat.
func (p *PNGFormat) GetFormat() *Format {
	return &Format{
		ODataType:       p.ODataType,
		FilenamePattern: p.FilenamePattern,
	}
}

// GetImageFormat implements the ImageFormatClassification interface for type PNGFormat.
func (p *PNGFormat) GetImageFormat() *ImageFormat {
	return &ImageFormat{
		ODataType:       p.ODataType,
		FilenamePattern: p.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PNGFormat.
func (p PNGFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", p.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.PngFormat"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGFormat.
func (p *PNGFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &p.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type PNGImage.
func (p *PNGImage) GetCodec() *Codec {
	return &Codec{
		ODataType: p.ODataType,
		Label:     p.Label,
	}
}

// GetImage implements the ImageClassification interface for type PNGImage.
func (p *PNGImage) GetImage() *Image {
	return &Image{
		Start:            p.Start,
		Step:             p.Step,
		Range:            p.Range,
		KeyFrameInterval: p.KeyFrameInterval,
		StretchMode:      p.StretchMode,
		SyncMode:         p.SyncMode,
		ODataType:        p.ODataType,
		Label:            p.Label,
	}
}

// GetVideo implements the VideoClassification interface for type PNGImage.
func (p *PNGImage) GetVideo() *Video {
	return &Video{
		KeyFrameInterval: p.KeyFrameInterval,
		StretchMode:      p.StretchMode,
		SyncMode:         p.SyncMode,
		ODataType:        p.ODataType,
		Label:            p.Label,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PNGImage.
func (p PNGImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", p.KeyFrameInterval)
	populate(objectMap, "label", p.Label)
	populate(objectMap, "layers", p.Layers)
	objectMap["@odata.type"] = "#Microsoft.Media.PngImage"
	populate(objectMap, "range", p.Range)
	populate(objectMap, "start", p.Start)
	populate(objectMap, "step", p.Step)
	populate(objectMap, "stretchMode", p.StretchMode)
	populate(objectMap, "syncMode", p.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PNGImage.
func (p *PNGImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &p.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &p.Label)
			delete(rawMsg, key)
		case "layers":
			err = unpopulate(val, &p.Layers)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &p.ODataType)
			delete(rawMsg, key)
		case "range":
			err = unpopulate(val, &p.Range)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &p.Start)
			delete(rawMsg, key)
		case "step":
			err = unpopulate(val, &p.Step)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &p.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &p.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetPreset implements the PresetClassification interface for type Preset.
func (p *Preset) GetPreset() *Preset { return p }

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) GetAudioTrackDescriptor() *AudioTrackDescriptor {
	return &AudioTrackDescriptor{
		ChannelMapping: s.ChannelMapping,
		ODataType:      s.ODataType,
	}
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByAttribute.
func (s SelectAudioTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "channelMapping", s.ChannelMapping)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByAttribute.
func (s *SelectAudioTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "channelMapping":
			err = unpopulate(val, &s.ChannelMapping)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAudioTrackDescriptor implements the AudioTrackDescriptorClassification interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) GetAudioTrackDescriptor() *AudioTrackDescriptor {
	return &AudioTrackDescriptor{
		ChannelMapping: s.ChannelMapping,
		ODataType:      s.ODataType,
	}
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectAudioTrackByID.
func (s SelectAudioTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "channelMapping", s.ChannelMapping)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectAudioTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectAudioTrackByID.
func (s *SelectAudioTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channelMapping":
			err = unpopulate(val, &s.ChannelMapping)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) GetVideoTrackDescriptor() *VideoTrackDescriptor {
	return &VideoTrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByAttribute.
func (s SelectVideoTrackByAttribute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attribute", s.Attribute)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "filterValue", s.FilterValue)
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackByAttribute"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByAttribute.
func (s *SelectVideoTrackByAttribute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attribute":
			err = unpopulate(val, &s.Attribute)
			delete(rawMsg, key)
		case "filter":
			err = unpopulate(val, &s.Filter)
			delete(rawMsg, key)
		case "filterValue":
			err = unpopulate(val, &s.FilterValue)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: s.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) GetVideoTrackDescriptor() *VideoTrackDescriptor {
	return &VideoTrackDescriptor{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SelectVideoTrackByID.
func (s SelectVideoTrackByID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.SelectVideoTrackById"
	populate(objectMap, "trackId", s.TrackID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectVideoTrackByID.
func (s *SelectVideoTrackByID) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		case "trackId":
			err = unpopulate(val, &s.TrackID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSpecification.
func (s ServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", s.LogSpecifications)
	populate(objectMap, "metricSpecifications", s.MetricSpecifications)
	return json.Marshal(objectMap)
}

// GetPreset implements the PresetClassification interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: s.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StandardEncoderPreset.
func (s StandardEncoderPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "codecs", s.Codecs)
	populate(objectMap, "filters", s.Filters)
	populate(objectMap, "formats", s.Formats)
	objectMap["@odata.type"] = "#Microsoft.Media.StandardEncoderPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StandardEncoderPreset.
func (s *StandardEncoderPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codecs":
			s.Codecs, err = unmarshalCodecClassificationArray(val)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "formats":
			s.Formats, err = unmarshalFormatClassificationArray(val)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageEncryptedAssetDecryptionData.
func (s StorageEncryptedAssetDecryptionData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assetFileEncryptionMetadata", s.AssetFileEncryptionMetadata)
	populateByteArray(objectMap, "key", s.Key, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageEncryptedAssetDecryptionData.
func (s *StorageEncryptedAssetDecryptionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assetFileEncryptionMetadata":
			err = unpopulate(val, &s.AssetFileEncryptionMetadata)
			delete(rawMsg, key)
		case "key":
			err = runtime.DecodeByteArray(string(val), &s.Key, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpoint.
func (s StreamingEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointListResult.
func (s StreamingEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.count", s.ODataCount)
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointProperties.
func (s StreamingEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControl", s.AccessControl)
	populate(objectMap, "availabilitySetName", s.AvailabilitySetName)
	populate(objectMap, "cdnEnabled", s.CdnEnabled)
	populate(objectMap, "cdnProfile", s.CdnProfile)
	populate(objectMap, "cdnProvider", s.CdnProvider)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "crossSiteAccessPolicies", s.CrossSiteAccessPolicies)
	populate(objectMap, "customHostNames", s.CustomHostNames)
	populate(objectMap, "description", s.Description)
	populateTimeRFC3339(objectMap, "freeTrialEndTime", s.FreeTrialEndTime)
	populate(objectMap, "hostName", s.HostName)
	populateTimeRFC3339(objectMap, "lastModified", s.LastModified)
	populate(objectMap, "maxCacheAge", s.MaxCacheAge)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resourceState", s.ResourceState)
	populate(objectMap, "scaleUnits", s.ScaleUnits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingEndpointProperties.
func (s *StreamingEndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessControl":
			err = unpopulate(val, &s.AccessControl)
			delete(rawMsg, key)
		case "availabilitySetName":
			err = unpopulate(val, &s.AvailabilitySetName)
			delete(rawMsg, key)
		case "cdnEnabled":
			err = unpopulate(val, &s.CdnEnabled)
			delete(rawMsg, key)
		case "cdnProfile":
			err = unpopulate(val, &s.CdnProfile)
			delete(rawMsg, key)
		case "cdnProvider":
			err = unpopulate(val, &s.CdnProvider)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "crossSiteAccessPolicies":
			err = unpopulate(val, &s.CrossSiteAccessPolicies)
			delete(rawMsg, key)
		case "customHostNames":
			err = unpopulate(val, &s.CustomHostNames)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "freeTrialEndTime":
			err = unpopulateTimeRFC3339(val, &s.FreeTrialEndTime)
			delete(rawMsg, key)
		case "hostName":
			err = unpopulate(val, &s.HostName)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &s.LastModified)
			delete(rawMsg, key)
		case "maxCacheAge":
			err = unpopulate(val, &s.MaxCacheAge)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "resourceState":
			err = unpopulate(val, &s.ResourceState)
			delete(rawMsg, key)
		case "scaleUnits":
			err = unpopulate(val, &s.ScaleUnits)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingEndpointSKUInfoListResult.
func (s StreamingEndpointSKUInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorCollection.
func (s StreamingLocatorCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorContentKey.
func (s StreamingLocatorContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "labelReferenceInStreamingPolicy", s.LabelReferenceInStreamingPolicy)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingLocatorProperties.
func (s StreamingLocatorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternativeMediaId", s.AlternativeMediaID)
	populate(objectMap, "assetName", s.AssetName)
	populate(objectMap, "contentKeys", s.ContentKeys)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "filters", s.Filters)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "streamingLocatorId", s.StreamingLocatorID)
	populate(objectMap, "streamingPolicyName", s.StreamingPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingLocatorProperties.
func (s *StreamingLocatorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternativeMediaId":
			err = unpopulate(val, &s.AlternativeMediaID)
			delete(rawMsg, key)
		case "assetName":
			err = unpopulate(val, &s.AssetName)
			delete(rawMsg, key)
		case "contentKeys":
			err = unpopulate(val, &s.ContentKeys)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "filters":
			err = unpopulate(val, &s.Filters)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "streamingLocatorId":
			err = unpopulate(val, &s.StreamingLocatorID)
			delete(rawMsg, key)
		case "streamingPolicyName":
			err = unpopulate(val, &s.StreamingPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPath.
func (s StreamingPath) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptionScheme", s.EncryptionScheme)
	populate(objectMap, "paths", s.Paths)
	populate(objectMap, "streamingProtocol", s.StreamingProtocol)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyCollection.
func (s StreamingPolicyCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", s.ODataNextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKey.
func (s StreamingPolicyContentKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "label", s.Label)
	populate(objectMap, "policyName", s.PolicyName)
	populate(objectMap, "tracks", s.Tracks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyContentKeys.
func (s StreamingPolicyContentKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultKey", s.DefaultKey)
	populate(objectMap, "keyToTrackMappings", s.KeyToTrackMappings)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingPolicyProperties.
func (s StreamingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commonEncryptionCbcs", s.CommonEncryptionCbcs)
	populate(objectMap, "commonEncryptionCenc", s.CommonEncryptionCenc)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "defaultContentKeyPolicyName", s.DefaultContentKeyPolicyName)
	populate(objectMap, "envelopeEncryption", s.EnvelopeEncryption)
	populate(objectMap, "noEncryption", s.NoEncryption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingPolicyProperties.
func (s *StreamingPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonEncryptionCbcs":
			err = unpopulate(val, &s.CommonEncryptionCbcs)
			delete(rawMsg, key)
		case "commonEncryptionCenc":
			err = unpopulate(val, &s.CommonEncryptionCenc)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "defaultContentKeyPolicyName":
			err = unpopulate(val, &s.DefaultContentKeyPolicyName)
			delete(rawMsg, key)
		case "envelopeEncryption":
			err = unpopulate(val, &s.EnvelopeEncryption)
			delete(rawMsg, key)
		case "noEncryption":
			err = unpopulate(val, &s.NoEncryption)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackBase implements the TrackBaseClassification interface for type TextTrack.
func (t *TextTrack) GetTrackBase() *TrackBase {
	return &TrackBase{
		ODataType: t.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TextTrack.
func (t TextTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "fileName", t.FileName)
	populate(objectMap, "hlsSettings", t.HlsSettings)
	populate(objectMap, "languageCode", t.LanguageCode)
	objectMap["@odata.type"] = "#Microsoft.Media.TextTrack"
	populate(objectMap, "playerVisibility", t.PlayerVisibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextTrack.
func (t *TextTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, &t.DisplayName)
			delete(rawMsg, key)
		case "fileName":
			err = unpopulate(val, &t.FileName)
			delete(rawMsg, key)
		case "hlsSettings":
			err = unpopulate(val, &t.HlsSettings)
			delete(rawMsg, key)
		case "languageCode":
			err = unpopulate(val, &t.LanguageCode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &t.ODataType)
			delete(rawMsg, key)
		case "playerVisibility":
			err = unpopulate(val, &t.PlayerVisibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackBase implements the TrackBaseClassification interface for type TrackBase.
func (t *TrackBase) GetTrackBase() *TrackBase { return t }

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type TrackDescriptor.
func (t *TrackDescriptor) GetTrackDescriptor() *TrackDescriptor { return t }

// MarshalJSON implements the json.Marshaller interface for type TrackSelection.
func (t TrackSelection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "trackSelections", t.TrackSelections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Transform.
func (t Transform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TransformCollection.
func (t TransformCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@odata.nextLink", t.ODataNextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TransformOutput.
func (t TransformOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "onError", t.OnError)
	populate(objectMap, "preset", t.Preset)
	populate(objectMap, "relativePriority", t.RelativePriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformOutput.
func (t *TransformOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "onError":
			err = unpopulate(val, &t.OnError)
			delete(rawMsg, key)
		case "preset":
			t.Preset, err = unmarshalPresetClassification(val)
			delete(rawMsg, key)
		case "relativePriority":
			err = unpopulate(val, &t.RelativePriority)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TransformProperties.
func (t TransformProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", t.Created)
	populate(objectMap, "description", t.Description)
	populateTimeRFC3339(objectMap, "lastModified", t.LastModified)
	populate(objectMap, "outputs", t.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransformProperties.
func (t *TransformProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &t.Created)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &t.LastModified)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, &t.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFormat implements the FormatClassification interface for type TransportStreamFormat.
func (t *TransportStreamFormat) GetFormat() *Format {
	return &Format{
		ODataType:       t.ODataType,
		FilenamePattern: t.FilenamePattern,
	}
}

// GetMultiBitrateFormat implements the MultiBitrateFormatClassification interface for type TransportStreamFormat.
func (t *TransportStreamFormat) GetMultiBitrateFormat() *MultiBitrateFormat {
	return &MultiBitrateFormat{
		OutputFiles:     t.OutputFiles,
		ODataType:       t.ODataType,
		FilenamePattern: t.FilenamePattern,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TransportStreamFormat.
func (t TransportStreamFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filenamePattern", t.FilenamePattern)
	objectMap["@odata.type"] = "#Microsoft.Media.TransportStreamFormat"
	populate(objectMap, "outputFiles", t.OutputFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransportStreamFormat.
func (t *TransportStreamFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filenamePattern":
			err = unpopulate(val, &t.FilenamePattern)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &t.ODataType)
			delete(rawMsg, key)
		case "outputFiles":
			err = unpopulate(val, &t.OutputFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetClipTime implements the ClipTimeClassification interface for type UTCClipTime.
func (u *UTCClipTime) GetClipTime() *ClipTime {
	return &ClipTime{
		ODataType: u.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type UTCClipTime.
func (u UTCClipTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.UtcClipTime"
	populateTimeRFC3339(objectMap, "time", u.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UTCClipTime.
func (u *UTCClipTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &u.ODataType)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &u.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCodec implements the CodecClassification interface for type Video.
func (v *Video) GetCodec() *Codec {
	return &Codec{
		ODataType: v.ODataType,
		Label:     v.Label,
	}
}

// GetVideo implements the VideoClassification interface for type Video.
func (v *Video) GetVideo() *Video { return v }

// MarshalJSON implements the json.Marshaller interface for type Video.
func (v Video) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyFrameInterval", v.KeyFrameInterval)
	populate(objectMap, "label", v.Label)
	objectMap["@odata.type"] = "#Microsoft.Media.Video"
	populate(objectMap, "stretchMode", v.StretchMode)
	populate(objectMap, "syncMode", v.SyncMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Video.
func (v *Video) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyFrameInterval":
			err = unpopulate(val, &v.KeyFrameInterval)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &v.Label)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		case "stretchMode":
			err = unpopulate(val, &v.StretchMode)
			delete(rawMsg, key)
		case "syncMode":
			err = unpopulate(val, &v.SyncMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAudioAnalyzerPreset implements the AudioAnalyzerPresetClassification interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) GetAudioAnalyzerPreset() *AudioAnalyzerPreset {
	return &AudioAnalyzerPreset{
		AudioLanguage:       v.AudioLanguage,
		Mode:                v.Mode,
		ExperimentalOptions: v.ExperimentalOptions,
		ODataType:           v.ODataType,
	}
}

// GetPreset implements the PresetClassification interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) GetPreset() *Preset {
	return &Preset{
		ODataType: v.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VideoAnalyzerPreset.
func (v VideoAnalyzerPreset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioLanguage", v.AudioLanguage)
	populate(objectMap, "experimentalOptions", v.ExperimentalOptions)
	populate(objectMap, "insightsToExtract", v.InsightsToExtract)
	populate(objectMap, "mode", v.Mode)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoAnalyzerPreset"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoAnalyzerPreset.
func (v *VideoAnalyzerPreset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioLanguage":
			err = unpopulate(val, &v.AudioLanguage)
			delete(rawMsg, key)
		case "experimentalOptions":
			err = unpopulate(val, &v.ExperimentalOptions)
			delete(rawMsg, key)
		case "insightsToExtract":
			err = unpopulate(val, &v.InsightsToExtract)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, &v.Mode)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOverlay implements the OverlayClassification interface for type VideoOverlay.
func (v *VideoOverlay) GetOverlay() *Overlay {
	return &Overlay{
		ODataType:       v.ODataType,
		InputLabel:      v.InputLabel,
		Start:           v.Start,
		End:             v.End,
		FadeInDuration:  v.FadeInDuration,
		FadeOutDuration: v.FadeOutDuration,
		AudioGainLevel:  v.AudioGainLevel,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VideoOverlay.
func (v VideoOverlay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "audioGainLevel", v.AudioGainLevel)
	populate(objectMap, "cropRectangle", v.CropRectangle)
	populate(objectMap, "end", v.End)
	populate(objectMap, "fadeInDuration", v.FadeInDuration)
	populate(objectMap, "fadeOutDuration", v.FadeOutDuration)
	populate(objectMap, "inputLabel", v.InputLabel)
	objectMap["@odata.type"] = "#Microsoft.Media.VideoOverlay"
	populate(objectMap, "opacity", v.Opacity)
	populate(objectMap, "position", v.Position)
	populate(objectMap, "start", v.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoOverlay.
func (v *VideoOverlay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audioGainLevel":
			err = unpopulate(val, &v.AudioGainLevel)
			delete(rawMsg, key)
		case "cropRectangle":
			err = unpopulate(val, &v.CropRectangle)
			delete(rawMsg, key)
		case "end":
			err = unpopulate(val, &v.End)
			delete(rawMsg, key)
		case "fadeInDuration":
			err = unpopulate(val, &v.FadeInDuration)
			delete(rawMsg, key)
		case "fadeOutDuration":
			err = unpopulate(val, &v.FadeOutDuration)
			delete(rawMsg, key)
		case "inputLabel":
			err = unpopulate(val, &v.InputLabel)
			delete(rawMsg, key)
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		case "opacity":
			err = unpopulate(val, &v.Opacity)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, &v.Position)
			delete(rawMsg, key)
		case "start":
			err = unpopulate(val, &v.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackBase implements the TrackBaseClassification interface for type VideoTrack.
func (v *VideoTrack) GetTrackBase() *TrackBase {
	return &TrackBase{
		ODataType: v.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VideoTrack.
func (v VideoTrack) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.VideoTrack"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoTrack.
func (v *VideoTrack) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetTrackDescriptor implements the TrackDescriptorClassification interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) GetTrackDescriptor() *TrackDescriptor {
	return &TrackDescriptor{
		ODataType: v.ODataType,
	}
}

// GetVideoTrackDescriptor implements the VideoTrackDescriptorClassification interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) GetVideoTrackDescriptor() *VideoTrackDescriptor { return v }

// MarshalJSON implements the json.Marshaller interface for type VideoTrackDescriptor.
func (v VideoTrackDescriptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["@odata.type"] = "#Microsoft.Media.VideoTrackDescriptor"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VideoTrackDescriptor.
func (v *VideoTrackDescriptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
			err = unpopulate(val, &v.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
