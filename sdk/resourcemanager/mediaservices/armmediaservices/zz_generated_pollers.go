//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmediaservices

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// LiveEventsClientAllocatePoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientAllocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientAllocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientAllocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientAllocateResponse will be returned.
func (p *LiveEventsClientAllocatePoller) FinalResponse(ctx context.Context) (LiveEventsClientAllocateResponse, error) {
	respType := LiveEventsClientAllocateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveEventsClientAllocateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientAllocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientCreateResponse will be returned.
func (p *LiveEventsClientCreatePoller) FinalResponse(ctx context.Context) (LiveEventsClientCreateResponse, error) {
	respType := LiveEventsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LiveEvent)
	if err != nil {
		return LiveEventsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientDeleteResponse will be returned.
func (p *LiveEventsClientDeletePoller) FinalResponse(ctx context.Context) (LiveEventsClientDeleteResponse, error) {
	respType := LiveEventsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveEventsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientResetPoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientResetResponse will be returned.
func (p *LiveEventsClientResetPoller) FinalResponse(ctx context.Context) (LiveEventsClientResetResponse, error) {
	respType := LiveEventsClientResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveEventsClientResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientStartResponse will be returned.
func (p *LiveEventsClientStartPoller) FinalResponse(ctx context.Context) (LiveEventsClientStartResponse, error) {
	respType := LiveEventsClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveEventsClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientStopPoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientStopResponse will be returned.
func (p *LiveEventsClientStopPoller) FinalResponse(ctx context.Context) (LiveEventsClientStopResponse, error) {
	respType := LiveEventsClientStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveEventsClientStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveEventsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LiveEventsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveEventsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveEventsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveEventsClientUpdateResponse will be returned.
func (p *LiveEventsClientUpdatePoller) FinalResponse(ctx context.Context) (LiveEventsClientUpdateResponse, error) {
	respType := LiveEventsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LiveEvent)
	if err != nil {
		return LiveEventsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveEventsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveOutputsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type LiveOutputsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveOutputsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveOutputsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveOutputsClientCreateResponse will be returned.
func (p *LiveOutputsClientCreatePoller) FinalResponse(ctx context.Context) (LiveOutputsClientCreateResponse, error) {
	respType := LiveOutputsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LiveOutput)
	if err != nil {
		return LiveOutputsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveOutputsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LiveOutputsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LiveOutputsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LiveOutputsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LiveOutputsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LiveOutputsClientDeleteResponse will be returned.
func (p *LiveOutputsClientDeletePoller) FinalResponse(ctx context.Context) (LiveOutputsClientDeleteResponse, error) {
	respType := LiveOutputsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LiveOutputsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LiveOutputsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientCreateResponse will be returned.
func (p *StreamingEndpointsClientCreatePoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientCreateResponse, error) {
	respType := StreamingEndpointsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.StreamingEndpoint)
	if err != nil {
		return StreamingEndpointsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientDeleteResponse will be returned.
func (p *StreamingEndpointsClientDeletePoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientDeleteResponse, error) {
	respType := StreamingEndpointsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return StreamingEndpointsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientScalePoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientScalePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientScalePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientScalePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientScaleResponse will be returned.
func (p *StreamingEndpointsClientScalePoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientScaleResponse, error) {
	respType := StreamingEndpointsClientScaleResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return StreamingEndpointsClientScaleResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientScalePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientStartResponse will be returned.
func (p *StreamingEndpointsClientStartPoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientStartResponse, error) {
	respType := StreamingEndpointsClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return StreamingEndpointsClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientStopPoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientStopResponse will be returned.
func (p *StreamingEndpointsClientStopPoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientStopResponse, error) {
	respType := StreamingEndpointsClientStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return StreamingEndpointsClientStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StreamingEndpointsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type StreamingEndpointsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StreamingEndpointsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StreamingEndpointsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StreamingEndpointsClientUpdateResponse will be returned.
func (p *StreamingEndpointsClientUpdatePoller) FinalResponse(ctx context.Context) (StreamingEndpointsClientUpdateResponse, error) {
	respType := StreamingEndpointsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.StreamingEndpoint)
	if err != nil {
		return StreamingEndpointsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StreamingEndpointsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
