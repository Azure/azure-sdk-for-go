// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmigrationassessment

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AKSAssessment.
func (a AKSAssessment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessment.
func (a *AKSAssessment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentDetails.
func (a AKSAssessmentDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "machineCount", a.MachineCount)
	populateDateTimeRFC3339(objectMap, "pricesTimestamp", a.PricesTimestamp)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "totalMonthlyCost", a.TotalMonthlyCost)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	populate(objectMap, "webAppCount", a.WebAppCount)
	populate(objectMap, "webServerCount", a.WebServerCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentDetails.
func (a *AKSAssessmentDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "machineCount":
			err = unpopulate(val, "MachineCount", &a.MachineCount)
			delete(rawMsg, key)
		case "pricesTimestamp":
			err = unpopulateDateTimeRFC3339(val, "PricesTimestamp", &a.PricesTimestamp)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "totalMonthlyCost":
			err = unpopulate(val, "TotalMonthlyCost", &a.TotalMonthlyCost)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		case "webAppCount":
			err = unpopulate(val, "WebAppCount", &a.WebAppCount)
			delete(rawMsg, key)
		case "webServerCount":
			err = unpopulate(val, "WebServerCount", &a.WebServerCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentListResult.
func (a AKSAssessmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentListResult.
func (a *AKSAssessmentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentOptions.
func (a AKSAssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentOptions.
func (a *AKSAssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentOptionsListResult.
func (a AKSAssessmentOptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentOptionsListResult.
func (a *AKSAssessmentOptionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentOptionsProperties.
func (a AKSAssessmentOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "edges", a.Edges)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentOptionsProperties.
func (a *AKSAssessmentOptionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "edges":
			err = unpopulate(val, "Edges", &a.Edges)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentProperties.
func (a AKSAssessmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", a.Details)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "settings", a.Settings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentProperties.
func (a *AKSAssessmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
			err = unpopulate(val, "Details", &a.Details)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, "Scope", &a.Scope)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &a.Settings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentSettings.
func (a AKSAssessmentSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureLocation", a.AzureLocation)
	populate(objectMap, "category", a.Category)
	populate(objectMap, "consolidation", a.Consolidation)
	populate(objectMap, "currency", a.Currency)
	populate(objectMap, "discountPercentage", a.DiscountPercentage)
	populate(objectMap, "environmentType", a.EnvironmentType)
	populate(objectMap, "licensingProgram", a.LicensingProgram)
	populate(objectMap, "performanceData", a.PerformanceData)
	populate(objectMap, "pricingTier", a.PricingTier)
	populate(objectMap, "savingsOptions", a.SavingsOptions)
	populate(objectMap, "scalingFactor", a.ScalingFactor)
	populate(objectMap, "sizingCriteria", a.SizingCriteria)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentSettings.
func (a *AKSAssessmentSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureLocation":
			err = unpopulate(val, "AzureLocation", &a.AzureLocation)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &a.Category)
			delete(rawMsg, key)
		case "consolidation":
			err = unpopulate(val, "Consolidation", &a.Consolidation)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &a.Currency)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &a.DiscountPercentage)
			delete(rawMsg, key)
		case "environmentType":
			err = unpopulate(val, "EnvironmentType", &a.EnvironmentType)
			delete(rawMsg, key)
		case "licensingProgram":
			err = unpopulate(val, "LicensingProgram", &a.LicensingProgram)
			delete(rawMsg, key)
		case "performanceData":
			err = unpopulate(val, "PerformanceData", &a.PerformanceData)
			delete(rawMsg, key)
		case "pricingTier":
			err = unpopulate(val, "PricingTier", &a.PricingTier)
			delete(rawMsg, key)
		case "savingsOptions":
			err = unpopulate(val, "SavingsOptions", &a.SavingsOptions)
			delete(rawMsg, key)
		case "scalingFactor":
			err = unpopulate(val, "ScalingFactor", &a.ScalingFactor)
			delete(rawMsg, key)
		case "sizingCriteria":
			err = unpopulate(val, "SizingCriteria", &a.SizingCriteria)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSAssessmentSummary.
func (a AKSAssessmentSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "machineCount", a.MachineCount)
	populate(objectMap, "skuSummary", a.SKUSummary)
	populate(objectMap, "totalMonthlyCost", a.TotalMonthlyCost)
	populate(objectMap, "webAppCount", a.WebAppCount)
	populate(objectMap, "webAppSummary", a.WebAppSummary)
	populate(objectMap, "webServerCount", a.WebServerCount)
	populate(objectMap, "webServerSummary", a.WebServerSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSAssessmentSummary.
func (a *AKSAssessmentSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "machineCount":
			err = unpopulate(val, "MachineCount", &a.MachineCount)
			delete(rawMsg, key)
		case "skuSummary":
			err = unpopulate(val, "SKUSummary", &a.SKUSummary)
			delete(rawMsg, key)
		case "totalMonthlyCost":
			err = unpopulate(val, "TotalMonthlyCost", &a.TotalMonthlyCost)
			delete(rawMsg, key)
		case "webAppCount":
			err = unpopulate(val, "WebAppCount", &a.WebAppCount)
			delete(rawMsg, key)
		case "webAppSummary":
			err = unpopulate(val, "WebAppSummary", &a.WebAppSummary)
			delete(rawMsg, key)
		case "webServerCount":
			err = unpopulate(val, "WebServerCount", &a.WebServerCount)
			delete(rawMsg, key)
		case "webServerSummary":
			err = unpopulate(val, "WebServerSummary", &a.WebServerSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSCluster.
func (a AKSCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSCluster.
func (a *AKSCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSClusterListResult.
func (a AKSClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSClusterListResult.
func (a *AKSClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSClusterProperties.
func (a AKSClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "monthlyCost", a.MonthlyCost)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "nodePools", a.NodePools)
	populate(objectMap, "podCount", a.PodCount)
	populate(objectMap, "region", a.Region)
	populate(objectMap, "systemNodeCount", a.SystemNodeCount)
	populate(objectMap, "systemNodePoolCount", a.SystemNodePoolCount)
	populate(objectMap, "userNodeCount", a.UserNodeCount)
	populate(objectMap, "userNodePoolCount", a.UserNodePoolCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSClusterProperties.
func (a *AKSClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "monthlyCost":
			err = unpopulate(val, "MonthlyCost", &a.MonthlyCost)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "nodePools":
			err = unpopulate(val, "NodePools", &a.NodePools)
			delete(rawMsg, key)
		case "podCount":
			err = unpopulate(val, "PodCount", &a.PodCount)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, "Region", &a.Region)
			delete(rawMsg, key)
		case "systemNodeCount":
			err = unpopulate(val, "SystemNodeCount", &a.SystemNodeCount)
			delete(rawMsg, key)
		case "systemNodePoolCount":
			err = unpopulate(val, "SystemNodePoolCount", &a.SystemNodePoolCount)
			delete(rawMsg, key)
		case "userNodeCount":
			err = unpopulate(val, "UserNodeCount", &a.UserNodeCount)
			delete(rawMsg, key)
		case "userNodePoolCount":
			err = unpopulate(val, "UserNodePoolCount", &a.UserNodePoolCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSCostDetail.
func (a AKSCostDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSCostDetail.
func (a *AKSCostDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSCostDetailListResult.
func (a AKSCostDetailListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSCostDetailListResult.
func (a *AKSCostDetailListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSCostDetailProperties.
func (a AKSCostDetailProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "armSkuName", a.ArmSKUName)
	populate(objectMap, "clusterName", a.ClusterName)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "mode", a.Mode)
	populate(objectMap, "monthlyCost", a.MonthlyCost)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "nodeCount", a.NodeCount)
	populate(objectMap, "osType", a.OSType)
	populate(objectMap, "podApproxMonthlyCost", a.PodApproxMonthlyCost)
	populate(objectMap, "podCount", a.PodCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSCostDetailProperties.
func (a *AKSCostDetailProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "armSkuName":
			err = unpopulate(val, "ArmSKUName", &a.ArmSKUName)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &a.ClusterName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &a.Mode)
			delete(rawMsg, key)
		case "monthlyCost":
			err = unpopulate(val, "MonthlyCost", &a.MonthlyCost)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &a.NodeCount)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &a.OSType)
			delete(rawMsg, key)
		case "podApproxMonthlyCost":
			err = unpopulate(val, "PodApproxMonthlyCost", &a.PodApproxMonthlyCost)
			delete(rawMsg, key)
		case "podCount":
			err = unpopulate(val, "PodCount", &a.PodCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSSummary.
func (a AKSSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSSummary.
func (a *AKSSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSSummaryListResult.
func (a AKSSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSSummaryListResult.
func (a *AKSSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AKSSummaryProperties.
func (a AKSSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aksAssessmentSummary", a.AksAssessmentSummary)
	populate(objectMap, "assessmentName", a.AssessmentName)
	populate(objectMap, "confidenceScore", a.ConfidenceScore)
	populate(objectMap, "monthlyComputeCost", a.MonthlyComputeCost)
	populate(objectMap, "monthlyStorageCost", a.MonthlyStorageCost)
	populate(objectMap, "suitabilityPerTarget", a.SuitabilityPerTarget)
	populate(objectMap, "summaryName", a.SummaryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AKSSummaryProperties.
func (a *AKSSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aksAssessmentSummary":
			err = unpopulate(val, "AksAssessmentSummary", &a.AksAssessmentSummary)
			delete(rawMsg, key)
		case "assessmentName":
			err = unpopulate(val, "AssessmentName", &a.AssessmentName)
			delete(rawMsg, key)
		case "confidenceScore":
			err = unpopulate(val, "ConfidenceScore", &a.ConfidenceScore)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &a.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &a.MonthlyStorageCost)
			delete(rawMsg, key)
		case "suitabilityPerTarget":
			err = unpopulate(val, "SuitabilityPerTarget", &a.SuitabilityPerTarget)
			delete(rawMsg, key)
		case "summaryName":
			err = unpopulate(val, "SummaryName", &a.SummaryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppServiceSKU.
func (a AppServiceSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", a.Cost)
	populate(objectMap, "count", a.Count)
	populate(objectMap, "skuName", a.SKUName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppServiceSKU.
func (a *AppServiceSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &a.Cost)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, "Count", &a.Count)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, "SKUName", &a.SKUName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppSvcContainerSettings.
func (a AppSvcContainerSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isolationRequired", a.IsolationRequired)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppSvcContainerSettings.
func (a *AppSvcContainerSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isolationRequired":
			err = unpopulate(val, "IsolationRequired", &a.IsolationRequired)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AppSvcNativeSettings.
func (a AppSvcNativeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isolationRequired", a.IsolationRequired)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppSvcNativeSettings.
func (a *AppSvcNativeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isolationRequired":
			err = unpopulate(val, "IsolationRequired", &a.IsolationRequired)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedDisk.
func (a AssessedDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "gigabytesForRecommendedDiskSize", a.GigabytesForRecommendedDiskSize)
	populate(objectMap, "gigabytesProvisioned", a.GigabytesProvisioned)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "monthlyStorageCost", a.MonthlyStorageCost)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	populate(objectMap, "recommendDiskThroughputInMbps", a.RecommendDiskThroughputInMbps)
	populate(objectMap, "recommendedDiskIops", a.RecommendedDiskIops)
	populate(objectMap, "recommendedDiskSize", a.RecommendedDiskSize)
	populate(objectMap, "recommendedDiskType", a.RecommendedDiskType)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedDisk.
func (a *AssessedDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "gigabytesForRecommendedDiskSize":
			err = unpopulate(val, "GigabytesForRecommendedDiskSize", &a.GigabytesForRecommendedDiskSize)
			delete(rawMsg, key)
		case "gigabytesProvisioned":
			err = unpopulate(val, "GigabytesProvisioned", &a.GigabytesProvisioned)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &a.MonthlyStorageCost)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		case "recommendDiskThroughputInMbps":
			err = unpopulate(val, "RecommendDiskThroughputInMbps", &a.RecommendDiskThroughputInMbps)
			delete(rawMsg, key)
		case "recommendedDiskIops":
			err = unpopulate(val, "RecommendedDiskIops", &a.RecommendedDiskIops)
			delete(rawMsg, key)
		case "recommendedDiskSize":
			err = unpopulate(val, "RecommendedDiskSize", &a.RecommendedDiskSize)
			delete(rawMsg, key)
		case "recommendedDiskType":
			err = unpopulate(val, "RecommendedDiskType", &a.RecommendedDiskType)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedDiskData.
func (a AssessedDiskData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "gigabytesProvisioned", a.GigabytesProvisioned)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "monthlyStorageCost", a.MonthlyStorageCost)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	populate(objectMap, "recommendDiskThroughputInMbps", a.RecommendDiskThroughputInMbps)
	populate(objectMap, "recommendedDiskIops", a.RecommendedDiskIops)
	populate(objectMap, "recommendedDiskSize", a.RecommendedDiskSize)
	populate(objectMap, "recommendedDiskSizeGigabytes", a.RecommendedDiskSizeGigabytes)
	populate(objectMap, "recommendedDiskType", a.RecommendedDiskType)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedDiskData.
func (a *AssessedDiskData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "gigabytesProvisioned":
			err = unpopulate(val, "GigabytesProvisioned", &a.GigabytesProvisioned)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &a.MonthlyStorageCost)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		case "recommendDiskThroughputInMbps":
			err = unpopulate(val, "RecommendDiskThroughputInMbps", &a.RecommendDiskThroughputInMbps)
			delete(rawMsg, key)
		case "recommendedDiskIops":
			err = unpopulate(val, "RecommendedDiskIops", &a.RecommendedDiskIops)
			delete(rawMsg, key)
		case "recommendedDiskSize":
			err = unpopulate(val, "RecommendedDiskSize", &a.RecommendedDiskSize)
			delete(rawMsg, key)
		case "recommendedDiskSizeGigabytes":
			err = unpopulate(val, "RecommendedDiskSizeGigabytes", &a.RecommendedDiskSizeGigabytes)
			delete(rawMsg, key)
		case "recommendedDiskType":
			err = unpopulate(val, "RecommendedDiskType", &a.RecommendedDiskType)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedMachine.
func (a AssessedMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedMachine.
func (a *AssessedMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedMachineListResult.
func (a AssessedMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedMachineListResult.
func (a *AssessedMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedMachineProperties.
func (a AssessedMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bootType", a.BootType)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populate(objectMap, "costComponents", a.CostComponents)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "datacenterMachineArmId", a.DatacenterMachineArmID)
	populate(objectMap, "datacenterManagementServerArmId", a.DatacenterManagementServerArmID)
	populate(objectMap, "datacenterManagementServerName", a.DatacenterManagementServerName)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "disks", a.Disks)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "hostProcessor", a.HostProcessor)
	populate(objectMap, "megabytesOfMemory", a.MegabytesOfMemory)
	populate(objectMap, "megabytesOfMemoryForRecommendedSize", a.MegabytesOfMemoryForRecommendedSize)
	populate(objectMap, "monthlyBandwidthCost", a.MonthlyBandwidthCost)
	populate(objectMap, "monthlyComputeCostForRecommendedSize", a.MonthlyComputeCostForRecommendedSize)
	populate(objectMap, "monthlyPremiumStorageCost", a.MonthlyPremiumStorageCost)
	populate(objectMap, "monthlyStandardSsdStorageCost", a.MonthlyStandardSsdStorageCost)
	populate(objectMap, "monthlyStorageCost", a.MonthlyStorageCost)
	populate(objectMap, "monthlyUltraStorageCost", a.MonthlyUltraStorageCost)
	populate(objectMap, "networkAdapters", a.NetworkAdapters)
	populate(objectMap, "numberOfCores", a.NumberOfCores)
	populate(objectMap, "numberOfCoresForRecommendedSize", a.NumberOfCoresForRecommendedSize)
	populate(objectMap, "operatingSystemArchitecture", a.OperatingSystemArchitecture)
	populate(objectMap, "operatingSystemName", a.OperatingSystemName)
	populate(objectMap, "operatingSystemType", a.OperatingSystemType)
	populate(objectMap, "operatingSystemVersion", a.OperatingSystemVersion)
	populate(objectMap, "percentageCoresUtilization", a.PercentageCoresUtilization)
	populate(objectMap, "percentageMemoryUtilization", a.PercentageMemoryUtilization)
	populate(objectMap, "productSupportStatus", a.ProductSupportStatus)
	populate(objectMap, "recommendedSize", a.RecommendedSize)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	populate(objectMap, "type", a.Type)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedMachineProperties.
func (a *AssessedMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bootType":
			err = unpopulate(val, "BootType", &a.BootType)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &a.CostComponents)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "datacenterMachineArmId":
			err = unpopulate(val, "DatacenterMachineArmID", &a.DatacenterMachineArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerArmId":
			err = unpopulate(val, "DatacenterManagementServerArmID", &a.DatacenterManagementServerArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerName":
			err = unpopulate(val, "DatacenterManagementServerName", &a.DatacenterManagementServerName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &a.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &a.Errors)
			delete(rawMsg, key)
		case "hostProcessor":
			err = unpopulate(val, "HostProcessor", &a.HostProcessor)
			delete(rawMsg, key)
		case "megabytesOfMemory":
			err = unpopulate(val, "MegabytesOfMemory", &a.MegabytesOfMemory)
			delete(rawMsg, key)
		case "megabytesOfMemoryForRecommendedSize":
			err = unpopulate(val, "MegabytesOfMemoryForRecommendedSize", &a.MegabytesOfMemoryForRecommendedSize)
			delete(rawMsg, key)
		case "monthlyBandwidthCost":
			err = unpopulate(val, "MonthlyBandwidthCost", &a.MonthlyBandwidthCost)
			delete(rawMsg, key)
		case "monthlyComputeCostForRecommendedSize":
			err = unpopulate(val, "MonthlyComputeCostForRecommendedSize", &a.MonthlyComputeCostForRecommendedSize)
			delete(rawMsg, key)
		case "monthlyPremiumStorageCost":
			err = unpopulate(val, "MonthlyPremiumStorageCost", &a.MonthlyPremiumStorageCost)
			delete(rawMsg, key)
		case "monthlyStandardSsdStorageCost":
			err = unpopulate(val, "MonthlyStandardSsdStorageCost", &a.MonthlyStandardSsdStorageCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &a.MonthlyStorageCost)
			delete(rawMsg, key)
		case "monthlyUltraStorageCost":
			err = unpopulate(val, "MonthlyUltraStorageCost", &a.MonthlyUltraStorageCost)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &a.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfCores":
			err = unpopulate(val, "NumberOfCores", &a.NumberOfCores)
			delete(rawMsg, key)
		case "numberOfCoresForRecommendedSize":
			err = unpopulate(val, "NumberOfCoresForRecommendedSize", &a.NumberOfCoresForRecommendedSize)
			delete(rawMsg, key)
		case "operatingSystemArchitecture":
			err = unpopulate(val, "OperatingSystemArchitecture", &a.OperatingSystemArchitecture)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &a.OperatingSystemName)
			delete(rawMsg, key)
		case "operatingSystemType":
			err = unpopulate(val, "OperatingSystemType", &a.OperatingSystemType)
			delete(rawMsg, key)
		case "operatingSystemVersion":
			err = unpopulate(val, "OperatingSystemVersion", &a.OperatingSystemVersion)
			delete(rawMsg, key)
		case "percentageCoresUtilization":
			err = unpopulate(val, "PercentageCoresUtilization", &a.PercentageCoresUtilization)
			delete(rawMsg, key)
		case "percentageMemoryUtilization":
			err = unpopulate(val, "PercentageMemoryUtilization", &a.PercentageMemoryUtilization)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &a.ProductSupportStatus)
			delete(rawMsg, key)
		case "recommendedSize":
			err = unpopulate(val, "RecommendedSize", &a.RecommendedSize)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedNetworkAdapter.
func (a AssessedNetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "ipAddresses", a.IPAddresses)
	populate(objectMap, "macAddress", a.MacAddress)
	populate(objectMap, "megabytesPerSecondReceived", a.MegabytesPerSecondReceived)
	populate(objectMap, "megabytesPerSecondTransmitted", a.MegabytesPerSecondTransmitted)
	populate(objectMap, "monthlyBandwidthCosts", a.MonthlyBandwidthCosts)
	populate(objectMap, "netGigabytesTransmittedPerMonth", a.NetGigabytesTransmittedPerMonth)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedNetworkAdapter.
func (a *AssessedNetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &a.IPAddresses)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &a.MacAddress)
			delete(rawMsg, key)
		case "megabytesPerSecondReceived":
			err = unpopulate(val, "MegabytesPerSecondReceived", &a.MegabytesPerSecondReceived)
			delete(rawMsg, key)
		case "megabytesPerSecondTransmitted":
			err = unpopulate(val, "MegabytesPerSecondTransmitted", &a.MegabytesPerSecondTransmitted)
			delete(rawMsg, key)
		case "monthlyBandwidthCosts":
			err = unpopulate(val, "MonthlyBandwidthCosts", &a.MonthlyBandwidthCosts)
			delete(rawMsg, key)
		case "netGigabytesTransmittedPerMonth":
			err = unpopulate(val, "NetGigabytesTransmittedPerMonth", &a.NetGigabytesTransmittedPerMonth)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLDatabaseV2.
func (a AssessedSQLDatabaseV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLDatabaseV2.
func (a *AssessedSQLDatabaseV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLDatabaseV2ListResult.
func (a AssessedSQLDatabaseV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLDatabaseV2ListResult.
func (a *AssessedSQLDatabaseV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLDatabaseV2Properties.
func (a AssessedSQLDatabaseV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessedSqlInstanceArmId", a.AssessedSQLInstanceArmID)
	populate(objectMap, "azureSqlDBSuitabilityDetails", a.AzureSQLDBSuitabilityDetails)
	populate(objectMap, "azureSqlMISuitabilityDetails", a.AzureSQLMISuitabilityDetails)
	populate(objectMap, "bufferCacheSizeInMB", a.BufferCacheSizeInMB)
	populate(objectMap, "compatibilityLevel", a.CompatibilityLevel)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "databaseName", a.DatabaseName)
	populate(objectMap, "databaseSizeInMB", a.DatabaseSizeInMB)
	populate(objectMap, "instanceName", a.InstanceName)
	populate(objectMap, "isDatabaseHighlyAvailable", a.IsDatabaseHighlyAvailable)
	populate(objectMap, "linkedAvailabilityGroupOverview", a.LinkedAvailabilityGroupOverview)
	populate(objectMap, "machineArmId", a.MachineArmID)
	populate(objectMap, "machineName", a.MachineName)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	populate(objectMap, "percentageCoresUtilization", a.PercentageCoresUtilization)
	populate(objectMap, "productSupportStatus", a.ProductSupportStatus)
	populate(objectMap, "recommendedAzureSqlTargetType", a.RecommendedAzureSQLTargetType)
	populate(objectMap, "recommendedSuitability", a.RecommendedSuitability)
	populate(objectMap, "sqlDatabaseSdsArmId", a.SQLDatabaseSdsArmID)
	populate(objectMap, "sizingCriterion", a.SizingCriterion)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLDatabaseV2Properties.
func (a *AssessedSQLDatabaseV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedSqlInstanceArmId":
			err = unpopulate(val, "AssessedSQLInstanceArmID", &a.AssessedSQLInstanceArmID)
			delete(rawMsg, key)
		case "azureSqlDBSuitabilityDetails":
			err = unpopulate(val, "AzureSQLDBSuitabilityDetails", &a.AzureSQLDBSuitabilityDetails)
			delete(rawMsg, key)
		case "azureSqlMISuitabilityDetails":
			err = unpopulate(val, "AzureSQLMISuitabilityDetails", &a.AzureSQLMISuitabilityDetails)
			delete(rawMsg, key)
		case "bufferCacheSizeInMB":
			err = unpopulate(val, "BufferCacheSizeInMB", &a.BufferCacheSizeInMB)
			delete(rawMsg, key)
		case "compatibilityLevel":
			err = unpopulate(val, "CompatibilityLevel", &a.CompatibilityLevel)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &a.DatabaseName)
			delete(rawMsg, key)
		case "databaseSizeInMB":
			err = unpopulate(val, "DatabaseSizeInMB", &a.DatabaseSizeInMB)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, "InstanceName", &a.InstanceName)
			delete(rawMsg, key)
		case "isDatabaseHighlyAvailable":
			err = unpopulate(val, "IsDatabaseHighlyAvailable", &a.IsDatabaseHighlyAvailable)
			delete(rawMsg, key)
		case "linkedAvailabilityGroupOverview":
			err = unpopulate(val, "LinkedAvailabilityGroupOverview", &a.LinkedAvailabilityGroupOverview)
			delete(rawMsg, key)
		case "machineArmId":
			err = unpopulate(val, "MachineArmID", &a.MachineArmID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &a.MachineName)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		case "percentageCoresUtilization":
			err = unpopulate(val, "PercentageCoresUtilization", &a.PercentageCoresUtilization)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &a.ProductSupportStatus)
			delete(rawMsg, key)
		case "recommendedAzureSqlTargetType":
			err = unpopulate(val, "RecommendedAzureSQLTargetType", &a.RecommendedAzureSQLTargetType)
			delete(rawMsg, key)
		case "recommendedSuitability":
			err = unpopulate(val, "RecommendedSuitability", &a.RecommendedSuitability)
			delete(rawMsg, key)
		case "sqlDatabaseSdsArmId":
			err = unpopulate(val, "SQLDatabaseSdsArmID", &a.SQLDatabaseSdsArmID)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &a.SizingCriterion)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceDatabaseSummary.
func (a AssessedSQLInstanceDatabaseSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "largestDatabaseSizeInMB", a.LargestDatabaseSizeInMB)
	populate(objectMap, "numberOfUserDatabases", a.NumberOfUserDatabases)
	populate(objectMap, "totalDatabaseSizeInMB", a.TotalDatabaseSizeInMB)
	populate(objectMap, "totalDiscoveredUserDatabases", a.TotalDiscoveredUserDatabases)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceDatabaseSummary.
func (a *AssessedSQLInstanceDatabaseSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "largestDatabaseSizeInMB":
			err = unpopulate(val, "LargestDatabaseSizeInMB", &a.LargestDatabaseSizeInMB)
			delete(rawMsg, key)
		case "numberOfUserDatabases":
			err = unpopulate(val, "NumberOfUserDatabases", &a.NumberOfUserDatabases)
			delete(rawMsg, key)
		case "totalDatabaseSizeInMB":
			err = unpopulate(val, "TotalDatabaseSizeInMB", &a.TotalDatabaseSizeInMB)
			delete(rawMsg, key)
		case "totalDiscoveredUserDatabases":
			err = unpopulate(val, "TotalDiscoveredUserDatabases", &a.TotalDiscoveredUserDatabases)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceDiskDetails.
func (a AssessedSQLInstanceDiskDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskId", a.DiskID)
	populate(objectMap, "diskSizeInMB", a.DiskSizeInMB)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceDiskDetails.
func (a *AssessedSQLInstanceDiskDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskId":
			err = unpopulate(val, "DiskID", &a.DiskID)
			delete(rawMsg, key)
		case "diskSizeInMB":
			err = unpopulate(val, "DiskSizeInMB", &a.DiskSizeInMB)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceStorageDetails.
func (a AssessedSQLInstanceStorageDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskSizeInMB", a.DiskSizeInMB)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	populate(objectMap, "storageType", a.StorageType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceStorageDetails.
func (a *AssessedSQLInstanceStorageDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskSizeInMB":
			err = unpopulate(val, "DiskSizeInMB", &a.DiskSizeInMB)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, "StorageType", &a.StorageType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceSummary.
func (a AssessedSQLInstanceSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceId", a.InstanceID)
	populate(objectMap, "instanceName", a.InstanceName)
	populate(objectMap, "isClustered", a.IsClustered)
	populate(objectMap, "isHighAvailabilityEnabled", a.IsHighAvailabilityEnabled)
	populate(objectMap, "sqlEdition", a.SQLEdition)
	populate(objectMap, "sqlFciState", a.SQLFciState)
	populate(objectMap, "sqlInstanceEntityId", a.SQLInstanceEntityID)
	populate(objectMap, "sqlInstanceSdsArmId", a.SQLInstanceSdsArmID)
	populate(objectMap, "sqlVersion", a.SQLVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceSummary.
func (a *AssessedSQLInstanceSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceId":
			err = unpopulate(val, "InstanceID", &a.InstanceID)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, "InstanceName", &a.InstanceName)
			delete(rawMsg, key)
		case "isClustered":
			err = unpopulate(val, "IsClustered", &a.IsClustered)
			delete(rawMsg, key)
		case "isHighAvailabilityEnabled":
			err = unpopulate(val, "IsHighAvailabilityEnabled", &a.IsHighAvailabilityEnabled)
			delete(rawMsg, key)
		case "sqlEdition":
			err = unpopulate(val, "SQLEdition", &a.SQLEdition)
			delete(rawMsg, key)
		case "sqlFciState":
			err = unpopulate(val, "SQLFciState", &a.SQLFciState)
			delete(rawMsg, key)
		case "sqlInstanceEntityId":
			err = unpopulate(val, "SQLInstanceEntityID", &a.SQLInstanceEntityID)
			delete(rawMsg, key)
		case "sqlInstanceSdsArmId":
			err = unpopulate(val, "SQLInstanceSdsArmID", &a.SQLInstanceSdsArmID)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &a.SQLVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceV2.
func (a AssessedSQLInstanceV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceV2.
func (a *AssessedSQLInstanceV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceV2ListResult.
func (a AssessedSQLInstanceV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceV2ListResult.
func (a *AssessedSQLInstanceV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLInstanceV2Properties.
func (a AssessedSQLInstanceV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availabilityReplicaSummary", a.AvailabilityReplicaSummary)
	populate(objectMap, "azureSqlDBSuitabilityDetails", a.AzureSQLDBSuitabilityDetails)
	populate(objectMap, "azureSqlMISuitabilityDetails", a.AzureSQLMISuitabilityDetails)
	populate(objectMap, "azureSqlVMSuitabilityDetails", a.AzureSQLVMSuitabilityDetails)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "databaseSummary", a.DatabaseSummary)
	populate(objectMap, "fciMetadata", a.FciMetadata)
	populate(objectMap, "hasScanOccurred", a.HasScanOccurred)
	populate(objectMap, "instanceName", a.InstanceName)
	populate(objectMap, "isClustered", a.IsClustered)
	populate(objectMap, "isHighAvailabilityEnabled", a.IsHighAvailabilityEnabled)
	populate(objectMap, "logicalDisks", a.LogicalDisks)
	populate(objectMap, "machineArmId", a.MachineArmID)
	populate(objectMap, "machineName", a.MachineName)
	populate(objectMap, "memoryInUseInMB", a.MemoryInUseInMB)
	populate(objectMap, "numberOfCoresAllocated", a.NumberOfCoresAllocated)
	populate(objectMap, "percentageCoresUtilization", a.PercentageCoresUtilization)
	populate(objectMap, "productSupportStatus", a.ProductSupportStatus)
	populate(objectMap, "recommendedAzureSqlTargetType", a.RecommendedAzureSQLTargetType)
	populate(objectMap, "recommendedSuitability", a.RecommendedSuitability)
	populate(objectMap, "recommendedTargetReasonings", a.RecommendedTargetReasonings)
	populate(objectMap, "sqlEdition", a.SQLEdition)
	populate(objectMap, "sqlInstanceSdsArmId", a.SQLInstanceSdsArmID)
	populate(objectMap, "sqlVersion", a.SQLVersion)
	populate(objectMap, "sizingCriterion", a.SizingCriterion)
	populate(objectMap, "storageTypeBasedDetails", a.StorageTypeBasedDetails)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLInstanceV2Properties.
func (a *AssessedSQLInstanceV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availabilityReplicaSummary":
			err = unpopulate(val, "AvailabilityReplicaSummary", &a.AvailabilityReplicaSummary)
			delete(rawMsg, key)
		case "azureSqlDBSuitabilityDetails":
			err = unpopulate(val, "AzureSQLDBSuitabilityDetails", &a.AzureSQLDBSuitabilityDetails)
			delete(rawMsg, key)
		case "azureSqlMISuitabilityDetails":
			err = unpopulate(val, "AzureSQLMISuitabilityDetails", &a.AzureSQLMISuitabilityDetails)
			delete(rawMsg, key)
		case "azureSqlVMSuitabilityDetails":
			err = unpopulate(val, "AzureSQLVMSuitabilityDetails", &a.AzureSQLVMSuitabilityDetails)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "databaseSummary":
			err = unpopulate(val, "DatabaseSummary", &a.DatabaseSummary)
			delete(rawMsg, key)
		case "fciMetadata":
			err = unpopulate(val, "FciMetadata", &a.FciMetadata)
			delete(rawMsg, key)
		case "hasScanOccurred":
			err = unpopulate(val, "HasScanOccurred", &a.HasScanOccurred)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, "InstanceName", &a.InstanceName)
			delete(rawMsg, key)
		case "isClustered":
			err = unpopulate(val, "IsClustered", &a.IsClustered)
			delete(rawMsg, key)
		case "isHighAvailabilityEnabled":
			err = unpopulate(val, "IsHighAvailabilityEnabled", &a.IsHighAvailabilityEnabled)
			delete(rawMsg, key)
		case "logicalDisks":
			err = unpopulate(val, "LogicalDisks", &a.LogicalDisks)
			delete(rawMsg, key)
		case "machineArmId":
			err = unpopulate(val, "MachineArmID", &a.MachineArmID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &a.MachineName)
			delete(rawMsg, key)
		case "memoryInUseInMB":
			err = unpopulate(val, "MemoryInUseInMB", &a.MemoryInUseInMB)
			delete(rawMsg, key)
		case "numberOfCoresAllocated":
			err = unpopulate(val, "NumberOfCoresAllocated", &a.NumberOfCoresAllocated)
			delete(rawMsg, key)
		case "percentageCoresUtilization":
			err = unpopulate(val, "PercentageCoresUtilization", &a.PercentageCoresUtilization)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &a.ProductSupportStatus)
			delete(rawMsg, key)
		case "recommendedAzureSqlTargetType":
			err = unpopulate(val, "RecommendedAzureSQLTargetType", &a.RecommendedAzureSQLTargetType)
			delete(rawMsg, key)
		case "recommendedSuitability":
			err = unpopulate(val, "RecommendedSuitability", &a.RecommendedSuitability)
			delete(rawMsg, key)
		case "recommendedTargetReasonings":
			err = unpopulate(val, "RecommendedTargetReasonings", &a.RecommendedTargetReasonings)
			delete(rawMsg, key)
		case "sqlEdition":
			err = unpopulate(val, "SQLEdition", &a.SQLEdition)
			delete(rawMsg, key)
		case "sqlInstanceSdsArmId":
			err = unpopulate(val, "SQLInstanceSdsArmID", &a.SQLInstanceSdsArmID)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &a.SQLVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &a.SizingCriterion)
			delete(rawMsg, key)
		case "storageTypeBasedDetails":
			err = unpopulate(val, "StorageTypeBasedDetails", &a.StorageTypeBasedDetails)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLMachine.
func (a AssessedSQLMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLMachine.
func (a *AssessedSQLMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLMachineListResult.
func (a AssessedSQLMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLMachineListResult.
func (a *AssessedSQLMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLMachineProperties.
func (a AssessedSQLMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "biosGuid", a.BiosGUID)
	populate(objectMap, "bootType", a.BootType)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populate(objectMap, "costComponents", a.CostComponents)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "datacenterMachineArmId", a.DatacenterMachineArmID)
	populate(objectMap, "datacenterManagementServerArmId", a.DatacenterManagementServerArmID)
	populate(objectMap, "datacenterManagementServerName", a.DatacenterManagementServerName)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "disks", a.Disks)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "fqdn", a.Fqdn)
	populate(objectMap, "megabytesOfMemory", a.MegabytesOfMemory)
	populate(objectMap, "migrationGuidelines", a.MigrationGuidelines)
	populate(objectMap, "monthlyBandwidthCost", a.MonthlyBandwidthCost)
	populate(objectMap, "monthlyComputeCost", a.MonthlyComputeCost)
	populate(objectMap, "monthlyStorageCost", a.MonthlyStorageCost)
	populate(objectMap, "networkAdapters", a.NetworkAdapters)
	populate(objectMap, "numberOfCores", a.NumberOfCores)
	populate(objectMap, "operatingSystemArchitecture", a.OperatingSystemArchitecture)
	populate(objectMap, "operatingSystemName", a.OperatingSystemName)
	populate(objectMap, "operatingSystemType", a.OperatingSystemType)
	populate(objectMap, "operatingSystemVersion", a.OperatingSystemVersion)
	populate(objectMap, "percentageCoresUtilization", a.PercentageCoresUtilization)
	populate(objectMap, "percentageMemoryUtilization", a.PercentageMemoryUtilization)
	populate(objectMap, "productSupportStatus", a.ProductSupportStatus)
	populate(objectMap, "recommendedVmFamily", a.RecommendedVMFamily)
	populate(objectMap, "recommendedVmSize", a.RecommendedVMSize)
	populate(objectMap, "recommendedVmSizeMegabytesOfMemory", a.RecommendedVMSizeMegabytesOfMemory)
	populate(objectMap, "recommendedVmSizeNumberOfCores", a.RecommendedVMSizeNumberOfCores)
	populate(objectMap, "sqlInstances", a.SQLInstances)
	populate(objectMap, "securitySuitability", a.SecuritySuitability)
	populate(objectMap, "sizingCriterion", a.SizingCriterion)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	populate(objectMap, "type", a.Type)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLMachineProperties.
func (a *AssessedSQLMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "biosGuid":
			err = unpopulate(val, "BiosGUID", &a.BiosGUID)
			delete(rawMsg, key)
		case "bootType":
			err = unpopulate(val, "BootType", &a.BootType)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &a.CostComponents)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "datacenterMachineArmId":
			err = unpopulate(val, "DatacenterMachineArmID", &a.DatacenterMachineArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerArmId":
			err = unpopulate(val, "DatacenterManagementServerArmID", &a.DatacenterManagementServerArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerName":
			err = unpopulate(val, "DatacenterManagementServerName", &a.DatacenterManagementServerName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &a.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &a.Fqdn)
			delete(rawMsg, key)
		case "megabytesOfMemory":
			err = unpopulate(val, "MegabytesOfMemory", &a.MegabytesOfMemory)
			delete(rawMsg, key)
		case "migrationGuidelines":
			err = unpopulate(val, "MigrationGuidelines", &a.MigrationGuidelines)
			delete(rawMsg, key)
		case "monthlyBandwidthCost":
			err = unpopulate(val, "MonthlyBandwidthCost", &a.MonthlyBandwidthCost)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &a.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &a.MonthlyStorageCost)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &a.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfCores":
			err = unpopulate(val, "NumberOfCores", &a.NumberOfCores)
			delete(rawMsg, key)
		case "operatingSystemArchitecture":
			err = unpopulate(val, "OperatingSystemArchitecture", &a.OperatingSystemArchitecture)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &a.OperatingSystemName)
			delete(rawMsg, key)
		case "operatingSystemType":
			err = unpopulate(val, "OperatingSystemType", &a.OperatingSystemType)
			delete(rawMsg, key)
		case "operatingSystemVersion":
			err = unpopulate(val, "OperatingSystemVersion", &a.OperatingSystemVersion)
			delete(rawMsg, key)
		case "percentageCoresUtilization":
			err = unpopulate(val, "PercentageCoresUtilization", &a.PercentageCoresUtilization)
			delete(rawMsg, key)
		case "percentageMemoryUtilization":
			err = unpopulate(val, "PercentageMemoryUtilization", &a.PercentageMemoryUtilization)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &a.ProductSupportStatus)
			delete(rawMsg, key)
		case "recommendedVmFamily":
			err = unpopulate(val, "RecommendedVMFamily", &a.RecommendedVMFamily)
			delete(rawMsg, key)
		case "recommendedVmSize":
			err = unpopulate(val, "RecommendedVMSize", &a.RecommendedVMSize)
			delete(rawMsg, key)
		case "recommendedVmSizeMegabytesOfMemory":
			err = unpopulate(val, "RecommendedVMSizeMegabytesOfMemory", &a.RecommendedVMSizeMegabytesOfMemory)
			delete(rawMsg, key)
		case "recommendedVmSizeNumberOfCores":
			err = unpopulate(val, "RecommendedVMSizeNumberOfCores", &a.RecommendedVMSizeNumberOfCores)
			delete(rawMsg, key)
		case "sqlInstances":
			err = unpopulate(val, "SQLInstances", &a.SQLInstances)
			delete(rawMsg, key)
		case "securitySuitability":
			err = unpopulate(val, "SecuritySuitability", &a.SecuritySuitability)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &a.SizingCriterion)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLRecommendedEntity.
func (a AssessedSQLRecommendedEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLRecommendedEntity.
func (a *AssessedSQLRecommendedEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLRecommendedEntityListResult.
func (a AssessedSQLRecommendedEntityListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLRecommendedEntityListResult.
func (a *AssessedSQLRecommendedEntityListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedSQLRecommendedEntityProperties.
func (a AssessedSQLRecommendedEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessedSqlEntityArmId", a.AssessedSQLEntityArmID)
	populate(objectMap, "azureSqlDBSuitabilityDetails", a.AzureSQLDBSuitabilityDetails)
	populate(objectMap, "azureSqlMISuitabilityDetails", a.AzureSQLMISuitabilityDetails)
	populate(objectMap, "azureSqlVMSuitabilityDetails", a.AzureSQLVMSuitabilityDetails)
	populate(objectMap, "dbCount", a.DbCount)
	populate(objectMap, "discoveredDBCount", a.DiscoveredDBCount)
	populate(objectMap, "hasScanOccurred", a.HasScanOccurred)
	populate(objectMap, "instanceName", a.InstanceName)
	populate(objectMap, "isClustered", a.IsClustered)
	populate(objectMap, "isHighAvailabilityEnabled", a.IsHighAvailabilityEnabled)
	populate(objectMap, "machineName", a.MachineName)
	populate(objectMap, "productSupportStatus", a.ProductSupportStatus)
	populate(objectMap, "recommendedAzureSqlTargetType", a.RecommendedAzureSQLTargetType)
	populate(objectMap, "recommendedSuitability", a.RecommendedSuitability)
	populate(objectMap, "sqlEdition", a.SQLEdition)
	populate(objectMap, "sqlVersion", a.SQLVersion)
	populate(objectMap, "sizingCriterion", a.SizingCriterion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedSQLRecommendedEntityProperties.
func (a *AssessedSQLRecommendedEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedSqlEntityArmId":
			err = unpopulate(val, "AssessedSQLEntityArmID", &a.AssessedSQLEntityArmID)
			delete(rawMsg, key)
		case "azureSqlDBSuitabilityDetails":
			err = unpopulate(val, "AzureSQLDBSuitabilityDetails", &a.AzureSQLDBSuitabilityDetails)
			delete(rawMsg, key)
		case "azureSqlMISuitabilityDetails":
			err = unpopulate(val, "AzureSQLMISuitabilityDetails", &a.AzureSQLMISuitabilityDetails)
			delete(rawMsg, key)
		case "azureSqlVMSuitabilityDetails":
			err = unpopulate(val, "AzureSQLVMSuitabilityDetails", &a.AzureSQLVMSuitabilityDetails)
			delete(rawMsg, key)
		case "dbCount":
			err = unpopulate(val, "DbCount", &a.DbCount)
			delete(rawMsg, key)
		case "discoveredDBCount":
			err = unpopulate(val, "DiscoveredDBCount", &a.DiscoveredDBCount)
			delete(rawMsg, key)
		case "hasScanOccurred":
			err = unpopulate(val, "HasScanOccurred", &a.HasScanOccurred)
			delete(rawMsg, key)
		case "instanceName":
			err = unpopulate(val, "InstanceName", &a.InstanceName)
			delete(rawMsg, key)
		case "isClustered":
			err = unpopulate(val, "IsClustered", &a.IsClustered)
			delete(rawMsg, key)
		case "isHighAvailabilityEnabled":
			err = unpopulate(val, "IsHighAvailabilityEnabled", &a.IsHighAvailabilityEnabled)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &a.MachineName)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &a.ProductSupportStatus)
			delete(rawMsg, key)
		case "recommendedAzureSqlTargetType":
			err = unpopulate(val, "RecommendedAzureSQLTargetType", &a.RecommendedAzureSQLTargetType)
			delete(rawMsg, key)
		case "recommendedSuitability":
			err = unpopulate(val, "RecommendedSuitability", &a.RecommendedSuitability)
			delete(rawMsg, key)
		case "sqlEdition":
			err = unpopulate(val, "SQLEdition", &a.SQLEdition)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &a.SQLVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &a.SizingCriterion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebAppV2.
func (a AssessedWebAppV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebAppV2.
func (a *AssessedWebAppV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebAppV2ListResult.
func (a AssessedWebAppV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebAppV2ListResult.
func (a *AssessedWebAppV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebAppV2Properties.
func (a AssessedWebAppV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appServicePlanName", a.AppServicePlanName)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "discoveredMachineId", a.DiscoveredMachineID)
	populate(objectMap, "discoveredWebAppId", a.DiscoveredWebAppID)
	populate(objectMap, "machineName", a.MachineName)
	populate(objectMap, "serverArmId", a.ServerArmID)
	populate(objectMap, "targetSpecificResult", a.TargetSpecificResult)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	populate(objectMap, "webAppName", a.WebAppName)
	populate(objectMap, "webAppType", a.WebAppType)
	populate(objectMap, "webServerName", a.WebServerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebAppV2Properties.
func (a *AssessedWebAppV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appServicePlanName":
			err = unpopulate(val, "AppServicePlanName", &a.AppServicePlanName)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "discoveredMachineId":
			err = unpopulate(val, "DiscoveredMachineID", &a.DiscoveredMachineID)
			delete(rawMsg, key)
		case "discoveredWebAppId":
			err = unpopulate(val, "DiscoveredWebAppID", &a.DiscoveredWebAppID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &a.MachineName)
			delete(rawMsg, key)
		case "serverArmId":
			err = unpopulate(val, "ServerArmID", &a.ServerArmID)
			delete(rawMsg, key)
		case "targetSpecificResult":
			err = unpopulate(val, "TargetSpecificResult", &a.TargetSpecificResult)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		case "webAppName":
			err = unpopulate(val, "WebAppName", &a.WebAppName)
			delete(rawMsg, key)
		case "webAppType":
			err = unpopulate(val, "WebAppType", &a.WebAppType)
			delete(rawMsg, key)
		case "webServerName":
			err = unpopulate(val, "WebServerName", &a.WebServerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebApplication.
func (a AssessedWebApplication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", a.ETag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebApplication.
func (a *AssessedWebApplication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &a.ETag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebApplicationListResult.
func (a AssessedWebApplicationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebApplicationListResult.
func (a *AssessedWebApplicationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessedWebApplicationProperties.
func (a AssessedWebApplicationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "discoveryArmId", a.DiscoveryArmID)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "machineArmId", a.MachineArmID)
	populate(objectMap, "machineDisplayName", a.MachineDisplayName)
	populate(objectMap, "recommendationResult", a.RecommendationResult)
	populate(objectMap, "suitabilityResult", a.SuitabilityResult)
	populate(objectMap, "webAppType", a.WebAppType)
	populate(objectMap, "webServerArmId", a.WebServerArmID)
	populate(objectMap, "webServerDisplayName", a.WebServerDisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessedWebApplicationProperties.
func (a *AssessedWebApplicationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "discoveryArmId":
			err = unpopulate(val, "DiscoveryArmID", &a.DiscoveryArmID)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "machineArmId":
			err = unpopulate(val, "MachineArmID", &a.MachineArmID)
			delete(rawMsg, key)
		case "machineDisplayName":
			err = unpopulate(val, "MachineDisplayName", &a.MachineDisplayName)
			delete(rawMsg, key)
		case "recommendationResult":
			err = unpopulate(val, "RecommendationResult", &a.RecommendationResult)
			delete(rawMsg, key)
		case "suitabilityResult":
			err = unpopulate(val, "SuitabilityResult", &a.SuitabilityResult)
			delete(rawMsg, key)
		case "webAppType":
			err = unpopulate(val, "WebAppType", &a.WebAppType)
			delete(rawMsg, key)
		case "webServerArmId":
			err = unpopulate(val, "WebServerArmID", &a.WebServerArmID)
			delete(rawMsg, key)
		case "webServerDisplayName":
			err = unpopulate(val, "WebServerDisplayName", &a.WebServerDisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Assessment.
func (a Assessment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Assessment.
func (a *Assessment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentListResult.
func (a AssessmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentListResult.
func (a *AssessmentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentOptions.
func (a AssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentOptions.
func (a *AssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentOptionsListResult.
func (a AssessmentOptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentOptionsListResult.
func (a *AssessmentOptionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentOptionsProperties.
func (a AssessmentOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "premiumDiskVmFamilies", a.PremiumDiskVMFamilies)
	populate(objectMap, "premiumV2DiskSupportedLocations", a.PremiumV2DiskSupportedLocations)
	populate(objectMap, "reservedInstanceSupportedCurrencies", a.ReservedInstanceSupportedCurrencies)
	populate(objectMap, "reservedInstanceSupportedLocations", a.ReservedInstanceSupportedLocations)
	populate(objectMap, "reservedInstanceSupportedOffers", a.ReservedInstanceSupportedOffers)
	populate(objectMap, "reservedInstanceVmFamilies", a.ReservedInstanceVMFamilies)
	populate(objectMap, "savingsPlanSupportedLocations", a.SavingsPlanSupportedLocations)
	populate(objectMap, "savingsPlanVmFamilies", a.SavingsPlanVMFamilies)
	populate(objectMap, "ultraDiskVmFamilies", a.UltraDiskVMFamilies)
	populate(objectMap, "vmFamilies", a.VMFamilies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentOptionsProperties.
func (a *AssessmentOptionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "premiumDiskVmFamilies":
			err = unpopulate(val, "PremiumDiskVMFamilies", &a.PremiumDiskVMFamilies)
			delete(rawMsg, key)
		case "premiumV2DiskSupportedLocations":
			err = unpopulate(val, "PremiumV2DiskSupportedLocations", &a.PremiumV2DiskSupportedLocations)
			delete(rawMsg, key)
		case "reservedInstanceSupportedCurrencies":
			err = unpopulate(val, "ReservedInstanceSupportedCurrencies", &a.ReservedInstanceSupportedCurrencies)
			delete(rawMsg, key)
		case "reservedInstanceSupportedLocations":
			err = unpopulate(val, "ReservedInstanceSupportedLocations", &a.ReservedInstanceSupportedLocations)
			delete(rawMsg, key)
		case "reservedInstanceSupportedOffers":
			err = unpopulate(val, "ReservedInstanceSupportedOffers", &a.ReservedInstanceSupportedOffers)
			delete(rawMsg, key)
		case "reservedInstanceVmFamilies":
			err = unpopulate(val, "ReservedInstanceVMFamilies", &a.ReservedInstanceVMFamilies)
			delete(rawMsg, key)
		case "savingsPlanSupportedLocations":
			err = unpopulate(val, "SavingsPlanSupportedLocations", &a.SavingsPlanSupportedLocations)
			delete(rawMsg, key)
		case "savingsPlanVmFamilies":
			err = unpopulate(val, "SavingsPlanVMFamilies", &a.SavingsPlanVMFamilies)
			delete(rawMsg, key)
		case "ultraDiskVmFamilies":
			err = unpopulate(val, "UltraDiskVMFamilies", &a.UltraDiskVMFamilies)
			delete(rawMsg, key)
		case "vmFamilies":
			err = unpopulate(val, "VMFamilies", &a.VMFamilies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProject.
func (a AssessmentProject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProject.
func (a *AssessmentProject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectListResult.
func (a AssessmentProjectListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectListResult.
func (a *AssessmentProjectListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectSummary.
func (a AssessmentProjectSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectSummary.
func (a *AssessmentProjectSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectSummaryListResult.
func (a AssessmentProjectSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectSummaryListResult.
func (a *AssessmentProjectSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectSummaryProperties.
func (a AssessmentProjectSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorSummaryAffectedEntities", a.ErrorSummaryAffectedEntities)
	populateDateTimeRFC3339(objectMap, "lastAssessmentTimestamp", a.LastAssessmentTimestamp)
	populate(objectMap, "numberOfAssessments", a.NumberOfAssessments)
	populate(objectMap, "numberOfGroups", a.NumberOfGroups)
	populate(objectMap, "numberOfImportMachines", a.NumberOfImportMachines)
	populate(objectMap, "numberOfMachines", a.NumberOfMachines)
	populate(objectMap, "numberOfPrivateEndpointConnections", a.NumberOfPrivateEndpointConnections)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectSummaryProperties.
func (a *AssessmentProjectSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorSummaryAffectedEntities":
			err = unpopulate(val, "ErrorSummaryAffectedEntities", &a.ErrorSummaryAffectedEntities)
			delete(rawMsg, key)
		case "lastAssessmentTimestamp":
			err = unpopulateDateTimeRFC3339(val, "LastAssessmentTimestamp", &a.LastAssessmentTimestamp)
			delete(rawMsg, key)
		case "numberOfAssessments":
			err = unpopulate(val, "NumberOfAssessments", &a.NumberOfAssessments)
			delete(rawMsg, key)
		case "numberOfGroups":
			err = unpopulate(val, "NumberOfGroups", &a.NumberOfGroups)
			delete(rawMsg, key)
		case "numberOfImportMachines":
			err = unpopulate(val, "NumberOfImportMachines", &a.NumberOfImportMachines)
			delete(rawMsg, key)
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &a.NumberOfMachines)
			delete(rawMsg, key)
		case "numberOfPrivateEndpointConnections":
			err = unpopulate(val, "NumberOfPrivateEndpointConnections", &a.NumberOfPrivateEndpointConnections)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectUpdate.
func (a AssessmentProjectUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectUpdate.
func (a *AssessmentProjectUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProjectUpdateProperties.
func (a AssessmentProjectUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentSolutionId", a.AssessmentSolutionID)
	populate(objectMap, "customerStorageAccountArmId", a.CustomerStorageAccountArmID)
	populate(objectMap, "customerWorkspaceId", a.CustomerWorkspaceID)
	populate(objectMap, "customerWorkspaceLocation", a.CustomerWorkspaceLocation)
	populate(objectMap, "projectStatus", a.ProjectStatus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", a.PublicNetworkAccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProjectUpdateProperties.
func (a *AssessmentProjectUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentSolutionId":
			err = unpopulate(val, "AssessmentSolutionID", &a.AssessmentSolutionID)
			delete(rawMsg, key)
		case "customerStorageAccountArmId":
			err = unpopulate(val, "CustomerStorageAccountArmID", &a.CustomerStorageAccountArmID)
			delete(rawMsg, key)
		case "customerWorkspaceId":
			err = unpopulate(val, "CustomerWorkspaceID", &a.CustomerWorkspaceID)
			delete(rawMsg, key)
		case "customerWorkspaceLocation":
			err = unpopulate(val, "CustomerWorkspaceLocation", &a.CustomerWorkspaceLocation)
			delete(rawMsg, key)
		case "projectStatus":
			err = unpopulate(val, "ProjectStatus", &a.ProjectStatus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &a.PublicNetworkAccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentResult.
func (a AssessmentResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appServicePlanName", a.AppServicePlanName)
	populate(objectMap, "securitySuitability", a.SecuritySuitability)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "webAppSkuName", a.WebAppSKUName)
	populate(objectMap, "webAppSkuSize", a.WebAppSKUSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentResult.
func (a *AssessmentResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appServicePlanName":
			err = unpopulate(val, "AppServicePlanName", &a.AppServicePlanName)
			delete(rawMsg, key)
		case "securitySuitability":
			err = unpopulate(val, "SecuritySuitability", &a.SecuritySuitability)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "webAppSkuName":
			err = unpopulate(val, "WebAppSKUName", &a.WebAppSKUName)
			delete(rawMsg, key)
		case "webAppSkuSize":
			err = unpopulate(val, "WebAppSKUSize", &a.WebAppSKUSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentScopeParameters.
func (a AssessmentScopeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "serverGroupId", a.ServerGroupID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentScopeParameters.
func (a *AssessmentScopeParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "serverGroupId":
			err = unpopulate(val, "ServerGroupID", &a.ServerGroupID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessedDisk.
func (a AvsAssessedDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessedExternalStorageType", a.AssessedExternalStorageType)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "estimatedDiskSizeInGB", a.EstimatedDiskSizeInGB)
	populate(objectMap, "gigabytesProvisioned", a.GigabytesProvisioned)
	populate(objectMap, "megabytesPerSecondOfRead", a.MegabytesPerSecondOfRead)
	populate(objectMap, "megabytesPerSecondOfWrite", a.MegabytesPerSecondOfWrite)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "numberOfReadOperationsPerSecond", a.NumberOfReadOperationsPerSecond)
	populate(objectMap, "numberOfWriteOperationsPerSecond", a.NumberOfWriteOperationsPerSecond)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessedDisk.
func (a *AvsAssessedDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedExternalStorageType":
			err = unpopulate(val, "AssessedExternalStorageType", &a.AssessedExternalStorageType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "estimatedDiskSizeInGB":
			err = unpopulate(val, "EstimatedDiskSizeInGB", &a.EstimatedDiskSizeInGB)
			delete(rawMsg, key)
		case "gigabytesProvisioned":
			err = unpopulate(val, "GigabytesProvisioned", &a.GigabytesProvisioned)
			delete(rawMsg, key)
		case "megabytesPerSecondOfRead":
			err = unpopulate(val, "MegabytesPerSecondOfRead", &a.MegabytesPerSecondOfRead)
			delete(rawMsg, key)
		case "megabytesPerSecondOfWrite":
			err = unpopulate(val, "MegabytesPerSecondOfWrite", &a.MegabytesPerSecondOfWrite)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "numberOfReadOperationsPerSecond":
			err = unpopulate(val, "NumberOfReadOperationsPerSecond", &a.NumberOfReadOperationsPerSecond)
			delete(rawMsg, key)
		case "numberOfWriteOperationsPerSecond":
			err = unpopulate(val, "NumberOfWriteOperationsPerSecond", &a.NumberOfWriteOperationsPerSecond)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessedMachine.
func (a AvsAssessedMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessedMachine.
func (a *AvsAssessedMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessedMachineListResult.
func (a AvsAssessedMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessedMachineListResult.
func (a *AvsAssessedMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessedMachineProperties.
func (a AvsAssessedMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bootType", a.BootType)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "datacenterMachineArmId", a.DatacenterMachineArmID)
	populate(objectMap, "datacenterManagementServerArmId", a.DatacenterManagementServerArmID)
	populate(objectMap, "datacenterManagementServerName", a.DatacenterManagementServerName)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "disks", a.Disks)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "megabytesOfMemory", a.MegabytesOfMemory)
	populate(objectMap, "networkAdapters", a.NetworkAdapters)
	populate(objectMap, "numberOfCores", a.NumberOfCores)
	populate(objectMap, "operatingSystemArchitecture", a.OperatingSystemArchitecture)
	populate(objectMap, "operatingSystemName", a.OperatingSystemName)
	populate(objectMap, "operatingSystemType", a.OperatingSystemType)
	populate(objectMap, "operatingSystemVersion", a.OperatingSystemVersion)
	populate(objectMap, "percentageCoresUtilization", a.PercentageCoresUtilization)
	populate(objectMap, "percentageMemoryUtilization", a.PercentageMemoryUtilization)
	populate(objectMap, "storageInUseGB", a.StorageInUseGB)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityDetail", a.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	populate(objectMap, "type", a.Type)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessedMachineProperties.
func (a *AvsAssessedMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bootType":
			err = unpopulate(val, "BootType", &a.BootType)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "datacenterMachineArmId":
			err = unpopulate(val, "DatacenterMachineArmID", &a.DatacenterMachineArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerArmId":
			err = unpopulate(val, "DatacenterManagementServerArmID", &a.DatacenterManagementServerArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerName":
			err = unpopulate(val, "DatacenterManagementServerName", &a.DatacenterManagementServerName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &a.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &a.Errors)
			delete(rawMsg, key)
		case "megabytesOfMemory":
			err = unpopulate(val, "MegabytesOfMemory", &a.MegabytesOfMemory)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &a.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfCores":
			err = unpopulate(val, "NumberOfCores", &a.NumberOfCores)
			delete(rawMsg, key)
		case "operatingSystemArchitecture":
			err = unpopulate(val, "OperatingSystemArchitecture", &a.OperatingSystemArchitecture)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &a.OperatingSystemName)
			delete(rawMsg, key)
		case "operatingSystemType":
			err = unpopulate(val, "OperatingSystemType", &a.OperatingSystemType)
			delete(rawMsg, key)
		case "operatingSystemVersion":
			err = unpopulate(val, "OperatingSystemVersion", &a.OperatingSystemVersion)
			delete(rawMsg, key)
		case "percentageCoresUtilization":
			err = unpopulate(val, "PercentageCoresUtilization", &a.PercentageCoresUtilization)
			delete(rawMsg, key)
		case "percentageMemoryUtilization":
			err = unpopulate(val, "PercentageMemoryUtilization", &a.PercentageMemoryUtilization)
			delete(rawMsg, key)
		case "storageInUseGB":
			err = unpopulate(val, "StorageInUseGB", &a.StorageInUseGB)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &a.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessedNetworkAdapter.
func (a AvsAssessedNetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "ipAddresses", a.IPAddresses)
	populate(objectMap, "macAddress", a.MacAddress)
	populate(objectMap, "megabytesPerSecondReceived", a.MegabytesPerSecondReceived)
	populate(objectMap, "megabytesPerSecondTransmitted", a.MegabytesPerSecondTransmitted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessedNetworkAdapter.
func (a *AvsAssessedNetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &a.IPAddresses)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &a.MacAddress)
			delete(rawMsg, key)
		case "megabytesPerSecondReceived":
			err = unpopulate(val, "MegabytesPerSecondReceived", &a.MegabytesPerSecondReceived)
			delete(rawMsg, key)
		case "megabytesPerSecondTransmitted":
			err = unpopulate(val, "MegabytesPerSecondTransmitted", &a.MegabytesPerSecondTransmitted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessment.
func (a AvsAssessment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessment.
func (a *AvsAssessment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessmentListResult.
func (a AvsAssessmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessmentListResult.
func (a *AvsAssessmentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessmentOptions.
func (a AvsAssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessmentOptions.
func (a *AvsAssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessmentOptionsListResult.
func (a AvsAssessmentOptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessmentOptionsListResult.
func (a *AvsAssessmentOptionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessmentOptionsProperties.
func (a AvsAssessmentOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avsExternalStorageTypes", a.AvsExternalStorageTypes)
	populate(objectMap, "avsNodes", a.AvsNodes)
	populate(objectMap, "failuresToTolerateAndRaidLevelValues", a.FailuresToTolerateAndRaidLevelValues)
	populate(objectMap, "reservedInstanceAvsNodes", a.ReservedInstanceAvsNodes)
	populate(objectMap, "reservedInstanceSupportedCurrencies", a.ReservedInstanceSupportedCurrencies)
	populate(objectMap, "reservedInstanceSupportedLocations", a.ReservedInstanceSupportedLocations)
	populate(objectMap, "reservedInstanceSupportedOffers", a.ReservedInstanceSupportedOffers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessmentOptionsProperties.
func (a *AvsAssessmentOptionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avsExternalStorageTypes":
			err = unpopulate(val, "AvsExternalStorageTypes", &a.AvsExternalStorageTypes)
			delete(rawMsg, key)
		case "avsNodes":
			err = unpopulate(val, "AvsNodes", &a.AvsNodes)
			delete(rawMsg, key)
		case "failuresToTolerateAndRaidLevelValues":
			err = unpopulate(val, "FailuresToTolerateAndRaidLevelValues", &a.FailuresToTolerateAndRaidLevelValues)
			delete(rawMsg, key)
		case "reservedInstanceAvsNodes":
			err = unpopulate(val, "ReservedInstanceAvsNodes", &a.ReservedInstanceAvsNodes)
			delete(rawMsg, key)
		case "reservedInstanceSupportedCurrencies":
			err = unpopulate(val, "ReservedInstanceSupportedCurrencies", &a.ReservedInstanceSupportedCurrencies)
			delete(rawMsg, key)
		case "reservedInstanceSupportedLocations":
			err = unpopulate(val, "ReservedInstanceSupportedLocations", &a.ReservedInstanceSupportedLocations)
			delete(rawMsg, key)
		case "reservedInstanceSupportedOffers":
			err = unpopulate(val, "ReservedInstanceSupportedOffers", &a.ReservedInstanceSupportedOffers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsAssessmentProperties.
func (a AvsAssessmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentErrorSummary", a.AssessmentErrorSummary)
	populate(objectMap, "assessmentType", a.AssessmentType)
	populate(objectMap, "avsAssessmentScenario", a.AvsAssessmentScenario)
	populate(objectMap, "avsEstimatedExternalStorages", a.AvsEstimatedExternalStorages)
	populate(objectMap, "avsEstimatedNetworks", a.AvsEstimatedNetworks)
	populate(objectMap, "avsEstimatedNodes", a.AvsEstimatedNodes)
	populate(objectMap, "azureLocation", a.AzureLocation)
	populate(objectMap, "azureOfferCode", a.AzureOfferCode)
	populate(objectMap, "cpuHeadroom", a.CPUHeadroom)
	populate(objectMap, "cpuUtilization", a.CPUUtilization)
	populate(objectMap, "confidenceRatingInPercentage", a.ConfidenceRatingInPercentage)
	populate(objectMap, "costComponents", a.CostComponents)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", a.CreatedTimestamp)
	populate(objectMap, "currency", a.Currency)
	populate(objectMap, "dedupeCompression", a.DedupeCompression)
	populate(objectMap, "discountPercentage", a.DiscountPercentage)
	populate(objectMap, "externalStorageTypes", a.ExternalStorageTypes)
	populate(objectMap, "failuresToTolerateAndRaidLevel", a.FailuresToTolerateAndRaidLevel)
	populate(objectMap, "failuresToTolerateAndRaidLevelList", a.FailuresToTolerateAndRaidLevelList)
	populate(objectMap, "groupType", a.GroupType)
	populate(objectMap, "isStretchClusterEnabled", a.IsStretchClusterEnabled)
	populate(objectMap, "isVcfByolEnabled", a.IsVcfByolEnabled)
	populate(objectMap, "limitingFactor", a.LimitingFactor)
	populate(objectMap, "memOvercommit", a.MemOvercommit)
	populate(objectMap, "nodeType", a.NodeType)
	populate(objectMap, "nodeTypes", a.NodeTypes)
	populate(objectMap, "numberOfMachines", a.NumberOfMachines)
	populate(objectMap, "numberOfNodes", a.NumberOfNodes)
	populate(objectMap, "percentile", a.Percentile)
	populateDateTimeRFC3339(objectMap, "perfDataEndTime", a.PerfDataEndTime)
	populateDateTimeRFC3339(objectMap, "perfDataStartTime", a.PerfDataStartTime)
	populateDateTimeRFC3339(objectMap, "pricesTimestamp", a.PricesTimestamp)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "ramUtilization", a.RAMUtilization)
	populate(objectMap, "reservedInstance", a.ReservedInstance)
	populate(objectMap, "scalingFactor", a.ScalingFactor)
	populate(objectMap, "schemaVersion", a.SchemaVersion)
	populate(objectMap, "sizingCriterion", a.SizingCriterion)
	populate(objectMap, "stage", a.Stage)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "storageUtilization", a.StorageUtilization)
	populate(objectMap, "suitability", a.Suitability)
	populate(objectMap, "suitabilityExplanation", a.SuitabilityExplanation)
	populate(objectMap, "suitabilitySummary", a.SuitabilitySummary)
	populate(objectMap, "timeRange", a.TimeRange)
	populate(objectMap, "totalCpuCores", a.TotalCPUCores)
	populate(objectMap, "totalMonthlyCost", a.TotalMonthlyCost)
	populate(objectMap, "totalRamInGB", a.TotalRAMInGB)
	populate(objectMap, "totalStorageInGB", a.TotalStorageInGB)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", a.UpdatedTimestamp)
	populate(objectMap, "vcpuOversubscription", a.VcpuOversubscription)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsAssessmentProperties.
func (a *AvsAssessmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentErrorSummary":
			err = unpopulate(val, "AssessmentErrorSummary", &a.AssessmentErrorSummary)
			delete(rawMsg, key)
		case "assessmentType":
			err = unpopulate(val, "AssessmentType", &a.AssessmentType)
			delete(rawMsg, key)
		case "avsAssessmentScenario":
			err = unpopulate(val, "AvsAssessmentScenario", &a.AvsAssessmentScenario)
			delete(rawMsg, key)
		case "avsEstimatedExternalStorages":
			err = unpopulate(val, "AvsEstimatedExternalStorages", &a.AvsEstimatedExternalStorages)
			delete(rawMsg, key)
		case "avsEstimatedNetworks":
			err = unpopulate(val, "AvsEstimatedNetworks", &a.AvsEstimatedNetworks)
			delete(rawMsg, key)
		case "avsEstimatedNodes":
			err = unpopulate(val, "AvsEstimatedNodes", &a.AvsEstimatedNodes)
			delete(rawMsg, key)
		case "azureLocation":
			err = unpopulate(val, "AzureLocation", &a.AzureLocation)
			delete(rawMsg, key)
		case "azureOfferCode":
			err = unpopulate(val, "AzureOfferCode", &a.AzureOfferCode)
			delete(rawMsg, key)
		case "cpuHeadroom":
			err = unpopulate(val, "CPUHeadroom", &a.CPUHeadroom)
			delete(rawMsg, key)
		case "cpuUtilization":
			err = unpopulate(val, "CPUUtilization", &a.CPUUtilization)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &a.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &a.CostComponents)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &a.CreatedTimestamp)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &a.Currency)
			delete(rawMsg, key)
		case "dedupeCompression":
			err = unpopulate(val, "DedupeCompression", &a.DedupeCompression)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &a.DiscountPercentage)
			delete(rawMsg, key)
		case "externalStorageTypes":
			err = unpopulate(val, "ExternalStorageTypes", &a.ExternalStorageTypes)
			delete(rawMsg, key)
		case "failuresToTolerateAndRaidLevel":
			err = unpopulate(val, "FailuresToTolerateAndRaidLevel", &a.FailuresToTolerateAndRaidLevel)
			delete(rawMsg, key)
		case "failuresToTolerateAndRaidLevelList":
			err = unpopulate(val, "FailuresToTolerateAndRaidLevelList", &a.FailuresToTolerateAndRaidLevelList)
			delete(rawMsg, key)
		case "groupType":
			err = unpopulate(val, "GroupType", &a.GroupType)
			delete(rawMsg, key)
		case "isStretchClusterEnabled":
			err = unpopulate(val, "IsStretchClusterEnabled", &a.IsStretchClusterEnabled)
			delete(rawMsg, key)
		case "isVcfByolEnabled":
			err = unpopulate(val, "IsVcfByolEnabled", &a.IsVcfByolEnabled)
			delete(rawMsg, key)
		case "limitingFactor":
			err = unpopulate(val, "LimitingFactor", &a.LimitingFactor)
			delete(rawMsg, key)
		case "memOvercommit":
			err = unpopulate(val, "MemOvercommit", &a.MemOvercommit)
			delete(rawMsg, key)
		case "nodeType":
			err = unpopulate(val, "NodeType", &a.NodeType)
			delete(rawMsg, key)
		case "nodeTypes":
			err = unpopulate(val, "NodeTypes", &a.NodeTypes)
			delete(rawMsg, key)
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &a.NumberOfMachines)
			delete(rawMsg, key)
		case "numberOfNodes":
			err = unpopulate(val, "NumberOfNodes", &a.NumberOfNodes)
			delete(rawMsg, key)
		case "percentile":
			err = unpopulate(val, "Percentile", &a.Percentile)
			delete(rawMsg, key)
		case "perfDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataEndTime", &a.PerfDataEndTime)
			delete(rawMsg, key)
		case "perfDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataStartTime", &a.PerfDataStartTime)
			delete(rawMsg, key)
		case "pricesTimestamp":
			err = unpopulateDateTimeRFC3339(val, "PricesTimestamp", &a.PricesTimestamp)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "ramUtilization":
			err = unpopulate(val, "RAMUtilization", &a.RAMUtilization)
			delete(rawMsg, key)
		case "reservedInstance":
			err = unpopulate(val, "ReservedInstance", &a.ReservedInstance)
			delete(rawMsg, key)
		case "scalingFactor":
			err = unpopulate(val, "ScalingFactor", &a.ScalingFactor)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &a.SchemaVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &a.SizingCriterion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, "Stage", &a.Stage)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "storageUtilization":
			err = unpopulate(val, "StorageUtilization", &a.StorageUtilization)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &a.Suitability)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &a.SuitabilityExplanation)
			delete(rawMsg, key)
		case "suitabilitySummary":
			err = unpopulate(val, "SuitabilitySummary", &a.SuitabilitySummary)
			delete(rawMsg, key)
		case "timeRange":
			err = unpopulate(val, "TimeRange", &a.TimeRange)
			delete(rawMsg, key)
		case "totalCpuCores":
			err = unpopulate(val, "TotalCPUCores", &a.TotalCPUCores)
			delete(rawMsg, key)
		case "totalMonthlyCost":
			err = unpopulate(val, "TotalMonthlyCost", &a.TotalMonthlyCost)
			delete(rawMsg, key)
		case "totalRamInGB":
			err = unpopulate(val, "TotalRAMInGB", &a.TotalRAMInGB)
			delete(rawMsg, key)
		case "totalStorageInGB":
			err = unpopulate(val, "TotalStorageInGB", &a.TotalStorageInGB)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &a.UpdatedTimestamp)
			delete(rawMsg, key)
		case "vcpuOversubscription":
			err = unpopulate(val, "VcpuOversubscription", &a.VcpuOversubscription)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsEstimatedExternalStorage.
func (a AvsEstimatedExternalStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "monthlyPrice", a.MonthlyPrice)
	populate(objectMap, "storageType", a.StorageType)
	populate(objectMap, "storageUtilization", a.StorageUtilization)
	populate(objectMap, "totalStorageInGB", a.TotalStorageInGB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsEstimatedExternalStorage.
func (a *AvsEstimatedExternalStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "monthlyPrice":
			err = unpopulate(val, "MonthlyPrice", &a.MonthlyPrice)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, "StorageType", &a.StorageType)
			delete(rawMsg, key)
		case "storageUtilization":
			err = unpopulate(val, "StorageUtilization", &a.StorageUtilization)
			delete(rawMsg, key)
		case "totalStorageInGB":
			err = unpopulate(val, "TotalStorageInGB", &a.TotalStorageInGB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsEstimatedNetwork.
func (a AvsEstimatedNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "monthlyPrice", a.MonthlyPrice)
	populate(objectMap, "networkType", a.NetworkType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsEstimatedNetwork.
func (a *AvsEstimatedNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "monthlyPrice":
			err = unpopulate(val, "MonthlyPrice", &a.MonthlyPrice)
			delete(rawMsg, key)
		case "networkType":
			err = unpopulate(val, "NetworkType", &a.NetworkType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsEstimatedNode.
func (a AvsEstimatedNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuUtilization", a.CPUUtilization)
	populate(objectMap, "fttRaidLevel", a.FttRaidLevel)
	populate(objectMap, "monthlyPrice", a.MonthlyPrice)
	populate(objectMap, "nodeNumber", a.NodeNumber)
	populate(objectMap, "nodeType", a.NodeType)
	populate(objectMap, "pricingModel", a.PricingModel)
	populate(objectMap, "ramUtilization", a.RAMUtilization)
	populate(objectMap, "storageUtilization", a.StorageUtilization)
	populate(objectMap, "totalCpu", a.TotalCPU)
	populate(objectMap, "totalRam", a.TotalRAM)
	populate(objectMap, "totalStorage", a.TotalStorage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsEstimatedNode.
func (a *AvsEstimatedNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuUtilization":
			err = unpopulate(val, "CPUUtilization", &a.CPUUtilization)
			delete(rawMsg, key)
		case "fttRaidLevel":
			err = unpopulate(val, "FttRaidLevel", &a.FttRaidLevel)
			delete(rawMsg, key)
		case "monthlyPrice":
			err = unpopulate(val, "MonthlyPrice", &a.MonthlyPrice)
			delete(rawMsg, key)
		case "nodeNumber":
			err = unpopulate(val, "NodeNumber", &a.NodeNumber)
			delete(rawMsg, key)
		case "nodeType":
			err = unpopulate(val, "NodeType", &a.NodeType)
			delete(rawMsg, key)
		case "pricingModel":
			err = unpopulate(val, "PricingModel", &a.PricingModel)
			delete(rawMsg, key)
		case "ramUtilization":
			err = unpopulate(val, "RAMUtilization", &a.RAMUtilization)
			delete(rawMsg, key)
		case "storageUtilization":
			err = unpopulate(val, "StorageUtilization", &a.StorageUtilization)
			delete(rawMsg, key)
		case "totalCpu":
			err = unpopulate(val, "TotalCPU", &a.TotalCPU)
			delete(rawMsg, key)
		case "totalRam":
			err = unpopulate(val, "TotalRAM", &a.TotalRAM)
			delete(rawMsg, key)
		case "totalStorage":
			err = unpopulate(val, "TotalStorage", &a.TotalStorage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsExternalStorageOptions.
func (a AvsExternalStorageOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storageType", a.StorageType)
	populate(objectMap, "targetLocations", a.TargetLocations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsExternalStorageOptions.
func (a *AvsExternalStorageOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storageType":
			err = unpopulate(val, "StorageType", &a.StorageType)
			delete(rawMsg, key)
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &a.TargetLocations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsNodeSummary.
func (a AvsNodeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avsNodeCostDetails", a.AvsNodeCostDetails)
	populate(objectMap, "cores", a.Cores)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "estimatedCost", a.EstimatedCost)
	populate(objectMap, "estimatedCostByRecommendedOffer", a.EstimatedCostByRecommendedOffer)
	populate(objectMap, "estimatedCostWithVcfByol", a.EstimatedCostWithVcfByol)
	populate(objectMap, "estimatedExternalStorage", a.EstimatedExternalStorage)
	populate(objectMap, "estimatedNetwork", a.EstimatedNetwork)
	populate(objectMap, "memoryGb", a.MemoryGb)
	populate(objectMap, "osLicensingCost", a.OSLicensingCost)
	populate(objectMap, "recommendedAvsNodeTypeSummary", a.RecommendedAvsNodeTypeSummary)
	populate(objectMap, "serversSuitableForMigration", a.ServersSuitableForMigration)
	populate(objectMap, "totalNumberOfServers", a.TotalNumberOfServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsNodeSummary.
func (a *AvsNodeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avsNodeCostDetails":
			err = unpopulate(val, "AvsNodeCostDetails", &a.AvsNodeCostDetails)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &a.Cores)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &a.Errors)
			delete(rawMsg, key)
		case "estimatedCost":
			err = unpopulate(val, "EstimatedCost", &a.EstimatedCost)
			delete(rawMsg, key)
		case "estimatedCostByRecommendedOffer":
			err = unpopulate(val, "EstimatedCostByRecommendedOffer", &a.EstimatedCostByRecommendedOffer)
			delete(rawMsg, key)
		case "estimatedCostWithVcfByol":
			err = unpopulate(val, "EstimatedCostWithVcfByol", &a.EstimatedCostWithVcfByol)
			delete(rawMsg, key)
		case "estimatedExternalStorage":
			err = unpopulate(val, "EstimatedExternalStorage", &a.EstimatedExternalStorage)
			delete(rawMsg, key)
		case "estimatedNetwork":
			err = unpopulate(val, "EstimatedNetwork", &a.EstimatedNetwork)
			delete(rawMsg, key)
		case "memoryGb":
			err = unpopulate(val, "MemoryGb", &a.MemoryGb)
			delete(rawMsg, key)
		case "osLicensingCost":
			err = unpopulate(val, "OSLicensingCost", &a.OSLicensingCost)
			delete(rawMsg, key)
		case "recommendedAvsNodeTypeSummary":
			err = unpopulate(val, "RecommendedAvsNodeTypeSummary", &a.RecommendedAvsNodeTypeSummary)
			delete(rawMsg, key)
		case "serversSuitableForMigration":
			err = unpopulate(val, "ServersSuitableForMigration", &a.ServersSuitableForMigration)
			delete(rawMsg, key)
		case "totalNumberOfServers":
			err = unpopulate(val, "TotalNumberOfServers", &a.TotalNumberOfServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsSKUOptions.
func (a AvsSKUOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeType", a.NodeType)
	populate(objectMap, "targetLocations", a.TargetLocations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsSKUOptions.
func (a *AvsSKUOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeType":
			err = unpopulate(val, "NodeType", &a.NodeType)
			delete(rawMsg, key)
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &a.TargetLocations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsSummary.
func (a AvsSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsSummary.
func (a *AvsSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsSummaryListResult.
func (a AvsSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsSummaryListResult.
func (a *AvsSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvsSummaryProperties.
func (a AvsSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureAvsSummary", a.AzureAvsSummary)
	populate(objectMap, "onPremisesAvsSummary", a.OnPremisesAvsSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvsSummaryProperties.
func (a *AvsSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureAvsSummary":
			err = unpopulate(val, "AzureAvsSummary", &a.AzureAvsSummary)
			delete(rawMsg, key)
		case "onPremisesAvsSummary":
			err = unpopulate(val, "OnPremisesAvsSummary", &a.OnPremisesAvsSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureAppServiceContainerSummary.
func (a AzureAppServiceContainerSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionByApp", a.DistributionByApp)
	populate(objectMap, "distributionBySku", a.DistributionBySKU)
	populate(objectMap, "estimatedCostByOffer", a.EstimatedCostByOffer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureAppServiceContainerSummary.
func (a *AzureAppServiceContainerSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionByApp":
			err = unpopulate(val, "DistributionByApp", &a.DistributionByApp)
			delete(rawMsg, key)
		case "distributionBySku":
			err = unpopulate(val, "DistributionBySKU", &a.DistributionBySKU)
			delete(rawMsg, key)
		case "estimatedCostByOffer":
			err = unpopulate(val, "EstimatedCostByOffer", &a.EstimatedCostByOffer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureAppServiceSummary.
func (a AzureAppServiceSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionByApp", a.DistributionByApp)
	populate(objectMap, "distributionBySku", a.DistributionBySKU)
	populate(objectMap, "estimatedCostByOffer", a.EstimatedCostByOffer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureAppServiceSummary.
func (a *AzureAppServiceSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionByApp":
			err = unpopulate(val, "DistributionByApp", &a.DistributionByApp)
			delete(rawMsg, key)
		case "distributionBySku":
			err = unpopulate(val, "DistributionBySKU", &a.DistributionBySKU)
			delete(rawMsg, key)
		case "estimatedCostByOffer":
			err = unpopulate(val, "EstimatedCostByOffer", &a.EstimatedCostByOffer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureArcManagementSettings.
func (a AzureArcManagementSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "monitoringSettings", a.MonitoringSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureArcManagementSettings.
func (a *AzureArcManagementSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "monitoringSettings":
			err = unpopulate(val, "MonitoringSettings", &a.MonitoringSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureArcMonitoringSettings.
func (a AzureArcMonitoringSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alertRulesCount", a.AlertRulesCount)
	populate(objectMap, "logsVolumeInGB", a.LogsVolumeInGB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureArcMonitoringSettings.
func (a *AzureArcMonitoringSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCount":
			err = unpopulate(val, "AlertRulesCount", &a.AlertRulesCount)
			delete(rawMsg, key)
		case "logsVolumeInGB":
			err = unpopulate(val, "LogsVolumeInGB", &a.LogsVolumeInGB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureArcSettings.
func (a AzureArcSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureArcState", a.AzureArcState)
	populate(objectMap, "laborCostPercentage", a.LaborCostPercentage)
	populate(objectMap, "managementSettings", a.ManagementSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureArcSettings.
func (a *AzureArcSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureArcState":
			err = unpopulate(val, "AzureArcState", &a.AzureArcState)
			delete(rawMsg, key)
		case "laborCostPercentage":
			err = unpopulate(val, "LaborCostPercentage", &a.LaborCostPercentage)
			delete(rawMsg, key)
		case "managementSettings":
			err = unpopulate(val, "ManagementSettings", &a.ManagementSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureAvsSummary.
func (a AzureAvsSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avsCostDetails", a.AvsCostDetails)
	populate(objectMap, "avsNodeSummary", a.AvsNodeSummary)
	populate(objectMap, "yearOnYearEstimates", a.YearOnYearEstimates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureAvsSummary.
func (a *AzureAvsSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avsCostDetails":
			err = unpopulate(val, "AvsCostDetails", &a.AvsCostDetails)
			delete(rawMsg, key)
		case "avsNodeSummary":
			err = unpopulate(val, "AvsNodeSummary", &a.AvsNodeSummary)
			delete(rawMsg, key)
		case "yearOnYearEstimates":
			err = unpopulate(val, "YearOnYearEstimates", &a.YearOnYearEstimates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaasSQLSummary.
func (a AzureIaasSQLSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlCostDetails", a.AzureSQLCostDetails)
	populate(objectMap, "costByStorageType", a.CostByStorageType)
	populate(objectMap, "estimatedCost", a.EstimatedCost)
	populate(objectMap, "estimatedCostByRecommendedOffer", a.EstimatedCostByRecommendedOffer)
	populate(objectMap, "osLicensingCost", a.OSLicensingCost)
	populate(objectMap, "recommendedVmFamilySummary", a.RecommendedVMFamilySummary)
	populate(objectMap, "suitableSqlEntities", a.SuitableSQLEntities)
	populate(objectMap, "totalSqlEntities", a.TotalSQLEntities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaasSQLSummary.
func (a *AzureIaasSQLSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlCostDetails":
			err = unpopulate(val, "AzureSQLCostDetails", &a.AzureSQLCostDetails)
			delete(rawMsg, key)
		case "costByStorageType":
			err = unpopulate(val, "CostByStorageType", &a.CostByStorageType)
			delete(rawMsg, key)
		case "estimatedCost":
			err = unpopulate(val, "EstimatedCost", &a.EstimatedCost)
			delete(rawMsg, key)
		case "estimatedCostByRecommendedOffer":
			err = unpopulate(val, "EstimatedCostByRecommendedOffer", &a.EstimatedCostByRecommendedOffer)
			delete(rawMsg, key)
		case "osLicensingCost":
			err = unpopulate(val, "OSLicensingCost", &a.OSLicensingCost)
			delete(rawMsg, key)
		case "recommendedVmFamilySummary":
			err = unpopulate(val, "RecommendedVMFamilySummary", &a.RecommendedVMFamilySummary)
			delete(rawMsg, key)
		case "suitableSqlEntities":
			err = unpopulate(val, "SuitableSQLEntities", &a.SuitableSQLEntities)
			delete(rawMsg, key)
		case "totalSqlEntities":
			err = unpopulate(val, "TotalSQLEntities", &a.TotalSQLEntities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaasSummary.
func (a AzureIaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureIaasCostDetails", a.AzureIaasCostDetails)
	populate(objectMap, "azureIaasSqlSummary", a.AzureIaasSQLSummary)
	populate(objectMap, "azureIaasVmSummary", a.AzureIaasVMSummary)
	populate(objectMap, "yearOnYearEstimates", a.YearOnYearEstimates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaasSummary.
func (a *AzureIaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureIaasCostDetails":
			err = unpopulate(val, "AzureIaasCostDetails", &a.AzureIaasCostDetails)
			delete(rawMsg, key)
		case "azureIaasSqlSummary":
			err = unpopulate(val, "AzureIaasSQLSummary", &a.AzureIaasSQLSummary)
			delete(rawMsg, key)
		case "azureIaasVmSummary":
			err = unpopulate(val, "AzureIaasVMSummary", &a.AzureIaasVMSummary)
			delete(rawMsg, key)
		case "yearOnYearEstimates":
			err = unpopulate(val, "YearOnYearEstimates", &a.YearOnYearEstimates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaasVMSummary.
func (a AzureIaasVMSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureVmCostDetails", a.AzureVMCostDetails)
	populate(objectMap, "cores", a.Cores)
	populate(objectMap, "costByStorageType", a.CostByStorageType)
	populate(objectMap, "estimatedCost", a.EstimatedCost)
	populate(objectMap, "estimatedCostByRecommendedOffer", a.EstimatedCostByRecommendedOffer)
	populate(objectMap, "memoryGb", a.MemoryGb)
	populate(objectMap, "osLicensingCost", a.OSLicensingCost)
	populate(objectMap, "recommendedVmFamilySummary", a.RecommendedVMFamilySummary)
	populate(objectMap, "serversSuitableForMigration", a.ServersSuitableForMigration)
	populate(objectMap, "totalNumberOfServers", a.TotalNumberOfServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaasVMSummary.
func (a *AzureIaasVMSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureVmCostDetails":
			err = unpopulate(val, "AzureVMCostDetails", &a.AzureVMCostDetails)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &a.Cores)
			delete(rawMsg, key)
		case "costByStorageType":
			err = unpopulate(val, "CostByStorageType", &a.CostByStorageType)
			delete(rawMsg, key)
		case "estimatedCost":
			err = unpopulate(val, "EstimatedCost", &a.EstimatedCost)
			delete(rawMsg, key)
		case "estimatedCostByRecommendedOffer":
			err = unpopulate(val, "EstimatedCostByRecommendedOffer", &a.EstimatedCostByRecommendedOffer)
			delete(rawMsg, key)
		case "memoryGb":
			err = unpopulate(val, "MemoryGb", &a.MemoryGb)
			delete(rawMsg, key)
		case "osLicensingCost":
			err = unpopulate(val, "OSLicensingCost", &a.OSLicensingCost)
			delete(rawMsg, key)
		case "recommendedVmFamilySummary":
			err = unpopulate(val, "RecommendedVMFamilySummary", &a.RecommendedVMFamilySummary)
			delete(rawMsg, key)
		case "serversSuitableForMigration":
			err = unpopulate(val, "ServersSuitableForMigration", &a.ServersSuitableForMigration)
			delete(rawMsg, key)
		case "totalNumberOfServers":
			err = unpopulate(val, "TotalNumberOfServers", &a.TotalNumberOfServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKubernetesServiceSummary.
func (a AzureKubernetesServiceSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionByApp", a.DistributionByApp)
	populate(objectMap, "distributionBySku", a.DistributionBySKU)
	populate(objectMap, "estimatedCostByOffer", a.EstimatedCostByOffer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKubernetesServiceSummary.
func (a *AzureKubernetesServiceSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionByApp":
			err = unpopulate(val, "DistributionByApp", &a.DistributionByApp)
			delete(rawMsg, key)
		case "distributionBySku":
			err = unpopulate(val, "DistributionBySKU", &a.DistributionBySKU)
			delete(rawMsg, key)
		case "estimatedCostByOffer":
			err = unpopulate(val, "EstimatedCostByOffer", &a.EstimatedCostByOffer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureManagedDiskSKUDTO.
func (a AzureManagedDiskSKUDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskRedundancy", a.DiskRedundancy)
	populate(objectMap, "diskSize", a.DiskSize)
	populate(objectMap, "diskType", a.DiskType)
	populate(objectMap, "recommendedIops", a.RecommendedIops)
	populate(objectMap, "recommendedSizeInGib", a.RecommendedSizeInGib)
	populate(objectMap, "recommendedThroughputInMbps", a.RecommendedThroughputInMbps)
	populate(objectMap, "storageCost", a.StorageCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureManagedDiskSKUDTO.
func (a *AzureManagedDiskSKUDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &a.DiskRedundancy)
			delete(rawMsg, key)
		case "diskSize":
			err = unpopulate(val, "DiskSize", &a.DiskSize)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, "DiskType", &a.DiskType)
			delete(rawMsg, key)
		case "recommendedIops":
			err = unpopulate(val, "RecommendedIops", &a.RecommendedIops)
			delete(rawMsg, key)
		case "recommendedSizeInGib":
			err = unpopulate(val, "RecommendedSizeInGib", &a.RecommendedSizeInGib)
			delete(rawMsg, key)
		case "recommendedThroughputInMbps":
			err = unpopulate(val, "RecommendedThroughputInMbps", &a.RecommendedThroughputInMbps)
			delete(rawMsg, key)
		case "storageCost":
			err = unpopulate(val, "StorageCost", &a.StorageCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzurePaasSummary.
func (a AzurePaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureAppServiceContainerSummary", a.AzureAppServiceContainerSummary)
	populate(objectMap, "azureAppServiceSummary", a.AzureAppServiceSummary)
	populate(objectMap, "azureKubernetesServiceSummary", a.AzureKubernetesServiceSummary)
	populate(objectMap, "azureSqlSummary", a.AzureSQLSummary)
	populate(objectMap, "cores", a.Cores)
	populate(objectMap, "estimatedCostByTarget", a.EstimatedCostByTarget)
	populate(objectMap, "estimatedSqlServerLicensingCost", a.EstimatedSQLServerLicensingCost)
	populate(objectMap, "memory", a.Memory)
	populate(objectMap, "storage", a.Storage)
	populate(objectMap, "suitableSqlEntities", a.SuitableSQLEntities)
	populate(objectMap, "suitableWebApps", a.SuitableWebApps)
	populate(objectMap, "totalAzurePaasCost", a.TotalAzurePaasCost)
	populate(objectMap, "totalSqlEntities", a.TotalSQLEntities)
	populate(objectMap, "totalWebApps", a.TotalWebApps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePaasSummary.
func (a *AzurePaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureAppServiceContainerSummary":
			err = unpopulate(val, "AzureAppServiceContainerSummary", &a.AzureAppServiceContainerSummary)
			delete(rawMsg, key)
		case "azureAppServiceSummary":
			err = unpopulate(val, "AzureAppServiceSummary", &a.AzureAppServiceSummary)
			delete(rawMsg, key)
		case "azureKubernetesServiceSummary":
			err = unpopulate(val, "AzureKubernetesServiceSummary", &a.AzureKubernetesServiceSummary)
			delete(rawMsg, key)
		case "azureSqlSummary":
			err = unpopulate(val, "AzureSQLSummary", &a.AzureSQLSummary)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &a.Cores)
			delete(rawMsg, key)
		case "estimatedCostByTarget":
			err = unpopulate(val, "EstimatedCostByTarget", &a.EstimatedCostByTarget)
			delete(rawMsg, key)
		case "estimatedSqlServerLicensingCost":
			err = unpopulate(val, "EstimatedSQLServerLicensingCost", &a.EstimatedSQLServerLicensingCost)
			delete(rawMsg, key)
		case "memory":
			err = unpopulate(val, "Memory", &a.Memory)
			delete(rawMsg, key)
		case "storage":
			err = unpopulate(val, "Storage", &a.Storage)
			delete(rawMsg, key)
		case "suitableSqlEntities":
			err = unpopulate(val, "SuitableSQLEntities", &a.SuitableSQLEntities)
			delete(rawMsg, key)
		case "suitableWebApps":
			err = unpopulate(val, "SuitableWebApps", &a.SuitableWebApps)
			delete(rawMsg, key)
		case "totalAzurePaasCost":
			err = unpopulate(val, "TotalAzurePaasCost", &a.TotalAzurePaasCost)
			delete(rawMsg, key)
		case "totalSqlEntities":
			err = unpopulate(val, "TotalSQLEntities", &a.TotalSQLEntities)
			delete(rawMsg, key)
		case "totalWebApps":
			err = unpopulate(val, "TotalWebApps", &a.TotalWebApps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureQuorumWitnessDTO.
func (a AzureQuorumWitnessDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "quorumWitnessType", a.QuorumWitnessType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureQuorumWitnessDTO.
func (a *AzureQuorumWitnessDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "quorumWitnessType":
			err = unpopulate(val, "QuorumWitnessType", &a.QuorumWitnessType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLIaasSKUDTO.
func (a AzureSQLIaasSKUDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlTargetType", a.AzureSQLTargetType)
	populate(objectMap, "dataDiskSizes", a.DataDiskSizes)
	populate(objectMap, "logDiskSizes", a.LogDiskSizes)
	populate(objectMap, "virtualMachineSize", a.VirtualMachineSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLIaasSKUDTO.
func (a *AzureSQLIaasSKUDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlTargetType":
			err = unpopulate(val, "AzureSQLTargetType", &a.AzureSQLTargetType)
			delete(rawMsg, key)
		case "dataDiskSizes":
			err = unpopulate(val, "DataDiskSizes", &a.DataDiskSizes)
			delete(rawMsg, key)
		case "logDiskSizes":
			err = unpopulate(val, "LogDiskSizes", &a.LogDiskSizes)
			delete(rawMsg, key)
		case "virtualMachineSize":
			err = unpopulate(val, "VirtualMachineSize", &a.VirtualMachineSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLPaasSKUDTO.
func (a AzureSQLPaasSKUDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlComputeTier", a.AzureSQLComputeTier)
	populate(objectMap, "azureSqlHardwareGeneration", a.AzureSQLHardwareGeneration)
	populate(objectMap, "azureSqlServiceTier", a.AzureSQLServiceTier)
	populate(objectMap, "azureSqlTargetType", a.AzureSQLTargetType)
	populate(objectMap, "cores", a.Cores)
	populate(objectMap, "predictedDataSizeInMB", a.PredictedDataSizeInMB)
	populate(objectMap, "predictedLogSizeInMB", a.PredictedLogSizeInMB)
	populate(objectMap, "storageMaxSizeInMB", a.StorageMaxSizeInMB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLPaasSKUDTO.
func (a *AzureSQLPaasSKUDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlComputeTier":
			err = unpopulate(val, "AzureSQLComputeTier", &a.AzureSQLComputeTier)
			delete(rawMsg, key)
		case "azureSqlHardwareGeneration":
			err = unpopulate(val, "AzureSQLHardwareGeneration", &a.AzureSQLHardwareGeneration)
			delete(rawMsg, key)
		case "azureSqlServiceTier":
			err = unpopulate(val, "AzureSQLServiceTier", &a.AzureSQLServiceTier)
			delete(rawMsg, key)
		case "azureSqlTargetType":
			err = unpopulate(val, "AzureSQLTargetType", &a.AzureSQLTargetType)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &a.Cores)
			delete(rawMsg, key)
		case "predictedDataSizeInMB":
			err = unpopulate(val, "PredictedDataSizeInMB", &a.PredictedDataSizeInMB)
			delete(rawMsg, key)
		case "predictedLogSizeInMB":
			err = unpopulate(val, "PredictedLogSizeInMB", &a.PredictedLogSizeInMB)
			delete(rawMsg, key)
		case "storageMaxSizeInMB":
			err = unpopulate(val, "StorageMaxSizeInMB", &a.StorageMaxSizeInMB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSummary.
func (a AzureSQLSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionByServiceTier", a.DistributionByServiceTier)
	populate(objectMap, "distributionByServiceTierForSqlDb", a.DistributionByServiceTierForSQLDb)
	populate(objectMap, "distributionByServiceTierForSqlMi", a.DistributionByServiceTierForSQLMi)
	populate(objectMap, "estimatedCostByOffer", a.EstimatedCostByOffer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSummary.
func (a *AzureSQLSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionByServiceTier":
			err = unpopulate(val, "DistributionByServiceTier", &a.DistributionByServiceTier)
			delete(rawMsg, key)
		case "distributionByServiceTierForSqlDb":
			err = unpopulate(val, "DistributionByServiceTierForSQLDb", &a.DistributionByServiceTierForSQLDb)
			delete(rawMsg, key)
		case "distributionByServiceTierForSqlMi":
			err = unpopulate(val, "DistributionByServiceTierForSQLMi", &a.DistributionByServiceTierForSQLMi)
			delete(rawMsg, key)
		case "estimatedCostByOffer":
			err = unpopulate(val, "EstimatedCostByOffer", &a.EstimatedCostByOffer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSettings.
func (a AzureSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avsLaborCostPercentage", a.AvsLaborCostPercentage)
	populate(objectMap, "businessCaseType", a.BusinessCaseType)
	populate(objectMap, "comfortFactor", a.ComfortFactor)
	populate(objectMap, "currency", a.Currency)
	populate(objectMap, "discountPercentage", a.DiscountPercentage)
	populate(objectMap, "iaasLaborCostPercentage", a.IaasLaborCostPercentage)
	populate(objectMap, "infrastructureGrowthRate", a.InfrastructureGrowthRate)
	populate(objectMap, "networkCostPercentage", a.NetworkCostPercentage)
	populate(objectMap, "paasLaborCostPercentage", a.PaasLaborCostPercentage)
	populate(objectMap, "perYearMigrationCompletionPercentage", a.PerYearMigrationCompletionPercentage)
	populateDateTimeRFC3339(objectMap, "performanceDataEndTime", a.PerformanceDataEndTime)
	populateDateTimeRFC3339(objectMap, "performanceDataStartTime", a.PerformanceDataStartTime)
	populate(objectMap, "performanceUtilizationPercentile", a.PerformanceUtilizationPercentile)
	populate(objectMap, "savingsOption", a.SavingsOption)
	populate(objectMap, "targetLocation", a.TargetLocation)
	populate(objectMap, "wacc", a.Wacc)
	populate(objectMap, "workloadDiscoverySource", a.WorkloadDiscoverySource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSettings.
func (a *AzureSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avsLaborCostPercentage":
			err = unpopulate(val, "AvsLaborCostPercentage", &a.AvsLaborCostPercentage)
			delete(rawMsg, key)
		case "businessCaseType":
			err = unpopulate(val, "BusinessCaseType", &a.BusinessCaseType)
			delete(rawMsg, key)
		case "comfortFactor":
			err = unpopulate(val, "ComfortFactor", &a.ComfortFactor)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &a.Currency)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &a.DiscountPercentage)
			delete(rawMsg, key)
		case "iaasLaborCostPercentage":
			err = unpopulate(val, "IaasLaborCostPercentage", &a.IaasLaborCostPercentage)
			delete(rawMsg, key)
		case "infrastructureGrowthRate":
			err = unpopulate(val, "InfrastructureGrowthRate", &a.InfrastructureGrowthRate)
			delete(rawMsg, key)
		case "networkCostPercentage":
			err = unpopulate(val, "NetworkCostPercentage", &a.NetworkCostPercentage)
			delete(rawMsg, key)
		case "paasLaborCostPercentage":
			err = unpopulate(val, "PaasLaborCostPercentage", &a.PaasLaborCostPercentage)
			delete(rawMsg, key)
		case "perYearMigrationCompletionPercentage":
			err = unpopulate(val, "PerYearMigrationCompletionPercentage", &a.PerYearMigrationCompletionPercentage)
			delete(rawMsg, key)
		case "performanceDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerformanceDataEndTime", &a.PerformanceDataEndTime)
			delete(rawMsg, key)
		case "performanceDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerformanceDataStartTime", &a.PerformanceDataStartTime)
			delete(rawMsg, key)
		case "performanceUtilizationPercentile":
			err = unpopulate(val, "PerformanceUtilizationPercentile", &a.PerformanceUtilizationPercentile)
			delete(rawMsg, key)
		case "savingsOption":
			err = unpopulate(val, "SavingsOption", &a.SavingsOption)
			delete(rawMsg, key)
		case "targetLocation":
			err = unpopulate(val, "TargetLocation", &a.TargetLocation)
			delete(rawMsg, key)
		case "wacc":
			err = unpopulate(val, "Wacc", &a.Wacc)
			delete(rawMsg, key)
		case "workloadDiscoverySource":
			err = unpopulate(val, "WorkloadDiscoverySource", &a.WorkloadDiscoverySource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVirtualMachineSKUDTO.
func (a AzureVirtualMachineSKUDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableCores", a.AvailableCores)
	populate(objectMap, "azureSkuName", a.AzureSKUName)
	populate(objectMap, "azureVmFamily", a.AzureVMFamily)
	populate(objectMap, "cores", a.Cores)
	populate(objectMap, "maxNetworkInterfaces", a.MaxNetworkInterfaces)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVirtualMachineSKUDTO.
func (a *AzureVirtualMachineSKUDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableCores":
			err = unpopulate(val, "AvailableCores", &a.AvailableCores)
			delete(rawMsg, key)
		case "azureSkuName":
			err = unpopulate(val, "AzureSKUName", &a.AzureSKUName)
			delete(rawMsg, key)
		case "azureVmFamily":
			err = unpopulate(val, "AzureVMFamily", &a.AzureVMFamily)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &a.Cores)
			delete(rawMsg, key)
		case "maxNetworkInterfaces":
			err = unpopulate(val, "MaxNetworkInterfaces", &a.MaxNetworkInterfaces)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BusinessCase.
func (b BusinessCase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "systemData", b.SystemData)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BusinessCase.
func (b *BusinessCase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &b.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BusinessCaseListResult.
func (b BusinessCaseListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BusinessCaseListResult.
func (b *BusinessCaseListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &b.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BusinessCaseProperties.
func (b BusinessCaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "reportStatusDetails", b.ReportStatusDetails)
	populate(objectMap, "settings", b.Settings)
	populate(objectMap, "state", b.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BusinessCaseProperties.
func (b *BusinessCaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		case "reportStatusDetails":
			err = unpopulate(val, "ReportStatusDetails", &b.ReportStatusDetails)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &b.Settings)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Check.
func (c Check) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "behavior", c.Behavior)
	populate(objectMap, "cause", c.Cause)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "moreInfo", c.MoreInfo)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "recommendation", c.Recommendation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Check.
func (c *Check) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "behavior":
			err = unpopulate(val, "Behavior", &c.Behavior)
			delete(rawMsg, key)
		case "cause":
			err = unpopulate(val, "Cause", &c.Cause)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "moreInfo":
			err = unpopulate(val, "MoreInfo", &c.MoreInfo)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, "Recommendation", &c.Recommendation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CollectorAgentPropertiesBase.
func (c CollectorAgentPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populateDateTimeRFC3339(objectMap, "lastHeartbeatUtc", c.LastHeartbeatUTC)
	populate(objectMap, "spnDetails", c.SpnDetails)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CollectorAgentPropertiesBase.
func (c *CollectorAgentPropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "lastHeartbeatUtc":
			err = unpopulateDateTimeRFC3339(val, "LastHeartbeatUTC", &c.LastHeartbeatUTC)
			delete(rawMsg, key)
		case "spnDetails":
			err = unpopulate(val, "SpnDetails", &c.SpnDetails)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CollectorAgentSpnPropertiesBase.
func (c CollectorAgentSpnPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", c.ApplicationID)
	populate(objectMap, "audience", c.Audience)
	populate(objectMap, "authority", c.Authority)
	populate(objectMap, "objectId", c.ObjectID)
	populate(objectMap, "tenantId", c.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CollectorAgentSpnPropertiesBase.
func (c *CollectorAgentSpnPropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &c.ApplicationID)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, "Audience", &c.Audience)
			delete(rawMsg, key)
		case "authority":
			err = unpopulate(val, "Authority", &c.Authority)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &c.ObjectID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &c.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CollectorPropertiesBase.
func (c CollectorPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", c.CreatedTimestamp)
	populate(objectMap, "discoverySiteId", c.DiscoverySiteID)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", c.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CollectorPropertiesBase.
func (c *CollectorPropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &c.CreatedTimestamp)
			delete(rawMsg, key)
		case "discoverySiteId":
			err = unpopulate(val, "DiscoverySiteID", &c.DiscoverySiteID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &c.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CollectorPropertiesBaseWithAgent.
func (c CollectorPropertiesBaseWithAgent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentProperties", c.AgentProperties)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", c.CreatedTimestamp)
	populate(objectMap, "discoverySiteId", c.DiscoverySiteID)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", c.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CollectorPropertiesBaseWithAgent.
func (c *CollectorPropertiesBaseWithAgent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentProperties":
			err = unpopulate(val, "AgentProperties", &c.AgentProperties)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &c.CreatedTimestamp)
			delete(rawMsg, key)
		case "discoverySiteId":
			err = unpopulate(val, "DiscoverySiteID", &c.DiscoverySiteID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &c.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompareSummary.
func (c CompareSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureArcEnabledOnPremisesCostDetails", c.AzureArcEnabledOnPremisesCostDetails)
	populate(objectMap, "azureAvsCostDetails", c.AzureAvsCostDetails)
	populate(objectMap, "azureIaasCostDetails", c.AzureIaasCostDetails)
	populate(objectMap, "azurePaasCostDetails", c.AzurePaasCostDetails)
	populate(objectMap, "futureAzureArcEnabledOnPremisesCostDetails", c.FutureAzureArcEnabledOnPremisesCostDetails)
	populate(objectMap, "futureCostDetails", c.FutureCostDetails)
	populate(objectMap, "onPremisesAvsCostDetails", c.OnPremisesAvsCostDetails)
	populate(objectMap, "onPremisesAvsDecommissionedCostDetails", c.OnPremisesAvsDecommissionedCostDetails)
	populate(objectMap, "onPremisesIaasCostDetails", c.OnPremisesIaasCostDetails)
	populate(objectMap, "onPremisesIaasDecommissionedCostDetails", c.OnPremisesIaasDecommissionedCostDetails)
	populate(objectMap, "onPremisesPaasCostDetails", c.OnPremisesPaasCostDetails)
	populate(objectMap, "onPremisesPaasDecommissionedCostDetails", c.OnPremisesPaasDecommissionedCostDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompareSummary.
func (c *CompareSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureArcEnabledOnPremisesCostDetails":
			err = unpopulate(val, "AzureArcEnabledOnPremisesCostDetails", &c.AzureArcEnabledOnPremisesCostDetails)
			delete(rawMsg, key)
		case "azureAvsCostDetails":
			err = unpopulate(val, "AzureAvsCostDetails", &c.AzureAvsCostDetails)
			delete(rawMsg, key)
		case "azureIaasCostDetails":
			err = unpopulate(val, "AzureIaasCostDetails", &c.AzureIaasCostDetails)
			delete(rawMsg, key)
		case "azurePaasCostDetails":
			err = unpopulate(val, "AzurePaasCostDetails", &c.AzurePaasCostDetails)
			delete(rawMsg, key)
		case "futureAzureArcEnabledOnPremisesCostDetails":
			err = unpopulate(val, "FutureAzureArcEnabledOnPremisesCostDetails", &c.FutureAzureArcEnabledOnPremisesCostDetails)
			delete(rawMsg, key)
		case "futureCostDetails":
			err = unpopulate(val, "FutureCostDetails", &c.FutureCostDetails)
			delete(rawMsg, key)
		case "onPremisesAvsCostDetails":
			err = unpopulate(val, "OnPremisesAvsCostDetails", &c.OnPremisesAvsCostDetails)
			delete(rawMsg, key)
		case "onPremisesAvsDecommissionedCostDetails":
			err = unpopulate(val, "OnPremisesAvsDecommissionedCostDetails", &c.OnPremisesAvsDecommissionedCostDetails)
			delete(rawMsg, key)
		case "onPremisesIaasCostDetails":
			err = unpopulate(val, "OnPremisesIaasCostDetails", &c.OnPremisesIaasCostDetails)
			delete(rawMsg, key)
		case "onPremisesIaasDecommissionedCostDetails":
			err = unpopulate(val, "OnPremisesIaasDecommissionedCostDetails", &c.OnPremisesIaasDecommissionedCostDetails)
			delete(rawMsg, key)
		case "onPremisesPaasCostDetails":
			err = unpopulate(val, "OnPremisesPaasCostDetails", &c.OnPremisesPaasCostDetails)
			delete(rawMsg, key)
		case "onPremisesPaasDecommissionedCostDetails":
			err = unpopulate(val, "OnPremisesPaasDecommissionedCostDetails", &c.OnPremisesPaasDecommissionedCostDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeResource.
func (c ComputeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cores", c.Cores)
	populate(objectMap, "memory", c.Memory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeResource.
func (c *ComputeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cores":
			err = unpopulate(val, "Cores", &c.Cores)
			delete(rawMsg, key)
		case "memory":
			err = unpopulate(val, "Memory", &c.Memory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeSettings.
func (c ComputeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hyperthreadCoreToMemoryRatio", c.HyperthreadCoreToMemoryRatio)
	populate(objectMap, "price", c.Price)
	populate(objectMap, "rhelLinuxServerLicensing", c.RhelLinuxServerLicensing)
	populate(objectMap, "sqlServerLicensing", c.SQLServerLicensing)
	populate(objectMap, "suseLinuxServerLicensing", c.SuseLinuxServerLicensing)
	populate(objectMap, "virtualizationSoftwareSettings", c.VirtualizationSoftwareSettings)
	populate(objectMap, "windowsServerLicensing", c.WindowsServerLicensing)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeSettings.
func (c *ComputeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hyperthreadCoreToMemoryRatio":
			err = unpopulate(val, "HyperthreadCoreToMemoryRatio", &c.HyperthreadCoreToMemoryRatio)
			delete(rawMsg, key)
		case "price":
			err = unpopulate(val, "Price", &c.Price)
			delete(rawMsg, key)
		case "rhelLinuxServerLicensing":
			err = unpopulate(val, "RhelLinuxServerLicensing", &c.RhelLinuxServerLicensing)
			delete(rawMsg, key)
		case "sqlServerLicensing":
			err = unpopulate(val, "SQLServerLicensing", &c.SQLServerLicensing)
			delete(rawMsg, key)
		case "suseLinuxServerLicensing":
			err = unpopulate(val, "SuseLinuxServerLicensing", &c.SuseLinuxServerLicensing)
			delete(rawMsg, key)
		case "virtualizationSoftwareSettings":
			err = unpopulate(val, "VirtualizationSoftwareSettings", &c.VirtualizationSoftwareSettings)
			delete(rawMsg, key)
		case "windowsServerLicensing":
			err = unpopulate(val, "WindowsServerLicensing", &c.WindowsServerLicensing)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CostByStorageType.
func (c CostByStorageType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", c.Cost)
	populate(objectMap, "storageType", c.StorageType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CostByStorageType.
func (c *CostByStorageType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &c.Cost)
			delete(rawMsg, key)
		case "storageType":
			err = unpopulate(val, "StorageType", &c.StorageType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CostComponent.
func (c CostComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CostComponent.
func (c *CostComponent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CostDetails.
func (c CostDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ahubSavings", c.AhubSavings)
	populate(objectMap, "computeCost", c.ComputeCost)
	populate(objectMap, "esuSavings", c.EsuSavings)
	populate(objectMap, "facilitiesCost", c.FacilitiesCost)
	populate(objectMap, "itLaborCost", c.ItLaborCost)
	populate(objectMap, "linuxAhubSavings", c.LinuxAhubSavings)
	populate(objectMap, "managementCostDetails", c.ManagementCostDetails)
	populate(objectMap, "networkCost", c.NetworkCost)
	populate(objectMap, "securityCost", c.SecurityCost)
	populate(objectMap, "storageCost", c.StorageCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CostDetails.
func (c *CostDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ahubSavings":
			err = unpopulate(val, "AhubSavings", &c.AhubSavings)
			delete(rawMsg, key)
		case "computeCost":
			err = unpopulate(val, "ComputeCost", &c.ComputeCost)
			delete(rawMsg, key)
		case "esuSavings":
			err = unpopulate(val, "EsuSavings", &c.EsuSavings)
			delete(rawMsg, key)
		case "facilitiesCost":
			err = unpopulate(val, "FacilitiesCost", &c.FacilitiesCost)
			delete(rawMsg, key)
		case "itLaborCost":
			err = unpopulate(val, "ItLaborCost", &c.ItLaborCost)
			delete(rawMsg, key)
		case "linuxAhubSavings":
			err = unpopulate(val, "LinuxAhubSavings", &c.LinuxAhubSavings)
			delete(rawMsg, key)
		case "managementCostDetails":
			err = unpopulate(val, "ManagementCostDetails", &c.ManagementCostDetails)
			delete(rawMsg, key)
		case "networkCost":
			err = unpopulate(val, "NetworkCost", &c.NetworkCost)
			delete(rawMsg, key)
		case "securityCost":
			err = unpopulate(val, "SecurityCost", &c.SecurityCost)
			delete(rawMsg, key)
		case "storageCost":
			err = unpopulate(val, "StorageCost", &c.StorageCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiscoveredEntitiesSummary.
func (d DiscoveredEntitiesSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfMachines", d.NumberOfMachines)
	populate(objectMap, "numberOfServers", d.NumberOfServers)
	populate(objectMap, "numberOfWebApps", d.NumberOfWebApps)
	populate(objectMap, "webAppSummary", d.WebAppSummary)
	populate(objectMap, "webServerSummary", d.WebServerSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiscoveredEntitiesSummary.
func (d *DiscoveredEntitiesSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &d.NumberOfMachines)
			delete(rawMsg, key)
		case "numberOfServers":
			err = unpopulate(val, "NumberOfServers", &d.NumberOfServers)
			delete(rawMsg, key)
		case "numberOfWebApps":
			err = unpopulate(val, "NumberOfWebApps", &d.NumberOfWebApps)
			delete(rawMsg, key)
		case "webAppSummary":
			err = unpopulate(val, "WebAppSummary", &d.WebAppSummary)
			delete(rawMsg, key)
		case "webServerSummary":
			err = unpopulate(val, "WebServerSummary", &d.WebServerSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiscoveredEntityLightSummary.
func (d DiscoveredEntityLightSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfMachines", d.NumberOfMachines)
	populate(objectMap, "numberOfServers", d.NumberOfServers)
	populate(objectMap, "numberOfWebApps", d.NumberOfWebApps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiscoveredEntityLightSummary.
func (d *DiscoveredEntityLightSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &d.NumberOfMachines)
			delete(rawMsg, key)
		case "numberOfServers":
			err = unpopulate(val, "NumberOfServers", &d.NumberOfServers)
			delete(rawMsg, key)
		case "numberOfWebApps":
			err = unpopulate(val, "NumberOfWebApps", &d.NumberOfWebApps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Disk.
func (d Disk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "gigabytesAllocated", d.GigabytesAllocated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Disk.
func (d *Disk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "gigabytesAllocated":
			err = unpopulate(val, "GigabytesAllocated", &d.GigabytesAllocated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionByOperatingSystem.
func (d DistributionByOperatingSystem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", d.Count)
	populate(objectMap, "osClassificationType", d.OSClassificationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionByOperatingSystem.
func (d *DistributionByOperatingSystem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &d.Count)
			delete(rawMsg, key)
		case "osClassificationType":
			err = unpopulate(val, "OSClassificationType", &d.OSClassificationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionByType.
func (d DistributionByType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", d.Count)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionByType.
func (d *DistributionByType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &d.Count)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionByVirtualization.
func (d DistributionByVirtualization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", d.Count)
	populate(objectMap, "virtualizationType", d.VirtualizationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionByVirtualization.
func (d *DistributionByVirtualization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &d.Count)
			delete(rawMsg, key)
		case "virtualizationType":
			err = unpopulate(val, "VirtualizationType", &d.VirtualizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DownloadURL.
func (d DownloadURL) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentReportUrl", d.AssessmentReportURL)
	populateDateTimeRFC3339(objectMap, "expirationTime", d.ExpirationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadURL.
func (d *DownloadURL) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentReportUrl":
			err = unpopulate(val, "AssessmentReportURL", &d.AssessmentReportURL)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTime", &d.ExpirationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityUptime.
func (e EntityUptime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "daysPerMonth", e.DaysPerMonth)
	populate(objectMap, "hoursPerDay", e.HoursPerDay)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityUptime.
func (e *EntityUptime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "daysPerMonth":
			err = unpopulate(val, "DaysPerMonth", &e.DaysPerMonth)
			delete(rawMsg, key)
		case "hoursPerDay":
			err = unpopulate(val, "HoursPerDay", &e.HoursPerDay)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentScenario", e.AgentScenario)
	populate(objectMap, "applianceName", e.ApplianceName)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "impactedAssessmentType", e.ImpactedAssessmentType)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "messageParameters", e.MessageParameters)
	populate(objectMap, "possibleCauses", e.PossibleCauses)
	populate(objectMap, "recommendedAction", e.RecommendedAction)
	populate(objectMap, "runAsAccountId", e.RunAsAccountID)
	populate(objectMap, "severity", e.Severity)
	populate(objectMap, "summaryMessage", e.SummaryMessage)
	populateDateTimeRFC3339(objectMap, "updatedTimeStamp", e.UpdatedTimeStamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentScenario":
			err = unpopulate(val, "AgentScenario", &e.AgentScenario)
			delete(rawMsg, key)
		case "applianceName":
			err = unpopulate(val, "ApplianceName", &e.ApplianceName)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "impactedAssessmentType":
			err = unpopulate(val, "ImpactedAssessmentType", &e.ImpactedAssessmentType)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "messageParameters":
			err = unpopulate(val, "MessageParameters", &e.MessageParameters)
			delete(rawMsg, key)
		case "possibleCauses":
			err = unpopulate(val, "PossibleCauses", &e.PossibleCauses)
			delete(rawMsg, key)
		case "recommendedAction":
			err = unpopulate(val, "RecommendedAction", &e.RecommendedAction)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &e.RunAsAccountID)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &e.Severity)
			delete(rawMsg, key)
		case "summaryMessage":
			err = unpopulate(val, "SummaryMessage", &e.SummaryMessage)
			delete(rawMsg, key)
		case "updatedTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimeStamp", &e.UpdatedTimeStamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetailAutoGenerated.
func (e ErrorDetailAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetailAutoGenerated.
func (e *ErrorDetailAutoGenerated) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorSummary.
func (e ErrorSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentType", e.AssessmentType)
	populate(objectMap, "count", e.Count)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorSummary.
func (e *ErrorSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentType":
			err = unpopulate(val, "AssessmentType", &e.AssessmentType)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, "Count", &e.Count)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedCostByOffer.
func (e EstimatedCostByOffer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", e.Cost)
	populate(objectMap, "offerName", e.OfferName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedCostByOffer.
func (e *EstimatedCostByOffer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &e.Cost)
			delete(rawMsg, key)
		case "offerName":
			err = unpopulate(val, "OfferName", &e.OfferName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedCostByTarget.
func (e EstimatedCostByTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appServiceContainerCost", e.AppServiceContainerCost)
	populate(objectMap, "appServiceCost", e.AppServiceCost)
	populate(objectMap, "azureKubernetesServiceCost", e.AzureKubernetesServiceCost)
	populate(objectMap, "azureSqlDbCost", e.AzureSQLDbCost)
	populate(objectMap, "azureSqlMiCost", e.AzureSQLMiCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedCostByTarget.
func (e *EstimatedCostByTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appServiceContainerCost":
			err = unpopulate(val, "AppServiceContainerCost", &e.AppServiceContainerCost)
			delete(rawMsg, key)
		case "appServiceCost":
			err = unpopulate(val, "AppServiceCost", &e.AppServiceCost)
			delete(rawMsg, key)
		case "azureKubernetesServiceCost":
			err = unpopulate(val, "AzureKubernetesServiceCost", &e.AzureKubernetesServiceCost)
			delete(rawMsg, key)
		case "azureSqlDbCost":
			err = unpopulate(val, "AzureSQLDbCost", &e.AzureSQLDbCost)
			delete(rawMsg, key)
		case "azureSqlMiCost":
			err = unpopulate(val, "AzureSQLMiCost", &e.AzureSQLMiCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedExternalStorage.
func (e EstimatedExternalStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storageType", e.StorageType)
	populate(objectMap, "storageUtilization", e.StorageUtilization)
	populate(objectMap, "totalStorageCost", e.TotalStorageCost)
	populate(objectMap, "totalStorageInGB", e.TotalStorageInGB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedExternalStorage.
func (e *EstimatedExternalStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storageType":
			err = unpopulate(val, "StorageType", &e.StorageType)
			delete(rawMsg, key)
		case "storageUtilization":
			err = unpopulate(val, "StorageUtilization", &e.StorageUtilization)
			delete(rawMsg, key)
		case "totalStorageCost":
			err = unpopulate(val, "TotalStorageCost", &e.TotalStorageCost)
			delete(rawMsg, key)
		case "totalStorageInGB":
			err = unpopulate(val, "TotalStorageInGB", &e.TotalStorageInGB)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedNetwork.
func (e EstimatedNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", e.Cost)
	populate(objectMap, "skuType", e.SKUType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedNetwork.
func (e *EstimatedNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &e.Cost)
			delete(rawMsg, key)
		case "skuType":
			err = unpopulate(val, "SKUType", &e.SKUType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedAvsMachine.
func (e EvaluatedAvsMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedAvsMachine.
func (e *EvaluatedAvsMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedAvsMachineListResult.
func (e EvaluatedAvsMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedAvsMachineListResult.
func (e *EvaluatedAvsMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedAvsMachineProperties.
func (e EvaluatedAvsMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityState", e.ActivityState)
	populate(objectMap, "machineId", e.MachineID)
	populate(objectMap, "operatingSystemName", e.OperatingSystemName)
	populate(objectMap, "qualifyingOffer", e.QualifyingOffer)
	populate(objectMap, "readyForMigration", e.ReadyForMigration)
	populate(objectMap, "recommendedAzureTarget", e.RecommendedAzureTarget)
	populate(objectMap, "serverName", e.ServerName)
	populate(objectMap, "supportStatus", e.SupportStatus)
	populate(objectMap, "virtualizationType", e.VirtualizationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedAvsMachineProperties.
func (e *EvaluatedAvsMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityState":
			err = unpopulate(val, "ActivityState", &e.ActivityState)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &e.MachineID)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &e.OperatingSystemName)
			delete(rawMsg, key)
		case "qualifyingOffer":
			err = unpopulate(val, "QualifyingOffer", &e.QualifyingOffer)
			delete(rawMsg, key)
		case "readyForMigration":
			err = unpopulate(val, "ReadyForMigration", &e.ReadyForMigration)
			delete(rawMsg, key)
		case "recommendedAzureTarget":
			err = unpopulate(val, "RecommendedAzureTarget", &e.RecommendedAzureTarget)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &e.ServerName)
			delete(rawMsg, key)
		case "supportStatus":
			err = unpopulate(val, "SupportStatus", &e.SupportStatus)
			delete(rawMsg, key)
		case "virtualizationType":
			err = unpopulate(val, "VirtualizationType", &e.VirtualizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedMachine.
func (e EvaluatedMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedMachine.
func (e *EvaluatedMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedMachineListResult.
func (e EvaluatedMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedMachineListResult.
func (e *EvaluatedMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedMachineProperties.
func (e EvaluatedMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityState", e.ActivityState)
	populate(objectMap, "machineId", e.MachineID)
	populate(objectMap, "operatingSystemName", e.OperatingSystemName)
	populate(objectMap, "qualifyingOffer", e.QualifyingOffer)
	populate(objectMap, "readyForMigration", e.ReadyForMigration)
	populate(objectMap, "recommendedAzureTarget", e.RecommendedAzureTarget)
	populate(objectMap, "serverName", e.ServerName)
	populate(objectMap, "supportStatus", e.SupportStatus)
	populate(objectMap, "virtualizationType", e.VirtualizationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedMachineProperties.
func (e *EvaluatedMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityState":
			err = unpopulate(val, "ActivityState", &e.ActivityState)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &e.MachineID)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &e.OperatingSystemName)
			delete(rawMsg, key)
		case "qualifyingOffer":
			err = unpopulate(val, "QualifyingOffer", &e.QualifyingOffer)
			delete(rawMsg, key)
		case "readyForMigration":
			err = unpopulate(val, "ReadyForMigration", &e.ReadyForMigration)
			delete(rawMsg, key)
		case "recommendedAzureTarget":
			err = unpopulate(val, "RecommendedAzureTarget", &e.RecommendedAzureTarget)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &e.ServerName)
			delete(rawMsg, key)
		case "supportStatus":
			err = unpopulate(val, "SupportStatus", &e.SupportStatus)
			delete(rawMsg, key)
		case "virtualizationType":
			err = unpopulate(val, "VirtualizationType", &e.VirtualizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedSQLEntity.
func (e EvaluatedSQLEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedSQLEntity.
func (e *EvaluatedSQLEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedSQLEntityListResult.
func (e EvaluatedSQLEntityListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedSQLEntityListResult.
func (e *EvaluatedSQLEntityListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedSQLEntityProperties.
func (e EvaluatedSQLEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityState", e.ActivityState)
	populate(objectMap, "dbCount", e.DbCount)
	populate(objectMap, "qualifyingOffer", e.QualifyingOffer)
	populate(objectMap, "readyForMigration", e.ReadyForMigration)
	populate(objectMap, "recommendedAzureTarget", e.RecommendedAzureTarget)
	populate(objectMap, "sqlEdition", e.SQLEdition)
	populate(objectMap, "sqlVersion", e.SQLVersion)
	populate(objectMap, "serverName", e.ServerName)
	populate(objectMap, "supportStatus", e.SupportStatus)
	populate(objectMap, "virtualizationType", e.VirtualizationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedSQLEntityProperties.
func (e *EvaluatedSQLEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityState":
			err = unpopulate(val, "ActivityState", &e.ActivityState)
			delete(rawMsg, key)
		case "dbCount":
			err = unpopulate(val, "DbCount", &e.DbCount)
			delete(rawMsg, key)
		case "qualifyingOffer":
			err = unpopulate(val, "QualifyingOffer", &e.QualifyingOffer)
			delete(rawMsg, key)
		case "readyForMigration":
			err = unpopulate(val, "ReadyForMigration", &e.ReadyForMigration)
			delete(rawMsg, key)
		case "recommendedAzureTarget":
			err = unpopulate(val, "RecommendedAzureTarget", &e.RecommendedAzureTarget)
			delete(rawMsg, key)
		case "sqlEdition":
			err = unpopulate(val, "SQLEdition", &e.SQLEdition)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &e.SQLVersion)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &e.ServerName)
			delete(rawMsg, key)
		case "supportStatus":
			err = unpopulate(val, "SupportStatus", &e.SupportStatus)
			delete(rawMsg, key)
		case "virtualizationType":
			err = unpopulate(val, "VirtualizationType", &e.VirtualizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedWebApp.
func (e EvaluatedWebApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedWebApp.
func (e *EvaluatedWebApp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedWebAppListResult.
func (e EvaluatedWebAppListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedWebAppListResult.
func (e *EvaluatedWebAppListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluatedWebAppProperties.
func (e EvaluatedWebAppProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityState", e.ActivityState)
	populate(objectMap, "readyForMigration", e.ReadyForMigration)
	populate(objectMap, "recommendedAzureSkuName", e.RecommendedAzureSKUName)
	populate(objectMap, "recommendedAzureSkuSize", e.RecommendedAzureSKUSize)
	populate(objectMap, "recommendedAzureTarget", e.RecommendedAzureTarget)
	populate(objectMap, "serverName", e.ServerName)
	populate(objectMap, "workload", e.Workload)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluatedWebAppProperties.
func (e *EvaluatedWebAppProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityState":
			err = unpopulate(val, "ActivityState", &e.ActivityState)
			delete(rawMsg, key)
		case "readyForMigration":
			err = unpopulate(val, "ReadyForMigration", &e.ReadyForMigration)
			delete(rawMsg, key)
		case "recommendedAzureSkuName":
			err = unpopulate(val, "RecommendedAzureSKUName", &e.RecommendedAzureSKUName)
			delete(rawMsg, key)
		case "recommendedAzureSkuSize":
			err = unpopulate(val, "RecommendedAzureSKUSize", &e.RecommendedAzureSKUSize)
			delete(rawMsg, key)
		case "recommendedAzureTarget":
			err = unpopulate(val, "RecommendedAzureTarget", &e.RecommendedAzureTarget)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &e.ServerName)
			delete(rawMsg, key)
		case "workload":
			err = unpopulate(val, "Workload", &e.Workload)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FacilitySettings.
func (f FacilitySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "facilitiesCostPerKwh", f.FacilitiesCostPerKwh)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FacilitySettings.
func (f *FacilitySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "facilitiesCostPerKwh":
			err = unpopulate(val, "FacilitiesCostPerKwh", &f.FacilitiesCostPerKwh)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Group.
func (g Group) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Group.
func (g *Group) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupBodyProperties.
func (g GroupBodyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "machines", g.Machines)
	populate(objectMap, "operationType", g.OperationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupBodyProperties.
func (g *GroupBodyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "machines":
			err = unpopulate(val, "Machines", &g.Machines)
			delete(rawMsg, key)
		case "operationType":
			err = unpopulate(val, "OperationType", &g.OperationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupListResult.
func (g GroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupListResult.
func (g *GroupListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupProperties.
func (g GroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "areAssessmentsRunning", g.AreAssessmentsRunning)
	populate(objectMap, "assessments", g.Assessments)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", g.CreatedTimestamp)
	populate(objectMap, "groupStatus", g.GroupStatus)
	populate(objectMap, "groupType", g.GroupType)
	populate(objectMap, "machineCount", g.MachineCount)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "supportedAssessmentTypes", g.SupportedAssessmentTypes)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", g.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupProperties.
func (g *GroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "areAssessmentsRunning":
			err = unpopulate(val, "AreAssessmentsRunning", &g.AreAssessmentsRunning)
			delete(rawMsg, key)
		case "assessments":
			err = unpopulate(val, "Assessments", &g.Assessments)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &g.CreatedTimestamp)
			delete(rawMsg, key)
		case "groupStatus":
			err = unpopulate(val, "GroupStatus", &g.GroupStatus)
			delete(rawMsg, key)
		case "groupType":
			err = unpopulate(val, "GroupType", &g.GroupType)
			delete(rawMsg, key)
		case "machineCount":
			err = unpopulate(val, "MachineCount", &g.MachineCount)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		case "supportedAssessmentTypes":
			err = unpopulate(val, "SupportedAssessmentTypes", &g.SupportedAssessmentTypes)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &g.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HypervCollector.
func (h HypervCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HypervCollector.
func (h *HypervCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HypervCollectorListResult.
func (h HypervCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HypervCollectorListResult.
func (h *HypervCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HypervLicense.
func (h HypervLicense) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseCost", h.LicenseCost)
	populate(objectMap, "licenseType", h.LicenseType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HypervLicense.
func (h *HypervLicense) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseCost":
			err = unpopulate(val, "LicenseCost", &h.LicenseCost)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, "LicenseType", &h.LicenseType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HypervVirtualizationManagementSettings.
func (h HypervVirtualizationManagementSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseAndSupportList", h.LicenseAndSupportList)
	populate(objectMap, "numberOfPhysicalCoresPerLicense", h.NumberOfPhysicalCoresPerLicense)
	populate(objectMap, "softwareAssuranceCost", h.SoftwareAssuranceCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HypervVirtualizationManagementSettings.
func (h *HypervVirtualizationManagementSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseAndSupportList":
			err = unpopulate(val, "LicenseAndSupportList", &h.LicenseAndSupportList)
			delete(rawMsg, key)
		case "numberOfPhysicalCoresPerLicense":
			err = unpopulate(val, "NumberOfPhysicalCoresPerLicense", &h.NumberOfPhysicalCoresPerLicense)
			delete(rawMsg, key)
		case "softwareAssuranceCost":
			err = unpopulate(val, "SoftwareAssuranceCost", &h.SoftwareAssuranceCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasOsDistribution.
func (i IaasOsDistribution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "linux", i.Linux)
	populate(objectMap, "other", i.Other)
	populate(objectMap, "windows", i.Windows)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasOsDistribution.
func (i *IaasOsDistribution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linux":
			err = unpopulate(val, "Linux", &i.Linux)
			delete(rawMsg, key)
		case "other":
			err = unpopulate(val, "Other", &i.Other)
			delete(rawMsg, key)
		case "windows":
			err = unpopulate(val, "Windows", &i.Windows)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasOsLicensingDetails.
func (i IaasOsLicensingDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "decomissionCost", i.DecomissionCost)
	populate(objectMap, "osType", i.OSType)
	populate(objectMap, "totalCost", i.TotalCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasOsLicensingDetails.
func (i *IaasOsLicensingDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "decomissionCost":
			err = unpopulate(val, "DecomissionCost", &i.DecomissionCost)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &i.OSType)
			delete(rawMsg, key)
		case "totalCost":
			err = unpopulate(val, "TotalCost", &i.TotalCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasSummary.
func (i IaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasSummary.
func (i *IaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasSummaryListResult.
func (i IaasSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasSummaryListResult.
func (i *IaasSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IaasSummaryProperties.
func (i IaasSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureIaasSummary", i.AzureIaasSummary)
	populate(objectMap, "onPremisesIaasSummary", i.OnPremisesIaasSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IaasSummaryProperties.
func (i *IaasSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureIaasSummary":
			err = unpopulate(val, "AzureIaasSummary", &i.AzureIaasSummary)
			delete(rawMsg, key)
		case "onPremisesIaasSummary":
			err = unpopulate(val, "OnPremisesIaasSummary", &i.OnPremisesIaasSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImpactedAssessmentObject.
func (i ImpactedAssessmentObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "objectName", i.ObjectName)
	populate(objectMap, "objectType", i.ObjectType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpactedAssessmentObject.
func (i *ImpactedAssessmentObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectName":
			err = unpopulate(val, "ObjectName", &i.ObjectName)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &i.ObjectType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImportCollector.
func (i ImportCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImportCollector.
func (i *ImportCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImportCollectorListResult.
func (i ImportCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImportCollectorListResult.
func (i *ImportCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LaborSettings.
func (l LaborSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hourlyAdminCost", l.HourlyAdminCost)
	populate(objectMap, "physicalServersPerAdmin", l.PhysicalServersPerAdmin)
	populate(objectMap, "virtualMachinesPerAdmin", l.VirtualMachinesPerAdmin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LaborSettings.
func (l *LaborSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hourlyAdminCost":
			err = unpopulate(val, "HourlyAdminCost", &l.HourlyAdminCost)
			delete(rawMsg, key)
		case "physicalServersPerAdmin":
			err = unpopulate(val, "PhysicalServersPerAdmin", &l.PhysicalServersPerAdmin)
			delete(rawMsg, key)
		case "virtualMachinesPerAdmin":
			err = unpopulate(val, "VirtualMachinesPerAdmin", &l.VirtualMachinesPerAdmin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinuxServerLicensingSettings.
func (l LinuxServerLicensingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseCost", l.LicenseCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinuxServerLicensingSettings.
func (l *LinuxServerLicensingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseCost":
			err = unpopulate(val, "LicenseCost", &l.LicenseCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Machine.
func (m Machine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Machine.
func (m *Machine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineAssessmentProperties.
func (m MachineAssessmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentErrorSummary", m.AssessmentErrorSummary)
	populate(objectMap, "assessmentType", m.AssessmentType)
	populate(objectMap, "azureDiskTypes", m.AzureDiskTypes)
	populate(objectMap, "azureHybridUseBenefit", m.AzureHybridUseBenefit)
	populate(objectMap, "azureLocation", m.AzureLocation)
	populate(objectMap, "azureOfferCode", m.AzureOfferCode)
	populate(objectMap, "azurePricingTier", m.AzurePricingTier)
	populate(objectMap, "azureStorageRedundancy", m.AzureStorageRedundancy)
	populate(objectMap, "azureVmFamilies", m.AzureVMFamilies)
	populate(objectMap, "confidenceRatingInPercentage", m.ConfidenceRatingInPercentage)
	populate(objectMap, "costComponents", m.CostComponents)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", m.CreatedTimestamp)
	populate(objectMap, "currency", m.Currency)
	populate(objectMap, "discountPercentage", m.DiscountPercentage)
	populate(objectMap, "distributionByOsName", m.DistributionByOsName)
	populate(objectMap, "distributionByServicePackInsight", m.DistributionByServicePackInsight)
	populate(objectMap, "distributionBySupportStatus", m.DistributionBySupportStatus)
	populate(objectMap, "eaSubscriptionId", m.EaSubscriptionID)
	populate(objectMap, "groupType", m.GroupType)
	populate(objectMap, "linuxAzureHybridUseBenefit", m.LinuxAzureHybridUseBenefit)
	populate(objectMap, "monthlyBandwidthCost", m.MonthlyBandwidthCost)
	populate(objectMap, "monthlyComputeCost", m.MonthlyComputeCost)
	populate(objectMap, "monthlyPremiumStorageCost", m.MonthlyPremiumStorageCost)
	populate(objectMap, "monthlyStandardSsdStorageCost", m.MonthlyStandardSsdStorageCost)
	populate(objectMap, "monthlyStorageCost", m.MonthlyStorageCost)
	populate(objectMap, "monthlyUltraStorageCost", m.MonthlyUltraStorageCost)
	populate(objectMap, "numberOfMachines", m.NumberOfMachines)
	populate(objectMap, "percentile", m.Percentile)
	populateDateTimeRFC3339(objectMap, "perfDataEndTime", m.PerfDataEndTime)
	populateDateTimeRFC3339(objectMap, "perfDataStartTime", m.PerfDataStartTime)
	populateDateTimeRFC3339(objectMap, "pricesTimestamp", m.PricesTimestamp)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "reservedInstance", m.ReservedInstance)
	populate(objectMap, "scalingFactor", m.ScalingFactor)
	populate(objectMap, "schemaVersion", m.SchemaVersion)
	populate(objectMap, "sizingCriterion", m.SizingCriterion)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "suitabilitySummary", m.SuitabilitySummary)
	populate(objectMap, "timeRange", m.TimeRange)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", m.UpdatedTimestamp)
	populate(objectMap, "vmUptime", m.VMUptime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineAssessmentProperties.
func (m *MachineAssessmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentErrorSummary":
			err = unpopulate(val, "AssessmentErrorSummary", &m.AssessmentErrorSummary)
			delete(rawMsg, key)
		case "assessmentType":
			err = unpopulate(val, "AssessmentType", &m.AssessmentType)
			delete(rawMsg, key)
		case "azureDiskTypes":
			err = unpopulate(val, "AzureDiskTypes", &m.AzureDiskTypes)
			delete(rawMsg, key)
		case "azureHybridUseBenefit":
			err = unpopulate(val, "AzureHybridUseBenefit", &m.AzureHybridUseBenefit)
			delete(rawMsg, key)
		case "azureLocation":
			err = unpopulate(val, "AzureLocation", &m.AzureLocation)
			delete(rawMsg, key)
		case "azureOfferCode":
			err = unpopulate(val, "AzureOfferCode", &m.AzureOfferCode)
			delete(rawMsg, key)
		case "azurePricingTier":
			err = unpopulate(val, "AzurePricingTier", &m.AzurePricingTier)
			delete(rawMsg, key)
		case "azureStorageRedundancy":
			err = unpopulate(val, "AzureStorageRedundancy", &m.AzureStorageRedundancy)
			delete(rawMsg, key)
		case "azureVmFamilies":
			err = unpopulate(val, "AzureVMFamilies", &m.AzureVMFamilies)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &m.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &m.CostComponents)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &m.CreatedTimestamp)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &m.Currency)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &m.DiscountPercentage)
			delete(rawMsg, key)
		case "distributionByOsName":
			err = unpopulate(val, "DistributionByOsName", &m.DistributionByOsName)
			delete(rawMsg, key)
		case "distributionByServicePackInsight":
			err = unpopulate(val, "DistributionByServicePackInsight", &m.DistributionByServicePackInsight)
			delete(rawMsg, key)
		case "distributionBySupportStatus":
			err = unpopulate(val, "DistributionBySupportStatus", &m.DistributionBySupportStatus)
			delete(rawMsg, key)
		case "eaSubscriptionId":
			err = unpopulate(val, "EaSubscriptionID", &m.EaSubscriptionID)
			delete(rawMsg, key)
		case "groupType":
			err = unpopulate(val, "GroupType", &m.GroupType)
			delete(rawMsg, key)
		case "linuxAzureHybridUseBenefit":
			err = unpopulate(val, "LinuxAzureHybridUseBenefit", &m.LinuxAzureHybridUseBenefit)
			delete(rawMsg, key)
		case "monthlyBandwidthCost":
			err = unpopulate(val, "MonthlyBandwidthCost", &m.MonthlyBandwidthCost)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &m.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyPremiumStorageCost":
			err = unpopulate(val, "MonthlyPremiumStorageCost", &m.MonthlyPremiumStorageCost)
			delete(rawMsg, key)
		case "monthlyStandardSsdStorageCost":
			err = unpopulate(val, "MonthlyStandardSsdStorageCost", &m.MonthlyStandardSsdStorageCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &m.MonthlyStorageCost)
			delete(rawMsg, key)
		case "monthlyUltraStorageCost":
			err = unpopulate(val, "MonthlyUltraStorageCost", &m.MonthlyUltraStorageCost)
			delete(rawMsg, key)
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &m.NumberOfMachines)
			delete(rawMsg, key)
		case "percentile":
			err = unpopulate(val, "Percentile", &m.Percentile)
			delete(rawMsg, key)
		case "perfDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataEndTime", &m.PerfDataEndTime)
			delete(rawMsg, key)
		case "perfDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataStartTime", &m.PerfDataStartTime)
			delete(rawMsg, key)
		case "pricesTimestamp":
			err = unpopulateDateTimeRFC3339(val, "PricesTimestamp", &m.PricesTimestamp)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		case "reservedInstance":
			err = unpopulate(val, "ReservedInstance", &m.ReservedInstance)
			delete(rawMsg, key)
		case "scalingFactor":
			err = unpopulate(val, "ScalingFactor", &m.ScalingFactor)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &m.SchemaVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &m.SizingCriterion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, "Stage", &m.Stage)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &m.Status)
			delete(rawMsg, key)
		case "suitabilitySummary":
			err = unpopulate(val, "SuitabilitySummary", &m.SuitabilitySummary)
			delete(rawMsg, key)
		case "timeRange":
			err = unpopulate(val, "TimeRange", &m.TimeRange)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &m.UpdatedTimestamp)
			delete(rawMsg, key)
		case "vmUptime":
			err = unpopulate(val, "VMUptime", &m.VMUptime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineListResult.
func (m MachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineListResult.
func (m *MachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineProperties.
func (m MachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bootType", m.BootType)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", m.CreatedTimestamp)
	populate(objectMap, "datacenterManagementServerArmId", m.DatacenterManagementServerArmID)
	populate(objectMap, "datacenterManagementServerName", m.DatacenterManagementServerName)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "discoveryMachineArmId", m.DiscoveryMachineArmID)
	populate(objectMap, "disks", m.Disks)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "groups", m.Groups)
	populate(objectMap, "hostProcessor", m.HostProcessor)
	populate(objectMap, "megabytesOfMemory", m.MegabytesOfMemory)
	populate(objectMap, "networkAdapters", m.NetworkAdapters)
	populate(objectMap, "numberOfCores", m.NumberOfCores)
	populate(objectMap, "operatingSystemName", m.OperatingSystemName)
	populate(objectMap, "operatingSystemType", m.OperatingSystemType)
	populate(objectMap, "operatingSystemVersion", m.OperatingSystemVersion)
	populate(objectMap, "productSupportStatus", m.ProductSupportStatus)
	populate(objectMap, "sqlInstances", m.SQLInstances)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", m.UpdatedTimestamp)
	populate(objectMap, "webApplications", m.WebApplications)
	populate(objectMap, "workloadSummary", m.WorkloadSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineProperties.
func (m *MachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bootType":
			err = unpopulate(val, "BootType", &m.BootType)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &m.CreatedTimestamp)
			delete(rawMsg, key)
		case "datacenterManagementServerArmId":
			err = unpopulate(val, "DatacenterManagementServerArmID", &m.DatacenterManagementServerArmID)
			delete(rawMsg, key)
		case "datacenterManagementServerName":
			err = unpopulate(val, "DatacenterManagementServerName", &m.DatacenterManagementServerName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "discoveryMachineArmId":
			err = unpopulate(val, "DiscoveryMachineArmID", &m.DiscoveryMachineArmID)
			delete(rawMsg, key)
		case "disks":
			err = unpopulate(val, "Disks", &m.Disks)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &m.Errors)
			delete(rawMsg, key)
		case "groups":
			err = unpopulate(val, "Groups", &m.Groups)
			delete(rawMsg, key)
		case "hostProcessor":
			err = unpopulate(val, "HostProcessor", &m.HostProcessor)
			delete(rawMsg, key)
		case "megabytesOfMemory":
			err = unpopulate(val, "MegabytesOfMemory", &m.MegabytesOfMemory)
			delete(rawMsg, key)
		case "networkAdapters":
			err = unpopulate(val, "NetworkAdapters", &m.NetworkAdapters)
			delete(rawMsg, key)
		case "numberOfCores":
			err = unpopulate(val, "NumberOfCores", &m.NumberOfCores)
			delete(rawMsg, key)
		case "operatingSystemName":
			err = unpopulate(val, "OperatingSystemName", &m.OperatingSystemName)
			delete(rawMsg, key)
		case "operatingSystemType":
			err = unpopulate(val, "OperatingSystemType", &m.OperatingSystemType)
			delete(rawMsg, key)
		case "operatingSystemVersion":
			err = unpopulate(val, "OperatingSystemVersion", &m.OperatingSystemVersion)
			delete(rawMsg, key)
		case "productSupportStatus":
			err = unpopulate(val, "ProductSupportStatus", &m.ProductSupportStatus)
			delete(rawMsg, key)
		case "sqlInstances":
			err = unpopulate(val, "SQLInstances", &m.SQLInstances)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &m.UpdatedTimestamp)
			delete(rawMsg, key)
		case "webApplications":
			err = unpopulate(val, "WebApplications", &m.WebApplications)
			delete(rawMsg, key)
		case "workloadSummary":
			err = unpopulate(val, "WorkloadSummary", &m.WorkloadSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementCostComponent.
func (m ManagementCostComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementCostComponent.
func (m *ManagementCostComponent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementCostDetails.
func (m ManagementCostDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "managementCost", m.ManagementCost)
	populate(objectMap, "managementCostComponents", m.ManagementCostComponents)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementCostDetails.
func (m *ManagementCostDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managementCost":
			err = unpopulate(val, "ManagementCost", &m.ManagementCost)
			delete(rawMsg, key)
		case "managementCostComponents":
			err = unpopulate(val, "ManagementCostComponents", &m.ManagementCostComponents)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementSettings.
func (m ManagementSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hypervVirtualizationManagementSettings", m.HypervVirtualizationManagementSettings)
	populate(objectMap, "otherManagementCostsSettings", m.OtherManagementCostsSettings)
	populate(objectMap, "thirdPartyManagementSettings", m.ThirdPartyManagementSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementSettings.
func (m *ManagementSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hypervVirtualizationManagementSettings":
			err = unpopulate(val, "HypervVirtualizationManagementSettings", &m.HypervVirtualizationManagementSettings)
			delete(rawMsg, key)
		case "otherManagementCostsSettings":
			err = unpopulate(val, "OtherManagementCostsSettings", &m.OtherManagementCostsSettings)
			delete(rawMsg, key)
		case "thirdPartyManagementSettings":
			err = unpopulate(val, "ThirdPartyManagementSettings", &m.ThirdPartyManagementSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MigrationGuidelineContext.
func (m MigrationGuidelineContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextKey", m.ContextKey)
	populate(objectMap, "contextValue", m.ContextValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationGuidelineContext.
func (m *MigrationGuidelineContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextKey":
			err = unpopulate(val, "ContextKey", &m.ContextKey)
			delete(rawMsg, key)
		case "contextValue":
			err = unpopulate(val, "ContextValue", &m.ContextValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MoreInfo.
func (m MoreInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "title", m.Title)
	populate(objectMap, "url", m.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MoreInfo.
func (m *MoreInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "title":
			err = unpopulate(val, "Title", &m.Title)
			delete(rawMsg, key)
		case "url":
			err = unpopulate(val, "URL", &m.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAdapter.
func (n NetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", n.DisplayName)
	populate(objectMap, "ipAddresses", n.IPAddresses)
	populate(objectMap, "macAddress", n.MacAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAdapter.
func (n *NetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &n.DisplayName)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &n.IPAddresses)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &n.MacAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSettings.
func (n NetworkSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hardwareSoftwareCostPercentage", n.HardwareSoftwareCostPercentage)
	populate(objectMap, "maintenanceCostPercentage", n.MaintenanceCostPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSettings.
func (n *NetworkSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hardwareSoftwareCostPercentage":
			err = unpopulate(val, "HardwareSoftwareCostPercentage", &n.HardwareSoftwareCostPercentage)
			delete(rawMsg, key)
		case "maintenanceCostPercentage":
			err = unpopulate(val, "MaintenanceCostPercentage", &n.MaintenanceCostPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePool.
func (n NodePool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "armSkuName", n.ArmSKUName)
	populate(objectMap, "clusterName", n.ClusterName)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "mode", n.Mode)
	populate(objectMap, "monthlyCost", n.MonthlyCost)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "nodeCount", n.NodeCount)
	populate(objectMap, "osType", n.OSType)
	populate(objectMap, "podApproxMonthlyCost", n.PodApproxMonthlyCost)
	populate(objectMap, "podCount", n.PodCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePool.
func (n *NodePool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "armSkuName":
			err = unpopulate(val, "ArmSKUName", &n.ArmSKUName)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &n.ClusterName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &n.Mode)
			delete(rawMsg, key)
		case "monthlyCost":
			err = unpopulate(val, "MonthlyCost", &n.MonthlyCost)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &n.NodeCount)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &n.OSType)
			delete(rawMsg, key)
		case "podApproxMonthlyCost":
			err = unpopulate(val, "PodApproxMonthlyCost", &n.PodApproxMonthlyCost)
			delete(rawMsg, key)
		case "podCount":
			err = unpopulate(val, "PodCount", &n.PodCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremiseSettings.
func (o OnPremiseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeSettings", o.ComputeSettings)
	populate(objectMap, "facilitySettings", o.FacilitySettings)
	populate(objectMap, "laborSettings", o.LaborSettings)
	populate(objectMap, "managementSettings", o.ManagementSettings)
	populate(objectMap, "networkSettings", o.NetworkSettings)
	populate(objectMap, "securitySettings", o.SecuritySettings)
	populate(objectMap, "storageSettings", o.StorageSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremiseSettings.
func (o *OnPremiseSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeSettings":
			err = unpopulate(val, "ComputeSettings", &o.ComputeSettings)
			delete(rawMsg, key)
		case "facilitySettings":
			err = unpopulate(val, "FacilitySettings", &o.FacilitySettings)
			delete(rawMsg, key)
		case "laborSettings":
			err = unpopulate(val, "LaborSettings", &o.LaborSettings)
			delete(rawMsg, key)
		case "managementSettings":
			err = unpopulate(val, "ManagementSettings", &o.ManagementSettings)
			delete(rawMsg, key)
		case "networkSettings":
			err = unpopulate(val, "NetworkSettings", &o.NetworkSettings)
			delete(rawMsg, key)
		case "securitySettings":
			err = unpopulate(val, "SecuritySettings", &o.SecuritySettings)
			delete(rawMsg, key)
		case "storageSettings":
			err = unpopulate(val, "StorageSettings", &o.StorageSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesIaasSummary.
func (o OnPremisesIaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuUtilization", o.CPUUtilization)
	populate(objectMap, "cores", o.Cores)
	populate(objectMap, "distributionByOperatingSystem", o.DistributionByOperatingSystem)
	populate(objectMap, "distributionByOperatingSystemVersion", o.DistributionByOperatingSystemVersion)
	populate(objectMap, "distributionBySqlEdition", o.DistributionBySQLEdition)
	populate(objectMap, "distributionBySqlVersion", o.DistributionBySQLVersion)
	populate(objectMap, "distributionByVirtualization", o.DistributionByVirtualization)
	populate(objectMap, "iaasOsSupportStatusDistribution", o.IaasOsSupportStatusDistribution)
	populate(objectMap, "iaasSqlSupportStatusDistribution", o.IaasSQLSupportStatusDistribution)
	populate(objectMap, "memoryGb", o.MemoryGb)
	populate(objectMap, "memoryUtilization", o.MemoryUtilization)
	populate(objectMap, "osLicensingDetails", o.OSLicensingDetails)
	populate(objectMap, "osServicePackInsight", o.OSServicePackInsight)
	populate(objectMap, "onPremisesIaasCostDetails", o.OnPremisesIaasCostDetails)
	populate(objectMap, "onPremisesIaasCostForDecommissioned", o.OnPremisesIaasCostForDecommissioned)
	populate(objectMap, "onPremisesUtilizationData", o.OnPremisesUtilizationData)
	populate(objectMap, "sqlServicePackInsight", o.SQLServicePackInsight)
	populate(objectMap, "servers", o.Servers)
	populate(objectMap, "storageUtilization", o.StorageUtilization)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesIaasSummary.
func (o *OnPremisesIaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuUtilization":
			err = unpopulate(val, "CPUUtilization", &o.CPUUtilization)
			delete(rawMsg, key)
		case "cores":
			err = unpopulate(val, "Cores", &o.Cores)
			delete(rawMsg, key)
		case "distributionByOperatingSystem":
			err = unpopulate(val, "DistributionByOperatingSystem", &o.DistributionByOperatingSystem)
			delete(rawMsg, key)
		case "distributionByOperatingSystemVersion":
			err = unpopulate(val, "DistributionByOperatingSystemVersion", &o.DistributionByOperatingSystemVersion)
			delete(rawMsg, key)
		case "distributionBySqlEdition":
			err = unpopulate(val, "DistributionBySQLEdition", &o.DistributionBySQLEdition)
			delete(rawMsg, key)
		case "distributionBySqlVersion":
			err = unpopulate(val, "DistributionBySQLVersion", &o.DistributionBySQLVersion)
			delete(rawMsg, key)
		case "distributionByVirtualization":
			err = unpopulate(val, "DistributionByVirtualization", &o.DistributionByVirtualization)
			delete(rawMsg, key)
		case "iaasOsSupportStatusDistribution":
			err = unpopulate(val, "IaasOsSupportStatusDistribution", &o.IaasOsSupportStatusDistribution)
			delete(rawMsg, key)
		case "iaasSqlSupportStatusDistribution":
			err = unpopulate(val, "IaasSQLSupportStatusDistribution", &o.IaasSQLSupportStatusDistribution)
			delete(rawMsg, key)
		case "memoryGb":
			err = unpopulate(val, "MemoryGb", &o.MemoryGb)
			delete(rawMsg, key)
		case "memoryUtilization":
			err = unpopulate(val, "MemoryUtilization", &o.MemoryUtilization)
			delete(rawMsg, key)
		case "osLicensingDetails":
			err = unpopulate(val, "OSLicensingDetails", &o.OSLicensingDetails)
			delete(rawMsg, key)
		case "osServicePackInsight":
			err = unpopulate(val, "OSServicePackInsight", &o.OSServicePackInsight)
			delete(rawMsg, key)
		case "onPremisesIaasCostDetails":
			err = unpopulate(val, "OnPremisesIaasCostDetails", &o.OnPremisesIaasCostDetails)
			delete(rawMsg, key)
		case "onPremisesIaasCostForDecommissioned":
			err = unpopulate(val, "OnPremisesIaasCostForDecommissioned", &o.OnPremisesIaasCostForDecommissioned)
			delete(rawMsg, key)
		case "onPremisesUtilizationData":
			err = unpopulate(val, "OnPremisesUtilizationData", &o.OnPremisesUtilizationData)
			delete(rawMsg, key)
		case "sqlServicePackInsight":
			err = unpopulate(val, "SQLServicePackInsight", &o.SQLServicePackInsight)
			delete(rawMsg, key)
		case "servers":
			err = unpopulate(val, "Servers", &o.Servers)
			delete(rawMsg, key)
		case "storageUtilization":
			err = unpopulate(val, "StorageUtilization", &o.StorageUtilization)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesPaasLicensingCost.
func (o OnPremisesPaasLicensingCost) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "decomissionServerCost", o.DecomissionServerCost)
	populate(objectMap, "totalCost", o.TotalCost)
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesPaasLicensingCost.
func (o *OnPremisesPaasLicensingCost) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "decomissionServerCost":
			err = unpopulate(val, "DecomissionServerCost", &o.DecomissionServerCost)
			delete(rawMsg, key)
		case "totalCost":
			err = unpopulate(val, "TotalCost", &o.TotalCost)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesPaasSummary.
func (o OnPremisesPaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuUtilization", o.CPUUtilization)
	populate(objectMap, "memoryUtilization", o.MemoryUtilization)
	populate(objectMap, "osServicePackInsight", o.OSServicePackInsight)
	populate(objectMap, "osSupportStatusDistribution", o.OSSupportStatusDistribution)
	populate(objectMap, "onPremisesPaasCostForDecommisioned", o.OnPremisesPaasCostForDecommisioned)
	populate(objectMap, "onPremisesPaasLicensingCost", o.OnPremisesPaasLicensingCost)
	populate(objectMap, "onPremisesSqlSummary", o.OnPremisesSQLSummary)
	populate(objectMap, "onPremisesWebAppSummary", o.OnPremisesWebAppSummary)
	populate(objectMap, "sqlServicePackInsight", o.SQLServicePackInsight)
	populate(objectMap, "sqlSupportStatusDistribution", o.SQLSupportStatusDistribution)
	populate(objectMap, "totalOnPremisesPaasCost", o.TotalOnPremisesPaasCost)
	populate(objectMap, "totalServers", o.TotalServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesPaasSummary.
func (o *OnPremisesPaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuUtilization":
			err = unpopulate(val, "CPUUtilization", &o.CPUUtilization)
			delete(rawMsg, key)
		case "memoryUtilization":
			err = unpopulate(val, "MemoryUtilization", &o.MemoryUtilization)
			delete(rawMsg, key)
		case "osServicePackInsight":
			err = unpopulate(val, "OSServicePackInsight", &o.OSServicePackInsight)
			delete(rawMsg, key)
		case "osSupportStatusDistribution":
			err = unpopulate(val, "OSSupportStatusDistribution", &o.OSSupportStatusDistribution)
			delete(rawMsg, key)
		case "onPremisesPaasCostForDecommisioned":
			err = unpopulate(val, "OnPremisesPaasCostForDecommisioned", &o.OnPremisesPaasCostForDecommisioned)
			delete(rawMsg, key)
		case "onPremisesPaasLicensingCost":
			err = unpopulate(val, "OnPremisesPaasLicensingCost", &o.OnPremisesPaasLicensingCost)
			delete(rawMsg, key)
		case "onPremisesSqlSummary":
			err = unpopulate(val, "OnPremisesSQLSummary", &o.OnPremisesSQLSummary)
			delete(rawMsg, key)
		case "onPremisesWebAppSummary":
			err = unpopulate(val, "OnPremisesWebAppSummary", &o.OnPremisesWebAppSummary)
			delete(rawMsg, key)
		case "sqlServicePackInsight":
			err = unpopulate(val, "SQLServicePackInsight", &o.SQLServicePackInsight)
			delete(rawMsg, key)
		case "sqlSupportStatusDistribution":
			err = unpopulate(val, "SQLSupportStatusDistribution", &o.SQLSupportStatusDistribution)
			delete(rawMsg, key)
		case "totalOnPremisesPaasCost":
			err = unpopulate(val, "TotalOnPremisesPaasCost", &o.TotalOnPremisesPaasCost)
			delete(rawMsg, key)
		case "totalServers":
			err = unpopulate(val, "TotalServers", &o.TotalServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesSQLSummary.
func (o OnPremisesSQLSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionBySqlEdition", o.DistributionBySQLEdition)
	populate(objectMap, "distributionBySqlVersion", o.DistributionBySQLVersion)
	populate(objectMap, "sqlDatabases", o.SQLDatabases)
	populate(objectMap, "sqlInstances", o.SQLInstances)
	populate(objectMap, "sqlOnPremisesUtilizationData", o.SQLOnPremisesUtilizationData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesSQLSummary.
func (o *OnPremisesSQLSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionBySqlEdition":
			err = unpopulate(val, "DistributionBySQLEdition", &o.DistributionBySQLEdition)
			delete(rawMsg, key)
		case "distributionBySqlVersion":
			err = unpopulate(val, "DistributionBySQLVersion", &o.DistributionBySQLVersion)
			delete(rawMsg, key)
		case "sqlDatabases":
			err = unpopulate(val, "SQLDatabases", &o.SQLDatabases)
			delete(rawMsg, key)
		case "sqlInstances":
			err = unpopulate(val, "SQLInstances", &o.SQLInstances)
			delete(rawMsg, key)
		case "sqlOnPremisesUtilizationData":
			err = unpopulate(val, "SQLOnPremisesUtilizationData", &o.SQLOnPremisesUtilizationData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesWebAppSummary.
func (o OnPremisesWebAppSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfWebApplications", o.NumberOfWebApplications)
	populate(objectMap, "numberOfWebAppsPerType", o.NumberOfWebAppsPerType)
	populate(objectMap, "numberOfWebServers", o.NumberOfWebServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesWebAppSummary.
func (o *OnPremisesWebAppSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfWebApplications":
			err = unpopulate(val, "NumberOfWebApplications", &o.NumberOfWebApplications)
			delete(rawMsg, key)
		case "numberOfWebAppsPerType":
			err = unpopulate(val, "NumberOfWebAppsPerType", &o.NumberOfWebAppsPerType)
			delete(rawMsg, key)
		case "numberOfWebServers":
			err = unpopulate(val, "NumberOfWebServers", &o.NumberOfWebServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OtherManagementCostsSettings.
func (o OtherManagementCostsSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataProtectionCostPerServerPerYear", o.DataProtectionCostPerServerPerYear)
	populate(objectMap, "monitoringCostPerServerPerYear", o.MonitoringCostPerServerPerYear)
	populate(objectMap, "patchingCostPerServerPerYear", o.PatchingCostPerServerPerYear)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OtherManagementCostsSettings.
func (o *OtherManagementCostsSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataProtectionCostPerServerPerYear":
			err = unpopulate(val, "DataProtectionCostPerServerPerYear", &o.DataProtectionCostPerServerPerYear)
			delete(rawMsg, key)
		case "monitoringCostPerServerPerYear":
			err = unpopulate(val, "MonitoringCostPerServerPerYear", &o.MonitoringCostPerServerPerYear)
			delete(rawMsg, key)
		case "patchingCostPerServerPerYear":
			err = unpopulate(val, "PatchingCostPerServerPerYear", &o.PatchingCostPerServerPerYear)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OverviewSummary.
func (o OverviewSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OverviewSummary.
func (o *OverviewSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OverviewSummaryListResult.
func (o OverviewSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OverviewSummaryListResult.
func (o *OverviewSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OverviewSummaryProperties.
func (o OverviewSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureArcEnabledOnPremisesCost", o.AzureArcEnabledOnPremisesCost)
	populate(objectMap, "azureArcServicesCost", o.AzureArcServicesCost)
	populate(objectMap, "esuSavingsFor4years", o.EsuSavingsFor4Years)
	populate(objectMap, "futureAzureArcEnabledOnPremisesCost", o.FutureAzureArcEnabledOnPremisesCost)
	populate(objectMap, "futureAzureArcServicesCost", o.FutureAzureArcServicesCost)
	populate(objectMap, "futureAzureIaasCost", o.FutureAzureIaasCost)
	populate(objectMap, "futureAzurePaasCost", o.FutureAzurePaasCost)
	populate(objectMap, "futureCostIncludingAzureArc", o.FutureCostIncludingAzureArc)
	populate(objectMap, "futureEsuSavingsFor4YearsIncludingAzureArc", o.FutureEsuSavingsFor4YearsIncludingAzureArc)
	populate(objectMap, "futureManagementCostSavingsIncludingAzureArc", o.FutureManagementCostSavingsIncludingAzureArc)
	populate(objectMap, "futureSecurityCostSavingsIncludingAzureArc", o.FutureSecurityCostSavingsIncludingAzureArc)
	populate(objectMap, "iaasOsDistribution", o.IaasOsDistribution)
	populate(objectMap, "linuxAhubSavings", o.LinuxAhubSavings)
	populate(objectMap, "managementCostSavings", o.ManagementCostSavings)
	populate(objectMap, "osSupportStatusDistribution", o.OSSupportStatusDistribution)
	populate(objectMap, "paasDistribution", o.PaasDistribution)
	populate(objectMap, "sqlAhubSavings", o.SQLAhubSavings)
	populate(objectMap, "sqlSupportStatusDistribution", o.SQLSupportStatusDistribution)
	populate(objectMap, "securityCostSavings", o.SecurityCostSavings)
	populate(objectMap, "serversDiscovered", o.ServersDiscovered)
	populate(objectMap, "totalAzureAvsCost", o.TotalAzureAvsCost)
	populate(objectMap, "totalAzureCost", o.TotalAzureCost)
	populate(objectMap, "totalAzureIaasCost", o.TotalAzureIaasCost)
	populate(objectMap, "totalAzurePaasCost", o.TotalAzurePaasCost)
	populate(objectMap, "totalOnPremisesCost", o.TotalOnPremisesCost)
	populate(objectMap, "utilizationData", o.UtilizationData)
	populate(objectMap, "windowsAhubSavings", o.WindowsAhubSavings)
	populate(objectMap, "yearOnYearEstimates", o.YearOnYearEstimates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OverviewSummaryProperties.
func (o *OverviewSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureArcEnabledOnPremisesCost":
			err = unpopulate(val, "AzureArcEnabledOnPremisesCost", &o.AzureArcEnabledOnPremisesCost)
			delete(rawMsg, key)
		case "azureArcServicesCost":
			err = unpopulate(val, "AzureArcServicesCost", &o.AzureArcServicesCost)
			delete(rawMsg, key)
		case "esuSavingsFor4years":
			err = unpopulate(val, "EsuSavingsFor4Years", &o.EsuSavingsFor4Years)
			delete(rawMsg, key)
		case "futureAzureArcEnabledOnPremisesCost":
			err = unpopulate(val, "FutureAzureArcEnabledOnPremisesCost", &o.FutureAzureArcEnabledOnPremisesCost)
			delete(rawMsg, key)
		case "futureAzureArcServicesCost":
			err = unpopulate(val, "FutureAzureArcServicesCost", &o.FutureAzureArcServicesCost)
			delete(rawMsg, key)
		case "futureAzureIaasCost":
			err = unpopulate(val, "FutureAzureIaasCost", &o.FutureAzureIaasCost)
			delete(rawMsg, key)
		case "futureAzurePaasCost":
			err = unpopulate(val, "FutureAzurePaasCost", &o.FutureAzurePaasCost)
			delete(rawMsg, key)
		case "futureCostIncludingAzureArc":
			err = unpopulate(val, "FutureCostIncludingAzureArc", &o.FutureCostIncludingAzureArc)
			delete(rawMsg, key)
		case "futureEsuSavingsFor4YearsIncludingAzureArc":
			err = unpopulate(val, "FutureEsuSavingsFor4YearsIncludingAzureArc", &o.FutureEsuSavingsFor4YearsIncludingAzureArc)
			delete(rawMsg, key)
		case "futureManagementCostSavingsIncludingAzureArc":
			err = unpopulate(val, "FutureManagementCostSavingsIncludingAzureArc", &o.FutureManagementCostSavingsIncludingAzureArc)
			delete(rawMsg, key)
		case "futureSecurityCostSavingsIncludingAzureArc":
			err = unpopulate(val, "FutureSecurityCostSavingsIncludingAzureArc", &o.FutureSecurityCostSavingsIncludingAzureArc)
			delete(rawMsg, key)
		case "iaasOsDistribution":
			err = unpopulate(val, "IaasOsDistribution", &o.IaasOsDistribution)
			delete(rawMsg, key)
		case "linuxAhubSavings":
			err = unpopulate(val, "LinuxAhubSavings", &o.LinuxAhubSavings)
			delete(rawMsg, key)
		case "managementCostSavings":
			err = unpopulate(val, "ManagementCostSavings", &o.ManagementCostSavings)
			delete(rawMsg, key)
		case "osSupportStatusDistribution":
			err = unpopulate(val, "OSSupportStatusDistribution", &o.OSSupportStatusDistribution)
			delete(rawMsg, key)
		case "paasDistribution":
			err = unpopulate(val, "PaasDistribution", &o.PaasDistribution)
			delete(rawMsg, key)
		case "sqlAhubSavings":
			err = unpopulate(val, "SQLAhubSavings", &o.SQLAhubSavings)
			delete(rawMsg, key)
		case "sqlSupportStatusDistribution":
			err = unpopulate(val, "SQLSupportStatusDistribution", &o.SQLSupportStatusDistribution)
			delete(rawMsg, key)
		case "securityCostSavings":
			err = unpopulate(val, "SecurityCostSavings", &o.SecurityCostSavings)
			delete(rawMsg, key)
		case "serversDiscovered":
			err = unpopulate(val, "ServersDiscovered", &o.ServersDiscovered)
			delete(rawMsg, key)
		case "totalAzureAvsCost":
			err = unpopulate(val, "TotalAzureAvsCost", &o.TotalAzureAvsCost)
			delete(rawMsg, key)
		case "totalAzureCost":
			err = unpopulate(val, "TotalAzureCost", &o.TotalAzureCost)
			delete(rawMsg, key)
		case "totalAzureIaasCost":
			err = unpopulate(val, "TotalAzureIaasCost", &o.TotalAzureIaasCost)
			delete(rawMsg, key)
		case "totalAzurePaasCost":
			err = unpopulate(val, "TotalAzurePaasCost", &o.TotalAzurePaasCost)
			delete(rawMsg, key)
		case "totalOnPremisesCost":
			err = unpopulate(val, "TotalOnPremisesCost", &o.TotalOnPremisesCost)
			delete(rawMsg, key)
		case "utilizationData":
			err = unpopulate(val, "UtilizationData", &o.UtilizationData)
			delete(rawMsg, key)
		case "windowsAhubSavings":
			err = unpopulate(val, "WindowsAhubSavings", &o.WindowsAhubSavings)
			delete(rawMsg, key)
		case "yearOnYearEstimates":
			err = unpopulate(val, "YearOnYearEstimates", &o.YearOnYearEstimates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaasDistribution.
func (p PaasDistribution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "iisWebServers", p.IisWebServers)
	populate(objectMap, "sqlServers", p.SQLServers)
	populate(objectMap, "webAppDistribution", p.WebAppDistribution)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaasDistribution.
func (p *PaasDistribution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "iisWebServers":
			err = unpopulate(val, "IisWebServers", &p.IisWebServers)
			delete(rawMsg, key)
		case "sqlServers":
			err = unpopulate(val, "SQLServers", &p.SQLServers)
			delete(rawMsg, key)
		case "webAppDistribution":
			err = unpopulate(val, "WebAppDistribution", &p.WebAppDistribution)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaasSummary.
func (p PaasSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaasSummary.
func (p *PaasSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaasSummaryListResult.
func (p PaasSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaasSummaryListResult.
func (p *PaasSummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaasSummaryProperties.
func (p PaasSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azure", p.Azure)
	populate(objectMap, "onPremises", p.OnPremises)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaasSummaryProperties.
func (p *PaasSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azure":
			err = unpopulate(val, "Azure", &p.Azure)
			delete(rawMsg, key)
		case "onPremises":
			err = unpopulate(val, "OnPremises", &p.OnPremises)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PerfDataSettings.
func (p PerfDataSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "percentile", p.Percentile)
	populateDateTimeRFC3339(objectMap, "perfDataEndTime", p.PerfDataEndTime)
	populateDateTimeRFC3339(objectMap, "perfDataStartTime", p.PerfDataStartTime)
	populate(objectMap, "timeRange", p.TimeRange)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PerfDataSettings.
func (p *PerfDataSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "percentile":
			err = unpopulate(val, "Percentile", &p.Percentile)
			delete(rawMsg, key)
		case "perfDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataEndTime", &p.PerfDataEndTime)
			delete(rawMsg, key)
		case "perfDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataStartTime", &p.PerfDataStartTime)
			delete(rawMsg, key)
		case "timeRange":
			err = unpopulate(val, "TimeRange", &p.TimeRange)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpoint.
func (p PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpoint.
func (p *PrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionListResult.
func (p *PrivateEndpointConnectionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProperties.
func (p PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProperties.
func (p *PrivateEndpointConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupIds":
			err = unpopulate(val, "GroupIDs", &p.GroupIDs)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &p.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &p.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceListResult.
func (p *PrivateLinkResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceProperties.
func (p *PrivateLinkResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &p.GroupID)
			delete(rawMsg, key)
		case "requiredMembers":
			err = unpopulate(val, "RequiredMembers", &p.RequiredMembers)
			delete(rawMsg, key)
		case "requiredZoneNames":
			err = unpopulate(val, "RequiredZoneNames", &p.RequiredZoneNames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnectionState.
func (p PrivateLinkServiceConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnectionState.
func (p *PrivateLinkServiceConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProcessorInfo.
func (p ProcessorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "numberOfCoresPerSocket", p.NumberOfCoresPerSocket)
	populate(objectMap, "numberOfSockets", p.NumberOfSockets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessorInfo.
func (p *ProcessorInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "numberOfCoresPerSocket":
			err = unpopulate(val, "NumberOfCoresPerSocket", &p.NumberOfCoresPerSocket)
			delete(rawMsg, key)
		case "numberOfSockets":
			err = unpopulate(val, "NumberOfSockets", &p.NumberOfSockets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProductSupportStatus.
func (p ProductSupportStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentEsuYear", p.CurrentEsuYear)
	populate(objectMap, "currentVersion", p.CurrentVersion)
	populate(objectMap, "esuStatus", p.EsuStatus)
	populate(objectMap, "eta", p.Eta)
	populateDateTimeRFC3339(objectMap, "extendedSecurityUpdateYear1EndDate", p.ExtendedSecurityUpdateYear1EndDate)
	populateDateTimeRFC3339(objectMap, "extendedSecurityUpdateYear2EndDate", p.ExtendedSecurityUpdateYear2EndDate)
	populateDateTimeRFC3339(objectMap, "extendedSecurityUpdateYear3EndDate", p.ExtendedSecurityUpdateYear3EndDate)
	populateDateTimeRFC3339(objectMap, "extendedSupportEndDate", p.ExtendedSupportEndDate)
	populateDateTimeRFC3339(objectMap, "mainstreamEndDate", p.MainstreamEndDate)
	populate(objectMap, "servicePackStatus", p.ServicePackStatus)
	populate(objectMap, "supportStatus", p.SupportStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProductSupportStatus.
func (p *ProductSupportStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentEsuYear":
			err = unpopulate(val, "CurrentEsuYear", &p.CurrentEsuYear)
			delete(rawMsg, key)
		case "currentVersion":
			err = unpopulate(val, "CurrentVersion", &p.CurrentVersion)
			delete(rawMsg, key)
		case "esuStatus":
			err = unpopulate(val, "EsuStatus", &p.EsuStatus)
			delete(rawMsg, key)
		case "eta":
			err = unpopulate(val, "Eta", &p.Eta)
			delete(rawMsg, key)
		case "extendedSecurityUpdateYear1EndDate":
			err = unpopulateDateTimeRFC3339(val, "ExtendedSecurityUpdateYear1EndDate", &p.ExtendedSecurityUpdateYear1EndDate)
			delete(rawMsg, key)
		case "extendedSecurityUpdateYear2EndDate":
			err = unpopulateDateTimeRFC3339(val, "ExtendedSecurityUpdateYear2EndDate", &p.ExtendedSecurityUpdateYear2EndDate)
			delete(rawMsg, key)
		case "extendedSecurityUpdateYear3EndDate":
			err = unpopulateDateTimeRFC3339(val, "ExtendedSecurityUpdateYear3EndDate", &p.ExtendedSecurityUpdateYear3EndDate)
			delete(rawMsg, key)
		case "extendedSupportEndDate":
			err = unpopulateDateTimeRFC3339(val, "ExtendedSupportEndDate", &p.ExtendedSupportEndDate)
			delete(rawMsg, key)
		case "mainstreamEndDate":
			err = unpopulateDateTimeRFC3339(val, "MainstreamEndDate", &p.MainstreamEndDate)
			delete(rawMsg, key)
		case "servicePackStatus":
			err = unpopulate(val, "ServicePackStatus", &p.ServicePackStatus)
			delete(rawMsg, key)
		case "supportStatus":
			err = unpopulate(val, "SupportStatus", &p.SupportStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectProperties.
func (p ProjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentSolutionId", p.AssessmentSolutionID)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", p.CreatedTimestamp)
	populate(objectMap, "customerStorageAccountArmId", p.CustomerStorageAccountArmID)
	populate(objectMap, "customerWorkspaceId", p.CustomerWorkspaceID)
	populate(objectMap, "customerWorkspaceLocation", p.CustomerWorkspaceLocation)
	populate(objectMap, "privateEndpointConnections", p.PrivateEndpointConnections)
	populate(objectMap, "projectStatus", p.ProjectStatus)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", p.PublicNetworkAccess)
	populate(objectMap, "serviceEndpoint", p.ServiceEndpoint)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", p.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectProperties.
func (p *ProjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentSolutionId":
			err = unpopulate(val, "AssessmentSolutionID", &p.AssessmentSolutionID)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &p.CreatedTimestamp)
			delete(rawMsg, key)
		case "customerStorageAccountArmId":
			err = unpopulate(val, "CustomerStorageAccountArmID", &p.CustomerStorageAccountArmID)
			delete(rawMsg, key)
		case "customerWorkspaceId":
			err = unpopulate(val, "CustomerWorkspaceID", &p.CustomerWorkspaceID)
			delete(rawMsg, key)
		case "customerWorkspaceLocation":
			err = unpopulate(val, "CustomerWorkspaceLocation", &p.CustomerWorkspaceLocation)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, "PrivateEndpointConnections", &p.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "projectStatus":
			err = unpopulate(val, "ProjectStatus", &p.ProjectStatus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &p.PublicNetworkAccess)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &p.ServiceEndpoint)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &p.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecommendationResult.
func (r RecommendationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "approxMonthlyCost", r.ApproxMonthlyCost)
	populate(objectMap, "clusterName", r.ClusterName)
	populate(objectMap, "limit", r.Limit)
	populate(objectMap, "nodePoolArmSkuName", r.NodePoolArmSKUName)
	populate(objectMap, "nodePoolId", r.NodePoolID)
	populate(objectMap, "nodePoolName", r.NodePoolName)
	populate(objectMap, "osType", r.OSType)
	populate(objectMap, "request", r.Request)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecommendationResult.
func (r *RecommendationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "approxMonthlyCost":
			err = unpopulate(val, "ApproxMonthlyCost", &r.ApproxMonthlyCost)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &r.ClusterName)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, "Limit", &r.Limit)
			delete(rawMsg, key)
		case "nodePoolArmSkuName":
			err = unpopulate(val, "NodePoolArmSKUName", &r.NodePoolArmSKUName)
			delete(rawMsg, key)
		case "nodePoolId":
			err = unpopulate(val, "NodePoolID", &r.NodePoolID)
			delete(rawMsg, key)
		case "nodePoolName":
			err = unpopulate(val, "NodePoolName", &r.NodePoolName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &r.OSType)
			delete(rawMsg, key)
		case "request":
			err = unpopulate(val, "Request", &r.Request)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecommendedAvsNodeTypeSummary.
func (r RecommendedAvsNodeTypeSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avsNodeType", r.AvsNodeType)
	populate(objectMap, "failuresToTolerateAndRaidLevel", r.FailuresToTolerateAndRaidLevel)
	populate(objectMap, "numberOfNodes", r.NumberOfNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecommendedAvsNodeTypeSummary.
func (r *RecommendedAvsNodeTypeSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avsNodeType":
			err = unpopulate(val, "AvsNodeType", &r.AvsNodeType)
			delete(rawMsg, key)
		case "failuresToTolerateAndRaidLevel":
			err = unpopulate(val, "FailuresToTolerateAndRaidLevel", &r.FailuresToTolerateAndRaidLevel)
			delete(rawMsg, key)
		case "numberOfNodes":
			err = unpopulate(val, "NumberOfNodes", &r.NumberOfNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecommendedVMFamilySummary.
func (r RecommendedVMFamilySummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureVmFamily", r.AzureVMFamily)
	populate(objectMap, "numberOfMachines", r.NumberOfMachines)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecommendedVMFamilySummary.
func (r *RecommendedVMFamilySummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureVmFamily":
			err = unpopulate(val, "AzureVMFamily", &r.AzureVMFamily)
			delete(rawMsg, key)
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &r.NumberOfMachines)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReportDetails.
func (r ReportDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "reportStatus", r.ReportStatus)
	populate(objectMap, "reportType", r.ReportType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReportDetails.
func (r *ReportDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "reportStatus":
			err = unpopulate(val, "ReportStatus", &r.ReportStatus)
			delete(rawMsg, key)
		case "reportType":
			err = unpopulate(val, "ReportType", &r.ReportType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReportDownloadURL.
func (r ReportDownloadURL) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "businessCaseReportUrl", r.BusinessCaseReportURL)
	populateDateTimeRFC3339(objectMap, "expirationTime", r.ExpirationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReportDownloadURL.
func (r *ReportDownloadURL) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "businessCaseReportUrl":
			err = unpopulate(val, "BusinessCaseReportURL", &r.BusinessCaseReportURL)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTime", &r.ExpirationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessedNetworkAdapter.
func (s SQLAssessedNetworkAdapter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "ipAddresses", s.IPAddresses)
	populate(objectMap, "macAddress", s.MacAddress)
	populate(objectMap, "megabytesPerSecondReceived", s.MegabytesPerSecondReceived)
	populate(objectMap, "megabytesPerSecondTransmitted", s.MegabytesPerSecondTransmitted)
	populate(objectMap, "monthlyBandwidthCosts", s.MonthlyBandwidthCosts)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "netGigabytesTransmittedPerMonth", s.NetGigabytesTransmittedPerMonth)
	populate(objectMap, "suitability", s.Suitability)
	populate(objectMap, "suitabilityDetail", s.SuitabilityDetail)
	populate(objectMap, "suitabilityExplanation", s.SuitabilityExplanation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessedNetworkAdapter.
func (s *SQLAssessedNetworkAdapter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &s.DisplayName)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, "IPAddresses", &s.IPAddresses)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &s.MacAddress)
			delete(rawMsg, key)
		case "megabytesPerSecondReceived":
			err = unpopulate(val, "MegabytesPerSecondReceived", &s.MegabytesPerSecondReceived)
			delete(rawMsg, key)
		case "megabytesPerSecondTransmitted":
			err = unpopulate(val, "MegabytesPerSecondTransmitted", &s.MegabytesPerSecondTransmitted)
			delete(rawMsg, key)
		case "monthlyBandwidthCosts":
			err = unpopulate(val, "MonthlyBandwidthCosts", &s.MonthlyBandwidthCosts)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "netGigabytesTransmittedPerMonth":
			err = unpopulate(val, "NetGigabytesTransmittedPerMonth", &s.NetGigabytesTransmittedPerMonth)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &s.Suitability)
			delete(rawMsg, key)
		case "suitabilityDetail":
			err = unpopulate(val, "SuitabilityDetail", &s.SuitabilityDetail)
			delete(rawMsg, key)
		case "suitabilityExplanation":
			err = unpopulate(val, "SuitabilityExplanation", &s.SuitabilityExplanation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentMigrationIssue.
func (s SQLAssessmentMigrationIssue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "impactedObjects", s.ImpactedObjects)
	populate(objectMap, "issueCategory", s.IssueCategory)
	populate(objectMap, "issueId", s.IssueID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentMigrationIssue.
func (s *SQLAssessmentMigrationIssue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "impactedObjects":
			err = unpopulate(val, "ImpactedObjects", &s.ImpactedObjects)
			delete(rawMsg, key)
		case "issueCategory":
			err = unpopulate(val, "IssueCategory", &s.IssueCategory)
			delete(rawMsg, key)
		case "issueId":
			err = unpopulate(val, "IssueID", &s.IssueID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentOptions.
func (s SQLAssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentOptions.
func (s *SQLAssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentOptionsListResult.
func (s SQLAssessmentOptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentOptionsListResult.
func (s *SQLAssessmentOptionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentOptionsProperties.
func (s SQLAssessmentOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "premiumDiskVmFamilies", s.PremiumDiskVMFamilies)
	populate(objectMap, "reservedInstanceSqlTargets", s.ReservedInstanceSQLTargets)
	populate(objectMap, "reservedInstanceSupportedCurrencies", s.ReservedInstanceSupportedCurrencies)
	populate(objectMap, "reservedInstanceSupportedLocations", s.ReservedInstanceSupportedLocations)
	populate(objectMap, "reservedInstanceSupportedLocationsForIaas", s.ReservedInstanceSupportedLocationsForIaas)
	populate(objectMap, "reservedInstanceSupportedOffers", s.ReservedInstanceSupportedOffers)
	populate(objectMap, "reservedInstanceVmFamilies", s.ReservedInstanceVMFamilies)
	populate(objectMap, "sqlSkus", s.SQLSKUs)
	populate(objectMap, "savingsPlanSupportedLocations", s.SavingsPlanSupportedLocations)
	populate(objectMap, "savingsPlanSupportedLocationsForPaas", s.SavingsPlanSupportedLocationsForPaas)
	populate(objectMap, "savingsPlanSupportedOffers", s.SavingsPlanSupportedOffers)
	populate(objectMap, "savingsPlanVmFamilies", s.SavingsPlanVMFamilies)
	populate(objectMap, "supportedOffers", s.SupportedOffers)
	populate(objectMap, "vmFamilies", s.VMFamilies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentOptionsProperties.
func (s *SQLAssessmentOptionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "premiumDiskVmFamilies":
			err = unpopulate(val, "PremiumDiskVMFamilies", &s.PremiumDiskVMFamilies)
			delete(rawMsg, key)
		case "reservedInstanceSqlTargets":
			err = unpopulate(val, "ReservedInstanceSQLTargets", &s.ReservedInstanceSQLTargets)
			delete(rawMsg, key)
		case "reservedInstanceSupportedCurrencies":
			err = unpopulate(val, "ReservedInstanceSupportedCurrencies", &s.ReservedInstanceSupportedCurrencies)
			delete(rawMsg, key)
		case "reservedInstanceSupportedLocations":
			err = unpopulate(val, "ReservedInstanceSupportedLocations", &s.ReservedInstanceSupportedLocations)
			delete(rawMsg, key)
		case "reservedInstanceSupportedLocationsForIaas":
			err = unpopulate(val, "ReservedInstanceSupportedLocationsForIaas", &s.ReservedInstanceSupportedLocationsForIaas)
			delete(rawMsg, key)
		case "reservedInstanceSupportedOffers":
			err = unpopulate(val, "ReservedInstanceSupportedOffers", &s.ReservedInstanceSupportedOffers)
			delete(rawMsg, key)
		case "reservedInstanceVmFamilies":
			err = unpopulate(val, "ReservedInstanceVMFamilies", &s.ReservedInstanceVMFamilies)
			delete(rawMsg, key)
		case "sqlSkus":
			err = unpopulate(val, "SQLSKUs", &s.SQLSKUs)
			delete(rawMsg, key)
		case "savingsPlanSupportedLocations":
			err = unpopulate(val, "SavingsPlanSupportedLocations", &s.SavingsPlanSupportedLocations)
			delete(rawMsg, key)
		case "savingsPlanSupportedLocationsForPaas":
			err = unpopulate(val, "SavingsPlanSupportedLocationsForPaas", &s.SavingsPlanSupportedLocationsForPaas)
			delete(rawMsg, key)
		case "savingsPlanSupportedOffers":
			err = unpopulate(val, "SavingsPlanSupportedOffers", &s.SavingsPlanSupportedOffers)
			delete(rawMsg, key)
		case "savingsPlanVmFamilies":
			err = unpopulate(val, "SavingsPlanVMFamilies", &s.SavingsPlanVMFamilies)
			delete(rawMsg, key)
		case "supportedOffers":
			err = unpopulate(val, "SupportedOffers", &s.SupportedOffers)
			delete(rawMsg, key)
		case "vmFamilies":
			err = unpopulate(val, "VMFamilies", &s.VMFamilies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2.
func (s SQLAssessmentV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2.
func (s *SQLAssessmentV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2IaasSuitabilityData.
func (s SQLAssessmentV2IaasSuitabilityData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlSku", s.AzureSQLSKU)
	populate(objectMap, "costComponents", s.CostComponents)
	populate(objectMap, "migrationGuidelines", s.MigrationGuidelines)
	populate(objectMap, "migrationIssues", s.MigrationIssues)
	populate(objectMap, "migrationTargetPlatform", s.MigrationTargetPlatform)
	populate(objectMap, "monthlyComputeCost", s.MonthlyComputeCost)
	populate(objectMap, "monthlyStorageCost", s.MonthlyStorageCost)
	populate(objectMap, "recommendationReasonings", s.RecommendationReasonings)
	populate(objectMap, "replicaAzureSqlSku", s.ReplicaAzureSQLSKU)
	populate(objectMap, "skuReplicationMode", s.SKUReplicationMode)
	populate(objectMap, "securitySuitability", s.SecuritySuitability)
	populate(objectMap, "sharedResources", s.SharedResources)
	populate(objectMap, "shouldProvisionReplicas", s.ShouldProvisionReplicas)
	populate(objectMap, "suitability", s.Suitability)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2IaasSuitabilityData.
func (s *SQLAssessmentV2IaasSuitabilityData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlSku":
			err = unpopulate(val, "AzureSQLSKU", &s.AzureSQLSKU)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &s.CostComponents)
			delete(rawMsg, key)
		case "migrationGuidelines":
			err = unpopulate(val, "MigrationGuidelines", &s.MigrationGuidelines)
			delete(rawMsg, key)
		case "migrationIssues":
			err = unpopulate(val, "MigrationIssues", &s.MigrationIssues)
			delete(rawMsg, key)
		case "migrationTargetPlatform":
			err = unpopulate(val, "MigrationTargetPlatform", &s.MigrationTargetPlatform)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &s.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &s.MonthlyStorageCost)
			delete(rawMsg, key)
		case "recommendationReasonings":
			err = unpopulate(val, "RecommendationReasonings", &s.RecommendationReasonings)
			delete(rawMsg, key)
		case "replicaAzureSqlSku":
			err = unpopulate(val, "ReplicaAzureSQLSKU", &s.ReplicaAzureSQLSKU)
			delete(rawMsg, key)
		case "skuReplicationMode":
			err = unpopulate(val, "SKUReplicationMode", &s.SKUReplicationMode)
			delete(rawMsg, key)
		case "securitySuitability":
			err = unpopulate(val, "SecuritySuitability", &s.SecuritySuitability)
			delete(rawMsg, key)
		case "sharedResources":
			err = unpopulate(val, "SharedResources", &s.SharedResources)
			delete(rawMsg, key)
		case "shouldProvisionReplicas":
			err = unpopulate(val, "ShouldProvisionReplicas", &s.ShouldProvisionReplicas)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &s.Suitability)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2ListResult.
func (s SQLAssessmentV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2ListResult.
func (s *SQLAssessmentV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2PaasSuitabilityData.
func (s SQLAssessmentV2PaasSuitabilityData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlSku", s.AzureSQLSKU)
	populate(objectMap, "costComponents", s.CostComponents)
	populate(objectMap, "migrationGuidelines", s.MigrationGuidelines)
	populate(objectMap, "migrationIssues", s.MigrationIssues)
	populate(objectMap, "migrationTargetPlatform", s.MigrationTargetPlatform)
	populate(objectMap, "monthlyComputeCost", s.MonthlyComputeCost)
	populate(objectMap, "monthlyStorageCost", s.MonthlyStorageCost)
	populate(objectMap, "recommendationReasonings", s.RecommendationReasonings)
	populate(objectMap, "replicaAzureSqlSku", s.ReplicaAzureSQLSKU)
	populate(objectMap, "skuReplicationMode", s.SKUReplicationMode)
	populate(objectMap, "securitySuitability", s.SecuritySuitability)
	populate(objectMap, "sharedResources", s.SharedResources)
	populate(objectMap, "shouldProvisionReplicas", s.ShouldProvisionReplicas)
	populate(objectMap, "suitability", s.Suitability)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2PaasSuitabilityData.
func (s *SQLAssessmentV2PaasSuitabilityData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlSku":
			err = unpopulate(val, "AzureSQLSKU", &s.AzureSQLSKU)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &s.CostComponents)
			delete(rawMsg, key)
		case "migrationGuidelines":
			err = unpopulate(val, "MigrationGuidelines", &s.MigrationGuidelines)
			delete(rawMsg, key)
		case "migrationIssues":
			err = unpopulate(val, "MigrationIssues", &s.MigrationIssues)
			delete(rawMsg, key)
		case "migrationTargetPlatform":
			err = unpopulate(val, "MigrationTargetPlatform", &s.MigrationTargetPlatform)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &s.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &s.MonthlyStorageCost)
			delete(rawMsg, key)
		case "recommendationReasonings":
			err = unpopulate(val, "RecommendationReasonings", &s.RecommendationReasonings)
			delete(rawMsg, key)
		case "replicaAzureSqlSku":
			err = unpopulate(val, "ReplicaAzureSQLSKU", &s.ReplicaAzureSQLSKU)
			delete(rawMsg, key)
		case "skuReplicationMode":
			err = unpopulate(val, "SKUReplicationMode", &s.SKUReplicationMode)
			delete(rawMsg, key)
		case "securitySuitability":
			err = unpopulate(val, "SecuritySuitability", &s.SecuritySuitability)
			delete(rawMsg, key)
		case "sharedResources":
			err = unpopulate(val, "SharedResources", &s.SharedResources)
			delete(rawMsg, key)
		case "shouldProvisionReplicas":
			err = unpopulate(val, "ShouldProvisionReplicas", &s.ShouldProvisionReplicas)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &s.Suitability)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2Properties.
func (s SQLAssessmentV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentType", s.AssessmentType)
	populate(objectMap, "asyncCommitModeIntent", s.AsyncCommitModeIntent)
	populate(objectMap, "azureLocation", s.AzureLocation)
	populate(objectMap, "azureOfferCode", s.AzureOfferCode)
	populate(objectMap, "azureOfferCodeForVm", s.AzureOfferCodeForVM)
	populate(objectMap, "azureSqlDatabaseSettings", s.AzureSQLDatabaseSettings)
	populate(objectMap, "azureSqlManagedInstanceSettings", s.AzureSQLManagedInstanceSettings)
	populate(objectMap, "azureSqlVmSettings", s.AzureSQLVMSettings)
	populate(objectMap, "azureSecurityOfferingType", s.AzureSecurityOfferingType)
	populate(objectMap, "confidenceRatingInPercentage", s.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", s.CreatedTimestamp)
	populate(objectMap, "currency", s.Currency)
	populate(objectMap, "disasterRecoveryLocation", s.DisasterRecoveryLocation)
	populate(objectMap, "discountPercentage", s.DiscountPercentage)
	populate(objectMap, "eaSubscriptionId", s.EaSubscriptionID)
	populate(objectMap, "enableHadrAssessment", s.EnableHadrAssessment)
	populate(objectMap, "entityUptime", s.EntityUptime)
	populate(objectMap, "environmentType", s.EnvironmentType)
	populate(objectMap, "groupType", s.GroupType)
	populate(objectMap, "isInternetAccessAvailable", s.IsInternetAccessAvailable)
	populate(objectMap, "multiSubnetIntent", s.MultiSubnetIntent)
	populate(objectMap, "osLicense", s.OSLicense)
	populate(objectMap, "optimizationLogic", s.OptimizationLogic)
	populate(objectMap, "percentile", s.Percentile)
	populateDateTimeRFC3339(objectMap, "perfDataEndTime", s.PerfDataEndTime)
	populateDateTimeRFC3339(objectMap, "perfDataStartTime", s.PerfDataStartTime)
	populateDateTimeRFC3339(objectMap, "pricesTimestamp", s.PricesTimestamp)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "reservedInstance", s.ReservedInstance)
	populate(objectMap, "reservedInstanceForVm", s.ReservedInstanceForVM)
	populate(objectMap, "sqlServerLicense", s.SQLServerLicense)
	populate(objectMap, "scalingFactor", s.ScalingFactor)
	populate(objectMap, "schemaVersion", s.SchemaVersion)
	populate(objectMap, "sizingCriterion", s.SizingCriterion)
	populate(objectMap, "stage", s.Stage)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "timeRange", s.TimeRange)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", s.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2Properties.
func (s *SQLAssessmentV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentType":
			err = unpopulate(val, "AssessmentType", &s.AssessmentType)
			delete(rawMsg, key)
		case "asyncCommitModeIntent":
			err = unpopulate(val, "AsyncCommitModeIntent", &s.AsyncCommitModeIntent)
			delete(rawMsg, key)
		case "azureLocation":
			err = unpopulate(val, "AzureLocation", &s.AzureLocation)
			delete(rawMsg, key)
		case "azureOfferCode":
			err = unpopulate(val, "AzureOfferCode", &s.AzureOfferCode)
			delete(rawMsg, key)
		case "azureOfferCodeForVm":
			err = unpopulate(val, "AzureOfferCodeForVM", &s.AzureOfferCodeForVM)
			delete(rawMsg, key)
		case "azureSqlDatabaseSettings":
			err = unpopulate(val, "AzureSQLDatabaseSettings", &s.AzureSQLDatabaseSettings)
			delete(rawMsg, key)
		case "azureSqlManagedInstanceSettings":
			err = unpopulate(val, "AzureSQLManagedInstanceSettings", &s.AzureSQLManagedInstanceSettings)
			delete(rawMsg, key)
		case "azureSqlVmSettings":
			err = unpopulate(val, "AzureSQLVMSettings", &s.AzureSQLVMSettings)
			delete(rawMsg, key)
		case "azureSecurityOfferingType":
			err = unpopulate(val, "AzureSecurityOfferingType", &s.AzureSecurityOfferingType)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &s.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &s.CreatedTimestamp)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &s.Currency)
			delete(rawMsg, key)
		case "disasterRecoveryLocation":
			err = unpopulate(val, "DisasterRecoveryLocation", &s.DisasterRecoveryLocation)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &s.DiscountPercentage)
			delete(rawMsg, key)
		case "eaSubscriptionId":
			err = unpopulate(val, "EaSubscriptionID", &s.EaSubscriptionID)
			delete(rawMsg, key)
		case "enableHadrAssessment":
			err = unpopulate(val, "EnableHadrAssessment", &s.EnableHadrAssessment)
			delete(rawMsg, key)
		case "entityUptime":
			err = unpopulate(val, "EntityUptime", &s.EntityUptime)
			delete(rawMsg, key)
		case "environmentType":
			err = unpopulate(val, "EnvironmentType", &s.EnvironmentType)
			delete(rawMsg, key)
		case "groupType":
			err = unpopulate(val, "GroupType", &s.GroupType)
			delete(rawMsg, key)
		case "isInternetAccessAvailable":
			err = unpopulate(val, "IsInternetAccessAvailable", &s.IsInternetAccessAvailable)
			delete(rawMsg, key)
		case "multiSubnetIntent":
			err = unpopulate(val, "MultiSubnetIntent", &s.MultiSubnetIntent)
			delete(rawMsg, key)
		case "osLicense":
			err = unpopulate(val, "OSLicense", &s.OSLicense)
			delete(rawMsg, key)
		case "optimizationLogic":
			err = unpopulate(val, "OptimizationLogic", &s.OptimizationLogic)
			delete(rawMsg, key)
		case "percentile":
			err = unpopulate(val, "Percentile", &s.Percentile)
			delete(rawMsg, key)
		case "perfDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataEndTime", &s.PerfDataEndTime)
			delete(rawMsg, key)
		case "perfDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataStartTime", &s.PerfDataStartTime)
			delete(rawMsg, key)
		case "pricesTimestamp":
			err = unpopulateDateTimeRFC3339(val, "PricesTimestamp", &s.PricesTimestamp)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "reservedInstance":
			err = unpopulate(val, "ReservedInstance", &s.ReservedInstance)
			delete(rawMsg, key)
		case "reservedInstanceForVm":
			err = unpopulate(val, "ReservedInstanceForVM", &s.ReservedInstanceForVM)
			delete(rawMsg, key)
		case "sqlServerLicense":
			err = unpopulate(val, "SQLServerLicense", &s.SQLServerLicense)
			delete(rawMsg, key)
		case "scalingFactor":
			err = unpopulate(val, "ScalingFactor", &s.ScalingFactor)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &s.SchemaVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &s.SizingCriterion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, "Stage", &s.Stage)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "timeRange":
			err = unpopulate(val, "TimeRange", &s.TimeRange)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &s.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2Summary.
func (s SQLAssessmentV2Summary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2Summary.
func (s *SQLAssessmentV2Summary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2SummaryData.
func (s SQLAssessmentV2SummaryData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "confidenceScore", s.ConfidenceScore)
	populate(objectMap, "monthlyComputeCost", s.MonthlyComputeCost)
	populate(objectMap, "monthlyLicenseCost", s.MonthlyLicenseCost)
	populate(objectMap, "monthlySecurityCost", s.MonthlySecurityCost)
	populate(objectMap, "monthlyStorageCost", s.MonthlyStorageCost)
	populate(objectMap, "suitabilitySummary", s.SuitabilitySummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2SummaryData.
func (s *SQLAssessmentV2SummaryData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "confidenceScore":
			err = unpopulate(val, "ConfidenceScore", &s.ConfidenceScore)
			delete(rawMsg, key)
		case "monthlyComputeCost":
			err = unpopulate(val, "MonthlyComputeCost", &s.MonthlyComputeCost)
			delete(rawMsg, key)
		case "monthlyLicenseCost":
			err = unpopulate(val, "MonthlyLicenseCost", &s.MonthlyLicenseCost)
			delete(rawMsg, key)
		case "monthlySecurityCost":
			err = unpopulate(val, "MonthlySecurityCost", &s.MonthlySecurityCost)
			delete(rawMsg, key)
		case "monthlyStorageCost":
			err = unpopulate(val, "MonthlyStorageCost", &s.MonthlyStorageCost)
			delete(rawMsg, key)
		case "suitabilitySummary":
			err = unpopulate(val, "SuitabilitySummary", &s.SuitabilitySummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2SummaryListResult.
func (s SQLAssessmentV2SummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2SummaryListResult.
func (s *SQLAssessmentV2SummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAssessmentV2SummaryProperties.
func (s SQLAssessmentV2SummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentSummary", s.AssessmentSummary)
	populate(objectMap, "databaseDistributionBySizingCriterion", s.DatabaseDistributionBySizingCriterion)
	populate(objectMap, "distributionBySqlEdition", s.DistributionBySQLEdition)
	populate(objectMap, "distributionBySqlVersion", s.DistributionBySQLVersion)
	populate(objectMap, "distributionByServicePackInsight", s.DistributionByServicePackInsight)
	populate(objectMap, "distributionBySupportStatus", s.DistributionBySupportStatus)
	populate(objectMap, "instanceDistributionBySizingCriterion", s.InstanceDistributionBySizingCriterion)
	populate(objectMap, "numberOfFciInstances", s.NumberOfFciInstances)
	populate(objectMap, "numberOfMachines", s.NumberOfMachines)
	populate(objectMap, "numberOfSqlAvailabilityGroups", s.NumberOfSQLAvailabilityGroups)
	populate(objectMap, "numberOfSqlDatabases", s.NumberOfSQLDatabases)
	populate(objectMap, "numberOfSqlInstances", s.NumberOfSQLInstances)
	populate(objectMap, "numberOfSuccessfullyDiscoveredSqlInstances", s.NumberOfSuccessfullyDiscoveredSQLInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAssessmentV2SummaryProperties.
func (s *SQLAssessmentV2SummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentSummary":
			err = unpopulate(val, "AssessmentSummary", &s.AssessmentSummary)
			delete(rawMsg, key)
		case "databaseDistributionBySizingCriterion":
			err = unpopulate(val, "DatabaseDistributionBySizingCriterion", &s.DatabaseDistributionBySizingCriterion)
			delete(rawMsg, key)
		case "distributionBySqlEdition":
			err = unpopulate(val, "DistributionBySQLEdition", &s.DistributionBySQLEdition)
			delete(rawMsg, key)
		case "distributionBySqlVersion":
			err = unpopulate(val, "DistributionBySQLVersion", &s.DistributionBySQLVersion)
			delete(rawMsg, key)
		case "distributionByServicePackInsight":
			err = unpopulate(val, "DistributionByServicePackInsight", &s.DistributionByServicePackInsight)
			delete(rawMsg, key)
		case "distributionBySupportStatus":
			err = unpopulate(val, "DistributionBySupportStatus", &s.DistributionBySupportStatus)
			delete(rawMsg, key)
		case "instanceDistributionBySizingCriterion":
			err = unpopulate(val, "InstanceDistributionBySizingCriterion", &s.InstanceDistributionBySizingCriterion)
			delete(rawMsg, key)
		case "numberOfFciInstances":
			err = unpopulate(val, "NumberOfFciInstances", &s.NumberOfFciInstances)
			delete(rawMsg, key)
		case "numberOfMachines":
			err = unpopulate(val, "NumberOfMachines", &s.NumberOfMachines)
			delete(rawMsg, key)
		case "numberOfSqlAvailabilityGroups":
			err = unpopulate(val, "NumberOfSQLAvailabilityGroups", &s.NumberOfSQLAvailabilityGroups)
			delete(rawMsg, key)
		case "numberOfSqlDatabases":
			err = unpopulate(val, "NumberOfSQLDatabases", &s.NumberOfSQLDatabases)
			delete(rawMsg, key)
		case "numberOfSqlInstances":
			err = unpopulate(val, "NumberOfSQLInstances", &s.NumberOfSQLInstances)
			delete(rawMsg, key)
		case "numberOfSuccessfullyDiscoveredSqlInstances":
			err = unpopulate(val, "NumberOfSuccessfullyDiscoveredSQLInstances", &s.NumberOfSuccessfullyDiscoveredSQLInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAvailabilityGroupDataOverview.
func (s SQLAvailabilityGroupDataOverview) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availabilityGroupId", s.AvailabilityGroupID)
	populate(objectMap, "availabilityGroupName", s.AvailabilityGroupName)
	populate(objectMap, "sqlAvailabilityGroupEntityId", s.SQLAvailabilityGroupEntityID)
	populate(objectMap, "sqlAvailabilityGroupSdsArmId", s.SQLAvailabilityGroupSdsArmID)
	populate(objectMap, "sqlAvailabilityReplicaId", s.SQLAvailabilityReplicaID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAvailabilityGroupDataOverview.
func (s *SQLAvailabilityGroupDataOverview) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availabilityGroupId":
			err = unpopulate(val, "AvailabilityGroupID", &s.AvailabilityGroupID)
			delete(rawMsg, key)
		case "availabilityGroupName":
			err = unpopulate(val, "AvailabilityGroupName", &s.AvailabilityGroupName)
			delete(rawMsg, key)
		case "sqlAvailabilityGroupEntityId":
			err = unpopulate(val, "SQLAvailabilityGroupEntityID", &s.SQLAvailabilityGroupEntityID)
			delete(rawMsg, key)
		case "sqlAvailabilityGroupSdsArmId":
			err = unpopulate(val, "SQLAvailabilityGroupSdsArmID", &s.SQLAvailabilityGroupSdsArmID)
			delete(rawMsg, key)
		case "sqlAvailabilityReplicaId":
			err = unpopulate(val, "SQLAvailabilityReplicaID", &s.SQLAvailabilityReplicaID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLAvailabilityReplicaSummary.
func (s SQLAvailabilityReplicaSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfAsynchronousNonReadReplicas", s.NumberOfAsynchronousNonReadReplicas)
	populate(objectMap, "numberOfAsynchronousReadReplicas", s.NumberOfAsynchronousReadReplicas)
	populate(objectMap, "numberOfPrimaryReplicas", s.NumberOfPrimaryReplicas)
	populate(objectMap, "numberOfSynchronousNonReadReplicas", s.NumberOfSynchronousNonReadReplicas)
	populate(objectMap, "numberOfSynchronousReadReplicas", s.NumberOfSynchronousReadReplicas)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLAvailabilityReplicaSummary.
func (s *SQLAvailabilityReplicaSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfAsynchronousNonReadReplicas":
			err = unpopulate(val, "NumberOfAsynchronousNonReadReplicas", &s.NumberOfAsynchronousNonReadReplicas)
			delete(rawMsg, key)
		case "numberOfAsynchronousReadReplicas":
			err = unpopulate(val, "NumberOfAsynchronousReadReplicas", &s.NumberOfAsynchronousReadReplicas)
			delete(rawMsg, key)
		case "numberOfPrimaryReplicas":
			err = unpopulate(val, "NumberOfPrimaryReplicas", &s.NumberOfPrimaryReplicas)
			delete(rawMsg, key)
		case "numberOfSynchronousNonReadReplicas":
			err = unpopulate(val, "NumberOfSynchronousNonReadReplicas", &s.NumberOfSynchronousNonReadReplicas)
			delete(rawMsg, key)
		case "numberOfSynchronousReadReplicas":
			err = unpopulate(val, "NumberOfSynchronousReadReplicas", &s.NumberOfSynchronousReadReplicas)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLCollector.
func (s SQLCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLCollector.
func (s *SQLCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLCollectorListResult.
func (s SQLCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLCollectorListResult.
func (s *SQLCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLDbSettings.
func (s SQLDbSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlComputeTier", s.AzureSQLComputeTier)
	populate(objectMap, "azureSqlDataBaseType", s.AzureSQLDataBaseType)
	populate(objectMap, "azureSqlPurchaseModel", s.AzureSQLPurchaseModel)
	populate(objectMap, "azureSqlServiceTier", s.AzureSQLServiceTier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDbSettings.
func (s *SQLDbSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlComputeTier":
			err = unpopulate(val, "AzureSQLComputeTier", &s.AzureSQLComputeTier)
			delete(rawMsg, key)
		case "azureSqlDataBaseType":
			err = unpopulate(val, "AzureSQLDataBaseType", &s.AzureSQLDataBaseType)
			delete(rawMsg, key)
		case "azureSqlPurchaseModel":
			err = unpopulate(val, "AzureSQLPurchaseModel", &s.AzureSQLPurchaseModel)
			delete(rawMsg, key)
		case "azureSqlServiceTier":
			err = unpopulate(val, "AzureSQLServiceTier", &s.AzureSQLServiceTier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLFCIMetadata.
func (s SQLFCIMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fciSharedDiskCount", s.FciSharedDiskCount)
	populate(objectMap, "isMultiSubnet", s.IsMultiSubnet)
	populate(objectMap, "state", s.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLFCIMetadata.
func (s *SQLFCIMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fciSharedDiskCount":
			err = unpopulate(val, "FciSharedDiskCount", &s.FciSharedDiskCount)
			delete(rawMsg, key)
		case "isMultiSubnet":
			err = unpopulate(val, "IsMultiSubnet", &s.IsMultiSubnet)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLMiSettings.
func (s SQLMiSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSqlInstanceType", s.AzureSQLInstanceType)
	populate(objectMap, "azureSqlServiceTier", s.AzureSQLServiceTier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMiSettings.
func (s *SQLMiSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSqlInstanceType":
			err = unpopulate(val, "AzureSQLInstanceType", &s.AzureSQLInstanceType)
			delete(rawMsg, key)
		case "azureSqlServiceTier":
			err = unpopulate(val, "AzureSQLServiceTier", &s.AzureSQLServiceTier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLMigrationGuideline.
func (s SQLMigrationGuideline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "guidelineId", s.GuidelineID)
	populate(objectMap, "migrationGuidelineCategory", s.MigrationGuidelineCategory)
	populate(objectMap, "migrationGuidelineContext", s.MigrationGuidelineContext)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMigrationGuideline.
func (s *SQLMigrationGuideline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "guidelineId":
			err = unpopulate(val, "GuidelineID", &s.GuidelineID)
			delete(rawMsg, key)
		case "migrationGuidelineCategory":
			err = unpopulate(val, "MigrationGuidelineCategory", &s.MigrationGuidelineCategory)
			delete(rawMsg, key)
		case "migrationGuidelineContext":
			err = unpopulate(val, "MigrationGuidelineContext", &s.MigrationGuidelineContext)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLPaaSTargetOptions.
func (s SQLPaaSTargetOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeTier", s.ComputeTier)
	populate(objectMap, "hardwareGeneration", s.HardwareGeneration)
	populate(objectMap, "serviceTier", s.ServiceTier)
	populate(objectMap, "targetLocations", s.TargetLocations)
	populate(objectMap, "targetType", s.TargetType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPaaSTargetOptions.
func (s *SQLPaaSTargetOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeTier":
			err = unpopulate(val, "ComputeTier", &s.ComputeTier)
			delete(rawMsg, key)
		case "hardwareGeneration":
			err = unpopulate(val, "HardwareGeneration", &s.HardwareGeneration)
			delete(rawMsg, key)
		case "serviceTier":
			err = unpopulate(val, "ServiceTier", &s.ServiceTier)
			delete(rawMsg, key)
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &s.TargetLocations)
			delete(rawMsg, key)
		case "targetType":
			err = unpopulate(val, "TargetType", &s.TargetType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLRecommendationReasoning.
func (s SQLRecommendationReasoning) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextParameters", s.ContextParameters)
	populate(objectMap, "reasoningCategory", s.ReasoningCategory)
	populate(objectMap, "reasoningId", s.ReasoningID)
	populate(objectMap, "reasoningString", s.ReasoningString)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLRecommendationReasoning.
func (s *SQLRecommendationReasoning) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextParameters":
			err = unpopulate(val, "ContextParameters", &s.ContextParameters)
			delete(rawMsg, key)
		case "reasoningCategory":
			err = unpopulate(val, "ReasoningCategory", &s.ReasoningCategory)
			delete(rawMsg, key)
		case "reasoningId":
			err = unpopulate(val, "ReasoningID", &s.ReasoningID)
			delete(rawMsg, key)
		case "reasoningString":
			err = unpopulate(val, "ReasoningString", &s.ReasoningString)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLRecommendationReasoningContext.
func (s SQLRecommendationReasoningContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contextKey", s.ContextKey)
	populate(objectMap, "contextValue", s.ContextValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLRecommendationReasoningContext.
func (s *SQLRecommendationReasoningContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contextKey":
			err = unpopulate(val, "ContextKey", &s.ContextKey)
			delete(rawMsg, key)
		case "contextValue":
			err = unpopulate(val, "ContextValue", &s.ContextValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLicensingSettings.
func (s SQLServerLicensingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseCost", s.LicenseCost)
	populate(objectMap, "softwareAssuranceCost", s.SoftwareAssuranceCost)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLicensingSettings.
func (s *SQLServerLicensingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseCost":
			err = unpopulate(val, "LicenseCost", &s.LicenseCost)
			delete(rawMsg, key)
		case "softwareAssuranceCost":
			err = unpopulate(val, "SoftwareAssuranceCost", &s.SoftwareAssuranceCost)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLServiceTier.
func (s SQLServiceTier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "serviceTierName", s.ServiceTierName)
	populate(objectMap, "serviceTierNumber", s.ServiceTierNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServiceTier.
func (s *SQLServiceTier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "serviceTierName":
			err = unpopulate(val, "ServiceTierName", &s.ServiceTierName)
			delete(rawMsg, key)
		case "serviceTierNumber":
			err = unpopulate(val, "ServiceTierNumber", &s.ServiceTierNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLVMSettings.
func (s SQLVMSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceSeries", s.InstanceSeries)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLVMSettings.
func (s *SQLVMSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceSeries":
			err = unpopulate(val, "InstanceSeries", &s.InstanceSeries)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLVersionDetails.
func (s SQLVersionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfInstances", s.NumberOfInstances)
	populate(objectMap, "sqlVersion", s.SQLVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLVersionDetails.
func (s *SQLVersionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfInstances":
			err = unpopulate(val, "NumberOfInstances", &s.NumberOfInstances)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &s.SQLVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySettings.
func (s SecuritySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sqlServerSecurityCostPerServerPerYear", s.SQLServerSecurityCostPerServerPerYear)
	populate(objectMap, "serverSecurityCostPerServerPerYear", s.ServerSecurityCostPerServerPerYear)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecuritySettings.
func (s *SecuritySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sqlServerSecurityCostPerServerPerYear":
			err = unpopulate(val, "SQLServerSecurityCostPerServerPerYear", &s.SQLServerSecurityCostPerServerPerYear)
			delete(rawMsg, key)
		case "serverSecurityCostPerServerPerYear":
			err = unpopulate(val, "ServerSecurityCostPerServerPerYear", &s.ServerSecurityCostPerServerPerYear)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServerCollector.
func (s ServerCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerCollector.
func (s *ServerCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServerCollectorListResult.
func (s ServerCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerCollectorListResult.
func (s *ServerCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServersDiscovered.
func (s ServersDiscovered) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hyperV", s.HyperV)
	populate(objectMap, "notApplicable", s.NotApplicable)
	populate(objectMap, "physical", s.Physical)
	populate(objectMap, "vmWare", s.VMWare)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServersDiscovered.
func (s *ServersDiscovered) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hyperV":
			err = unpopulate(val, "HyperV", &s.HyperV)
			delete(rawMsg, key)
		case "notApplicable":
			err = unpopulate(val, "NotApplicable", &s.NotApplicable)
			delete(rawMsg, key)
		case "physical":
			err = unpopulate(val, "Physical", &s.Physical)
			delete(rawMsg, key)
		case "vmWare":
			err = unpopulate(val, "VMWare", &s.VMWare)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePackInsight.
func (s ServicePackInsight) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "patched", s.Patched)
	populate(objectMap, "unknownServicePack", s.UnknownServicePack)
	populate(objectMap, "unpatched", s.Unpatched)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePackInsight.
func (s *ServicePackInsight) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "patched":
			err = unpopulate(val, "Patched", &s.Patched)
			delete(rawMsg, key)
		case "unknownServicePack":
			err = unpopulate(val, "UnknownServicePack", &s.UnknownServicePack)
			delete(rawMsg, key)
		case "unpatched":
			err = unpopulate(val, "Unpatched", &s.Unpatched)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Settings.
func (s Settings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureArcSettings", s.AzureArcSettings)
	populate(objectMap, "azureSettings", s.AzureSettings)
	populate(objectMap, "onPremiseSettings", s.OnPremiseSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Settings.
func (s *Settings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureArcSettings":
			err = unpopulate(val, "AzureArcSettings", &s.AzureArcSettings)
			delete(rawMsg, key)
		case "azureSettings":
			err = unpopulate(val, "AzureSettings", &s.AzureSettings)
			delete(rawMsg, key)
		case "onPremiseSettings":
			err = unpopulate(val, "OnPremiseSettings", &s.OnPremiseSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharedResourcesDTO.
func (s SharedResourcesDTO) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfMounts", s.NumberOfMounts)
	populate(objectMap, "quorumWitness", s.QuorumWitness)
	populate(objectMap, "sharedDataDisks", s.SharedDataDisks)
	populate(objectMap, "sharedLogDisks", s.SharedLogDisks)
	populate(objectMap, "sharedTempDbDisks", s.SharedTempDbDisks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharedResourcesDTO.
func (s *SharedResourcesDTO) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfMounts":
			err = unpopulate(val, "NumberOfMounts", &s.NumberOfMounts)
			delete(rawMsg, key)
		case "quorumWitness":
			err = unpopulate(val, "QuorumWitness", &s.QuorumWitness)
			delete(rawMsg, key)
		case "sharedDataDisks":
			err = unpopulate(val, "SharedDataDisks", &s.SharedDataDisks)
			delete(rawMsg, key)
		case "sharedLogDisks":
			err = unpopulate(val, "SharedLogDisks", &s.SharedLogDisks)
			delete(rawMsg, key)
		case "sharedTempDbDisks":
			err = unpopulate(val, "SharedTempDbDisks", &s.SharedTempDbDisks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageSettings.
func (s StorageSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "costPerGbPerMonth", s.CostPerGbPerMonth)
	populate(objectMap, "maintainanceCostPercentageToAcquisitionCost", s.MaintainanceCostPercentageToAcquisitionCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageSettings.
func (s *StorageSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "costPerGbPerMonth":
			err = unpopulate(val, "CostPerGbPerMonth", &s.CostPerGbPerMonth)
			delete(rawMsg, key)
		case "maintainanceCostPercentageToAcquisitionCost":
			err = unpopulate(val, "MaintainanceCostPercentageToAcquisitionCost", &s.MaintainanceCostPercentageToAcquisitionCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuitabilityResult.
func (s SuitabilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "failedChecks", s.FailedChecks)
	populate(objectMap, "readiness", s.Readiness)
	populate(objectMap, "suggestedMigrationTool", s.SuggestedMigrationTool)
	populate(objectMap, "suitability", s.Suitability)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SuitabilityResult.
func (s *SuitabilityResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failedChecks":
			err = unpopulate(val, "FailedChecks", &s.FailedChecks)
			delete(rawMsg, key)
		case "readiness":
			err = unpopulate(val, "Readiness", &s.Readiness)
			delete(rawMsg, key)
		case "suggestedMigrationTool":
			err = unpopulate(val, "SuggestedMigrationTool", &s.SuggestedMigrationTool)
			delete(rawMsg, key)
		case "suitability":
			err = unpopulate(val, "Suitability", &s.Suitability)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SummaryDetails.
func (s SummaryDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", s.Count)
	populate(objectMap, "monthlyCost", s.MonthlyCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SummaryDetails.
func (s *SummaryDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &s.Count)
			delete(rawMsg, key)
		case "monthlyCost":
			err = unpopulate(val, "MonthlyCost", &s.MonthlyCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SupportStatusDistribution.
func (s SupportStatusDistribution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "extended", s.Extended)
	populate(objectMap, "mainStream", s.MainStream)
	populate(objectMap, "outOfSupport", s.OutOfSupport)
	populate(objectMap, "unknownSupport", s.UnknownSupport)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SupportStatusDistribution.
func (s *SupportStatusDistribution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extended":
			err = unpopulate(val, "Extended", &s.Extended)
			delete(rawMsg, key)
		case "mainStream":
			err = unpopulate(val, "MainStream", &s.MainStream)
			delete(rawMsg, key)
		case "outOfSupport":
			err = unpopulate(val, "OutOfSupport", &s.OutOfSupport)
			delete(rawMsg, key)
		case "unknownSupport":
			err = unpopulate(val, "UnknownSupport", &s.UnknownSupport)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetSpecificResult.
func (t TargetSpecificResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentResult", t.AssessmentResult)
	populate(objectMap, "migrationIssues", t.MigrationIssues)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetSpecificResult.
func (t *TargetSpecificResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentResult":
			err = unpopulate(val, "AssessmentResult", &t.AssessmentResult)
			delete(rawMsg, key)
		case "migrationIssues":
			err = unpopulate(val, "MigrationIssues", &t.MigrationIssues)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetSpecificSummary.
func (t TargetSpecificSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "readinessSummary", t.ReadinessSummary)
	populate(objectMap, "recommendationResultSkuDetails", t.RecommendationResultSKUDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetSpecificSummary.
func (t *TargetSpecificSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "readinessSummary":
			err = unpopulate(val, "ReadinessSummary", &t.ReadinessSummary)
			delete(rawMsg, key)
		case "recommendationResultSkuDetails":
			err = unpopulate(val, "RecommendationResultSKUDetails", &t.RecommendationResultSKUDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThirdPartyManagementSettings.
func (t ThirdPartyManagementSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseCost", t.LicenseCost)
	populate(objectMap, "supportCost", t.SupportCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThirdPartyManagementSettings.
func (t *ThirdPartyManagementSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseCost":
			err = unpopulate(val, "LicenseCost", &t.LicenseCost)
			delete(rawMsg, key)
		case "supportCost":
			err = unpopulate(val, "SupportCost", &t.SupportCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UltraDiskAssessmentOptions.
func (u UltraDiskAssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "familyName", u.FamilyName)
	populate(objectMap, "targetLocations", u.TargetLocations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UltraDiskAssessmentOptions.
func (u *UltraDiskAssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "familyName":
			err = unpopulate(val, "FamilyName", &u.FamilyName)
			delete(rawMsg, key)
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &u.TargetLocations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGroupBody.
func (u UpdateGroupBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", u.ETag)
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGroupBody.
func (u *UpdateGroupBody) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
			err = unpopulate(val, "ETag", &u.ETag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &u.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationData.
func (u UtilizationData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfActiveEntities", u.NumberOfActiveEntities)
	populate(objectMap, "numberOfDecommisionEntities", u.NumberOfDecommisionEntities)
	populate(objectMap, "numberOfInactiveEntities", u.NumberOfInactiveEntities)
	populate(objectMap, "numberOfUnknownEntities", u.NumberOfUnknownEntities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UtilizationData.
func (u *UtilizationData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfActiveEntities":
			err = unpopulate(val, "NumberOfActiveEntities", &u.NumberOfActiveEntities)
			delete(rawMsg, key)
		case "numberOfDecommisionEntities":
			err = unpopulate(val, "NumberOfDecommisionEntities", &u.NumberOfDecommisionEntities)
			delete(rawMsg, key)
		case "numberOfInactiveEntities":
			err = unpopulate(val, "NumberOfInactiveEntities", &u.NumberOfInactiveEntities)
			delete(rawMsg, key)
		case "numberOfUnknownEntities":
			err = unpopulate(val, "NumberOfUnknownEntities", &u.NumberOfUnknownEntities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMFamilyOptions.
func (v VMFamilyOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", v.Category)
	populate(objectMap, "familyName", v.FamilyName)
	populate(objectMap, "targetLocations", v.TargetLocations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMFamilyOptions.
func (v *VMFamilyOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &v.Category)
			delete(rawMsg, key)
		case "familyName":
			err = unpopulate(val, "FamilyName", &v.FamilyName)
			delete(rawMsg, key)
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &v.TargetLocations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMUptime.
func (v VMUptime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "daysPerMonth", v.DaysPerMonth)
	populate(objectMap, "hoursPerDay", v.HoursPerDay)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMUptime.
func (v *VMUptime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "daysPerMonth":
			err = unpopulate(val, "DaysPerMonth", &v.DaysPerMonth)
			delete(rawMsg, key)
		case "hoursPerDay":
			err = unpopulate(val, "HoursPerDay", &v.HoursPerDay)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualizationSoftwareSettings.
func (v VirtualizationSoftwareSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "vMwareCloudFoundationLicenseCost", v.VMwareCloudFoundationLicenseCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualizationSoftwareSettings.
func (v *VirtualizationSoftwareSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "vMwareCloudFoundationLicenseCost":
			err = unpopulate(val, "VMwareCloudFoundationLicenseCost", &v.VMwareCloudFoundationLicenseCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VmwareCollector.
func (v VmwareCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VmwareCollector.
func (v *VmwareCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VmwareCollectorListResult.
func (v VmwareCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VmwareCollectorListResult.
func (v *VmwareCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentOptions.
func (w WebAppAssessmentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentOptions.
func (w *WebAppAssessmentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentOptionsListResult.
func (w WebAppAssessmentOptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentOptionsListResult.
func (w *WebAppAssessmentOptionsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentOptionsProperties.
func (w WebAppAssessmentOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "reservedInstanceSupportedCurrencies", w.ReservedInstanceSupportedCurrencies)
	populate(objectMap, "reservedInstanceSupportedLocations", w.ReservedInstanceSupportedLocations)
	populate(objectMap, "reservedInstanceSupportedOffers", w.ReservedInstanceSupportedOffers)
	populate(objectMap, "reservedInstanceSupportedWebAppTiers", w.ReservedInstanceSupportedWebAppTiers)
	populate(objectMap, "savingsPlanSupportedLocations", w.SavingsPlanSupportedLocations)
	populate(objectMap, "savingsPlanSupportedWebAppTiers", w.SavingsPlanSupportedWebAppTiers)
	populate(objectMap, "webAppSkus", w.WebAppSKUs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentOptionsProperties.
func (w *WebAppAssessmentOptionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "reservedInstanceSupportedCurrencies":
			err = unpopulate(val, "ReservedInstanceSupportedCurrencies", &w.ReservedInstanceSupportedCurrencies)
			delete(rawMsg, key)
		case "reservedInstanceSupportedLocations":
			err = unpopulate(val, "ReservedInstanceSupportedLocations", &w.ReservedInstanceSupportedLocations)
			delete(rawMsg, key)
		case "reservedInstanceSupportedOffers":
			err = unpopulate(val, "ReservedInstanceSupportedOffers", &w.ReservedInstanceSupportedOffers)
			delete(rawMsg, key)
		case "reservedInstanceSupportedWebAppTiers":
			err = unpopulate(val, "ReservedInstanceSupportedWebAppTiers", &w.ReservedInstanceSupportedWebAppTiers)
			delete(rawMsg, key)
		case "savingsPlanSupportedLocations":
			err = unpopulate(val, "SavingsPlanSupportedLocations", &w.SavingsPlanSupportedLocations)
			delete(rawMsg, key)
		case "savingsPlanSupportedWebAppTiers":
			err = unpopulate(val, "SavingsPlanSupportedWebAppTiers", &w.SavingsPlanSupportedWebAppTiers)
			delete(rawMsg, key)
		case "webAppSkus":
			err = unpopulate(val, "WebAppSKUs", &w.WebAppSKUs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2.
func (w WebAppAssessmentV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2.
func (w *WebAppAssessmentV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2ListResult.
func (w WebAppAssessmentV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2ListResult.
func (w *WebAppAssessmentV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2Properties.
func (w WebAppAssessmentV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appSvcContainerSettings", w.AppSvcContainerSettings)
	populate(objectMap, "appSvcNativeSettings", w.AppSvcNativeSettings)
	populate(objectMap, "assessmentType", w.AssessmentType)
	populate(objectMap, "azureLocation", w.AzureLocation)
	populate(objectMap, "azureOfferCode", w.AzureOfferCode)
	populate(objectMap, "azureSecurityOfferingType", w.AzureSecurityOfferingType)
	populate(objectMap, "confidenceRatingInPercentage", w.ConfidenceRatingInPercentage)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", w.CreatedTimestamp)
	populate(objectMap, "currency", w.Currency)
	populate(objectMap, "discountPercentage", w.DiscountPercentage)
	populate(objectMap, "discoveredEntityLightSummary", w.DiscoveredEntityLightSummary)
	populate(objectMap, "eaSubscriptionId", w.EaSubscriptionID)
	populate(objectMap, "entityUptime", w.EntityUptime)
	populate(objectMap, "environmentType", w.EnvironmentType)
	populate(objectMap, "groupType", w.GroupType)
	populate(objectMap, "percentile", w.Percentile)
	populateDateTimeRFC3339(objectMap, "perfDataEndTime", w.PerfDataEndTime)
	populateDateTimeRFC3339(objectMap, "perfDataStartTime", w.PerfDataStartTime)
	populateDateTimeRFC3339(objectMap, "pricesTimestamp", w.PricesTimestamp)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "reservedInstance", w.ReservedInstance)
	populate(objectMap, "scalingFactor", w.ScalingFactor)
	populate(objectMap, "schemaVersion", w.SchemaVersion)
	populate(objectMap, "sizingCriterion", w.SizingCriterion)
	populate(objectMap, "stage", w.Stage)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "timeRange", w.TimeRange)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", w.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2Properties.
func (w *WebAppAssessmentV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appSvcContainerSettings":
			err = unpopulate(val, "AppSvcContainerSettings", &w.AppSvcContainerSettings)
			delete(rawMsg, key)
		case "appSvcNativeSettings":
			err = unpopulate(val, "AppSvcNativeSettings", &w.AppSvcNativeSettings)
			delete(rawMsg, key)
		case "assessmentType":
			err = unpopulate(val, "AssessmentType", &w.AssessmentType)
			delete(rawMsg, key)
		case "azureLocation":
			err = unpopulate(val, "AzureLocation", &w.AzureLocation)
			delete(rawMsg, key)
		case "azureOfferCode":
			err = unpopulate(val, "AzureOfferCode", &w.AzureOfferCode)
			delete(rawMsg, key)
		case "azureSecurityOfferingType":
			err = unpopulate(val, "AzureSecurityOfferingType", &w.AzureSecurityOfferingType)
			delete(rawMsg, key)
		case "confidenceRatingInPercentage":
			err = unpopulate(val, "ConfidenceRatingInPercentage", &w.ConfidenceRatingInPercentage)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &w.CreatedTimestamp)
			delete(rawMsg, key)
		case "currency":
			err = unpopulate(val, "Currency", &w.Currency)
			delete(rawMsg, key)
		case "discountPercentage":
			err = unpopulate(val, "DiscountPercentage", &w.DiscountPercentage)
			delete(rawMsg, key)
		case "discoveredEntityLightSummary":
			err = unpopulate(val, "DiscoveredEntityLightSummary", &w.DiscoveredEntityLightSummary)
			delete(rawMsg, key)
		case "eaSubscriptionId":
			err = unpopulate(val, "EaSubscriptionID", &w.EaSubscriptionID)
			delete(rawMsg, key)
		case "entityUptime":
			err = unpopulate(val, "EntityUptime", &w.EntityUptime)
			delete(rawMsg, key)
		case "environmentType":
			err = unpopulate(val, "EnvironmentType", &w.EnvironmentType)
			delete(rawMsg, key)
		case "groupType":
			err = unpopulate(val, "GroupType", &w.GroupType)
			delete(rawMsg, key)
		case "percentile":
			err = unpopulate(val, "Percentile", &w.Percentile)
			delete(rawMsg, key)
		case "perfDataEndTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataEndTime", &w.PerfDataEndTime)
			delete(rawMsg, key)
		case "perfDataStartTime":
			err = unpopulateDateTimeRFC3339(val, "PerfDataStartTime", &w.PerfDataStartTime)
			delete(rawMsg, key)
		case "pricesTimestamp":
			err = unpopulateDateTimeRFC3339(val, "PricesTimestamp", &w.PricesTimestamp)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "reservedInstance":
			err = unpopulate(val, "ReservedInstance", &w.ReservedInstance)
			delete(rawMsg, key)
		case "scalingFactor":
			err = unpopulate(val, "ScalingFactor", &w.ScalingFactor)
			delete(rawMsg, key)
		case "schemaVersion":
			err = unpopulate(val, "SchemaVersion", &w.SchemaVersion)
			delete(rawMsg, key)
		case "sizingCriterion":
			err = unpopulate(val, "SizingCriterion", &w.SizingCriterion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, "Stage", &w.Stage)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		case "timeRange":
			err = unpopulate(val, "TimeRange", &w.TimeRange)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &w.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2Summary.
func (w WebAppAssessmentV2Summary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2Summary.
func (w *WebAppAssessmentV2Summary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2SummaryListResult.
func (w WebAppAssessmentV2SummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2SummaryListResult.
func (w *WebAppAssessmentV2SummaryListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppAssessmentV2SummaryProperties.
func (w WebAppAssessmentV2SummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assessmentSummary", w.AssessmentSummary)
	populate(objectMap, "targetSpecificSummary", w.TargetSpecificSummary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppAssessmentV2SummaryProperties.
func (w *WebAppAssessmentV2SummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentSummary":
			err = unpopulate(val, "AssessmentSummary", &w.AssessmentSummary)
			delete(rawMsg, key)
		case "targetSpecificSummary":
			err = unpopulate(val, "TargetSpecificSummary", &w.TargetSpecificSummary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppCollector.
func (w WebAppCollector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppCollector.
func (w *WebAppCollector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppCollectorListResult.
func (w WebAppCollectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppCollectorListResult.
func (w *WebAppCollectorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppCollectorPropertiesBaseWithAgent.
func (w WebAppCollectorPropertiesBaseWithAgent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "agentProperties", w.AgentProperties)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", w.CreatedTimestamp)
	populate(objectMap, "discoverySiteId", w.DiscoverySiteID)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", w.UpdatedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppCollectorPropertiesBaseWithAgent.
func (w *WebAppCollectorPropertiesBaseWithAgent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentProperties":
			err = unpopulate(val, "AgentProperties", &w.AgentProperties)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &w.CreatedTimestamp)
			delete(rawMsg, key)
		case "discoverySiteId":
			err = unpopulate(val, "DiscoverySiteID", &w.DiscoverySiteID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &w.UpdatedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppDistribution.
func (w WebAppDistribution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfWebApps", w.NumberOfWebApps)
	populate(objectMap, "webAppType", w.WebAppType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppDistribution.
func (w *WebAppDistribution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfWebApps":
			err = unpopulate(val, "NumberOfWebApps", &w.NumberOfWebApps)
			delete(rawMsg, key)
		case "webAppType":
			err = unpopulate(val, "WebAppType", &w.WebAppType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppMigrationIssues.
func (w WebAppMigrationIssues) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "issueCategory", w.IssueCategory)
	populate(objectMap, "issueDescriptionList", w.IssueDescriptionList)
	populate(objectMap, "issueId", w.IssueID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppMigrationIssues.
func (w *WebAppMigrationIssues) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "issueCategory":
			err = unpopulate(val, "IssueCategory", &w.IssueCategory)
			delete(rawMsg, key)
		case "issueDescriptionList":
			err = unpopulate(val, "IssueDescriptionList", &w.IssueDescriptionList)
			delete(rawMsg, key)
		case "issueId":
			err = unpopulate(val, "IssueID", &w.IssueID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppSKUDetails.
func (w WebAppSKUDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appServicePlanCount", w.AppServicePlanCount)
	populate(objectMap, "monthlySecurityCost", w.MonthlySecurityCost)
	populate(objectMap, "skuName", w.SKUName)
	populate(objectMap, "skuSize", w.SKUSize)
	populate(objectMap, "totalMonthlyCost", w.TotalMonthlyCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppSKUDetails.
func (w *WebAppSKUDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appServicePlanCount":
			err = unpopulate(val, "AppServicePlanCount", &w.AppServicePlanCount)
			delete(rawMsg, key)
		case "monthlySecurityCost":
			err = unpopulate(val, "MonthlySecurityCost", &w.MonthlySecurityCost)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, "SKUName", &w.SKUName)
			delete(rawMsg, key)
		case "skuSize":
			err = unpopulate(val, "SKUSize", &w.SKUSize)
			delete(rawMsg, key)
		case "totalMonthlyCost":
			err = unpopulate(val, "TotalMonthlyCost", &w.TotalMonthlyCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppServicePlanV2.
func (w WebAppServicePlanV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppServicePlanV2.
func (w *WebAppServicePlanV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppServicePlanV2ListResult.
func (w WebAppServicePlanV2ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppServicePlanV2ListResult.
func (w *WebAppServicePlanV2ListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppServicePlanV2Properties.
func (w WebAppServicePlanV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cores", w.Cores)
	populate(objectMap, "costComponents", w.CostComponents)
	populateDateTimeRFC3339(objectMap, "createdTimestamp", w.CreatedTimestamp)
	populate(objectMap, "monthlyCost", w.MonthlyCost)
	populate(objectMap, "numberOfWebApps", w.NumberOfWebApps)
	populate(objectMap, "ram", w.RAM)
	populate(objectMap, "scaleOutInstances", w.ScaleOutInstances)
	populate(objectMap, "storage", w.Storage)
	populateDateTimeRFC3339(objectMap, "updatedTimestamp", w.UpdatedTimestamp)
	populate(objectMap, "webAppSkuName", w.WebAppSKUName)
	populate(objectMap, "webAppSkuSize", w.WebAppSKUSize)
	populate(objectMap, "webAppServicePlanName", w.WebAppServicePlanName)
	populate(objectMap, "webAppTargetType", w.WebAppTargetType)
	populate(objectMap, "webAppType", w.WebAppType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppServicePlanV2Properties.
func (w *WebAppServicePlanV2Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cores":
			err = unpopulate(val, "Cores", &w.Cores)
			delete(rawMsg, key)
		case "costComponents":
			err = unpopulate(val, "CostComponents", &w.CostComponents)
			delete(rawMsg, key)
		case "createdTimestamp":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimestamp", &w.CreatedTimestamp)
			delete(rawMsg, key)
		case "monthlyCost":
			err = unpopulate(val, "MonthlyCost", &w.MonthlyCost)
			delete(rawMsg, key)
		case "numberOfWebApps":
			err = unpopulate(val, "NumberOfWebApps", &w.NumberOfWebApps)
			delete(rawMsg, key)
		case "ram":
			err = unpopulate(val, "RAM", &w.RAM)
			delete(rawMsg, key)
		case "scaleOutInstances":
			err = unpopulate(val, "ScaleOutInstances", &w.ScaleOutInstances)
			delete(rawMsg, key)
		case "storage":
			err = unpopulate(val, "Storage", &w.Storage)
			delete(rawMsg, key)
		case "updatedTimestamp":
			err = unpopulateDateTimeRFC3339(val, "UpdatedTimestamp", &w.UpdatedTimestamp)
			delete(rawMsg, key)
		case "webAppSkuName":
			err = unpopulate(val, "WebAppSKUName", &w.WebAppSKUName)
			delete(rawMsg, key)
		case "webAppSkuSize":
			err = unpopulate(val, "WebAppSKUSize", &w.WebAppSKUSize)
			delete(rawMsg, key)
		case "webAppServicePlanName":
			err = unpopulate(val, "WebAppServicePlanName", &w.WebAppServicePlanName)
			delete(rawMsg, key)
		case "webAppTargetType":
			err = unpopulate(val, "WebAppTargetType", &w.WebAppTargetType)
			delete(rawMsg, key)
		case "webAppType":
			err = unpopulate(val, "WebAppType", &w.WebAppType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppTargetOptions.
func (w WebAppTargetOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targetLocations", w.TargetLocations)
	populate(objectMap, "webAppTier", w.WebAppTier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppTargetOptions.
func (w *WebAppTargetOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targetLocations":
			err = unpopulate(val, "TargetLocations", &w.TargetLocations)
			delete(rawMsg, key)
		case "webAppTier":
			err = unpopulate(val, "WebAppTier", &w.WebAppTier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAppTargetSKU.
func (w WebAppTargetSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", w.Cost)
	populate(objectMap, "count", w.Count)
	populate(objectMap, "skuName", w.SKUName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAppTargetSKU.
func (w *WebAppTargetSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &w.Cost)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, "Count", &w.Count)
			delete(rawMsg, key)
		case "skuName":
			err = unpopulate(val, "SKUName", &w.SKUName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsServerLicensingSettings.
func (w WindowsServerLicensingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "licenseCost", w.LicenseCost)
	populate(objectMap, "licensesPerCore", w.LicensesPerCore)
	populate(objectMap, "softwareAssuranceCost", w.SoftwareAssuranceCost)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsServerLicensingSettings.
func (w *WindowsServerLicensingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "licenseCost":
			err = unpopulate(val, "LicenseCost", &w.LicenseCost)
			delete(rawMsg, key)
		case "licensesPerCore":
			err = unpopulate(val, "LicensesPerCore", &w.LicensesPerCore)
			delete(rawMsg, key)
		case "softwareAssuranceCost":
			err = unpopulate(val, "SoftwareAssuranceCost", &w.SoftwareAssuranceCost)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadSummary.
func (w WorkloadSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "oracleInstances", w.OracleInstances)
	populate(objectMap, "springApps", w.SpringApps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadSummary.
func (w *WorkloadSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oracleInstances":
			err = unpopulate(val, "OracleInstances", &w.OracleInstances)
			delete(rawMsg, key)
		case "springApps":
			err = unpopulate(val, "SpringApps", &w.SpringApps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type YearOnYearCost.
func (y YearOnYearCost) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cost", y.Cost)
	populate(objectMap, "year", y.Year)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type YearOnYearCost.
func (y *YearOnYearCost) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", y, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cost":
			err = unpopulate(val, "Cost", &y.Cost)
			delete(rawMsg, key)
		case "year":
			err = unpopulate(val, "Year", &y.Year)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", y, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type YearOnYearEstimates.
func (y YearOnYearEstimates) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureArcEnabledOnPremisesCost", y.AzureArcEnabledOnPremisesCost)
	populate(objectMap, "azureCapexCost", y.AzureCapexCost)
	populate(objectMap, "azureCost", y.AzureCost)
	populate(objectMap, "azureOpexCost", y.AzureOpexCost)
	populate(objectMap, "futureAzureArcEnabledOnPremisesEsuCost", y.FutureAzureArcEnabledOnPremisesEsuCost)
	populate(objectMap, "futureCost", y.FutureCost)
	populate(objectMap, "futureOnPremisesEsuCost", y.FutureOnPremisesEsuCost)
	populate(objectMap, "onPremisesCapexCost", y.OnPremisesCapexCost)
	populate(objectMap, "onPremisesCost", y.OnPremisesCost)
	populate(objectMap, "onPremisesOpexCost", y.OnPremisesOpexCost)
	populate(objectMap, "paybackPeriod", y.PaybackPeriod)
	populate(objectMap, "savings", y.Savings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type YearOnYearEstimates.
func (y *YearOnYearEstimates) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", y, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureArcEnabledOnPremisesCost":
			err = unpopulate(val, "AzureArcEnabledOnPremisesCost", &y.AzureArcEnabledOnPremisesCost)
			delete(rawMsg, key)
		case "azureCapexCost":
			err = unpopulate(val, "AzureCapexCost", &y.AzureCapexCost)
			delete(rawMsg, key)
		case "azureCost":
			err = unpopulate(val, "AzureCost", &y.AzureCost)
			delete(rawMsg, key)
		case "azureOpexCost":
			err = unpopulate(val, "AzureOpexCost", &y.AzureOpexCost)
			delete(rawMsg, key)
		case "futureAzureArcEnabledOnPremisesEsuCost":
			err = unpopulate(val, "FutureAzureArcEnabledOnPremisesEsuCost", &y.FutureAzureArcEnabledOnPremisesEsuCost)
			delete(rawMsg, key)
		case "futureCost":
			err = unpopulate(val, "FutureCost", &y.FutureCost)
			delete(rawMsg, key)
		case "futureOnPremisesEsuCost":
			err = unpopulate(val, "FutureOnPremisesEsuCost", &y.FutureOnPremisesEsuCost)
			delete(rawMsg, key)
		case "onPremisesCapexCost":
			err = unpopulate(val, "OnPremisesCapexCost", &y.OnPremisesCapexCost)
			delete(rawMsg, key)
		case "onPremisesCost":
			err = unpopulate(val, "OnPremisesCost", &y.OnPremisesCost)
			delete(rawMsg, key)
		case "onPremisesOpexCost":
			err = unpopulate(val, "OnPremisesOpexCost", &y.OnPremisesOpexCost)
			delete(rawMsg, key)
		case "paybackPeriod":
			err = unpopulate(val, "PaybackPeriod", &y.PaybackPeriod)
			delete(rawMsg, key)
		case "savings":
			err = unpopulate(val, "Savings", &y.Savings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", y, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
