//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmonitor

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// GetAction implements the ActionClassification interface for type Action.
func (a *Action) GetAction() *Action { return a }

// MarshalJSON implements the json.Marshaller interface for type ActionGroup.
func (a ActionGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "armRoleReceivers", a.ArmRoleReceivers)
	populate(objectMap, "automationRunbookReceivers", a.AutomationRunbookReceivers)
	populate(objectMap, "azureAppPushReceivers", a.AzureAppPushReceivers)
	populate(objectMap, "azureFunctionReceivers", a.AzureFunctionReceivers)
	populate(objectMap, "emailReceivers", a.EmailReceivers)
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "eventHubReceivers", a.EventHubReceivers)
	populate(objectMap, "groupShortName", a.GroupShortName)
	populate(objectMap, "itsmReceivers", a.ItsmReceivers)
	populate(objectMap, "logicAppReceivers", a.LogicAppReceivers)
	populate(objectMap, "smsReceivers", a.SmsReceivers)
	populate(objectMap, "voiceReceivers", a.VoiceReceivers)
	populate(objectMap, "webhookReceivers", a.WebhookReceivers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroupAutoGenerated.
func (a ActionGroupAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionGroupId", a.ActionGroupID)
	populate(objectMap, "webhookProperties", a.WebhookProperties)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroupList.
func (a ActionGroupList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroupPatchBody.
func (a ActionGroupPatchBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionGroupResource.
func (a ActionGroupResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionList.
func (a ActionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionGroups", a.ActionGroups)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActivityLogAlertResource.
func (a ActivityLogAlertResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRule.
func (a AlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", a.Action)
	populate(objectMap, "actions", a.Actions)
	populate(objectMap, "condition", a.Condition)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", a.LastUpdatedTime)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertRule.
func (a *AlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			a.Action, err = unmarshalRuleActionClassification(val)
			delete(rawMsg, key)
		case "actions":
			a.Actions, err = unmarshalRuleActionClassificationArray(val)
			delete(rawMsg, key)
		case "condition":
			a.Condition, err = unmarshalRuleConditionClassification(val)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &a.IsEnabled)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &a.LastUpdatedTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleAllOfCondition.
func (a AlertRuleAllOfCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allOf", a.AllOf)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleAnyOfOrLeafCondition.
func (a AlertRuleAnyOfOrLeafCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "anyOf", a.AnyOf)
	populate(objectMap, "containsAny", a.ContainsAny)
	populate(objectMap, "equals", a.Equals)
	populate(objectMap, "field", a.Field)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleLeafCondition.
func (a AlertRuleLeafCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containsAny", a.ContainsAny)
	populate(objectMap, "equals", a.Equals)
	populate(objectMap, "field", a.Field)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleList.
func (a AlertRuleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRulePatchObject.
func (a AlertRulePatchObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleProperties.
func (a AlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", a.Actions)
	populate(objectMap, "condition", a.Condition)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "scopes", a.Scopes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleResource.
func (a AlertRuleResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleResourceCollection.
func (a AlertRuleResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleResourcePatch.
func (a AlertRuleResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// GetAction implements the ActionClassification interface for type AlertingAction.
func (a *AlertingAction) GetAction() *Action {
	return &Action{
		ODataType: a.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AlertingAction.
func (a AlertingAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aznsAction", a.AznsAction)
	objectMap["odata.type"] = "Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.AlertingAction"
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "throttlingInMin", a.ThrottlingInMin)
	populate(objectMap, "trigger", a.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertingAction.
func (a *AlertingAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aznsAction":
			err = unpopulate(val, &a.AznsAction)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &a.ODataType)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &a.Severity)
			delete(rawMsg, key)
		case "throttlingInMin":
			err = unpopulate(val, &a.ThrottlingInMin)
			delete(rawMsg, key)
		case "trigger":
			err = unpopulate(val, &a.Trigger)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleNotification.
func (a AutoscaleNotification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "email", a.Email)
	populate(objectMap, "operation", a.Operation)
	populate(objectMap, "webhooks", a.Webhooks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleProfile.
func (a AutoscaleProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capacity", a.Capacity)
	populate(objectMap, "fixedDate", a.FixedDate)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "recurrence", a.Recurrence)
	populate(objectMap, "rules", a.Rules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleSetting.
func (a AutoscaleSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "notifications", a.Notifications)
	populate(objectMap, "profiles", a.Profiles)
	populate(objectMap, "targetResourceLocation", a.TargetResourceLocation)
	populate(objectMap, "targetResourceUri", a.TargetResourceURI)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleSettingResource.
func (a AutoscaleSettingResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleSettingResourceCollection.
func (a AutoscaleSettingResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutoscaleSettingResourcePatch.
func (a AutoscaleSettingResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzNsActionGroup.
func (a AzNsActionGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionGroup", a.ActionGroup)
	populate(objectMap, "customWebhookPayload", a.CustomWebhookPayload)
	populate(objectMap, "emailSubject", a.EmailSubject)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureMonitorPrivateLinkScope.
func (a AzureMonitorPrivateLinkScope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureMonitorPrivateLinkScopeListResult.
func (a AzureMonitorPrivateLinkScopeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureMonitorPrivateLinkScopeProperties.
func (a AzureMonitorPrivateLinkScopeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "privateEndpointConnections", a.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureResource.
func (a AzureResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceAutoGenerated.
func (a AzureResourceAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Criteria.
func (c Criteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimensions", c.Dimensions)
	populate(objectMap, "metricName", c.MetricName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionEndpointResource.
func (d DataCollectionEndpointResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionEndpointResourceListResult.
func (d DataCollectionEndpointResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionEndpointResourceSystemData.
func (d DataCollectionEndpointResourceSystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", d.CreatedAt)
	populate(objectMap, "createdBy", d.CreatedBy)
	populate(objectMap, "createdByType", d.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", d.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", d.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", d.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionEndpointResourceSystemData.
func (d *DataCollectionEndpointResourceSystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &d.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &d.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &d.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &d.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &d.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &d.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRule.
func (d DataCollectionRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataCollectionEndpointId", d.DataCollectionEndpointID)
	populate(objectMap, "dataFlows", d.DataFlows)
	populate(objectMap, "dataSources", d.DataSources)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "destinations", d.Destinations)
	populate(objectMap, "immutableId", d.ImmutableID)
	populate(objectMap, "metadata", d.Metadata)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "streamDeclarations", d.StreamDeclarations)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleAssociationProxyOnlyResourceListResult.
func (d DataCollectionRuleAssociationProxyOnlyResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleAssociationProxyOnlyResourceSystemData.
func (d DataCollectionRuleAssociationProxyOnlyResourceSystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", d.CreatedAt)
	populate(objectMap, "createdBy", d.CreatedBy)
	populate(objectMap, "createdByType", d.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", d.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", d.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", d.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionRuleAssociationProxyOnlyResourceSystemData.
func (d *DataCollectionRuleAssociationProxyOnlyResourceSystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &d.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &d.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &d.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &d.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &d.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &d.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleDataSources.
func (d DataCollectionRuleDataSources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extensions", d.Extensions)
	populate(objectMap, "iisLogs", d.IisLogs)
	populate(objectMap, "logFiles", d.LogFiles)
	populate(objectMap, "performanceCounters", d.PerformanceCounters)
	populate(objectMap, "syslog", d.Syslog)
	populate(objectMap, "windowsEventLogs", d.WindowsEventLogs)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleDestinations.
func (d DataCollectionRuleDestinations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureMonitorMetrics", d.AzureMonitorMetrics)
	populate(objectMap, "logAnalytics", d.LogAnalytics)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleResource.
func (d DataCollectionRuleResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleResourceListResult.
func (d DataCollectionRuleResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleResourceProperties.
func (d DataCollectionRuleResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataCollectionEndpointId", d.DataCollectionEndpointID)
	populate(objectMap, "dataFlows", d.DataFlows)
	populate(objectMap, "dataSources", d.DataSources)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "destinations", d.Destinations)
	populate(objectMap, "immutableId", d.ImmutableID)
	populate(objectMap, "metadata", d.Metadata)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "streamDeclarations", d.StreamDeclarations)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionRuleResourceSystemData.
func (d DataCollectionRuleResourceSystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", d.CreatedAt)
	populate(objectMap, "createdBy", d.CreatedBy)
	populate(objectMap, "createdByType", d.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", d.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", d.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", d.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionRuleResourceSystemData.
func (d *DataCollectionRuleResourceSystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &d.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &d.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &d.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &d.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &d.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &d.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataFlow.
func (d DataFlow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destinations", d.Destinations)
	populate(objectMap, "outputStream", d.OutputStream)
	populate(objectMap, "streams", d.Streams)
	populate(objectMap, "transformKql", d.TransformKql)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataSourcesSpec.
func (d DataSourcesSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extensions", d.Extensions)
	populate(objectMap, "iisLogs", d.IisLogs)
	populate(objectMap, "logFiles", d.LogFiles)
	populate(objectMap, "performanceCounters", d.PerformanceCounters)
	populate(objectMap, "syslog", d.Syslog)
	populate(objectMap, "windowsEventLogs", d.WindowsEventLogs)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DestinationsSpec.
func (d DestinationsSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureMonitorMetrics", d.AzureMonitorMetrics)
	populate(objectMap, "logAnalytics", d.LogAnalytics)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticSettings.
func (d DiagnosticSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eventHubAuthorizationRuleId", d.EventHubAuthorizationRuleID)
	populate(objectMap, "eventHubName", d.EventHubName)
	populate(objectMap, "logAnalyticsDestinationType", d.LogAnalyticsDestinationType)
	populate(objectMap, "logs", d.Logs)
	populate(objectMap, "metrics", d.Metrics)
	populate(objectMap, "serviceBusRuleId", d.ServiceBusRuleID)
	populate(objectMap, "storageAccountId", d.StorageAccountID)
	populate(objectMap, "workspaceId", d.WorkspaceID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticSettingsCategoryResourceCollection.
func (d DiagnosticSettingsCategoryResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DiagnosticSettingsResourceCollection.
func (d DiagnosticSettingsResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Dimension.
func (d Dimension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", d.Name)
	populate(objectMap, "operator", d.Operator)
	populate(objectMap, "values", d.Values)
	return json.Marshal(objectMap)
}

// GetMultiMetricCriteria implements the MultiMetricCriteriaClassification interface for type DynamicMetricCriteria.
func (d *DynamicMetricCriteria) GetMultiMetricCriteria() *MultiMetricCriteria {
	return &MultiMetricCriteria{
		CriterionType:        d.CriterionType,
		Name:                 d.Name,
		MetricName:           d.MetricName,
		MetricNamespace:      d.MetricNamespace,
		TimeAggregation:      d.TimeAggregation,
		Dimensions:           d.Dimensions,
		SkipMetricValidation: d.SkipMetricValidation,
		AdditionalProperties: d.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DynamicMetricCriteria.
func (d DynamicMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertSensitivity", d.AlertSensitivity)
	objectMap["criterionType"] = CriterionTypeDynamicThresholdCriterion
	populate(objectMap, "dimensions", d.Dimensions)
	populate(objectMap, "failingPeriods", d.FailingPeriods)
	populateTimeRFC3339(objectMap, "ignoreDataBefore", d.IgnoreDataBefore)
	populate(objectMap, "metricName", d.MetricName)
	populate(objectMap, "metricNamespace", d.MetricNamespace)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "operator", d.Operator)
	populate(objectMap, "skipMetricValidation", d.SkipMetricValidation)
	populate(objectMap, "timeAggregation", d.TimeAggregation)
	if d.AdditionalProperties != nil {
		for key, val := range d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicMetricCriteria.
func (d *DynamicMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertSensitivity":
			err = unpopulate(val, &d.AlertSensitivity)
			delete(rawMsg, key)
		case "criterionType":
			err = unpopulate(val, &d.CriterionType)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, &d.Dimensions)
			delete(rawMsg, key)
		case "failingPeriods":
			err = unpopulate(val, &d.FailingPeriods)
			delete(rawMsg, key)
		case "ignoreDataBefore":
			err = unpopulateTimeRFC3339(val, &d.IgnoreDataBefore)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, &d.MetricName)
			delete(rawMsg, key)
		case "metricNamespace":
			err = unpopulate(val, &d.MetricNamespace)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "operator":
			err = unpopulate(val, &d.Operator)
			delete(rawMsg, key)
		case "skipMetricValidation":
			err = unpopulate(val, &d.SkipMetricValidation)
			delete(rawMsg, key)
		case "timeAggregation":
			err = unpopulate(val, &d.TimeAggregation)
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				d.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailNotification.
func (e EmailNotification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customEmails", e.CustomEmails)
	populate(objectMap, "sendToSubscriptionAdministrator", e.SendToSubscriptionAdministrator)
	populate(objectMap, "sendToSubscriptionCoAdministrators", e.SendToSubscriptionCoAdministrators)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseCommon.
func (e ErrorResponseCommon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventCategoryCollection.
func (e EventCategoryCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EventData.
func (e EventData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authorization", e.Authorization)
	populate(objectMap, "caller", e.Caller)
	populate(objectMap, "category", e.Category)
	populate(objectMap, "claims", e.Claims)
	populate(objectMap, "correlationId", e.CorrelationID)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "eventDataId", e.EventDataID)
	populate(objectMap, "eventName", e.EventName)
	populateTimeRFC3339(objectMap, "eventTimestamp", e.EventTimestamp)
	populate(objectMap, "httpRequest", e.HTTPRequest)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "level", e.Level)
	populate(objectMap, "operationId", e.OperationID)
	populate(objectMap, "operationName", e.OperationName)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "resourceGroupName", e.ResourceGroupName)
	populate(objectMap, "resourceId", e.ResourceID)
	populate(objectMap, "resourceProviderName", e.ResourceProviderName)
	populate(objectMap, "resourceType", e.ResourceType)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "subStatus", e.SubStatus)
	populateTimeRFC3339(objectMap, "submissionTimestamp", e.SubmissionTimestamp)
	populate(objectMap, "subscriptionId", e.SubscriptionID)
	populate(objectMap, "tenantId", e.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventData.
func (e *EventData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorization":
			err = unpopulate(val, &e.Authorization)
			delete(rawMsg, key)
		case "caller":
			err = unpopulate(val, &e.Caller)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, &e.Category)
			delete(rawMsg, key)
		case "claims":
			err = unpopulate(val, &e.Claims)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, &e.CorrelationID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &e.Description)
			delete(rawMsg, key)
		case "eventDataId":
			err = unpopulate(val, &e.EventDataID)
			delete(rawMsg, key)
		case "eventName":
			err = unpopulate(val, &e.EventName)
			delete(rawMsg, key)
		case "eventTimestamp":
			err = unpopulateTimeRFC3339(val, &e.EventTimestamp)
			delete(rawMsg, key)
		case "httpRequest":
			err = unpopulate(val, &e.HTTPRequest)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &e.Level)
			delete(rawMsg, key)
		case "operationId":
			err = unpopulate(val, &e.OperationID)
			delete(rawMsg, key)
		case "operationName":
			err = unpopulate(val, &e.OperationName)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, &e.ResourceGroupName)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &e.ResourceID)
			delete(rawMsg, key)
		case "resourceProviderName":
			err = unpopulate(val, &e.ResourceProviderName)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, &e.ResourceType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &e.Status)
			delete(rawMsg, key)
		case "subStatus":
			err = unpopulate(val, &e.SubStatus)
			delete(rawMsg, key)
		case "submissionTimestamp":
			err = unpopulateTimeRFC3339(val, &e.SubmissionTimestamp)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &e.SubscriptionID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &e.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventDataCollection.
func (e EventDataCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ExtensionDataSource.
func (e ExtensionDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extensionName", e.ExtensionName)
	populate(objectMap, "extensionSettings", &e.ExtensionSettings)
	populate(objectMap, "inputDataSources", e.InputDataSources)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "streams", e.Streams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IisLogsDataSource.
func (i IisLogsDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logDirectories", i.LogDirectories)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "streams", i.Streams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Incident.
func (i Incident) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "activatedTime", i.ActivatedTime)
	populate(objectMap, "isActive", i.IsActive)
	populate(objectMap, "name", i.Name)
	populateTimeRFC3339(objectMap, "resolvedTime", i.ResolvedTime)
	populate(objectMap, "ruleName", i.RuleName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Incident.
func (i *Incident) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activatedTime":
			err = unpopulateTimeRFC3339(val, &i.ActivatedTime)
			delete(rawMsg, key)
		case "isActive":
			err = unpopulate(val, &i.IsActive)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "resolvedTime":
			err = unpopulateTimeRFC3339(val, &i.ResolvedTime)
			delete(rawMsg, key)
		case "ruleName":
			err = unpopulate(val, &i.RuleName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IncidentListResult.
func (i IncidentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// GetRuleCondition implements the RuleConditionClassification interface for type LocationThresholdRuleCondition.
func (l *LocationThresholdRuleCondition) GetRuleCondition() *RuleCondition {
	return &RuleCondition{
		ODataType:  l.ODataType,
		DataSource: l.DataSource,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LocationThresholdRuleCondition.
func (l LocationThresholdRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSource", l.DataSource)
	populate(objectMap, "failedLocationCount", l.FailedLocationCount)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition"
	populate(objectMap, "windowSize", l.WindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LocationThresholdRuleCondition.
func (l *LocationThresholdRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			l.DataSource, err = unmarshalRuleDataSourceClassification(val)
			delete(rawMsg, key)
		case "failedLocationCount":
			err = unpopulate(val, &l.FailedLocationCount)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &l.ODataType)
			delete(rawMsg, key)
		case "windowSize":
			err = unpopulate(val, &l.WindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogFilesDataSource.
func (l LogFilesDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filePatterns", l.FilePatterns)
	populate(objectMap, "format", l.Format)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "settings", l.Settings)
	populate(objectMap, "streams", l.Streams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogProfileCollection.
func (l LogProfileCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogProfileProperties.
func (l LogProfileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "categories", l.Categories)
	populate(objectMap, "locations", l.Locations)
	populate(objectMap, "retentionPolicy", l.RetentionPolicy)
	populate(objectMap, "serviceBusRuleId", l.ServiceBusRuleID)
	populate(objectMap, "storageAccountId", l.StorageAccountID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogProfileResource.
func (l LogProfileResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", l.ID)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogProfileResourcePatch.
func (l LogProfileResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogSearchRule.
func (l LogSearchRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", l.Action)
	populate(objectMap, "autoMitigate", l.AutoMitigate)
	populate(objectMap, "createdWithApiVersion", l.CreatedWithAPIVersion)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "displayName", l.DisplayName)
	populate(objectMap, "enabled", l.Enabled)
	populate(objectMap, "isLegacyLogAnalyticsRule", l.IsLegacyLogAnalyticsRule)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", l.LastUpdatedTime)
	populate(objectMap, "provisioningState", l.ProvisioningState)
	populate(objectMap, "schedule", l.Schedule)
	populate(objectMap, "source", l.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogSearchRule.
func (l *LogSearchRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			l.Action, err = unmarshalActionClassification(val)
			delete(rawMsg, key)
		case "autoMitigate":
			err = unpopulate(val, &l.AutoMitigate)
			delete(rawMsg, key)
		case "createdWithApiVersion":
			err = unpopulate(val, &l.CreatedWithAPIVersion)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &l.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &l.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &l.Enabled)
			delete(rawMsg, key)
		case "isLegacyLogAnalyticsRule":
			err = unpopulate(val, &l.IsLegacyLogAnalyticsRule)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &l.LastUpdatedTime)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &l.ProvisioningState)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &l.Schedule)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &l.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogSearchRuleResource.
func (l LogSearchRuleResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", l.Etag)
	populate(objectMap, "id", l.ID)
	populate(objectMap, "kind", l.Kind)
	populate(objectMap, "location", l.Location)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogSearchRuleResourceCollection.
func (l LogSearchRuleResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LogSearchRuleResourcePatch.
func (l LogSearchRuleResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", l.Properties)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// GetAction implements the ActionClassification interface for type LogToMetricAction.
func (l *LogToMetricAction) GetAction() *Action {
	return &Action{
		ODataType: l.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type LogToMetricAction.
func (l LogToMetricAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "criteria", l.Criteria)
	objectMap["odata.type"] = "Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.LogToMetricAction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogToMetricAction.
func (l *LogToMetricAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "criteria":
			err = unpopulate(val, &l.Criteria)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRuleCondition implements the RuleConditionClassification interface for type ManagementEventRuleCondition.
func (m *ManagementEventRuleCondition) GetRuleCondition() *RuleCondition {
	return &RuleCondition{
		ODataType:  m.ODataType,
		DataSource: m.DataSource,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ManagementEventRuleCondition.
func (m ManagementEventRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregation", m.Aggregation)
	populate(objectMap, "dataSource", m.DataSource)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementEventRuleCondition.
func (m *ManagementEventRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregation":
			err = unpopulate(val, &m.Aggregation)
			delete(rawMsg, key)
		case "dataSource":
			m.DataSource, err = unmarshalRuleDataSourceClassification(val)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Metric.
func (m Metric) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "timeseries", m.Timeseries)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertAction.
func (m MetricAlertAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionGroupId", m.ActionGroupID)
	populate(objectMap, "webHookProperties", m.WebHookProperties)
	return json.Marshal(objectMap)
}

// GetMetricAlertCriteria implements the MetricAlertCriteriaClassification interface for type MetricAlertCriteria.
func (m *MetricAlertCriteria) GetMetricAlertCriteria() *MetricAlertCriteria { return m }

// MarshalJSON implements the json.Marshaller interface for type MetricAlertCriteria.
func (m MetricAlertCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["odata.type"] = m.ODataType
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertCriteria.
func (m *MetricAlertCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMetricAlertCriteria implements the MetricAlertCriteriaClassification interface for type MetricAlertMultipleResourceMultipleMetricCriteria.
func (m *MetricAlertMultipleResourceMultipleMetricCriteria) GetMetricAlertCriteria() *MetricAlertCriteria {
	return &MetricAlertCriteria{
		ODataType:            m.ODataType,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertMultipleResourceMultipleMetricCriteria.
func (m MetricAlertMultipleResourceMultipleMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allOf", m.AllOf)
	objectMap["odata.type"] = OdatatypeMicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertMultipleResourceMultipleMetricCriteria.
func (m *MetricAlertMultipleResourceMultipleMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allOf":
			m.AllOf, err = unmarshalMultiMetricCriteriaClassificationArray(val)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertProperties.
func (m MetricAlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", m.Actions)
	populate(objectMap, "autoMitigate", m.AutoMitigate)
	populate(objectMap, "criteria", m.Criteria)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "enabled", m.Enabled)
	populate(objectMap, "evaluationFrequency", m.EvaluationFrequency)
	populate(objectMap, "isMigrated", m.IsMigrated)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", m.LastUpdatedTime)
	populate(objectMap, "scopes", m.Scopes)
	populate(objectMap, "severity", m.Severity)
	populate(objectMap, "targetResourceRegion", m.TargetResourceRegion)
	populate(objectMap, "targetResourceType", m.TargetResourceType)
	populate(objectMap, "windowSize", m.WindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertProperties.
func (m *MetricAlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			err = unpopulate(val, &m.Actions)
			delete(rawMsg, key)
		case "autoMitigate":
			err = unpopulate(val, &m.AutoMitigate)
			delete(rawMsg, key)
		case "criteria":
			m.Criteria, err = unmarshalMetricAlertCriteriaClassification(val)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &m.Enabled)
			delete(rawMsg, key)
		case "evaluationFrequency":
			err = unpopulate(val, &m.EvaluationFrequency)
			delete(rawMsg, key)
		case "isMigrated":
			err = unpopulate(val, &m.IsMigrated)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &m.LastUpdatedTime)
			delete(rawMsg, key)
		case "scopes":
			err = unpopulate(val, &m.Scopes)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &m.Severity)
			delete(rawMsg, key)
		case "targetResourceRegion":
			err = unpopulate(val, &m.TargetResourceRegion)
			delete(rawMsg, key)
		case "targetResourceType":
			err = unpopulate(val, &m.TargetResourceType)
			delete(rawMsg, key)
		case "windowSize":
			err = unpopulate(val, &m.WindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertPropertiesPatch.
func (m MetricAlertPropertiesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", m.Actions)
	populate(objectMap, "autoMitigate", m.AutoMitigate)
	populate(objectMap, "criteria", m.Criteria)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "enabled", m.Enabled)
	populate(objectMap, "evaluationFrequency", m.EvaluationFrequency)
	populate(objectMap, "isMigrated", m.IsMigrated)
	populateTimeRFC3339(objectMap, "lastUpdatedTime", m.LastUpdatedTime)
	populate(objectMap, "scopes", m.Scopes)
	populate(objectMap, "severity", m.Severity)
	populate(objectMap, "targetResourceRegion", m.TargetResourceRegion)
	populate(objectMap, "targetResourceType", m.TargetResourceType)
	populate(objectMap, "windowSize", m.WindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertPropertiesPatch.
func (m *MetricAlertPropertiesPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			err = unpopulate(val, &m.Actions)
			delete(rawMsg, key)
		case "autoMitigate":
			err = unpopulate(val, &m.AutoMitigate)
			delete(rawMsg, key)
		case "criteria":
			m.Criteria, err = unmarshalMetricAlertCriteriaClassification(val)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &m.Enabled)
			delete(rawMsg, key)
		case "evaluationFrequency":
			err = unpopulate(val, &m.EvaluationFrequency)
			delete(rawMsg, key)
		case "isMigrated":
			err = unpopulate(val, &m.IsMigrated)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateTimeRFC3339(val, &m.LastUpdatedTime)
			delete(rawMsg, key)
		case "scopes":
			err = unpopulate(val, &m.Scopes)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &m.Severity)
			delete(rawMsg, key)
		case "targetResourceRegion":
			err = unpopulate(val, &m.TargetResourceRegion)
			delete(rawMsg, key)
		case "targetResourceType":
			err = unpopulate(val, &m.TargetResourceType)
			delete(rawMsg, key)
		case "windowSize":
			err = unpopulate(val, &m.WindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertResource.
func (m MetricAlertResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertResourceCollection.
func (m MetricAlertResourceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertResourcePatch.
func (m MetricAlertResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// GetMetricAlertCriteria implements the MetricAlertCriteriaClassification interface for type MetricAlertSingleResourceMultipleMetricCriteria.
func (m *MetricAlertSingleResourceMultipleMetricCriteria) GetMetricAlertCriteria() *MetricAlertCriteria {
	return &MetricAlertCriteria{
		ODataType:            m.ODataType,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertSingleResourceMultipleMetricCriteria.
func (m MetricAlertSingleResourceMultipleMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allOf", m.AllOf)
	objectMap["odata.type"] = OdatatypeMicrosoftAzureMonitorSingleResourceMultipleMetricCriteria
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertSingleResourceMultipleMetricCriteria.
func (m *MetricAlertSingleResourceMultipleMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allOf":
			err = unpopulate(val, &m.AllOf)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &m.ODataType)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertStatusCollection.
func (m MetricAlertStatusCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricAlertStatusProperties.
func (m MetricAlertStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "status", m.Status)
	populateTimeRFC3339(objectMap, "timestamp", m.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricAlertStatusProperties.
func (m *MetricAlertStatusProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimensions":
			err = unpopulate(val, &m.Dimensions)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &m.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricBaselinesProperties.
func (m MetricBaselinesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baselines", m.Baselines)
	populate(objectMap, "interval", m.Interval)
	populate(objectMap, "namespace", m.Namespace)
	populate(objectMap, "timespan", m.Timespan)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricBaselinesResponse.
func (m MetricBaselinesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// GetMultiMetricCriteria implements the MultiMetricCriteriaClassification interface for type MetricCriteria.
func (m *MetricCriteria) GetMultiMetricCriteria() *MultiMetricCriteria {
	return &MultiMetricCriteria{
		CriterionType:        m.CriterionType,
		Name:                 m.Name,
		MetricName:           m.MetricName,
		MetricNamespace:      m.MetricNamespace,
		TimeAggregation:      m.TimeAggregation,
		Dimensions:           m.Dimensions,
		SkipMetricValidation: m.SkipMetricValidation,
		AdditionalProperties: m.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MetricCriteria.
func (m MetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["criterionType"] = CriterionTypeStaticThresholdCriterion
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "metricName", m.MetricName)
	populate(objectMap, "metricNamespace", m.MetricNamespace)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "skipMetricValidation", m.SkipMetricValidation)
	populate(objectMap, "threshold", m.Threshold)
	populate(objectMap, "timeAggregation", m.TimeAggregation)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricCriteria.
func (m *MetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "criterionType":
			err = unpopulate(val, &m.CriterionType)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, &m.Dimensions)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, &m.MetricName)
			delete(rawMsg, key)
		case "metricNamespace":
			err = unpopulate(val, &m.MetricNamespace)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "operator":
			err = unpopulate(val, &m.Operator)
			delete(rawMsg, key)
		case "skipMetricValidation":
			err = unpopulate(val, &m.SkipMetricValidation)
			delete(rawMsg, key)
		case "threshold":
			err = unpopulate(val, &m.Threshold)
			delete(rawMsg, key)
		case "timeAggregation":
			err = unpopulate(val, &m.TimeAggregation)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetricDefinition.
func (m MetricDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", m.Category)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "displayDescription", m.DisplayDescription)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "isDimensionRequired", m.IsDimensionRequired)
	populate(objectMap, "metricAvailabilities", m.MetricAvailabilities)
	populate(objectMap, "metricClass", m.MetricClass)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "namespace", m.Namespace)
	populate(objectMap, "primaryAggregationType", m.PrimaryAggregationType)
	populate(objectMap, "resourceId", m.ResourceID)
	populate(objectMap, "supportedAggregationTypes", m.SupportedAggregationTypes)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricDefinitionCollection.
func (m MetricDefinitionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricDimension.
func (m MetricDimension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", m.Name)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "values", m.Values)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricNamespaceCollection.
func (m MetricNamespaceCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricTrigger.
func (m MetricTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "dividePerInstance", m.DividePerInstance)
	populate(objectMap, "metricName", m.MetricName)
	populate(objectMap, "metricNamespace", m.MetricNamespace)
	populate(objectMap, "metricResourceLocation", m.MetricResourceLocation)
	populate(objectMap, "metricResourceUri", m.MetricResourceURI)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "statistic", m.Statistic)
	populate(objectMap, "threshold", m.Threshold)
	populate(objectMap, "timeAggregation", m.TimeAggregation)
	populate(objectMap, "timeGrain", m.TimeGrain)
	populate(objectMap, "timeWindow", m.TimeWindow)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetricValue.
func (m MetricValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "average", m.Average)
	populate(objectMap, "count", m.Count)
	populate(objectMap, "maximum", m.Maximum)
	populate(objectMap, "minimum", m.Minimum)
	populateTimeRFC3339(objectMap, "timeStamp", m.TimeStamp)
	populate(objectMap, "total", m.Total)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricValue.
func (m *MetricValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "average":
			err = unpopulate(val, &m.Average)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, &m.Count)
			delete(rawMsg, key)
		case "maximum":
			err = unpopulate(val, &m.Maximum)
			delete(rawMsg, key)
		case "minimum":
			err = unpopulate(val, &m.Minimum)
			delete(rawMsg, key)
		case "timeStamp":
			err = unpopulateTimeRFC3339(val, &m.TimeStamp)
			delete(rawMsg, key)
		case "total":
			err = unpopulate(val, &m.Total)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMultiMetricCriteria implements the MultiMetricCriteriaClassification interface for type MultiMetricCriteria.
func (m *MultiMetricCriteria) GetMultiMetricCriteria() *MultiMetricCriteria { return m }

// MarshalJSON implements the json.Marshaller interface for type MultiMetricCriteria.
func (m MultiMetricCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["criterionType"] = m.CriterionType
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "metricName", m.MetricName)
	populate(objectMap, "metricNamespace", m.MetricNamespace)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "skipMetricValidation", m.SkipMetricValidation)
	populate(objectMap, "timeAggregation", m.TimeAggregation)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiMetricCriteria.
func (m *MultiMetricCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "criterionType":
			err = unpopulate(val, &m.CriterionType)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, &m.Dimensions)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, &m.MetricName)
			delete(rawMsg, key)
		case "metricNamespace":
			err = unpopulate(val, &m.MetricNamespace)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "skipMetricValidation":
			err = unpopulate(val, &m.SkipMetricValidation)
			delete(rawMsg, key)
		case "timeAggregation":
			err = unpopulate(val, &m.TimeAggregation)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NotificationRequestBody.
func (n NotificationRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertType", n.AlertType)
	populate(objectMap, "armRoleReceivers", n.ArmRoleReceivers)
	populate(objectMap, "automationRunbookReceivers", n.AutomationRunbookReceivers)
	populate(objectMap, "azureAppPushReceivers", n.AzureAppPushReceivers)
	populate(objectMap, "azureFunctionReceivers", n.AzureFunctionReceivers)
	populate(objectMap, "emailReceivers", n.EmailReceivers)
	populate(objectMap, "eventHubReceivers", n.EventHubReceivers)
	populate(objectMap, "itsmReceivers", n.ItsmReceivers)
	populate(objectMap, "logicAppReceivers", n.LogicAppReceivers)
	populate(objectMap, "smsReceivers", n.SmsReceivers)
	populate(objectMap, "voiceReceivers", n.VoiceReceivers)
	populate(objectMap, "webhookReceivers", n.WebhookReceivers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatus.
func (o OperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", o.EndTime)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populateTimeRFC3339(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatus.
func (o *OperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &o.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PerfCounterDataSource.
func (p PerfCounterDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "counterSpecifiers", p.CounterSpecifiers)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "samplingFrequencyInSeconds", p.SamplingFrequencyInSeconds)
	populate(objectMap, "streams", p.Streams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkScopesResource.
func (p PrivateLinkScopesResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RecurrentSchedule.
func (r RecurrentSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", r.Days)
	populate(objectMap, "hours", r.Hours)
	populate(objectMap, "minutes", r.Minutes)
	populate(objectMap, "timeZone", r.TimeZone)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourceForUpdate.
func (r ResourceForUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Response.
func (r Response) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cost", r.Cost)
	populate(objectMap, "interval", r.Interval)
	populate(objectMap, "namespace", r.Namespace)
	populate(objectMap, "resourceregion", r.Resourceregion)
	populate(objectMap, "timespan", r.Timespan)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// GetRuleAction implements the RuleActionClassification interface for type RuleAction.
func (r *RuleAction) GetRuleAction() *RuleAction { return r }

// GetRuleCondition implements the RuleConditionClassification interface for type RuleCondition.
func (r *RuleCondition) GetRuleCondition() *RuleCondition { return r }

// MarshalJSON implements the json.Marshaller interface for type RuleCondition.
func (r RuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSource", r.DataSource)
	objectMap["odata.type"] = r.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleCondition.
func (r *RuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			r.DataSource, err = unmarshalRuleDataSourceClassification(val)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRuleDataSource implements the RuleDataSourceClassification interface for type RuleDataSource.
func (r *RuleDataSource) GetRuleDataSource() *RuleDataSource { return r }

// GetRuleAction implements the RuleActionClassification interface for type RuleEmailAction.
func (r *RuleEmailAction) GetRuleAction() *RuleAction {
	return &RuleAction{
		ODataType: r.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RuleEmailAction.
func (r RuleEmailAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customEmails", r.CustomEmails)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.RuleEmailAction"
	populate(objectMap, "sendToServiceOwners", r.SendToServiceOwners)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleEmailAction.
func (r *RuleEmailAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customEmails":
			err = unpopulate(val, &r.CustomEmails)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		case "sendToServiceOwners":
			err = unpopulate(val, &r.SendToServiceOwners)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRuleDataSource implements the RuleDataSourceClassification interface for type RuleManagementEventDataSource.
func (r *RuleManagementEventDataSource) GetRuleDataSource() *RuleDataSource {
	return &RuleDataSource{
		ODataType:        r.ODataType,
		ResourceURI:      r.ResourceURI,
		LegacyResourceID: r.LegacyResourceID,
		ResourceLocation: r.ResourceLocation,
		MetricNamespace:  r.MetricNamespace,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RuleManagementEventDataSource.
func (r RuleManagementEventDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "claims", r.Claims)
	populate(objectMap, "eventName", r.EventName)
	populate(objectMap, "eventSource", r.EventSource)
	populate(objectMap, "legacyResourceId", r.LegacyResourceID)
	populate(objectMap, "level", r.Level)
	populate(objectMap, "metricNamespace", r.MetricNamespace)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource"
	populate(objectMap, "operationName", r.OperationName)
	populate(objectMap, "resourceGroupName", r.ResourceGroupName)
	populate(objectMap, "resourceLocation", r.ResourceLocation)
	populate(objectMap, "resourceProviderName", r.ResourceProviderName)
	populate(objectMap, "resourceUri", r.ResourceURI)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "subStatus", r.SubStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleManagementEventDataSource.
func (r *RuleManagementEventDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claims":
			err = unpopulate(val, &r.Claims)
			delete(rawMsg, key)
		case "eventName":
			err = unpopulate(val, &r.EventName)
			delete(rawMsg, key)
		case "eventSource":
			err = unpopulate(val, &r.EventSource)
			delete(rawMsg, key)
		case "legacyResourceId":
			err = unpopulate(val, &r.LegacyResourceID)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &r.Level)
			delete(rawMsg, key)
		case "metricNamespace":
			err = unpopulate(val, &r.MetricNamespace)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		case "operationName":
			err = unpopulate(val, &r.OperationName)
			delete(rawMsg, key)
		case "resourceGroupName":
			err = unpopulate(val, &r.ResourceGroupName)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &r.ResourceLocation)
			delete(rawMsg, key)
		case "resourceProviderName":
			err = unpopulate(val, &r.ResourceProviderName)
			delete(rawMsg, key)
		case "resourceUri":
			err = unpopulate(val, &r.ResourceURI)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "subStatus":
			err = unpopulate(val, &r.SubStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRuleDataSource implements the RuleDataSourceClassification interface for type RuleMetricDataSource.
func (r *RuleMetricDataSource) GetRuleDataSource() *RuleDataSource {
	return &RuleDataSource{
		ODataType:        r.ODataType,
		ResourceURI:      r.ResourceURI,
		LegacyResourceID: r.LegacyResourceID,
		ResourceLocation: r.ResourceLocation,
		MetricNamespace:  r.MetricNamespace,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RuleMetricDataSource.
func (r RuleMetricDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "legacyResourceId", r.LegacyResourceID)
	populate(objectMap, "metricName", r.MetricName)
	populate(objectMap, "metricNamespace", r.MetricNamespace)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource"
	populate(objectMap, "resourceLocation", r.ResourceLocation)
	populate(objectMap, "resourceUri", r.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleMetricDataSource.
func (r *RuleMetricDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "legacyResourceId":
			err = unpopulate(val, &r.LegacyResourceID)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, &r.MetricName)
			delete(rawMsg, key)
		case "metricNamespace":
			err = unpopulate(val, &r.MetricNamespace)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, &r.ResourceLocation)
			delete(rawMsg, key)
		case "resourceUri":
			err = unpopulate(val, &r.ResourceURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRuleAction implements the RuleActionClassification interface for type RuleWebhookAction.
func (r *RuleWebhookAction) GetRuleAction() *RuleAction {
	return &RuleAction{
		ODataType: r.ODataType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RuleWebhookAction.
func (r RuleWebhookAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.RuleWebhookAction"
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "serviceUri", r.ServiceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleWebhookAction.
func (r *RuleWebhookAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.type":
			err = unpopulate(val, &r.ODataType)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		case "serviceUri":
			err = unpopulate(val, &r.ServiceURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScaleRuleMetricDimension.
func (s ScaleRuleMetricDimension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "DimensionName", s.DimensionName)
	populate(objectMap, "Operator", s.Operator)
	populate(objectMap, "Values", s.Values)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScopedResourceListResult.
func (s ScopedResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SingleBaseline.
func (s SingleBaseline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "highThresholds", s.HighThresholds)
	populate(objectMap, "lowThresholds", s.LowThresholds)
	populate(objectMap, "sensitivity", s.Sensitivity)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Source.
func (s Source) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authorizedResources", s.AuthorizedResources)
	populate(objectMap, "dataSourceId", s.DataSourceID)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryType", s.QueryType)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamDeclaration.
func (s StreamDeclaration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", s.Columns)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SyslogDataSource.
func (s SyslogDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "facilityNames", s.FacilityNames)
	populate(objectMap, "logLevels", s.LogLevels)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "streams", s.Streams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagsResource.
func (t TagsResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TestNotificationDetailsResponse.
func (t TestNotificationDetailsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ActionDetails", t.ActionDetails)
	populate(objectMap, "CompletedTime", t.CompletedTime)
	populate(objectMap, "Context", t.Context)
	populate(objectMap, "CreatedTime", t.CreatedTime)
	populate(objectMap, "State", t.State)
	return json.Marshal(objectMap)
}

// GetRuleCondition implements the RuleConditionClassification interface for type ThresholdRuleCondition.
func (t *ThresholdRuleCondition) GetRuleCondition() *RuleCondition {
	return &RuleCondition{
		ODataType:  t.ODataType,
		DataSource: t.DataSource,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ThresholdRuleCondition.
func (t ThresholdRuleCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSource", t.DataSource)
	objectMap["odata.type"] = "Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition"
	populate(objectMap, "operator", t.Operator)
	populate(objectMap, "threshold", t.Threshold)
	populate(objectMap, "timeAggregation", t.TimeAggregation)
	populate(objectMap, "windowSize", t.WindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThresholdRuleCondition.
func (t *ThresholdRuleCondition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			t.DataSource, err = unmarshalRuleDataSourceClassification(val)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &t.ODataType)
			delete(rawMsg, key)
		case "operator":
			err = unpopulate(val, &t.Operator)
			delete(rawMsg, key)
		case "threshold":
			err = unpopulate(val, &t.Threshold)
			delete(rawMsg, key)
		case "timeAggregation":
			err = unpopulate(val, &t.TimeAggregation)
			delete(rawMsg, key)
		case "windowSize":
			err = unpopulate(val, &t.WindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimeSeriesBaseline.
func (t TimeSeriesBaseline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregation", t.Aggregation)
	populate(objectMap, "data", t.Data)
	populate(objectMap, "dimensions", t.Dimensions)
	populate(objectMap, "metadataValues", t.MetadataValues)
	aux := make([]*timeRFC3339, len(t.Timestamps), len(t.Timestamps))
	for i := 0; i < len(t.Timestamps); i++ {
		aux[i] = (*timeRFC3339)(t.Timestamps[i])
	}
	populate(objectMap, "timestamps", aux)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TimeSeriesElement.
func (t TimeSeriesElement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", t.Data)
	populate(objectMap, "metadatavalues", t.Metadatavalues)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TimeWindow.
func (t TimeWindow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "end", t.End)
	populateTimeRFC3339(objectMap, "start", t.Start)
	populate(objectMap, "timeZone", t.TimeZone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimeWindow.
func (t *TimeWindow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
			err = unpopulateTimeRFC3339(val, &t.End)
			delete(rawMsg, key)
		case "start":
			err = unpopulateTimeRFC3339(val, &t.Start)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, &t.TimeZone)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedEntityResource.
func (t TrackedEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "kind", t.Kind)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VMInsightsOnboardingStatusProperties.
func (v VMInsightsOnboardingStatusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", v.Data)
	populate(objectMap, "dataStatus", v.DataStatus)
	populate(objectMap, "onboardingStatus", v.OnboardingStatus)
	populate(objectMap, "resourceId", v.ResourceID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WebhookNotification.
func (w WebhookNotification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "serviceUri", w.ServiceURI)
	return json.Marshal(objectMap)
}

// GetMetricAlertCriteria implements the MetricAlertCriteriaClassification interface for type WebtestLocationAvailabilityCriteria.
func (w *WebtestLocationAvailabilityCriteria) GetMetricAlertCriteria() *MetricAlertCriteria {
	return &MetricAlertCriteria{
		ODataType:            w.ODataType,
		AdditionalProperties: w.AdditionalProperties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type WebtestLocationAvailabilityCriteria.
func (w WebtestLocationAvailabilityCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "componentId", w.ComponentID)
	populate(objectMap, "failedLocationCount", w.FailedLocationCount)
	objectMap["odata.type"] = OdatatypeMicrosoftAzureMonitorWebtestLocationAvailabilityCriteria
	populate(objectMap, "webTestId", w.WebTestID)
	if w.AdditionalProperties != nil {
		for key, val := range w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebtestLocationAvailabilityCriteria.
func (w *WebtestLocationAvailabilityCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "componentId":
			err = unpopulate(val, &w.ComponentID)
			delete(rawMsg, key)
		case "failedLocationCount":
			err = unpopulate(val, &w.FailedLocationCount)
			delete(rawMsg, key)
		case "odata.type":
			err = unpopulate(val, &w.ODataType)
			delete(rawMsg, key)
		case "webTestId":
			err = unpopulate(val, &w.WebTestID)
			delete(rawMsg, key)
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				w.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsEventLogDataSource.
func (w WindowsEventLogDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", w.Name)
	populate(objectMap, "streams", w.Streams)
	populate(objectMap, "xPathQueries", w.XPathQueries)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
