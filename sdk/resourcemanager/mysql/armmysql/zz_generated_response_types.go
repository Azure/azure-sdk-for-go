//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmysql

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AdvisorsClientGetResponse contains the response from method AdvisorsClient.Get.
type AdvisorsClientGetResponse struct {
	AdvisorsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AdvisorsClientGetResult contains the result from method AdvisorsClient.Get.
type AdvisorsClientGetResult struct {
	Advisor
}

// AdvisorsClientListByServerResponse contains the response from method AdvisorsClient.ListByServer.
type AdvisorsClientListByServerResponse struct {
	AdvisorsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AdvisorsClientListByServerResult contains the result from method AdvisorsClient.ListByServer.
type AdvisorsClientListByServerResult struct {
	AdvisorsResultList
}

// CheckNameAvailabilityClientExecuteResponse contains the response from method CheckNameAvailabilityClient.Execute.
type CheckNameAvailabilityClientExecuteResponse struct {
	CheckNameAvailabilityClientExecuteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CheckNameAvailabilityClientExecuteResult contains the result from method CheckNameAvailabilityClient.Execute.
type CheckNameAvailabilityClientExecuteResult struct {
	NameAvailability
}

// ConfigurationsClientCreateOrUpdatePollerResponse contains the response from method ConfigurationsClient.CreateOrUpdate.
type ConfigurationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigurationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigurationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigurationsClientCreateOrUpdateResponse, error) {
	respType := ConfigurationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Configuration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigurationsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ConfigurationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigurationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConfigurationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigurationsClientCreateOrUpdateResponse contains the response from method ConfigurationsClient.CreateOrUpdate.
type ConfigurationsClientCreateOrUpdateResponse struct {
	ConfigurationsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsClientCreateOrUpdateResult contains the result from method ConfigurationsClient.CreateOrUpdate.
type ConfigurationsClientCreateOrUpdateResult struct {
	Configuration
}

// ConfigurationsClientGetResponse contains the response from method ConfigurationsClient.Get.
type ConfigurationsClientGetResponse struct {
	ConfigurationsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsClientGetResult contains the result from method ConfigurationsClient.Get.
type ConfigurationsClientGetResult struct {
	Configuration
}

// ConfigurationsClientListByServerResponse contains the response from method ConfigurationsClient.ListByServer.
type ConfigurationsClientListByServerResponse struct {
	ConfigurationsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsClientListByServerResult contains the result from method ConfigurationsClient.ListByServer.
type ConfigurationsClientListByServerResult struct {
	ConfigurationListResult
}

// DatabasesClientCreateOrUpdatePollerResponse contains the response from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesClientCreateOrUpdateResponse, error) {
	respType := DatabasesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesClientCreateOrUpdateResponse contains the response from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdateResponse struct {
	DatabasesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientCreateOrUpdateResult contains the result from method DatabasesClient.CreateOrUpdate.
type DatabasesClientCreateOrUpdateResult struct {
	Database
}

// DatabasesClientDeletePollerResponse contains the response from method DatabasesClient.Delete.
type DatabasesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesClientDeleteResponse, error) {
	respType := DatabasesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesClientDeletePollerResponse from the provided client and resume token.
func (l *DatabasesClientDeletePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabasesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesClientDeleteResponse contains the response from method DatabasesClient.Delete.
type DatabasesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientGetResponse contains the response from method DatabasesClient.Get.
type DatabasesClientGetResponse struct {
	DatabasesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientGetResult contains the result from method DatabasesClient.Get.
type DatabasesClientGetResult struct {
	Database
}

// DatabasesClientListByServerResponse contains the response from method DatabasesClient.ListByServer.
type DatabasesClientListByServerResponse struct {
	DatabasesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesClientListByServerResult contains the result from method DatabasesClient.ListByServer.
type DatabasesClientListByServerResult struct {
	DatabaseListResult
}

// FirewallRulesClientCreateOrUpdatePollerResponse contains the response from method FirewallRulesClient.CreateOrUpdate.
type FirewallRulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallRulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallRulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallRulesClientCreateOrUpdateResponse, error) {
	respType := FirewallRulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallRulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallRulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallRulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallRulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallRulesClientCreateOrUpdateResponse contains the response from method FirewallRulesClient.CreateOrUpdate.
type FirewallRulesClientCreateOrUpdateResponse struct {
	FirewallRulesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesClientCreateOrUpdateResult contains the result from method FirewallRulesClient.CreateOrUpdate.
type FirewallRulesClientCreateOrUpdateResult struct {
	FirewallRule
}

// FirewallRulesClientDeletePollerResponse contains the response from method FirewallRulesClient.Delete.
type FirewallRulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallRulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallRulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallRulesClientDeleteResponse, error) {
	respType := FirewallRulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallRulesClientDeletePollerResponse from the provided client and resume token.
func (l *FirewallRulesClientDeletePollerResponse) Resume(ctx context.Context, client *FirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallRulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallRulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallRulesClientDeleteResponse contains the response from method FirewallRulesClient.Delete.
type FirewallRulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesClientGetResponse contains the response from method FirewallRulesClient.Get.
type FirewallRulesClientGetResponse struct {
	FirewallRulesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesClientGetResult contains the result from method FirewallRulesClient.Get.
type FirewallRulesClientGetResult struct {
	FirewallRule
}

// FirewallRulesClientListByServerResponse contains the response from method FirewallRulesClient.ListByServer.
type FirewallRulesClientListByServerResponse struct {
	FirewallRulesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesClientListByServerResult contains the result from method FirewallRulesClient.ListByServer.
type FirewallRulesClientListByServerResult struct {
	FirewallRuleListResult
}

// LocationBasedPerformanceTierClientListResponse contains the response from method LocationBasedPerformanceTierClient.List.
type LocationBasedPerformanceTierClientListResponse struct {
	LocationBasedPerformanceTierClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationBasedPerformanceTierClientListResult contains the result from method LocationBasedPerformanceTierClient.List.
type LocationBasedPerformanceTierClientListResult struct {
	PerformanceTierListResult
}

// LocationBasedRecommendedActionSessionsOperationStatusClientGetResponse contains the response from method LocationBasedRecommendedActionSessionsOperationStatusClient.Get.
type LocationBasedRecommendedActionSessionsOperationStatusClientGetResponse struct {
	LocationBasedRecommendedActionSessionsOperationStatusClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationBasedRecommendedActionSessionsOperationStatusClientGetResult contains the result from method LocationBasedRecommendedActionSessionsOperationStatusClient.Get.
type LocationBasedRecommendedActionSessionsOperationStatusClientGetResult struct {
	RecommendedActionSessionsOperationStatus
}

// LocationBasedRecommendedActionSessionsResultClientListResponse contains the response from method LocationBasedRecommendedActionSessionsResultClient.List.
type LocationBasedRecommendedActionSessionsResultClientListResponse struct {
	LocationBasedRecommendedActionSessionsResultClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocationBasedRecommendedActionSessionsResultClientListResult contains the result from method LocationBasedRecommendedActionSessionsResultClient.List.
type LocationBasedRecommendedActionSessionsResultClientListResult struct {
	RecommendationActionsResultList
}

// LogFilesClientListByServerResponse contains the response from method LogFilesClient.ListByServer.
type LogFilesClientListByServerResponse struct {
	LogFilesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LogFilesClientListByServerResult contains the result from method LogFilesClient.ListByServer.
type LogFilesClientListByServerResult struct {
	LogFileListResult
}

// ManagementClientCreateRecommendedActionSessionPollerResponse contains the response from method ManagementClient.CreateRecommendedActionSession.
type ManagementClientCreateRecommendedActionSessionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagementClientCreateRecommendedActionSessionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagementClientCreateRecommendedActionSessionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagementClientCreateRecommendedActionSessionResponse, error) {
	respType := ManagementClientCreateRecommendedActionSessionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagementClientCreateRecommendedActionSessionPollerResponse from the provided client and resume token.
func (l *ManagementClientCreateRecommendedActionSessionPollerResponse) Resume(ctx context.Context, client *ManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagementClient.CreateRecommendedActionSession", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagementClientCreateRecommendedActionSessionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagementClientCreateRecommendedActionSessionResponse contains the response from method ManagementClient.CreateRecommendedActionSession.
type ManagementClientCreateRecommendedActionSessionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientResetQueryPerformanceInsightDataResponse contains the response from method ManagementClient.ResetQueryPerformanceInsightData.
type ManagementClientResetQueryPerformanceInsightDataResponse struct {
	ManagementClientResetQueryPerformanceInsightDataResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientResetQueryPerformanceInsightDataResult contains the result from method ManagementClient.ResetQueryPerformanceInsightData.
type ManagementClientResetQueryPerformanceInsightDataResult struct {
	QueryPerformanceInsightResetDataResult
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}

// PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientCreateOrUpdateResponse contains the response from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientCreateOrUpdateResult contains the result from method PrivateEndpointConnectionsClient.CreateOrUpdate.
type PrivateEndpointConnectionsClientCreateOrUpdateResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsClientDeletePollerResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientDeleteResponse contains the response from method PrivateEndpointConnectionsClient.Delete.
type PrivateEndpointConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResponse contains the response from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResponse struct {
	PrivateEndpointConnectionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientGetResult contains the result from method PrivateEndpointConnectionsClient.Get.
type PrivateEndpointConnectionsClientGetResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsClientListByServerResponse contains the response from method PrivateEndpointConnectionsClient.ListByServer.
type PrivateEndpointConnectionsClientListByServerResponse struct {
	PrivateEndpointConnectionsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientListByServerResult contains the result from method PrivateEndpointConnectionsClient.ListByServer.
type PrivateEndpointConnectionsClientListByServerResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateEndpointConnectionsClientUpdateTagsPollerResponse contains the response from method PrivateEndpointConnectionsClient.UpdateTags.
type PrivateEndpointConnectionsClientUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsClientUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsClientUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsClientUpdateTagsResponse, error) {
	respType := PrivateEndpointConnectionsClientUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsClientUpdateTagsPollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsClientUpdateTagsPollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.UpdateTags", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsClientUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsClientUpdateTagsResponse contains the response from method PrivateEndpointConnectionsClient.UpdateTags.
type PrivateEndpointConnectionsClientUpdateTagsResponse struct {
	PrivateEndpointConnectionsClientUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsClientUpdateTagsResult contains the result from method PrivateEndpointConnectionsClient.UpdateTags.
type PrivateEndpointConnectionsClientUpdateTagsResult struct {
	PrivateEndpointConnection
}

// PrivateLinkResourcesClientGetResponse contains the response from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResponse struct {
	PrivateLinkResourcesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientGetResult contains the result from method PrivateLinkResourcesClient.Get.
type PrivateLinkResourcesClientGetResult struct {
	PrivateLinkResource
}

// PrivateLinkResourcesClientListByServerResponse contains the response from method PrivateLinkResourcesClient.ListByServer.
type PrivateLinkResourcesClientListByServerResponse struct {
	PrivateLinkResourcesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesClientListByServerResult contains the result from method PrivateLinkResourcesClient.ListByServer.
type PrivateLinkResourcesClientListByServerResult struct {
	PrivateLinkResourceListResult
}

// QueryTextsClientGetResponse contains the response from method QueryTextsClient.Get.
type QueryTextsClientGetResponse struct {
	QueryTextsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// QueryTextsClientGetResult contains the result from method QueryTextsClient.Get.
type QueryTextsClientGetResult struct {
	QueryText
}

// QueryTextsClientListByServerResponse contains the response from method QueryTextsClient.ListByServer.
type QueryTextsClientListByServerResponse struct {
	QueryTextsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// QueryTextsClientListByServerResult contains the result from method QueryTextsClient.ListByServer.
type QueryTextsClientListByServerResult struct {
	QueryTextsResultList
}

// RecommendedActionsClientGetResponse contains the response from method RecommendedActionsClient.Get.
type RecommendedActionsClientGetResponse struct {
	RecommendedActionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecommendedActionsClientGetResult contains the result from method RecommendedActionsClient.Get.
type RecommendedActionsClientGetResult struct {
	RecommendationAction
}

// RecommendedActionsClientListByServerResponse contains the response from method RecommendedActionsClient.ListByServer.
type RecommendedActionsClientListByServerResponse struct {
	RecommendedActionsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecommendedActionsClientListByServerResult contains the result from method RecommendedActionsClient.ListByServer.
type RecommendedActionsClientListByServerResult struct {
	RecommendationActionsResultList
}

// RecoverableServersClientGetResponse contains the response from method RecoverableServersClient.Get.
type RecoverableServersClientGetResponse struct {
	RecoverableServersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableServersClientGetResult contains the result from method RecoverableServersClient.Get.
type RecoverableServersClientGetResult struct {
	RecoverableServerResource
}

// ReplicasClientListByServerResponse contains the response from method ReplicasClient.ListByServer.
type ReplicasClientListByServerResponse struct {
	ReplicasClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicasClientListByServerResult contains the result from method ReplicasClient.ListByServer.
type ReplicasClientListByServerResult struct {
	ServerListResult
}

// ServerAdministratorsClientCreateOrUpdatePollerResponse contains the response from method ServerAdministratorsClient.CreateOrUpdate.
type ServerAdministratorsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAdministratorsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAdministratorsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAdministratorsClientCreateOrUpdateResponse, error) {
	respType := ServerAdministratorsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerAdministratorResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAdministratorsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerAdministratorsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAdministratorsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerAdministratorsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAdministratorsClientCreateOrUpdateResponse contains the response from method ServerAdministratorsClient.CreateOrUpdate.
type ServerAdministratorsClientCreateOrUpdateResponse struct {
	ServerAdministratorsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdministratorsClientCreateOrUpdateResult contains the result from method ServerAdministratorsClient.CreateOrUpdate.
type ServerAdministratorsClientCreateOrUpdateResult struct {
	ServerAdministratorResource
}

// ServerAdministratorsClientDeletePollerResponse contains the response from method ServerAdministratorsClient.Delete.
type ServerAdministratorsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAdministratorsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAdministratorsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAdministratorsClientDeleteResponse, error) {
	respType := ServerAdministratorsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAdministratorsClientDeletePollerResponse from the provided client and resume token.
func (l *ServerAdministratorsClientDeletePollerResponse) Resume(ctx context.Context, client *ServerAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAdministratorsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerAdministratorsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAdministratorsClientDeleteResponse contains the response from method ServerAdministratorsClient.Delete.
type ServerAdministratorsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdministratorsClientGetResponse contains the response from method ServerAdministratorsClient.Get.
type ServerAdministratorsClientGetResponse struct {
	ServerAdministratorsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdministratorsClientGetResult contains the result from method ServerAdministratorsClient.Get.
type ServerAdministratorsClientGetResult struct {
	ServerAdministratorResource
}

// ServerAdministratorsClientListResponse contains the response from method ServerAdministratorsClient.List.
type ServerAdministratorsClientListResponse struct {
	ServerAdministratorsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdministratorsClientListResult contains the result from method ServerAdministratorsClient.List.
type ServerAdministratorsClientListResult struct {
	ServerAdministratorResourceListResult
}

// ServerBasedPerformanceTierClientListResponse contains the response from method ServerBasedPerformanceTierClient.List.
type ServerBasedPerformanceTierClientListResponse struct {
	ServerBasedPerformanceTierClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerBasedPerformanceTierClientListResult contains the result from method ServerBasedPerformanceTierClient.List.
type ServerBasedPerformanceTierClientListResult struct {
	PerformanceTierListResult
}

// ServerKeysClientCreateOrUpdatePollerResponse contains the response from method ServerKeysClient.CreateOrUpdate.
type ServerKeysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerKeysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerKeysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysClientCreateOrUpdateResponse, error) {
	respType := ServerKeysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerKeysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerKeysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerKeysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerKeysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerKeysClientCreateOrUpdateResponse contains the response from method ServerKeysClient.CreateOrUpdate.
type ServerKeysClientCreateOrUpdateResponse struct {
	ServerKeysClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysClientCreateOrUpdateResult contains the result from method ServerKeysClient.CreateOrUpdate.
type ServerKeysClientCreateOrUpdateResult struct {
	ServerKey
}

// ServerKeysClientDeletePollerResponse contains the response from method ServerKeysClient.Delete.
type ServerKeysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerKeysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerKeysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysClientDeleteResponse, error) {
	respType := ServerKeysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerKeysClientDeletePollerResponse from the provided client and resume token.
func (l *ServerKeysClientDeletePollerResponse) Resume(ctx context.Context, client *ServerKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerKeysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerKeysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerKeysClientDeleteResponse contains the response from method ServerKeysClient.Delete.
type ServerKeysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysClientGetResponse contains the response from method ServerKeysClient.Get.
type ServerKeysClientGetResponse struct {
	ServerKeysClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysClientGetResult contains the result from method ServerKeysClient.Get.
type ServerKeysClientGetResult struct {
	ServerKey
}

// ServerKeysClientListResponse contains the response from method ServerKeysClient.List.
type ServerKeysClientListResponse struct {
	ServerKeysClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysClientListResult contains the result from method ServerKeysClient.List.
type ServerKeysClientListResult struct {
	ServerKeyListResult
}

// ServerParametersClientListUpdateConfigurationsPollerResponse contains the response from method ServerParametersClient.ListUpdateConfigurations.
type ServerParametersClientListUpdateConfigurationsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerParametersClientListUpdateConfigurationsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerParametersClientListUpdateConfigurationsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerParametersClientListUpdateConfigurationsResponse, error) {
	respType := ServerParametersClientListUpdateConfigurationsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigurationListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerParametersClientListUpdateConfigurationsPollerResponse from the provided client and resume token.
func (l *ServerParametersClientListUpdateConfigurationsPollerResponse) Resume(ctx context.Context, client *ServerParametersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerParametersClient.ListUpdateConfigurations", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerParametersClientListUpdateConfigurationsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerParametersClientListUpdateConfigurationsResponse contains the response from method ServerParametersClient.ListUpdateConfigurations.
type ServerParametersClientListUpdateConfigurationsResponse struct {
	ServerParametersClientListUpdateConfigurationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerParametersClientListUpdateConfigurationsResult contains the result from method ServerParametersClient.ListUpdateConfigurations.
type ServerParametersClientListUpdateConfigurationsResult struct {
	ConfigurationListResult
}

// ServerSecurityAlertPoliciesClientCreateOrUpdatePollerResponse contains the response from method ServerSecurityAlertPoliciesClient.CreateOrUpdate.
type ServerSecurityAlertPoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerSecurityAlertPoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerSecurityAlertPoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerSecurityAlertPoliciesClientCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerSecurityAlertPoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerSecurityAlertPoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerSecurityAlertPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerSecurityAlertPoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServerSecurityAlertPoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerSecurityAlertPoliciesClientCreateOrUpdateResponse contains the response from method ServerSecurityAlertPoliciesClient.CreateOrUpdate.
type ServerSecurityAlertPoliciesClientCreateOrUpdateResponse struct {
	ServerSecurityAlertPoliciesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesClientCreateOrUpdateResult contains the result from method ServerSecurityAlertPoliciesClient.CreateOrUpdate.
type ServerSecurityAlertPoliciesClientCreateOrUpdateResult struct {
	ServerSecurityAlertPolicy
}

// ServerSecurityAlertPoliciesClientGetResponse contains the response from method ServerSecurityAlertPoliciesClient.Get.
type ServerSecurityAlertPoliciesClientGetResponse struct {
	ServerSecurityAlertPoliciesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesClientGetResult contains the result from method ServerSecurityAlertPoliciesClient.Get.
type ServerSecurityAlertPoliciesClientGetResult struct {
	ServerSecurityAlertPolicy
}

// ServerSecurityAlertPoliciesClientListByServerResponse contains the response from method ServerSecurityAlertPoliciesClient.ListByServer.
type ServerSecurityAlertPoliciesClientListByServerResponse struct {
	ServerSecurityAlertPoliciesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesClientListByServerResult contains the result from method ServerSecurityAlertPoliciesClient.ListByServer.
type ServerSecurityAlertPoliciesClientListByServerResult struct {
	ServerSecurityAlertPolicyListResult
}

// ServersClientCreatePollerResponse contains the response from method ServersClient.Create.
type ServersClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientCreateResponse, error) {
	respType := ServersClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientCreatePollerResponse from the provided client and resume token.
func (l *ServersClientCreatePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientCreateResponse contains the response from method ServersClient.Create.
type ServersClientCreateResponse struct {
	ServersClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientCreateResult contains the result from method ServersClient.Create.
type ServersClientCreateResult struct {
	Server
}

// ServersClientDeletePollerResponse contains the response from method ServersClient.Delete.
type ServersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientDeleteResponse, error) {
	respType := ServersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientDeletePollerResponse from the provided client and resume token.
func (l *ServersClientDeletePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientDeleteResponse contains the response from method ServersClient.Delete.
type ServersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientGetResponse contains the response from method ServersClient.Get.
type ServersClientGetResponse struct {
	ServersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientGetResult contains the result from method ServersClient.Get.
type ServersClientGetResult struct {
	Server
}

// ServersClientListByResourceGroupResponse contains the response from method ServersClient.ListByResourceGroup.
type ServersClientListByResourceGroupResponse struct {
	ServersClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientListByResourceGroupResult contains the result from method ServersClient.ListByResourceGroup.
type ServersClientListByResourceGroupResult struct {
	ServerListResult
}

// ServersClientListResponse contains the response from method ServersClient.List.
type ServersClientListResponse struct {
	ServersClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientListResult contains the result from method ServersClient.List.
type ServersClientListResult struct {
	ServerListResult
}

// ServersClientRestartPollerResponse contains the response from method ServersClient.Restart.
type ServersClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientRestartResponse, error) {
	respType := ServersClientRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientRestartPollerResponse from the provided client and resume token.
func (l *ServersClientRestartPollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientRestartResponse contains the response from method ServersClient.Restart.
type ServersClientRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientStartPollerResponse contains the response from method ServersClient.Start.
type ServersClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientStartResponse, error) {
	respType := ServersClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientStartPollerResponse from the provided client and resume token.
func (l *ServersClientStartPollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientStartResponse contains the response from method ServersClient.Start.
type ServersClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientStopPollerResponse contains the response from method ServersClient.Stop.
type ServersClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientStopResponse, error) {
	respType := ServersClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientStopPollerResponse from the provided client and resume token.
func (l *ServersClientStopPollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientStopResponse contains the response from method ServersClient.Stop.
type ServersClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientUpdatePollerResponse contains the response from method ServersClient.Update.
type ServersClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientUpdateResponse, error) {
	respType := ServersClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientUpdatePollerResponse from the provided client and resume token.
func (l *ServersClientUpdatePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientUpdateResponse contains the response from method ServersClient.Update.
type ServersClientUpdateResponse struct {
	ServersClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersClientUpdateResult contains the result from method ServersClient.Update.
type ServersClientUpdateResult struct {
	Server
}

// ServersClientUpgradePollerResponse contains the response from method ServersClient.Upgrade.
type ServersClientUpgradePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersClientUpgradePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersClientUpgradePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersClientUpgradeResponse, error) {
	respType := ServersClientUpgradeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersClientUpgradePollerResponse from the provided client and resume token.
func (l *ServersClientUpgradePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Upgrade", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServersClientUpgradePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersClientUpgradeResponse contains the response from method ServersClient.Upgrade.
type ServersClientUpgradeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TopQueryStatisticsClientGetResponse contains the response from method TopQueryStatisticsClient.Get.
type TopQueryStatisticsClientGetResponse struct {
	TopQueryStatisticsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TopQueryStatisticsClientGetResult contains the result from method TopQueryStatisticsClient.Get.
type TopQueryStatisticsClientGetResult struct {
	QueryStatistic
}

// TopQueryStatisticsClientListByServerResponse contains the response from method TopQueryStatisticsClient.ListByServer.
type TopQueryStatisticsClientListByServerResponse struct {
	TopQueryStatisticsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TopQueryStatisticsClientListByServerResult contains the result from method TopQueryStatisticsClient.ListByServer.
type TopQueryStatisticsClientListByServerResult struct {
	TopQueryStatisticsResultList
}

// VirtualNetworkRulesClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworkRulesClient.CreateOrUpdate.
type VirtualNetworkRulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkRulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkRulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkRulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkRulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkRulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkRulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkRulesClientCreateOrUpdateResponse contains the response from method VirtualNetworkRulesClient.CreateOrUpdate.
type VirtualNetworkRulesClientCreateOrUpdateResponse struct {
	VirtualNetworkRulesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesClientCreateOrUpdateResult contains the result from method VirtualNetworkRulesClient.CreateOrUpdate.
type VirtualNetworkRulesClientCreateOrUpdateResult struct {
	VirtualNetworkRule
}

// VirtualNetworkRulesClientDeletePollerResponse contains the response from method VirtualNetworkRulesClient.Delete.
type VirtualNetworkRulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkRulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkRulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesClientDeleteResponse, error) {
	respType := VirtualNetworkRulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkRulesClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkRulesClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkRulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkRulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkRulesClientDeleteResponse contains the response from method VirtualNetworkRulesClient.Delete.
type VirtualNetworkRulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesClientGetResponse contains the response from method VirtualNetworkRulesClient.Get.
type VirtualNetworkRulesClientGetResponse struct {
	VirtualNetworkRulesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesClientGetResult contains the result from method VirtualNetworkRulesClient.Get.
type VirtualNetworkRulesClientGetResult struct {
	VirtualNetworkRule
}

// VirtualNetworkRulesClientListByServerResponse contains the response from method VirtualNetworkRulesClient.ListByServer.
type VirtualNetworkRulesClientListByServerResponse struct {
	VirtualNetworkRulesClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesClientListByServerResult contains the result from method VirtualNetworkRulesClient.ListByServer.
type VirtualNetworkRulesClientListByServerResult struct {
	VirtualNetworkRuleListResult
}

// WaitStatisticsClientGetResponse contains the response from method WaitStatisticsClient.Get.
type WaitStatisticsClientGetResponse struct {
	WaitStatisticsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WaitStatisticsClientGetResult contains the result from method WaitStatisticsClient.Get.
type WaitStatisticsClientGetResult struct {
	WaitStatistic
}

// WaitStatisticsClientListByServerResponse contains the response from method WaitStatisticsClient.ListByServer.
type WaitStatisticsClientListByServerResponse struct {
	WaitStatisticsClientListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WaitStatisticsClientListByServerResult contains the result from method WaitStatisticsClient.ListByServer.
type WaitStatisticsClientListByServerResult struct {
	WaitStatisticsResultList
}
