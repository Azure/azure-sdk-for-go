//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetapp

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AccountBackupsDeletePollerResponse contains the response from method AccountBackups.Delete.
type AccountBackupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountBackupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountBackupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountBackupsDeleteResponse, error) {
	respType := AccountBackupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountBackupsDeletePollerResponse from the provided client and resume token.
func (l *AccountBackupsDeletePollerResponse) Resume(ctx context.Context, client *AccountBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountBackupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AccountBackupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountBackupsDeleteResponse contains the response from method AccountBackups.Delete.
type AccountBackupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountBackupsGetResponse contains the response from method AccountBackups.Get.
type AccountBackupsGetResponse struct {
	AccountBackupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountBackupsGetResult contains the result from method AccountBackups.Get.
type AccountBackupsGetResult struct {
	Backup
}

// AccountBackupsListResponse contains the response from method AccountBackups.List.
type AccountBackupsListResponse struct {
	AccountBackupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountBackupsListResult contains the result from method AccountBackups.List.
type AccountBackupsListResult struct {
	BackupsList
}

// AccountsCreateOrUpdatePollerResponse contains the response from method Accounts.CreateOrUpdate.
type AccountsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsCreateOrUpdateResponse, error) {
	respType := AccountsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetAppAccount)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AccountsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AccountsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountsCreateOrUpdateResponse contains the response from method Accounts.CreateOrUpdate.
type AccountsCreateOrUpdateResponse struct {
	AccountsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsCreateOrUpdateResult contains the result from method Accounts.CreateOrUpdate.
type AccountsCreateOrUpdateResult struct {
	NetAppAccount
}

// AccountsDeletePollerResponse contains the response from method Accounts.Delete.
type AccountsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsDeleteResponse, error) {
	respType := AccountsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountsDeletePollerResponse from the provided client and resume token.
func (l *AccountsDeletePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AccountsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountsDeleteResponse contains the response from method Accounts.Delete.
type AccountsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsGetResponse contains the response from method Accounts.Get.
type AccountsGetResponse struct {
	AccountsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsGetResult contains the result from method Accounts.Get.
type AccountsGetResult struct {
	NetAppAccount
}

// AccountsListBySubscriptionResponse contains the response from method Accounts.ListBySubscription.
type AccountsListBySubscriptionResponse struct {
	AccountsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsListBySubscriptionResult contains the result from method Accounts.ListBySubscription.
type AccountsListBySubscriptionResult struct {
	NetAppAccountList
}

// AccountsListResponse contains the response from method Accounts.List.
type AccountsListResponse struct {
	AccountsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsListResult contains the result from method Accounts.List.
type AccountsListResult struct {
	NetAppAccountList
}

// AccountsUpdatePollerResponse contains the response from method Accounts.Update.
type AccountsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsUpdateResponse, error) {
	respType := AccountsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetAppAccount)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountsUpdatePollerResponse from the provided client and resume token.
func (l *AccountsUpdatePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &AccountsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountsUpdateResponse contains the response from method Accounts.Update.
type AccountsUpdateResponse struct {
	AccountsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountsUpdateResult contains the result from method Accounts.Update.
type AccountsUpdateResult struct {
	NetAppAccount
}

// BackupPoliciesCreatePollerResponse contains the response from method BackupPolicies.Create.
type BackupPoliciesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupPoliciesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupPoliciesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupPoliciesCreateResponse, error) {
	respType := BackupPoliciesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupPoliciesCreatePollerResponse from the provided client and resume token.
func (l *BackupPoliciesCreatePollerResponse) Resume(ctx context.Context, client *BackupPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupPoliciesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &BackupPoliciesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupPoliciesCreateResponse contains the response from method BackupPolicies.Create.
type BackupPoliciesCreateResponse struct {
	BackupPoliciesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupPoliciesCreateResult contains the result from method BackupPolicies.Create.
type BackupPoliciesCreateResult struct {
	BackupPolicy
}

// BackupPoliciesDeletePollerResponse contains the response from method BackupPolicies.Delete.
type BackupPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupPoliciesDeleteResponse, error) {
	respType := BackupPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupPoliciesDeletePollerResponse from the provided client and resume token.
func (l *BackupPoliciesDeletePollerResponse) Resume(ctx context.Context, client *BackupPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &BackupPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupPoliciesDeleteResponse contains the response from method BackupPolicies.Delete.
type BackupPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupPoliciesGetResponse contains the response from method BackupPolicies.Get.
type BackupPoliciesGetResponse struct {
	BackupPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupPoliciesGetResult contains the result from method BackupPolicies.Get.
type BackupPoliciesGetResult struct {
	BackupPolicy
}

// BackupPoliciesListResponse contains the response from method BackupPolicies.List.
type BackupPoliciesListResponse struct {
	BackupPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupPoliciesListResult contains the result from method BackupPolicies.List.
type BackupPoliciesListResult struct {
	BackupPoliciesList
}

// BackupPoliciesUpdatePollerResponse contains the response from method BackupPolicies.Update.
type BackupPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupPoliciesUpdateResponse, error) {
	respType := BackupPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *BackupPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *BackupPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &BackupPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupPoliciesUpdateResponse contains the response from method BackupPolicies.Update.
type BackupPoliciesUpdateResponse struct {
	BackupPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupPoliciesUpdateResult contains the result from method BackupPolicies.Update.
type BackupPoliciesUpdateResult struct {
	BackupPolicy
}

// BackupsCreatePollerResponse contains the response from method Backups.Create.
type BackupsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupsCreateResponse, error) {
	respType := BackupsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Backup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupsCreatePollerResponse from the provided client and resume token.
func (l *BackupsCreatePollerResponse) Resume(ctx context.Context, client *BackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &BackupsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupsCreateResponse contains the response from method Backups.Create.
type BackupsCreateResponse struct {
	BackupsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsCreateResult contains the result from method Backups.Create.
type BackupsCreateResult struct {
	Backup
}

// BackupsDeletePollerResponse contains the response from method Backups.Delete.
type BackupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupsDeleteResponse, error) {
	respType := BackupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupsDeletePollerResponse from the provided client and resume token.
func (l *BackupsDeletePollerResponse) Resume(ctx context.Context, client *BackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &BackupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupsDeleteResponse contains the response from method Backups.Delete.
type BackupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsGetResponse contains the response from method Backups.Get.
type BackupsGetResponse struct {
	BackupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsGetResult contains the result from method Backups.Get.
type BackupsGetResult struct {
	Backup
}

// BackupsGetStatusResponse contains the response from method Backups.GetStatus.
type BackupsGetStatusResponse struct {
	BackupsGetStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsGetStatusResult contains the result from method Backups.GetStatus.
type BackupsGetStatusResult struct {
	BackupStatus
}

// BackupsGetVolumeRestoreStatusResponse contains the response from method Backups.GetVolumeRestoreStatus.
type BackupsGetVolumeRestoreStatusResponse struct {
	BackupsGetVolumeRestoreStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsGetVolumeRestoreStatusResult contains the result from method Backups.GetVolumeRestoreStatus.
type BackupsGetVolumeRestoreStatusResult struct {
	RestoreStatus
}

// BackupsListResponse contains the response from method Backups.List.
type BackupsListResponse struct {
	BackupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsListResult contains the result from method Backups.List.
type BackupsListResult struct {
	BackupsList
}

// BackupsUpdatePollerResponse contains the response from method Backups.Update.
type BackupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupsUpdateResponse, error) {
	respType := BackupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Backup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupsUpdatePollerResponse from the provided client and resume token.
func (l *BackupsUpdatePollerResponse) Resume(ctx context.Context, client *BackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &BackupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupsUpdateResponse contains the response from method Backups.Update.
type BackupsUpdateResponse struct {
	BackupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupsUpdateResult contains the result from method Backups.Update.
type BackupsUpdateResult struct {
	Backup
}

// NetAppResourceCheckFilePathAvailabilityResponse contains the response from method NetAppResource.CheckFilePathAvailability.
type NetAppResourceCheckFilePathAvailabilityResponse struct {
	NetAppResourceCheckFilePathAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetAppResourceCheckFilePathAvailabilityResult contains the result from method NetAppResource.CheckFilePathAvailability.
type NetAppResourceCheckFilePathAvailabilityResult struct {
	CheckAvailabilityResponse
}

// NetAppResourceCheckNameAvailabilityResponse contains the response from method NetAppResource.CheckNameAvailability.
type NetAppResourceCheckNameAvailabilityResponse struct {
	NetAppResourceCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetAppResourceCheckNameAvailabilityResult contains the result from method NetAppResource.CheckNameAvailability.
type NetAppResourceCheckNameAvailabilityResult struct {
	CheckAvailabilityResponse
}

// NetAppResourceCheckQuotaAvailabilityResponse contains the response from method NetAppResource.CheckQuotaAvailability.
type NetAppResourceCheckQuotaAvailabilityResponse struct {
	NetAppResourceCheckQuotaAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetAppResourceCheckQuotaAvailabilityResult contains the result from method NetAppResource.CheckQuotaAvailability.
type NetAppResourceCheckQuotaAvailabilityResult struct {
	CheckAvailabilityResponse
}

// NetAppResourceQuotaLimitsGetResponse contains the response from method NetAppResourceQuotaLimits.Get.
type NetAppResourceQuotaLimitsGetResponse struct {
	NetAppResourceQuotaLimitsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetAppResourceQuotaLimitsGetResult contains the result from method NetAppResourceQuotaLimits.Get.
type NetAppResourceQuotaLimitsGetResult struct {
	SubscriptionQuotaItem
}

// NetAppResourceQuotaLimitsListResponse contains the response from method NetAppResourceQuotaLimits.List.
type NetAppResourceQuotaLimitsListResponse struct {
	NetAppResourceQuotaLimitsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetAppResourceQuotaLimitsListResult contains the result from method NetAppResourceQuotaLimits.List.
type NetAppResourceQuotaLimitsListResult struct {
	SubscriptionQuotaItemList
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// PoolsCreateOrUpdatePollerResponse contains the response from method Pools.CreateOrUpdate.
type PoolsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoolsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoolsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoolsCreateOrUpdateResponse, error) {
	respType := PoolsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CapacityPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoolsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PoolsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoolsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PoolsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoolsCreateOrUpdateResponse contains the response from method Pools.CreateOrUpdate.
type PoolsCreateOrUpdateResponse struct {
	PoolsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoolsCreateOrUpdateResult contains the result from method Pools.CreateOrUpdate.
type PoolsCreateOrUpdateResult struct {
	CapacityPool
}

// PoolsDeletePollerResponse contains the response from method Pools.Delete.
type PoolsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoolsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoolsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoolsDeleteResponse, error) {
	respType := PoolsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoolsDeletePollerResponse from the provided client and resume token.
func (l *PoolsDeletePollerResponse) Resume(ctx context.Context, client *PoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoolsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PoolsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoolsDeleteResponse contains the response from method Pools.Delete.
type PoolsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoolsGetResponse contains the response from method Pools.Get.
type PoolsGetResponse struct {
	PoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoolsGetResult contains the result from method Pools.Get.
type PoolsGetResult struct {
	CapacityPool
}

// PoolsListResponse contains the response from method Pools.List.
type PoolsListResponse struct {
	PoolsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoolsListResult contains the result from method Pools.List.
type PoolsListResult struct {
	CapacityPoolList
}

// PoolsUpdatePollerResponse contains the response from method Pools.Update.
type PoolsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PoolsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PoolsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PoolsUpdateResponse, error) {
	respType := PoolsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CapacityPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PoolsUpdatePollerResponse from the provided client and resume token.
func (l *PoolsUpdatePollerResponse) Resume(ctx context.Context, client *PoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PoolsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &PoolsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PoolsUpdateResponse contains the response from method Pools.Update.
type PoolsUpdateResponse struct {
	PoolsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PoolsUpdateResult contains the result from method Pools.Update.
type PoolsUpdateResult struct {
	CapacityPool
}

// SnapshotPoliciesCreateResponse contains the response from method SnapshotPolicies.Create.
type SnapshotPoliciesCreateResponse struct {
	SnapshotPoliciesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesCreateResult contains the result from method SnapshotPolicies.Create.
type SnapshotPoliciesCreateResult struct {
	SnapshotPolicy
}

// SnapshotPoliciesDeletePollerResponse contains the response from method SnapshotPolicies.Delete.
type SnapshotPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotPoliciesDeleteResponse, error) {
	respType := SnapshotPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotPoliciesDeletePollerResponse from the provided client and resume token.
func (l *SnapshotPoliciesDeletePollerResponse) Resume(ctx context.Context, client *SnapshotPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SnapshotPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotPoliciesDeleteResponse contains the response from method SnapshotPolicies.Delete.
type SnapshotPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesGetResponse contains the response from method SnapshotPolicies.Get.
type SnapshotPoliciesGetResponse struct {
	SnapshotPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesGetResult contains the result from method SnapshotPolicies.Get.
type SnapshotPoliciesGetResult struct {
	SnapshotPolicy
}

// SnapshotPoliciesListResponse contains the response from method SnapshotPolicies.List.
type SnapshotPoliciesListResponse struct {
	SnapshotPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesListResult contains the result from method SnapshotPolicies.List.
type SnapshotPoliciesListResult struct {
	SnapshotPoliciesList
}

// SnapshotPoliciesListVolumesResponse contains the response from method SnapshotPolicies.ListVolumes.
type SnapshotPoliciesListVolumesResponse struct {
	SnapshotPoliciesListVolumesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesListVolumesResult contains the result from method SnapshotPolicies.ListVolumes.
type SnapshotPoliciesListVolumesResult struct {
	SnapshotPolicyVolumeList
}

// SnapshotPoliciesUpdatePollerResponse contains the response from method SnapshotPolicies.Update.
type SnapshotPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotPoliciesUpdateResponse, error) {
	respType := SnapshotPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SnapshotPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &SnapshotPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotPoliciesUpdateResponse contains the response from method SnapshotPolicies.Update.
type SnapshotPoliciesUpdateResponse struct {
	SnapshotPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotPoliciesUpdateResult contains the result from method SnapshotPolicies.Update.
type SnapshotPoliciesUpdateResult struct {
	SnapshotPolicy
}

// SnapshotsCreatePollerResponse contains the response from method Snapshots.Create.
type SnapshotsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsCreateResponse, error) {
	respType := SnapshotsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsCreatePollerResponse from the provided client and resume token.
func (l *SnapshotsCreatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &SnapshotsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsCreateResponse contains the response from method Snapshots.Create.
type SnapshotsCreateResponse struct {
	SnapshotsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsCreateResult contains the result from method Snapshots.Create.
type SnapshotsCreateResult struct {
	Snapshot
}

// SnapshotsDeletePollerResponse contains the response from method Snapshots.Delete.
type SnapshotsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsDeleteResponse, error) {
	respType := SnapshotsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsDeletePollerResponse from the provided client and resume token.
func (l *SnapshotsDeletePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SnapshotsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsDeleteResponse contains the response from method Snapshots.Delete.
type SnapshotsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsGetResponse contains the response from method Snapshots.Get.
type SnapshotsGetResponse struct {
	SnapshotsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsGetResult contains the result from method Snapshots.Get.
type SnapshotsGetResult struct {
	Snapshot
}

// SnapshotsListResponse contains the response from method Snapshots.List.
type SnapshotsListResponse struct {
	SnapshotsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsListResult contains the result from method Snapshots.List.
type SnapshotsListResult struct {
	SnapshotsList
}

// SnapshotsUpdatePollerResponse contains the response from method Snapshots.Update.
type SnapshotsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsUpdateResponse, error) {
	respType := SnapshotsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotsUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &SnapshotsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsUpdateResponse contains the response from method Snapshots.Update.
type SnapshotsUpdateResponse struct {
	SnapshotsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsUpdateResult contains the result from method Snapshots.Update.
type SnapshotsUpdateResult struct {
	Snapshot
}

// VaultsListResponse contains the response from method Vaults.List.
type VaultsListResponse struct {
	VaultsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VaultsListResult contains the result from method Vaults.List.
type VaultsListResult struct {
	VaultList
}

// VolumeGroupsCreatePollerResponse contains the response from method VolumeGroups.Create.
type VolumeGroupsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumeGroupsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumeGroupsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumeGroupsCreateResponse, error) {
	respType := VolumeGroupsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VolumeGroupDetails)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumeGroupsCreatePollerResponse from the provided client and resume token.
func (l *VolumeGroupsCreatePollerResponse) Resume(ctx context.Context, client *VolumeGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumeGroupsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &VolumeGroupsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumeGroupsCreateResponse contains the response from method VolumeGroups.Create.
type VolumeGroupsCreateResponse struct {
	VolumeGroupsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGroupsCreateResult contains the result from method VolumeGroups.Create.
type VolumeGroupsCreateResult struct {
	VolumeGroupDetails
}

// VolumeGroupsDeletePollerResponse contains the response from method VolumeGroups.Delete.
type VolumeGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumeGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumeGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumeGroupsDeleteResponse, error) {
	respType := VolumeGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumeGroupsDeletePollerResponse from the provided client and resume token.
func (l *VolumeGroupsDeletePollerResponse) Resume(ctx context.Context, client *VolumeGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumeGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VolumeGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumeGroupsDeleteResponse contains the response from method VolumeGroups.Delete.
type VolumeGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGroupsGetResponse contains the response from method VolumeGroups.Get.
type VolumeGroupsGetResponse struct {
	VolumeGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGroupsGetResult contains the result from method VolumeGroups.Get.
type VolumeGroupsGetResult struct {
	VolumeGroupDetails
}

// VolumeGroupsListByNetAppAccountResponse contains the response from method VolumeGroups.ListByNetAppAccount.
type VolumeGroupsListByNetAppAccountResponse struct {
	VolumeGroupsListByNetAppAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGroupsListByNetAppAccountResult contains the result from method VolumeGroups.ListByNetAppAccount.
type VolumeGroupsListByNetAppAccountResult struct {
	VolumeGroupList
}

// VolumesAuthorizeReplicationPollerResponse contains the response from method Volumes.AuthorizeReplication.
type VolumesAuthorizeReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesAuthorizeReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesAuthorizeReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesAuthorizeReplicationResponse, error) {
	respType := VolumesAuthorizeReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesAuthorizeReplicationPollerResponse from the provided client and resume token.
func (l *VolumesAuthorizeReplicationPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.AuthorizeReplication", token, client.pl, client.authorizeReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesAuthorizeReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesAuthorizeReplicationResponse contains the response from method Volumes.AuthorizeReplication.
type VolumesAuthorizeReplicationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesBreakReplicationPollerResponse contains the response from method Volumes.BreakReplication.
type VolumesBreakReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesBreakReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesBreakReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesBreakReplicationResponse, error) {
	respType := VolumesBreakReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesBreakReplicationPollerResponse from the provided client and resume token.
func (l *VolumesBreakReplicationPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.BreakReplication", token, client.pl, client.breakReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesBreakReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesBreakReplicationResponse contains the response from method Volumes.BreakReplication.
type VolumesBreakReplicationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesCreateOrUpdatePollerResponse contains the response from method Volumes.CreateOrUpdate.
type VolumesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesCreateOrUpdateResponse, error) {
	respType := VolumesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Volume)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VolumesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesCreateOrUpdateResponse contains the response from method Volumes.CreateOrUpdate.
type VolumesCreateOrUpdateResponse struct {
	VolumesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesCreateOrUpdateResult contains the result from method Volumes.CreateOrUpdate.
type VolumesCreateOrUpdateResult struct {
	Volume
}

// VolumesDeletePollerResponse contains the response from method Volumes.Delete.
type VolumesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesDeleteResponse, error) {
	respType := VolumesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesDeletePollerResponse from the provided client and resume token.
func (l *VolumesDeletePollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesDeleteReplicationPollerResponse contains the response from method Volumes.DeleteReplication.
type VolumesDeleteReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesDeleteReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesDeleteReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesDeleteReplicationResponse, error) {
	respType := VolumesDeleteReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesDeleteReplicationPollerResponse from the provided client and resume token.
func (l *VolumesDeleteReplicationPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.DeleteReplication", token, client.pl, client.deleteReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesDeleteReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesDeleteReplicationResponse contains the response from method Volumes.DeleteReplication.
type VolumesDeleteReplicationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesDeleteResponse contains the response from method Volumes.Delete.
type VolumesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesGetResponse contains the response from method Volumes.Get.
type VolumesGetResponse struct {
	VolumesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesGetResult contains the result from method Volumes.Get.
type VolumesGetResult struct {
	Volume
}

// VolumesListResponse contains the response from method Volumes.List.
type VolumesListResponse struct {
	VolumesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesListResult contains the result from method Volumes.List.
type VolumesListResult struct {
	VolumeList
}

// VolumesPoolChangePollerResponse contains the response from method Volumes.PoolChange.
type VolumesPoolChangePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesPoolChangePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesPoolChangePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesPoolChangeResponse, error) {
	respType := VolumesPoolChangeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesPoolChangePollerResponse from the provided client and resume token.
func (l *VolumesPoolChangePollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.PoolChange", token, client.pl, client.poolChangeHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesPoolChangePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesPoolChangeResponse contains the response from method Volumes.PoolChange.
type VolumesPoolChangeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesReInitializeReplicationPollerResponse contains the response from method Volumes.ReInitializeReplication.
type VolumesReInitializeReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesReInitializeReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesReInitializeReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesReInitializeReplicationResponse, error) {
	respType := VolumesReInitializeReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesReInitializeReplicationPollerResponse from the provided client and resume token.
func (l *VolumesReInitializeReplicationPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.ReInitializeReplication", token, client.pl, client.reInitializeReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesReInitializeReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesReInitializeReplicationResponse contains the response from method Volumes.ReInitializeReplication.
type VolumesReInitializeReplicationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesReplicationStatusResponse contains the response from method Volumes.ReplicationStatus.
type VolumesReplicationStatusResponse struct {
	VolumesReplicationStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesReplicationStatusResult contains the result from method Volumes.ReplicationStatus.
type VolumesReplicationStatusResult struct {
	ReplicationStatus
}

// VolumesResyncReplicationPollerResponse contains the response from method Volumes.ResyncReplication.
type VolumesResyncReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesResyncReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesResyncReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesResyncReplicationResponse, error) {
	respType := VolumesResyncReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesResyncReplicationPollerResponse from the provided client and resume token.
func (l *VolumesResyncReplicationPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.ResyncReplication", token, client.pl, client.resyncReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesResyncReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesResyncReplicationResponse contains the response from method Volumes.ResyncReplication.
type VolumesResyncReplicationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesRevertPollerResponse contains the response from method Volumes.Revert.
type VolumesRevertPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesRevertPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesRevertPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesRevertResponse, error) {
	respType := VolumesRevertResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesRevertPollerResponse from the provided client and resume token.
func (l *VolumesRevertPollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.Revert", token, client.pl, client.revertHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesRevertPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesRevertResponse contains the response from method Volumes.Revert.
type VolumesRevertResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesUpdatePollerResponse contains the response from method Volumes.Update.
type VolumesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VolumesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumesUpdateResponse, error) {
	respType := VolumesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Volume)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumesUpdatePollerResponse from the provided client and resume token.
func (l *VolumesUpdatePollerResponse) Resume(ctx context.Context, client *VolumesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VolumesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &VolumesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumesUpdateResponse contains the response from method Volumes.Update.
type VolumesUpdateResponse struct {
	VolumesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumesUpdateResult contains the result from method Volumes.Update.
type VolumesUpdateResult struct {
	Volume
}
