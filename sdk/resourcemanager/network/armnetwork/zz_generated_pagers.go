//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ApplicationGatewayPrivateEndpointConnectionsListPager provides operations for iterating over paged responses.
type ApplicationGatewayPrivateEndpointConnectionsListPager struct {
	client    *ApplicationGatewayPrivateEndpointConnectionsClient
	current   ApplicationGatewayPrivateEndpointConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewayPrivateEndpointConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewayPrivateEndpointConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewayPrivateEndpointConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayPrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.ApplicationGatewayPrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewayPrivateEndpointConnectionsListResponse page.
func (p *ApplicationGatewayPrivateEndpointConnectionsListPager) PageResponse() ApplicationGatewayPrivateEndpointConnectionsListResponse {
	return p.current
}

// ApplicationGatewayPrivateLinkResourcesListPager provides operations for iterating over paged responses.
type ApplicationGatewayPrivateLinkResourcesListPager struct {
	client    *ApplicationGatewayPrivateLinkResourcesClient
	current   ApplicationGatewayPrivateLinkResourcesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewayPrivateLinkResourcesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewayPrivateLinkResourcesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewayPrivateLinkResourcesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayPrivateLinkResourceListResult.NextLink == nil || len(*p.current.ApplicationGatewayPrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewayPrivateLinkResourcesListResponse page.
func (p *ApplicationGatewayPrivateLinkResourcesListPager) PageResponse() ApplicationGatewayPrivateLinkResourcesListResponse {
	return p.current
}

// ApplicationGatewaysListAllPager provides operations for iterating over paged responses.
type ApplicationGatewaysListAllPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysListAllResponse page.
func (p *ApplicationGatewaysListAllPager) PageResponse() ApplicationGatewaysListAllResponse {
	return p.current
}

// ApplicationGatewaysListAvailableSSLPredefinedPoliciesPager provides operations for iterating over paged responses.
type ApplicationGatewaysListAvailableSSLPredefinedPoliciesPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysListAvailableSSLPredefinedPoliciesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysListAvailableSSLPredefinedPoliciesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink == nil || len(*p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAvailableSSLPredefinedPoliciesHandleError(resp)
		return false
	}
	result, err := p.client.listAvailableSSLPredefinedPoliciesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse page.
func (p *ApplicationGatewaysListAvailableSSLPredefinedPoliciesPager) PageResponse() ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse {
	return p.current
}

// ApplicationGatewaysListPager provides operations for iterating over paged responses.
type ApplicationGatewaysListPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysListResponse page.
func (p *ApplicationGatewaysListPager) PageResponse() ApplicationGatewaysListResponse {
	return p.current
}

// ApplicationSecurityGroupsListAllPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsListAllPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationSecurityGroupsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationSecurityGroupsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationSecurityGroupsListAllResponse page.
func (p *ApplicationSecurityGroupsListAllPager) PageResponse() ApplicationSecurityGroupsListAllResponse {
	return p.current
}

// ApplicationSecurityGroupsListPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsListPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationSecurityGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationSecurityGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationSecurityGroupsListResponse page.
func (p *ApplicationSecurityGroupsListPager) PageResponse() ApplicationSecurityGroupsListResponse {
	return p.current
}

// AvailableDelegationsListPager provides operations for iterating over paged responses.
type AvailableDelegationsListPager struct {
	client    *AvailableDelegationsClient
	current   AvailableDelegationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableDelegationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableDelegationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableDelegationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableDelegationsListResponse page.
func (p *AvailableDelegationsListPager) PageResponse() AvailableDelegationsListResponse {
	return p.current
}

// AvailableEndpointServicesListPager provides operations for iterating over paged responses.
type AvailableEndpointServicesListPager struct {
	client    *AvailableEndpointServicesClient
	current   AvailableEndpointServicesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableEndpointServicesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableEndpointServicesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableEndpointServicesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EndpointServicesListResult.NextLink == nil || len(*p.current.EndpointServicesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableEndpointServicesListResponse page.
func (p *AvailableEndpointServicesListPager) PageResponse() AvailableEndpointServicesListResponse {
	return p.current
}

// AvailablePrivateEndpointTypesListByResourceGroupPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesListByResourceGroupPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailablePrivateEndpointTypesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailablePrivateEndpointTypesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailablePrivateEndpointTypesListByResourceGroupResponse page.
func (p *AvailablePrivateEndpointTypesListByResourceGroupPager) PageResponse() AvailablePrivateEndpointTypesListByResourceGroupResponse {
	return p.current
}

// AvailablePrivateEndpointTypesListPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesListPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailablePrivateEndpointTypesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailablePrivateEndpointTypesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailablePrivateEndpointTypesListResponse page.
func (p *AvailablePrivateEndpointTypesListPager) PageResponse() AvailablePrivateEndpointTypesListResponse {
	return p.current
}

// AvailableResourceGroupDelegationsListPager provides operations for iterating over paged responses.
type AvailableResourceGroupDelegationsListPager struct {
	client    *AvailableResourceGroupDelegationsClient
	current   AvailableResourceGroupDelegationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableResourceGroupDelegationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableResourceGroupDelegationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableResourceGroupDelegationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableResourceGroupDelegationsListResponse page.
func (p *AvailableResourceGroupDelegationsListPager) PageResponse() AvailableResourceGroupDelegationsListResponse {
	return p.current
}

// AvailableServiceAliasesListByResourceGroupPager provides operations for iterating over paged responses.
type AvailableServiceAliasesListByResourceGroupPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableServiceAliasesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableServiceAliasesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableServiceAliasesListByResourceGroupResponse page.
func (p *AvailableServiceAliasesListByResourceGroupPager) PageResponse() AvailableServiceAliasesListByResourceGroupResponse {
	return p.current
}

// AvailableServiceAliasesListPager provides operations for iterating over paged responses.
type AvailableServiceAliasesListPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableServiceAliasesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableServiceAliasesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableServiceAliasesListResponse page.
func (p *AvailableServiceAliasesListPager) PageResponse() AvailableServiceAliasesListResponse {
	return p.current
}

// AzureFirewallFqdnTagsListAllPager provides operations for iterating over paged responses.
type AzureFirewallFqdnTagsListAllPager struct {
	client    *AzureFirewallFqdnTagsClient
	current   AzureFirewallFqdnTagsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallFqdnTagsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallFqdnTagsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallFqdnTagsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallFqdnTagListResult.NextLink == nil || len(*p.current.AzureFirewallFqdnTagListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallFqdnTagsListAllResponse page.
func (p *AzureFirewallFqdnTagsListAllPager) PageResponse() AzureFirewallFqdnTagsListAllResponse {
	return p.current
}

// AzureFirewallsListAllPager provides operations for iterating over paged responses.
type AzureFirewallsListAllPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallsListAllResponse page.
func (p *AzureFirewallsListAllPager) PageResponse() AzureFirewallsListAllResponse {
	return p.current
}

// AzureFirewallsListPager provides operations for iterating over paged responses.
type AzureFirewallsListPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallsListResponse page.
func (p *AzureFirewallsListPager) PageResponse() AzureFirewallsListResponse {
	return p.current
}

// BastionHostsListByResourceGroupPager provides operations for iterating over paged responses.
type BastionHostsListByResourceGroupPager struct {
	client    *BastionHostsClient
	current   BastionHostsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BastionHostsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BastionHostsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BastionHostsListByResourceGroupResponse page.
func (p *BastionHostsListByResourceGroupPager) PageResponse() BastionHostsListByResourceGroupResponse {
	return p.current
}

// BastionHostsListPager provides operations for iterating over paged responses.
type BastionHostsListPager struct {
	client    *BastionHostsClient
	current   BastionHostsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BastionHostsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BastionHostsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BastionHostsListResponse page.
func (p *BastionHostsListPager) PageResponse() BastionHostsListResponse {
	return p.current
}

// BgpServiceCommunitiesListPager provides operations for iterating over paged responses.
type BgpServiceCommunitiesListPager struct {
	client    *BgpServiceCommunitiesClient
	current   BgpServiceCommunitiesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BgpServiceCommunitiesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BgpServiceCommunitiesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BgpServiceCommunitiesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BgpServiceCommunityListResult.NextLink == nil || len(*p.current.BgpServiceCommunityListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BgpServiceCommunitiesListResponse page.
func (p *BgpServiceCommunitiesListPager) PageResponse() BgpServiceCommunitiesListResponse {
	return p.current
}

// CustomIPPrefixesListAllPager provides operations for iterating over paged responses.
type CustomIPPrefixesListAllPager struct {
	client    *CustomIPPrefixesClient
	current   CustomIPPrefixesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomIPPrefixesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomIPPrefixesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomIPPrefixesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomIPPrefixListResult.NextLink == nil || len(*p.current.CustomIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomIPPrefixesListAllResponse page.
func (p *CustomIPPrefixesListAllPager) PageResponse() CustomIPPrefixesListAllResponse {
	return p.current
}

// CustomIPPrefixesListPager provides operations for iterating over paged responses.
type CustomIPPrefixesListPager struct {
	client    *CustomIPPrefixesClient
	current   CustomIPPrefixesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomIPPrefixesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomIPPrefixesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomIPPrefixesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomIPPrefixListResult.NextLink == nil || len(*p.current.CustomIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomIPPrefixesListResponse page.
func (p *CustomIPPrefixesListPager) PageResponse() CustomIPPrefixesListResponse {
	return p.current
}

// DdosProtectionPlansListByResourceGroupPager provides operations for iterating over paged responses.
type DdosProtectionPlansListByResourceGroupPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DdosProtectionPlansListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DdosProtectionPlansListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DdosProtectionPlansListByResourceGroupResponse page.
func (p *DdosProtectionPlansListByResourceGroupPager) PageResponse() DdosProtectionPlansListByResourceGroupResponse {
	return p.current
}

// DdosProtectionPlansListPager provides operations for iterating over paged responses.
type DdosProtectionPlansListPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DdosProtectionPlansListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DdosProtectionPlansListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DdosProtectionPlansListResponse page.
func (p *DdosProtectionPlansListPager) PageResponse() DdosProtectionPlansListResponse {
	return p.current
}

// DefaultSecurityRulesListPager provides operations for iterating over paged responses.
type DefaultSecurityRulesListPager struct {
	client    *DefaultSecurityRulesClient
	current   DefaultSecurityRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefaultSecurityRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DefaultSecurityRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DefaultSecurityRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DefaultSecurityRulesListResponse page.
func (p *DefaultSecurityRulesListPager) PageResponse() DefaultSecurityRulesListResponse {
	return p.current
}

// DscpConfigurationListAllPager provides operations for iterating over paged responses.
type DscpConfigurationListAllPager struct {
	client    *DscpConfigurationClient
	current   DscpConfigurationListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscpConfigurationListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscpConfigurationListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscpConfigurationListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscpConfigurationListResult.NextLink == nil || len(*p.current.DscpConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscpConfigurationListAllResponse page.
func (p *DscpConfigurationListAllPager) PageResponse() DscpConfigurationListAllResponse {
	return p.current
}

// DscpConfigurationListPager provides operations for iterating over paged responses.
type DscpConfigurationListPager struct {
	client    *DscpConfigurationClient
	current   DscpConfigurationListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscpConfigurationListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscpConfigurationListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscpConfigurationListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscpConfigurationListResult.NextLink == nil || len(*p.current.DscpConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscpConfigurationListResponse page.
func (p *DscpConfigurationListPager) PageResponse() DscpConfigurationListResponse {
	return p.current
}

// ExpressRouteCircuitAuthorizationsListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitAuthorizationsListPager struct {
	client    *ExpressRouteCircuitAuthorizationsClient
	current   ExpressRouteCircuitAuthorizationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitAuthorizationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitAuthorizationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitAuthorizationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationListResult.NextLink == nil || len(*p.current.AuthorizationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitAuthorizationsListResponse page.
func (p *ExpressRouteCircuitAuthorizationsListPager) PageResponse() ExpressRouteCircuitAuthorizationsListResponse {
	return p.current
}

// ExpressRouteCircuitConnectionsListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitConnectionsListPager struct {
	client    *ExpressRouteCircuitConnectionsClient
	current   ExpressRouteCircuitConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitConnectionsListResponse page.
func (p *ExpressRouteCircuitConnectionsListPager) PageResponse() ExpressRouteCircuitConnectionsListResponse {
	return p.current
}

// ExpressRouteCircuitPeeringsListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitPeeringsListPager struct {
	client    *ExpressRouteCircuitPeeringsClient
	current   ExpressRouteCircuitPeeringsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitPeeringsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitPeeringsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitPeeringsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitPeeringListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitPeeringsListResponse page.
func (p *ExpressRouteCircuitPeeringsListPager) PageResponse() ExpressRouteCircuitPeeringsListResponse {
	return p.current
}

// ExpressRouteCircuitsListAllPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsListAllPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitsListAllResponse page.
func (p *ExpressRouteCircuitsListAllPager) PageResponse() ExpressRouteCircuitsListAllResponse {
	return p.current
}

// ExpressRouteCircuitsListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsListPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitsListResponse page.
func (p *ExpressRouteCircuitsListPager) PageResponse() ExpressRouteCircuitsListResponse {
	return p.current
}

// ExpressRouteCrossConnectionPeeringsListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionPeeringsListPager struct {
	client    *ExpressRouteCrossConnectionPeeringsClient
	current   ExpressRouteCrossConnectionPeeringsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionPeeringsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionPeeringsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionPeeringsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionPeeringList.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionPeeringList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionPeeringsListResponse page.
func (p *ExpressRouteCrossConnectionPeeringsListPager) PageResponse() ExpressRouteCrossConnectionPeeringsListResponse {
	return p.current
}

// ExpressRouteCrossConnectionsListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsListByResourceGroupPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionsListByResourceGroupResponse page.
func (p *ExpressRouteCrossConnectionsListByResourceGroupPager) PageResponse() ExpressRouteCrossConnectionsListByResourceGroupResponse {
	return p.current
}

// ExpressRouteCrossConnectionsListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsListPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionsListResponse page.
func (p *ExpressRouteCrossConnectionsListPager) PageResponse() ExpressRouteCrossConnectionsListResponse {
	return p.current
}

// ExpressRouteLinksListPager provides operations for iterating over paged responses.
type ExpressRouteLinksListPager struct {
	client    *ExpressRouteLinksClient
	current   ExpressRouteLinksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteLinksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteLinksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteLinksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteLinkListResult.NextLink == nil || len(*p.current.ExpressRouteLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteLinksListResponse page.
func (p *ExpressRouteLinksListPager) PageResponse() ExpressRouteLinksListResponse {
	return p.current
}

// ExpressRoutePortsListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRoutePortsListByResourceGroupPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsListByResourceGroupResponse page.
func (p *ExpressRoutePortsListByResourceGroupPager) PageResponse() ExpressRoutePortsListByResourceGroupResponse {
	return p.current
}

// ExpressRoutePortsListPager provides operations for iterating over paged responses.
type ExpressRoutePortsListPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsListResponse page.
func (p *ExpressRoutePortsListPager) PageResponse() ExpressRoutePortsListResponse {
	return p.current
}

// ExpressRoutePortsLocationsListPager provides operations for iterating over paged responses.
type ExpressRoutePortsLocationsListPager struct {
	client    *ExpressRoutePortsLocationsClient
	current   ExpressRoutePortsLocationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsLocationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsLocationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsLocationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortsLocationListResult.NextLink == nil || len(*p.current.ExpressRoutePortsLocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsLocationsListResponse page.
func (p *ExpressRoutePortsLocationsListPager) PageResponse() ExpressRoutePortsLocationsListResponse {
	return p.current
}

// ExpressRouteServiceProvidersListPager provides operations for iterating over paged responses.
type ExpressRouteServiceProvidersListPager struct {
	client    *ExpressRouteServiceProvidersClient
	current   ExpressRouteServiceProvidersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteServiceProvidersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteServiceProvidersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteServiceProvidersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteServiceProviderListResult.NextLink == nil || len(*p.current.ExpressRouteServiceProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteServiceProvidersListResponse page.
func (p *ExpressRouteServiceProvidersListPager) PageResponse() ExpressRouteServiceProvidersListResponse {
	return p.current
}

// FirewallPoliciesListAllPager provides operations for iterating over paged responses.
type FirewallPoliciesListAllPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPoliciesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPoliciesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPoliciesListAllResponse page.
func (p *FirewallPoliciesListAllPager) PageResponse() FirewallPoliciesListAllResponse {
	return p.current
}

// FirewallPoliciesListPager provides operations for iterating over paged responses.
type FirewallPoliciesListPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPoliciesListResponse page.
func (p *FirewallPoliciesListPager) PageResponse() FirewallPoliciesListResponse {
	return p.current
}

// FirewallPolicyRuleCollectionGroupsListPager provides operations for iterating over paged responses.
type FirewallPolicyRuleCollectionGroupsListPager struct {
	client    *FirewallPolicyRuleCollectionGroupsClient
	current   FirewallPolicyRuleCollectionGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPolicyRuleCollectionGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPolicyRuleCollectionGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPolicyRuleCollectionGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyRuleCollectionGroupListResult.NextLink == nil || len(*p.current.FirewallPolicyRuleCollectionGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPolicyRuleCollectionGroupsListResponse page.
func (p *FirewallPolicyRuleCollectionGroupsListPager) PageResponse() FirewallPolicyRuleCollectionGroupsListResponse {
	return p.current
}

// FlowLogsListPager provides operations for iterating over paged responses.
type FlowLogsListPager struct {
	client    *FlowLogsClient
	current   FlowLogsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FlowLogsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FlowLogsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FlowLogsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FlowLogListResult.NextLink == nil || len(*p.current.FlowLogListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FlowLogsListResponse page.
func (p *FlowLogsListPager) PageResponse() FlowLogsListResponse {
	return p.current
}

// HubRouteTablesListPager provides operations for iterating over paged responses.
type HubRouteTablesListPager struct {
	client    *HubRouteTablesClient
	current   HubRouteTablesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubRouteTablesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HubRouteTablesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HubRouteTablesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListHubRouteTablesResult.NextLink == nil || len(*p.current.ListHubRouteTablesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HubRouteTablesListResponse page.
func (p *HubRouteTablesListPager) PageResponse() HubRouteTablesListResponse {
	return p.current
}

// HubVirtualNetworkConnectionsListPager provides operations for iterating over paged responses.
type HubVirtualNetworkConnectionsListPager struct {
	client    *HubVirtualNetworkConnectionsClient
	current   HubVirtualNetworkConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubVirtualNetworkConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HubVirtualNetworkConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HubVirtualNetworkConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListHubVirtualNetworkConnectionsResult.NextLink == nil || len(*p.current.ListHubVirtualNetworkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HubVirtualNetworkConnectionsListResponse page.
func (p *HubVirtualNetworkConnectionsListPager) PageResponse() HubVirtualNetworkConnectionsListResponse {
	return p.current
}

// IPAllocationsListByResourceGroupPager provides operations for iterating over paged responses.
type IPAllocationsListByResourceGroupPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPAllocationsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPAllocationsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPAllocationsListByResourceGroupResponse page.
func (p *IPAllocationsListByResourceGroupPager) PageResponse() IPAllocationsListByResourceGroupResponse {
	return p.current
}

// IPAllocationsListPager provides operations for iterating over paged responses.
type IPAllocationsListPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPAllocationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPAllocationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPAllocationsListResponse page.
func (p *IPAllocationsListPager) PageResponse() IPAllocationsListResponse {
	return p.current
}

// IPGroupsListByResourceGroupPager provides operations for iterating over paged responses.
type IPGroupsListByResourceGroupPager struct {
	client    *IPGroupsClient
	current   IPGroupsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPGroupsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPGroupsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPGroupsListByResourceGroupResponse page.
func (p *IPGroupsListByResourceGroupPager) PageResponse() IPGroupsListByResourceGroupResponse {
	return p.current
}

// IPGroupsListPager provides operations for iterating over paged responses.
type IPGroupsListPager struct {
	client    *IPGroupsClient
	current   IPGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPGroupsListResponse page.
func (p *IPGroupsListPager) PageResponse() IPGroupsListResponse {
	return p.current
}

// InboundNatRulesListPager provides operations for iterating over paged responses.
type InboundNatRulesListPager struct {
	client    *InboundNatRulesClient
	current   InboundNatRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InboundNatRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InboundNatRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InboundNatRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InboundNatRuleListResult.NextLink == nil || len(*p.current.InboundNatRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InboundNatRulesListResponse page.
func (p *InboundNatRulesListPager) PageResponse() InboundNatRulesListResponse {
	return p.current
}

// LoadBalancerBackendAddressPoolsListPager provides operations for iterating over paged responses.
type LoadBalancerBackendAddressPoolsListPager struct {
	client    *LoadBalancerBackendAddressPoolsClient
	current   LoadBalancerBackendAddressPoolsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerBackendAddressPoolsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerBackendAddressPoolsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerBackendAddressPoolsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerBackendAddressPoolListResult.NextLink == nil || len(*p.current.LoadBalancerBackendAddressPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerBackendAddressPoolsListResponse page.
func (p *LoadBalancerBackendAddressPoolsListPager) PageResponse() LoadBalancerBackendAddressPoolsListResponse {
	return p.current
}

// LoadBalancerFrontendIPConfigurationsListPager provides operations for iterating over paged responses.
type LoadBalancerFrontendIPConfigurationsListPager struct {
	client    *LoadBalancerFrontendIPConfigurationsClient
	current   LoadBalancerFrontendIPConfigurationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerFrontendIPConfigurationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerFrontendIPConfigurationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerFrontendIPConfigurationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink == nil || len(*p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerFrontendIPConfigurationsListResponse page.
func (p *LoadBalancerFrontendIPConfigurationsListPager) PageResponse() LoadBalancerFrontendIPConfigurationsListResponse {
	return p.current
}

// LoadBalancerLoadBalancingRulesListPager provides operations for iterating over paged responses.
type LoadBalancerLoadBalancingRulesListPager struct {
	client    *LoadBalancerLoadBalancingRulesClient
	current   LoadBalancerLoadBalancingRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerLoadBalancingRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerLoadBalancingRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerLoadBalancingRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerLoadBalancingRuleListResult.NextLink == nil || len(*p.current.LoadBalancerLoadBalancingRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerLoadBalancingRulesListResponse page.
func (p *LoadBalancerLoadBalancingRulesListPager) PageResponse() LoadBalancerLoadBalancingRulesListResponse {
	return p.current
}

// LoadBalancerNetworkInterfacesListPager provides operations for iterating over paged responses.
type LoadBalancerNetworkInterfacesListPager struct {
	client    *LoadBalancerNetworkInterfacesClient
	current   LoadBalancerNetworkInterfacesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerNetworkInterfacesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerNetworkInterfacesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerNetworkInterfacesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerNetworkInterfacesListResponse page.
func (p *LoadBalancerNetworkInterfacesListPager) PageResponse() LoadBalancerNetworkInterfacesListResponse {
	return p.current
}

// LoadBalancerOutboundRulesListPager provides operations for iterating over paged responses.
type LoadBalancerOutboundRulesListPager struct {
	client    *LoadBalancerOutboundRulesClient
	current   LoadBalancerOutboundRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerOutboundRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerOutboundRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerOutboundRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerOutboundRuleListResult.NextLink == nil || len(*p.current.LoadBalancerOutboundRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerOutboundRulesListResponse page.
func (p *LoadBalancerOutboundRulesListPager) PageResponse() LoadBalancerOutboundRulesListResponse {
	return p.current
}

// LoadBalancerProbesListPager provides operations for iterating over paged responses.
type LoadBalancerProbesListPager struct {
	client    *LoadBalancerProbesClient
	current   LoadBalancerProbesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerProbesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerProbesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerProbesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerProbeListResult.NextLink == nil || len(*p.current.LoadBalancerProbeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerProbesListResponse page.
func (p *LoadBalancerProbesListPager) PageResponse() LoadBalancerProbesListResponse {
	return p.current
}

// LoadBalancersListAllPager provides operations for iterating over paged responses.
type LoadBalancersListAllPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancersListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancersListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancersListAllResponse page.
func (p *LoadBalancersListAllPager) PageResponse() LoadBalancersListAllResponse {
	return p.current
}

// LoadBalancersListPager provides operations for iterating over paged responses.
type LoadBalancersListPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancersListResponse page.
func (p *LoadBalancersListPager) PageResponse() LoadBalancersListResponse {
	return p.current
}

// LocalNetworkGatewaysListPager provides operations for iterating over paged responses.
type LocalNetworkGatewaysListPager struct {
	client    *LocalNetworkGatewaysClient
	current   LocalNetworkGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocalNetworkGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LocalNetworkGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LocalNetworkGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LocalNetworkGatewayListResult.NextLink == nil || len(*p.current.LocalNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LocalNetworkGatewaysListResponse page.
func (p *LocalNetworkGatewaysListPager) PageResponse() LocalNetworkGatewaysListResponse {
	return p.current
}

// NatGatewaysListAllPager provides operations for iterating over paged responses.
type NatGatewaysListAllPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatGatewaysListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatGatewaysListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatGatewaysListAllResponse page.
func (p *NatGatewaysListAllPager) PageResponse() NatGatewaysListAllResponse {
	return p.current
}

// NatGatewaysListPager provides operations for iterating over paged responses.
type NatGatewaysListPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatGatewaysListResponse page.
func (p *NatGatewaysListPager) PageResponse() NatGatewaysListResponse {
	return p.current
}

// NatRulesListByVPNGatewayPager provides operations for iterating over paged responses.
type NatRulesListByVPNGatewayPager struct {
	client    *NatRulesClient
	current   NatRulesListByVPNGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatRulesListByVPNGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatRulesListByVPNGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatRulesListByVPNGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewayNatRulesResult.NextLink == nil || len(*p.current.ListVPNGatewayNatRulesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVPNGatewayHandleError(resp)
		return false
	}
	result, err := p.client.listByVPNGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatRulesListByVPNGatewayResponse page.
func (p *NatRulesListByVPNGatewayPager) PageResponse() NatRulesListByVPNGatewayResponse {
	return p.current
}

// NetworkInterfaceIPConfigurationsListPager provides operations for iterating over paged responses.
type NetworkInterfaceIPConfigurationsListPager struct {
	client    *NetworkInterfaceIPConfigurationsClient
	current   NetworkInterfaceIPConfigurationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfaceIPConfigurationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfaceIPConfigurationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfaceIPConfigurationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfaceIPConfigurationsListResponse page.
func (p *NetworkInterfaceIPConfigurationsListPager) PageResponse() NetworkInterfaceIPConfigurationsListResponse {
	return p.current
}

// NetworkInterfaceLoadBalancersListPager provides operations for iterating over paged responses.
type NetworkInterfaceLoadBalancersListPager struct {
	client    *NetworkInterfaceLoadBalancersClient
	current   NetworkInterfaceLoadBalancersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfaceLoadBalancersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfaceLoadBalancersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfaceLoadBalancersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceLoadBalancerListResult.NextLink == nil || len(*p.current.NetworkInterfaceLoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfaceLoadBalancersListResponse page.
func (p *NetworkInterfaceLoadBalancersListPager) PageResponse() NetworkInterfaceLoadBalancersListResponse {
	return p.current
}

// NetworkInterfaceTapConfigurationsListPager provides operations for iterating over paged responses.
type NetworkInterfaceTapConfigurationsListPager struct {
	client    *NetworkInterfaceTapConfigurationsClient
	current   NetworkInterfaceTapConfigurationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfaceTapConfigurationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfaceTapConfigurationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfaceTapConfigurationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceTapConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceTapConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfaceTapConfigurationsListResponse page.
func (p *NetworkInterfaceTapConfigurationsListPager) PageResponse() NetworkInterfaceTapConfigurationsListResponse {
	return p.current
}

// NetworkInterfacesListAllPager provides operations for iterating over paged responses.
type NetworkInterfacesListAllPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListAllResponse page.
func (p *NetworkInterfacesListAllPager) PageResponse() NetworkInterfacesListAllResponse {
	return p.current
}

// NetworkInterfacesListCloudServiceNetworkInterfacesPager provides operations for iterating over paged responses.
type NetworkInterfacesListCloudServiceNetworkInterfacesPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListCloudServiceNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListCloudServiceNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListCloudServiceNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListCloudServiceNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCloudServiceNetworkInterfacesHandleError(resp)
		return false
	}
	result, err := p.client.listCloudServiceNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListCloudServiceNetworkInterfacesResponse page.
func (p *NetworkInterfacesListCloudServiceNetworkInterfacesPager) PageResponse() NetworkInterfacesListCloudServiceNetworkInterfacesResponse {
	return p.current
}

// NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesPager provides operations for iterating over paged responses.
type NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCloudServiceRoleInstanceNetworkInterfacesHandleError(resp)
		return false
	}
	result, err := p.client.listCloudServiceRoleInstanceNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse page.
func (p *NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesPager) PageResponse() NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse {
	return p.current
}

// NetworkInterfacesListPager provides operations for iterating over paged responses.
type NetworkInterfacesListPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListResponse page.
func (p *NetworkInterfacesListPager) PageResponse() NetworkInterfacesListResponse {
	return p.current
}

// NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsPager provides operations for iterating over paged responses.
type NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.NetworkInterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVirtualMachineScaleSetIPConfigurationsHandleError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetIPConfigurationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse page.
func (p *NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsPager) PageResponse() NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse {
	return p.current
}

// NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesPager provides operations for iterating over paged responses.
type NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVirtualMachineScaleSetNetworkInterfacesHandleError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse page.
func (p *NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesPager) PageResponse() NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse {
	return p.current
}

// NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesPager provides operations for iterating over paged responses.
type NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesPager struct {
	client    *NetworkInterfacesClient
	current   NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkInterfaceListResult.NextLink == nil || len(*p.current.NetworkInterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVirtualMachineScaleSetVMNetworkInterfacesHandleError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetVMNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse page.
func (p *NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesPager) PageResponse() NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse {
	return p.current
}

// NetworkManagementClientDisconnectActiveSessionsPager provides operations for iterating over paged responses.
type NetworkManagementClientDisconnectActiveSessionsPager struct {
	client    *NetworkManagementClient
	current   NetworkManagementClientDisconnectActiveSessionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkManagementClientDisconnectActiveSessionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkManagementClientDisconnectActiveSessionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkManagementClientDisconnectActiveSessionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionSessionDeleteResult.NextLink == nil || len(*p.current.BastionSessionDeleteResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.disconnectActiveSessionsHandleError(resp)
		return false
	}
	result, err := p.client.disconnectActiveSessionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkManagementClientDisconnectActiveSessionsResponse page.
func (p *NetworkManagementClientDisconnectActiveSessionsPager) PageResponse() NetworkManagementClientDisconnectActiveSessionsResponse {
	return p.current
}

// NetworkManagementClientGetActiveSessionsPager provides operations for iterating over paged responses.
type NetworkManagementClientGetActiveSessionsPager struct {
	client  *NetworkManagementClient
	current NetworkManagementClientGetActiveSessionsResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *NetworkManagementClientGetActiveSessionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkManagementClientGetActiveSessionsPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionActiveSessionListResult.NextLink == nil || len(*p.current.BastionActiveSessionListResult.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionActiveSessionListResult.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = p.client.getActiveSessionsHandleError(resp)
		return false
	}
	result, err := p.client.getActiveSessionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkManagementClientGetActiveSessionsResponse page.
func (p *NetworkManagementClientGetActiveSessionsPager) PageResponse() NetworkManagementClientGetActiveSessionsResponse {
	return p.current
}

// NetworkManagementClientGetBastionShareableLinkPager provides operations for iterating over paged responses.
type NetworkManagementClientGetBastionShareableLinkPager struct {
	client    *NetworkManagementClient
	current   NetworkManagementClientGetBastionShareableLinkResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkManagementClientGetBastionShareableLinkResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkManagementClientGetBastionShareableLinkPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkManagementClientGetBastionShareableLinkPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.getBastionShareableLinkHandleError(resp)
		return false
	}
	result, err := p.client.getBastionShareableLinkHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkManagementClientGetBastionShareableLinkResponse page.
func (p *NetworkManagementClientGetBastionShareableLinkPager) PageResponse() NetworkManagementClientGetBastionShareableLinkResponse {
	return p.current
}

// NetworkManagementClientPutBastionShareableLinkPager provides operations for iterating over paged responses.
type NetworkManagementClientPutBastionShareableLinkPager struct {
	client  *NetworkManagementClient
	current NetworkManagementClientPutBastionShareableLinkResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *NetworkManagementClientPutBastionShareableLinkPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkManagementClientPutBastionShareableLinkPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionShareableLinkListResult.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = p.client.putBastionShareableLinkHandleError(resp)
		return false
	}
	result, err := p.client.putBastionShareableLinkHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkManagementClientPutBastionShareableLinkResponse page.
func (p *NetworkManagementClientPutBastionShareableLinkPager) PageResponse() NetworkManagementClientPutBastionShareableLinkResponse {
	return p.current
}

// NetworkProfilesListAllPager provides operations for iterating over paged responses.
type NetworkProfilesListAllPager struct {
	client    *NetworkProfilesClient
	current   NetworkProfilesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkProfilesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkProfilesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkProfilesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkProfileListResult.NextLink == nil || len(*p.current.NetworkProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkProfilesListAllResponse page.
func (p *NetworkProfilesListAllPager) PageResponse() NetworkProfilesListAllResponse {
	return p.current
}

// NetworkProfilesListPager provides operations for iterating over paged responses.
type NetworkProfilesListPager struct {
	client    *NetworkProfilesClient
	current   NetworkProfilesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkProfilesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkProfilesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkProfilesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkProfileListResult.NextLink == nil || len(*p.current.NetworkProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkProfilesListResponse page.
func (p *NetworkProfilesListPager) PageResponse() NetworkProfilesListResponse {
	return p.current
}

// NetworkSecurityGroupsListAllPager provides operations for iterating over paged responses.
type NetworkSecurityGroupsListAllPager struct {
	client    *NetworkSecurityGroupsClient
	current   NetworkSecurityGroupsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkSecurityGroupsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkSecurityGroupsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkSecurityGroupsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkSecurityGroupListResult.NextLink == nil || len(*p.current.NetworkSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkSecurityGroupsListAllResponse page.
func (p *NetworkSecurityGroupsListAllPager) PageResponse() NetworkSecurityGroupsListAllResponse {
	return p.current
}

// NetworkSecurityGroupsListPager provides operations for iterating over paged responses.
type NetworkSecurityGroupsListPager struct {
	client    *NetworkSecurityGroupsClient
	current   NetworkSecurityGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkSecurityGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkSecurityGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkSecurityGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkSecurityGroupListResult.NextLink == nil || len(*p.current.NetworkSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkSecurityGroupsListResponse page.
func (p *NetworkSecurityGroupsListPager) PageResponse() NetworkSecurityGroupsListResponse {
	return p.current
}

// NetworkVirtualAppliancesListByResourceGroupPager provides operations for iterating over paged responses.
type NetworkVirtualAppliancesListByResourceGroupPager struct {
	client    *NetworkVirtualAppliancesClient
	current   NetworkVirtualAppliancesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkVirtualAppliancesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkVirtualAppliancesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkVirtualAppliancesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkVirtualApplianceListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkVirtualAppliancesListByResourceGroupResponse page.
func (p *NetworkVirtualAppliancesListByResourceGroupPager) PageResponse() NetworkVirtualAppliancesListByResourceGroupResponse {
	return p.current
}

// NetworkVirtualAppliancesListPager provides operations for iterating over paged responses.
type NetworkVirtualAppliancesListPager struct {
	client    *NetworkVirtualAppliancesClient
	current   NetworkVirtualAppliancesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NetworkVirtualAppliancesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NetworkVirtualAppliancesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NetworkVirtualAppliancesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkVirtualApplianceListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NetworkVirtualAppliancesListResponse page.
func (p *NetworkVirtualAppliancesListPager) PageResponse() NetworkVirtualAppliancesListResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// P2SVPNGatewaysListByResourceGroupPager provides operations for iterating over paged responses.
type P2SVPNGatewaysListByResourceGroupPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *P2SVPNGatewaysListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *P2SVPNGatewaysListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current P2SVPNGatewaysListByResourceGroupResponse page.
func (p *P2SVPNGatewaysListByResourceGroupPager) PageResponse() P2SVPNGatewaysListByResourceGroupResponse {
	return p.current
}

// P2SVPNGatewaysListPager provides operations for iterating over paged responses.
type P2SVPNGatewaysListPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *P2SVPNGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *P2SVPNGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current P2SVPNGatewaysListResponse page.
func (p *P2SVPNGatewaysListPager) PageResponse() P2SVPNGatewaysListResponse {
	return p.current
}

// PeerExpressRouteCircuitConnectionsListPager provides operations for iterating over paged responses.
type PeerExpressRouteCircuitConnectionsListPager struct {
	client    *PeerExpressRouteCircuitConnectionsClient
	current   PeerExpressRouteCircuitConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PeerExpressRouteCircuitConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PeerExpressRouteCircuitConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PeerExpressRouteCircuitConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PeerExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.PeerExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PeerExpressRouteCircuitConnectionsListResponse page.
func (p *PeerExpressRouteCircuitConnectionsListPager) PageResponse() PeerExpressRouteCircuitConnectionsListResponse {
	return p.current
}

// PrivateDNSZoneGroupsListPager provides operations for iterating over paged responses.
type PrivateDNSZoneGroupsListPager struct {
	client    *PrivateDNSZoneGroupsClient
	current   PrivateDNSZoneGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateDNSZoneGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateDNSZoneGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateDNSZoneGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateDNSZoneGroupListResult.NextLink == nil || len(*p.current.PrivateDNSZoneGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateDNSZoneGroupsListResponse page.
func (p *PrivateDNSZoneGroupsListPager) PageResponse() PrivateDNSZoneGroupsListResponse {
	return p.current
}

// PrivateEndpointsListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateEndpointsListBySubscriptionPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointsListBySubscriptionResponse page.
func (p *PrivateEndpointsListBySubscriptionPager) PageResponse() PrivateEndpointsListBySubscriptionResponse {
	return p.current
}

// PrivateEndpointsListPager provides operations for iterating over paged responses.
type PrivateEndpointsListPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointsListResponse page.
func (p *PrivateEndpointsListPager) PageResponse() PrivateEndpointsListResponse {
	return p.current
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupPager provides operations for iterating over paged responses.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAutoApprovedPrivateLinkServicesByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse page.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupPager) PageResponse() PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse {
	return p.current
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesPager provides operations for iterating over paged responses.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAutoApprovedPrivateLinkServicesHandleError(resp)
		return false
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse page.
func (p *PrivateLinkServicesListAutoApprovedPrivateLinkServicesPager) PageResponse() PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse {
	return p.current
}

// PrivateLinkServicesListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateLinkServicesListBySubscriptionPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesListBySubscriptionResponse page.
func (p *PrivateLinkServicesListBySubscriptionPager) PageResponse() PrivateLinkServicesListBySubscriptionResponse {
	return p.current
}

// PrivateLinkServicesListPager provides operations for iterating over paged responses.
type PrivateLinkServicesListPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesListResponse page.
func (p *PrivateLinkServicesListPager) PageResponse() PrivateLinkServicesListResponse {
	return p.current
}

// PrivateLinkServicesListPrivateEndpointConnectionsPager provides operations for iterating over paged responses.
type PrivateLinkServicesListPrivateEndpointConnectionsPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesListPrivateEndpointConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesListPrivateEndpointConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesListPrivateEndpointConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesListPrivateEndpointConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listPrivateEndpointConnectionsHandleError(resp)
		return false
	}
	result, err := p.client.listPrivateEndpointConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesListPrivateEndpointConnectionsResponse page.
func (p *PrivateLinkServicesListPrivateEndpointConnectionsPager) PageResponse() PrivateLinkServicesListPrivateEndpointConnectionsResponse {
	return p.current
}

// PublicIPAddressesListAllPager provides operations for iterating over paged responses.
type PublicIPAddressesListAllPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListAllResponse page.
func (p *PublicIPAddressesListAllPager) PageResponse() PublicIPAddressesListAllResponse {
	return p.current
}

// PublicIPAddressesListCloudServicePublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesListCloudServicePublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListCloudServicePublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListCloudServicePublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListCloudServicePublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListCloudServicePublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCloudServicePublicIPAddressesHandleError(resp)
		return false
	}
	result, err := p.client.listCloudServicePublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListCloudServicePublicIPAddressesResponse page.
func (p *PublicIPAddressesListCloudServicePublicIPAddressesPager) PageResponse() PublicIPAddressesListCloudServicePublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCloudServiceRoleInstancePublicIPAddressesHandleError(resp)
		return false
	}
	result, err := p.client.listCloudServiceRoleInstancePublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse page.
func (p *PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesPager) PageResponse() PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesListPager provides operations for iterating over paged responses.
type PublicIPAddressesListPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListResponse page.
func (p *PublicIPAddressesListPager) PageResponse() PublicIPAddressesListResponse {
	return p.current
}

// PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVirtualMachineScaleSetPublicIPAddressesHandleError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetPublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse page.
func (p *PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesPager) PageResponse() PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listVirtualMachineScaleSetVMPublicIPAddressesHandleError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetVMPublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse page.
func (p *PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesPager) PageResponse() PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse {
	return p.current
}

// PublicIPPrefixesListAllPager provides operations for iterating over paged responses.
type PublicIPPrefixesListAllPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPPrefixesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPPrefixesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPPrefixesListAllResponse page.
func (p *PublicIPPrefixesListAllPager) PageResponse() PublicIPPrefixesListAllResponse {
	return p.current
}

// PublicIPPrefixesListPager provides operations for iterating over paged responses.
type PublicIPPrefixesListPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPPrefixesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPPrefixesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPPrefixesListResponse page.
func (p *PublicIPPrefixesListPager) PageResponse() PublicIPPrefixesListResponse {
	return p.current
}

// RouteFilterRulesListByRouteFilterPager provides operations for iterating over paged responses.
type RouteFilterRulesListByRouteFilterPager struct {
	client    *RouteFilterRulesClient
	current   RouteFilterRulesListByRouteFilterResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFilterRulesListByRouteFilterResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFilterRulesListByRouteFilterPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFilterRulesListByRouteFilterPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterRuleListResult.NextLink == nil || len(*p.current.RouteFilterRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRouteFilterHandleError(resp)
		return false
	}
	result, err := p.client.listByRouteFilterHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFilterRulesListByRouteFilterResponse page.
func (p *RouteFilterRulesListByRouteFilterPager) PageResponse() RouteFilterRulesListByRouteFilterResponse {
	return p.current
}

// RouteFiltersListByResourceGroupPager provides operations for iterating over paged responses.
type RouteFiltersListByResourceGroupPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFiltersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFiltersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFiltersListByResourceGroupResponse page.
func (p *RouteFiltersListByResourceGroupPager) PageResponse() RouteFiltersListByResourceGroupResponse {
	return p.current
}

// RouteFiltersListPager provides operations for iterating over paged responses.
type RouteFiltersListPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFiltersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFiltersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFiltersListResponse page.
func (p *RouteFiltersListPager) PageResponse() RouteFiltersListResponse {
	return p.current
}

// RouteTablesListAllPager provides operations for iterating over paged responses.
type RouteTablesListAllPager struct {
	client    *RouteTablesClient
	current   RouteTablesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteTablesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteTablesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteTablesListAllResponse page.
func (p *RouteTablesListAllPager) PageResponse() RouteTablesListAllResponse {
	return p.current
}

// RouteTablesListPager provides operations for iterating over paged responses.
type RouteTablesListPager struct {
	client    *RouteTablesClient
	current   RouteTablesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteTablesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteTablesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteTablesListResponse page.
func (p *RouteTablesListPager) PageResponse() RouteTablesListResponse {
	return p.current
}

// RoutesListPager provides operations for iterating over paged responses.
type RoutesListPager struct {
	client    *RoutesClient
	current   RoutesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoutesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoutesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoutesListResponse page.
func (p *RoutesListPager) PageResponse() RoutesListResponse {
	return p.current
}

// RoutingIntentListPager provides operations for iterating over paged responses.
type RoutingIntentListPager struct {
	client    *RoutingIntentClient
	current   RoutingIntentListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutingIntentListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoutingIntentListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoutingIntentListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListRoutingIntentResult.NextLink == nil || len(*p.current.ListRoutingIntentResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoutingIntentListResponse page.
func (p *RoutingIntentListPager) PageResponse() RoutingIntentListResponse {
	return p.current
}

// SecurityPartnerProvidersListByResourceGroupPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersListByResourceGroupPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityPartnerProvidersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityPartnerProvidersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityPartnerProvidersListByResourceGroupResponse page.
func (p *SecurityPartnerProvidersListByResourceGroupPager) PageResponse() SecurityPartnerProvidersListByResourceGroupResponse {
	return p.current
}

// SecurityPartnerProvidersListPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersListPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityPartnerProvidersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityPartnerProvidersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityPartnerProvidersListResponse page.
func (p *SecurityPartnerProvidersListPager) PageResponse() SecurityPartnerProvidersListResponse {
	return p.current
}

// SecurityRulesListPager provides operations for iterating over paged responses.
type SecurityRulesListPager struct {
	client    *SecurityRulesClient
	current   SecurityRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityRulesListResponse page.
func (p *SecurityRulesListPager) PageResponse() SecurityRulesListResponse {
	return p.current
}

// ServiceEndpointPoliciesListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesListByResourceGroupPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPoliciesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPoliciesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPoliciesListByResourceGroupResponse page.
func (p *ServiceEndpointPoliciesListByResourceGroupPager) PageResponse() ServiceEndpointPoliciesListByResourceGroupResponse {
	return p.current
}

// ServiceEndpointPoliciesListPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesListPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPoliciesListResponse page.
func (p *ServiceEndpointPoliciesListPager) PageResponse() ServiceEndpointPoliciesListResponse {
	return p.current
}

// ServiceEndpointPolicyDefinitionsListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPolicyDefinitionsListByResourceGroupPager struct {
	client    *ServiceEndpointPolicyDefinitionsClient
	current   ServiceEndpointPolicyDefinitionsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPolicyDefinitionsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPolicyDefinitionsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPolicyDefinitionsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyDefinitionListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPolicyDefinitionsListByResourceGroupResponse page.
func (p *ServiceEndpointPolicyDefinitionsListByResourceGroupPager) PageResponse() ServiceEndpointPolicyDefinitionsListByResourceGroupResponse {
	return p.current
}

// ServiceTagInformationListPager provides operations for iterating over paged responses.
type ServiceTagInformationListPager struct {
	client    *ServiceTagInformationClient
	current   ServiceTagInformationListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceTagInformationListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceTagInformationListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceTagInformationListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceTagInformationListResult.NextLink == nil || len(*p.current.ServiceTagInformationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceTagInformationListResponse page.
func (p *ServiceTagInformationListPager) PageResponse() ServiceTagInformationListResponse {
	return p.current
}

// SubnetsListPager provides operations for iterating over paged responses.
type SubnetsListPager struct {
	client    *SubnetsClient
	current   SubnetsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubnetsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubnetsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubnetsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubnetListResult.NextLink == nil || len(*p.current.SubnetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubnetsListResponse page.
func (p *SubnetsListPager) PageResponse() SubnetsListResponse {
	return p.current
}

// UsagesListPager provides operations for iterating over paged responses.
type UsagesListPager struct {
	client    *UsagesClient
	current   UsagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsagesListResponse page.
func (p *UsagesListPager) PageResponse() UsagesListResponse {
	return p.current
}

// VPNConnectionsListByVPNGatewayPager provides operations for iterating over paged responses.
type VPNConnectionsListByVPNGatewayPager struct {
	client    *VPNConnectionsClient
	current   VPNConnectionsListByVPNGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNConnectionsListByVPNGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNConnectionsListByVPNGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNConnectionsListByVPNGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNConnectionsResult.NextLink == nil || len(*p.current.ListVPNConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVPNGatewayHandleError(resp)
		return false
	}
	result, err := p.client.listByVPNGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNConnectionsListByVPNGatewayResponse page.
func (p *VPNConnectionsListByVPNGatewayPager) PageResponse() VPNConnectionsListByVPNGatewayResponse {
	return p.current
}

// VPNGatewaysListByResourceGroupPager provides operations for iterating over paged responses.
type VPNGatewaysListByResourceGroupPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNGatewaysListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNGatewaysListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNGatewaysListByResourceGroupResponse page.
func (p *VPNGatewaysListByResourceGroupPager) PageResponse() VPNGatewaysListByResourceGroupResponse {
	return p.current
}

// VPNGatewaysListPager provides operations for iterating over paged responses.
type VPNGatewaysListPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNGatewaysListResponse page.
func (p *VPNGatewaysListPager) PageResponse() VPNGatewaysListResponse {
	return p.current
}

// VPNLinkConnectionsListByVPNConnectionPager provides operations for iterating over paged responses.
type VPNLinkConnectionsListByVPNConnectionPager struct {
	client    *VPNLinkConnectionsClient
	current   VPNLinkConnectionsListByVPNConnectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNLinkConnectionsListByVPNConnectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNLinkConnectionsListByVPNConnectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNLinkConnectionsListByVPNConnectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinkConnectionsResult.NextLink == nil || len(*p.current.ListVPNSiteLinkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVPNConnectionHandleError(resp)
		return false
	}
	result, err := p.client.listByVPNConnectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNLinkConnectionsListByVPNConnectionResponse page.
func (p *VPNLinkConnectionsListByVPNConnectionPager) PageResponse() VPNLinkConnectionsListByVPNConnectionResponse {
	return p.current
}

// VPNServerConfigurationsListByResourceGroupPager provides operations for iterating over paged responses.
type VPNServerConfigurationsListByResourceGroupPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNServerConfigurationsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNServerConfigurationsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNServerConfigurationsListByResourceGroupResponse page.
func (p *VPNServerConfigurationsListByResourceGroupPager) PageResponse() VPNServerConfigurationsListByResourceGroupResponse {
	return p.current
}

// VPNServerConfigurationsListPager provides operations for iterating over paged responses.
type VPNServerConfigurationsListPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNServerConfigurationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNServerConfigurationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNServerConfigurationsListResponse page.
func (p *VPNServerConfigurationsListPager) PageResponse() VPNServerConfigurationsListResponse {
	return p.current
}

// VPNSiteLinksListByVPNSitePager provides operations for iterating over paged responses.
type VPNSiteLinksListByVPNSitePager struct {
	client    *VPNSiteLinksClient
	current   VPNSiteLinksListByVPNSiteResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSiteLinksListByVPNSiteResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSiteLinksListByVPNSitePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSiteLinksListByVPNSitePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinksResult.NextLink == nil || len(*p.current.ListVPNSiteLinksResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVPNSiteHandleError(resp)
		return false
	}
	result, err := p.client.listByVPNSiteHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSiteLinksListByVPNSiteResponse page.
func (p *VPNSiteLinksListByVPNSitePager) PageResponse() VPNSiteLinksListByVPNSiteResponse {
	return p.current
}

// VPNSitesListByResourceGroupPager provides operations for iterating over paged responses.
type VPNSitesListByResourceGroupPager struct {
	client    *VPNSitesClient
	current   VPNSitesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSitesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSitesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSitesListByResourceGroupResponse page.
func (p *VPNSitesListByResourceGroupPager) PageResponse() VPNSitesListByResourceGroupResponse {
	return p.current
}

// VPNSitesListPager provides operations for iterating over paged responses.
type VPNSitesListPager struct {
	client    *VPNSitesClient
	current   VPNSitesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSitesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSitesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSitesListResponse page.
func (p *VPNSitesListPager) PageResponse() VPNSitesListResponse {
	return p.current
}

// VirtualApplianceSKUsListPager provides operations for iterating over paged responses.
type VirtualApplianceSKUsListPager struct {
	client    *VirtualApplianceSKUsClient
	current   VirtualApplianceSKUsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualApplianceSKUsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualApplianceSKUsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualApplianceSKUsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkVirtualApplianceSKUListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceSKUListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualApplianceSKUsListResponse page.
func (p *VirtualApplianceSKUsListPager) PageResponse() VirtualApplianceSKUsListResponse {
	return p.current
}

// VirtualApplianceSitesListPager provides operations for iterating over paged responses.
type VirtualApplianceSitesListPager struct {
	client    *VirtualApplianceSitesClient
	current   VirtualApplianceSitesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualApplianceSitesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualApplianceSitesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualApplianceSitesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NetworkVirtualApplianceSiteListResult.NextLink == nil || len(*p.current.NetworkVirtualApplianceSiteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualApplianceSitesListResponse page.
func (p *VirtualApplianceSitesListPager) PageResponse() VirtualApplianceSitesListResponse {
	return p.current
}

// VirtualHubBgpConnectionsListPager provides operations for iterating over paged responses.
type VirtualHubBgpConnectionsListPager struct {
	client    *VirtualHubBgpConnectionsClient
	current   VirtualHubBgpConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubBgpConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubBgpConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubBgpConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubBgpConnectionResults.NextLink == nil || len(*p.current.ListVirtualHubBgpConnectionResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubBgpConnectionsListResponse page.
func (p *VirtualHubBgpConnectionsListPager) PageResponse() VirtualHubBgpConnectionsListResponse {
	return p.current
}

// VirtualHubIPConfigurationListPager provides operations for iterating over paged responses.
type VirtualHubIPConfigurationListPager struct {
	client    *VirtualHubIPConfigurationClient
	current   VirtualHubIPConfigurationListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubIPConfigurationListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubIPConfigurationListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubIPConfigurationListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubIPConfigurationResults.NextLink == nil || len(*p.current.ListVirtualHubIPConfigurationResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubIPConfigurationListResponse page.
func (p *VirtualHubIPConfigurationListPager) PageResponse() VirtualHubIPConfigurationListResponse {
	return p.current
}

// VirtualHubRouteTableV2SListPager provides operations for iterating over paged responses.
type VirtualHubRouteTableV2SListPager struct {
	client    *VirtualHubRouteTableV2SClient
	current   VirtualHubRouteTableV2SListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubRouteTableV2SListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubRouteTableV2SListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubRouteTableV2SListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubRouteTableV2SResult.NextLink == nil || len(*p.current.ListVirtualHubRouteTableV2SResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubRouteTableV2SListResponse page.
func (p *VirtualHubRouteTableV2SListPager) PageResponse() VirtualHubRouteTableV2SListResponse {
	return p.current
}

// VirtualHubsListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualHubsListByResourceGroupPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubsListByResourceGroupResponse page.
func (p *VirtualHubsListByResourceGroupPager) PageResponse() VirtualHubsListByResourceGroupResponse {
	return p.current
}

// VirtualHubsListPager provides operations for iterating over paged responses.
type VirtualHubsListPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubsListResponse page.
func (p *VirtualHubsListPager) PageResponse() VirtualHubsListResponse {
	return p.current
}

// VirtualNetworkGatewayConnectionsListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewayConnectionsListPager struct {
	client    *VirtualNetworkGatewayConnectionsClient
	current   VirtualNetworkGatewayConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewayConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewayConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewayConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayConnectionListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewayConnectionsListResponse page.
func (p *VirtualNetworkGatewayConnectionsListPager) PageResponse() VirtualNetworkGatewayConnectionsListResponse {
	return p.current
}

// VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayPager provides operations for iterating over paged responses.
type VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayPager struct {
	client    *VirtualNetworkGatewayNatRulesClient
	current   VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualNetworkGatewayNatRulesResult.NextLink == nil || len(*p.current.ListVirtualNetworkGatewayNatRulesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVirtualNetworkGatewayHandleError(resp)
		return false
	}
	result, err := p.client.listByVirtualNetworkGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse page.
func (p *VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayPager) PageResponse() VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse {
	return p.current
}

// VirtualNetworkGatewaysListConnectionsPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysListConnectionsPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysListConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysListConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewaysListConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewaysListConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListConnectionsResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listConnectionsHandleError(resp)
		return false
	}
	result, err := p.client.listConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewaysListConnectionsResponse page.
func (p *VirtualNetworkGatewaysListConnectionsPager) PageResponse() VirtualNetworkGatewaysListConnectionsResponse {
	return p.current
}

// VirtualNetworkGatewaysListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysListPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewaysListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewaysListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewaysListResponse page.
func (p *VirtualNetworkGatewaysListPager) PageResponse() VirtualNetworkGatewaysListResponse {
	return p.current
}

// VirtualNetworkPeeringsListPager provides operations for iterating over paged responses.
type VirtualNetworkPeeringsListPager struct {
	client    *VirtualNetworkPeeringsClient
	current   VirtualNetworkPeeringsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkPeeringsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkPeeringsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkPeeringsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkPeeringListResult.NextLink == nil || len(*p.current.VirtualNetworkPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkPeeringsListResponse page.
func (p *VirtualNetworkPeeringsListPager) PageResponse() VirtualNetworkPeeringsListResponse {
	return p.current
}

// VirtualNetworkTapsListAllPager provides operations for iterating over paged responses.
type VirtualNetworkTapsListAllPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkTapsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkTapsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkTapsListAllResponse page.
func (p *VirtualNetworkTapsListAllPager) PageResponse() VirtualNetworkTapsListAllResponse {
	return p.current
}

// VirtualNetworkTapsListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualNetworkTapsListByResourceGroupPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkTapsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkTapsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkTapsListByResourceGroupResponse page.
func (p *VirtualNetworkTapsListByResourceGroupPager) PageResponse() VirtualNetworkTapsListByResourceGroupResponse {
	return p.current
}

// VirtualNetworksListAllPager provides operations for iterating over paged responses.
type VirtualNetworksListAllPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksListAllResponse page.
func (p *VirtualNetworksListAllPager) PageResponse() VirtualNetworksListAllResponse {
	return p.current
}

// VirtualNetworksListPager provides operations for iterating over paged responses.
type VirtualNetworksListPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksListResponse page.
func (p *VirtualNetworksListPager) PageResponse() VirtualNetworksListResponse {
	return p.current
}

// VirtualNetworksListUsagePager provides operations for iterating over paged responses.
type VirtualNetworksListUsagePager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksListUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksListUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksListUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksListUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListUsageResult.NextLink == nil || len(*p.current.VirtualNetworkListUsageResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listUsageHandleError(resp)
		return false
	}
	result, err := p.client.listUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksListUsageResponse page.
func (p *VirtualNetworksListUsagePager) PageResponse() VirtualNetworksListUsageResponse {
	return p.current
}

// VirtualRouterPeeringsListPager provides operations for iterating over paged responses.
type VirtualRouterPeeringsListPager struct {
	client    *VirtualRouterPeeringsClient
	current   VirtualRouterPeeringsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRouterPeeringsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRouterPeeringsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRouterPeeringsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterPeeringListResult.NextLink == nil || len(*p.current.VirtualRouterPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRouterPeeringsListResponse page.
func (p *VirtualRouterPeeringsListPager) PageResponse() VirtualRouterPeeringsListResponse {
	return p.current
}

// VirtualRoutersListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualRoutersListByResourceGroupPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRoutersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRoutersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRoutersListByResourceGroupResponse page.
func (p *VirtualRoutersListByResourceGroupPager) PageResponse() VirtualRoutersListByResourceGroupResponse {
	return p.current
}

// VirtualRoutersListPager provides operations for iterating over paged responses.
type VirtualRoutersListPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRoutersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRoutersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRoutersListResponse page.
func (p *VirtualRoutersListPager) PageResponse() VirtualRoutersListResponse {
	return p.current
}

// VirtualWansListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualWansListByResourceGroupPager struct {
	client    *VirtualWansClient
	current   VirtualWansListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualWansListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualWansListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualWansListByResourceGroupResponse page.
func (p *VirtualWansListByResourceGroupPager) PageResponse() VirtualWansListByResourceGroupResponse {
	return p.current
}

// VirtualWansListPager provides operations for iterating over paged responses.
type VirtualWansListPager struct {
	client    *VirtualWansClient
	current   VirtualWansListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualWansListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualWansListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualWansListResponse page.
func (p *VirtualWansListPager) PageResponse() VirtualWansListResponse {
	return p.current
}

// WebApplicationFirewallPoliciesListAllPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesListAllPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebApplicationFirewallPoliciesListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebApplicationFirewallPoliciesListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebApplicationFirewallPoliciesListAllResponse page.
func (p *WebApplicationFirewallPoliciesListAllPager) PageResponse() WebApplicationFirewallPoliciesListAllResponse {
	return p.current
}

// WebApplicationFirewallPoliciesListPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesListPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebApplicationFirewallPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebApplicationFirewallPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebApplicationFirewallPoliciesListResponse page.
func (p *WebApplicationFirewallPoliciesListPager) PageResponse() WebApplicationFirewallPoliciesListResponse {
	return p.current
}

// WebCategoriesListBySubscriptionPager provides operations for iterating over paged responses.
type WebCategoriesListBySubscriptionPager struct {
	client    *WebCategoriesClient
	current   WebCategoriesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebCategoriesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebCategoriesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebCategoriesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureWebCategoryListResult.NextLink == nil || len(*p.current.AzureWebCategoryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebCategoriesListBySubscriptionResponse page.
func (p *WebCategoriesListBySubscriptionPager) PageResponse() WebCategoriesListBySubscriptionResponse {
	return p.current
}
