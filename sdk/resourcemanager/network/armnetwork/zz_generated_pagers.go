//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ApplicationGatewayPrivateEndpointConnectionsClientListPager provides operations for iterating over paged responses.
type ApplicationGatewayPrivateEndpointConnectionsClientListPager struct {
	client    *ApplicationGatewayPrivateEndpointConnectionsClient
	current   ApplicationGatewayPrivateEndpointConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewayPrivateEndpointConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewayPrivateEndpointConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewayPrivateEndpointConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayPrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.ApplicationGatewayPrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewayPrivateEndpointConnectionsClientListResponse page.
func (p *ApplicationGatewayPrivateEndpointConnectionsClientListPager) PageResponse() ApplicationGatewayPrivateEndpointConnectionsClientListResponse {
	return p.current
}

// ApplicationGatewayPrivateLinkResourcesClientListPager provides operations for iterating over paged responses.
type ApplicationGatewayPrivateLinkResourcesClientListPager struct {
	client    *ApplicationGatewayPrivateLinkResourcesClient
	current   ApplicationGatewayPrivateLinkResourcesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewayPrivateLinkResourcesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewayPrivateLinkResourcesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewayPrivateLinkResourcesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayPrivateLinkResourceListResult.NextLink == nil || len(*p.current.ApplicationGatewayPrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewayPrivateLinkResourcesClientListResponse page.
func (p *ApplicationGatewayPrivateLinkResourcesClientListPager) PageResponse() ApplicationGatewayPrivateLinkResourcesClientListResponse {
	return p.current
}

// ApplicationGatewaysClientListAllPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListAllPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysClientListAllResponse page.
func (p *ApplicationGatewaysClientListAllPager) PageResponse() ApplicationGatewaysClientListAllResponse {
	return p.current
}

// ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink == nil || len(*p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAvailableSSLPredefinedPoliciesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse page.
func (p *ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager) PageResponse() ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse {
	return p.current
}

// ApplicationGatewaysClientListPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationGatewaysClientListResponse page.
func (p *ApplicationGatewaysClientListPager) PageResponse() ApplicationGatewaysClientListResponse {
	return p.current
}

// ApplicationSecurityGroupsClientListAllPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsClientListAllPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationSecurityGroupsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationSecurityGroupsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationSecurityGroupsClientListAllResponse page.
func (p *ApplicationSecurityGroupsClientListAllPager) PageResponse() ApplicationSecurityGroupsClientListAllResponse {
	return p.current
}

// ApplicationSecurityGroupsClientListPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsClientListPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ApplicationSecurityGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ApplicationSecurityGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ApplicationSecurityGroupsClientListResponse page.
func (p *ApplicationSecurityGroupsClientListPager) PageResponse() ApplicationSecurityGroupsClientListResponse {
	return p.current
}

// AvailableDelegationsClientListPager provides operations for iterating over paged responses.
type AvailableDelegationsClientListPager struct {
	client    *AvailableDelegationsClient
	current   AvailableDelegationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableDelegationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableDelegationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableDelegationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableDelegationsClientListResponse page.
func (p *AvailableDelegationsClientListPager) PageResponse() AvailableDelegationsClientListResponse {
	return p.current
}

// AvailableEndpointServicesClientListPager provides operations for iterating over paged responses.
type AvailableEndpointServicesClientListPager struct {
	client    *AvailableEndpointServicesClient
	current   AvailableEndpointServicesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableEndpointServicesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableEndpointServicesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableEndpointServicesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EndpointServicesListResult.NextLink == nil || len(*p.current.EndpointServicesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableEndpointServicesClientListResponse page.
func (p *AvailableEndpointServicesClientListPager) PageResponse() AvailableEndpointServicesClientListResponse {
	return p.current
}

// AvailablePrivateEndpointTypesClientListByResourceGroupPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesClientListByResourceGroupPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailablePrivateEndpointTypesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailablePrivateEndpointTypesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailablePrivateEndpointTypesClientListByResourceGroupResponse page.
func (p *AvailablePrivateEndpointTypesClientListByResourceGroupPager) PageResponse() AvailablePrivateEndpointTypesClientListByResourceGroupResponse {
	return p.current
}

// AvailablePrivateEndpointTypesClientListPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesClientListPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailablePrivateEndpointTypesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailablePrivateEndpointTypesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailablePrivateEndpointTypesClientListResponse page.
func (p *AvailablePrivateEndpointTypesClientListPager) PageResponse() AvailablePrivateEndpointTypesClientListResponse {
	return p.current
}

// AvailableResourceGroupDelegationsClientListPager provides operations for iterating over paged responses.
type AvailableResourceGroupDelegationsClientListPager struct {
	client    *AvailableResourceGroupDelegationsClient
	current   AvailableResourceGroupDelegationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableResourceGroupDelegationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableResourceGroupDelegationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableResourceGroupDelegationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableResourceGroupDelegationsClientListResponse page.
func (p *AvailableResourceGroupDelegationsClientListPager) PageResponse() AvailableResourceGroupDelegationsClientListResponse {
	return p.current
}

// AvailableServiceAliasesClientListByResourceGroupPager provides operations for iterating over paged responses.
type AvailableServiceAliasesClientListByResourceGroupPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableServiceAliasesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableServiceAliasesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableServiceAliasesClientListByResourceGroupResponse page.
func (p *AvailableServiceAliasesClientListByResourceGroupPager) PageResponse() AvailableServiceAliasesClientListByResourceGroupResponse {
	return p.current
}

// AvailableServiceAliasesClientListPager provides operations for iterating over paged responses.
type AvailableServiceAliasesClientListPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailableServiceAliasesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailableServiceAliasesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailableServiceAliasesClientListResponse page.
func (p *AvailableServiceAliasesClientListPager) PageResponse() AvailableServiceAliasesClientListResponse {
	return p.current
}

// AzureFirewallFqdnTagsClientListAllPager provides operations for iterating over paged responses.
type AzureFirewallFqdnTagsClientListAllPager struct {
	client    *AzureFirewallFqdnTagsClient
	current   AzureFirewallFqdnTagsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallFqdnTagsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallFqdnTagsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallFqdnTagsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallFqdnTagListResult.NextLink == nil || len(*p.current.AzureFirewallFqdnTagListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallFqdnTagsClientListAllResponse page.
func (p *AzureFirewallFqdnTagsClientListAllPager) PageResponse() AzureFirewallFqdnTagsClientListAllResponse {
	return p.current
}

// AzureFirewallsClientListAllPager provides operations for iterating over paged responses.
type AzureFirewallsClientListAllPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallsClientListAllResponse page.
func (p *AzureFirewallsClientListAllPager) PageResponse() AzureFirewallsClientListAllResponse {
	return p.current
}

// AzureFirewallsClientListPager provides operations for iterating over paged responses.
type AzureFirewallsClientListPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureFirewallsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureFirewallsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureFirewallsClientListResponse page.
func (p *AzureFirewallsClientListPager) PageResponse() AzureFirewallsClientListResponse {
	return p.current
}

// BastionHostsClientListByResourceGroupPager provides operations for iterating over paged responses.
type BastionHostsClientListByResourceGroupPager struct {
	client    *BastionHostsClient
	current   BastionHostsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BastionHostsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BastionHostsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BastionHostsClientListByResourceGroupResponse page.
func (p *BastionHostsClientListByResourceGroupPager) PageResponse() BastionHostsClientListByResourceGroupResponse {
	return p.current
}

// BastionHostsClientListPager provides operations for iterating over paged responses.
type BastionHostsClientListPager struct {
	client    *BastionHostsClient
	current   BastionHostsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BastionHostsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BastionHostsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BastionHostsClientListResponse page.
func (p *BastionHostsClientListPager) PageResponse() BastionHostsClientListResponse {
	return p.current
}

// BgpServiceCommunitiesClientListPager provides operations for iterating over paged responses.
type BgpServiceCommunitiesClientListPager struct {
	client    *BgpServiceCommunitiesClient
	current   BgpServiceCommunitiesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BgpServiceCommunitiesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BgpServiceCommunitiesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BgpServiceCommunitiesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BgpServiceCommunityListResult.NextLink == nil || len(*p.current.BgpServiceCommunityListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BgpServiceCommunitiesClientListResponse page.
func (p *BgpServiceCommunitiesClientListPager) PageResponse() BgpServiceCommunitiesClientListResponse {
	return p.current
}

// CustomIPPrefixesClientListAllPager provides operations for iterating over paged responses.
type CustomIPPrefixesClientListAllPager struct {
	client    *CustomIPPrefixesClient
	current   CustomIPPrefixesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomIPPrefixesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomIPPrefixesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomIPPrefixesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomIPPrefixListResult.NextLink == nil || len(*p.current.CustomIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomIPPrefixesClientListAllResponse page.
func (p *CustomIPPrefixesClientListAllPager) PageResponse() CustomIPPrefixesClientListAllResponse {
	return p.current
}

// CustomIPPrefixesClientListPager provides operations for iterating over paged responses.
type CustomIPPrefixesClientListPager struct {
	client    *CustomIPPrefixesClient
	current   CustomIPPrefixesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomIPPrefixesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomIPPrefixesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomIPPrefixesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomIPPrefixListResult.NextLink == nil || len(*p.current.CustomIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomIPPrefixesClientListResponse page.
func (p *CustomIPPrefixesClientListPager) PageResponse() CustomIPPrefixesClientListResponse {
	return p.current
}

// DdosProtectionPlansClientListByResourceGroupPager provides operations for iterating over paged responses.
type DdosProtectionPlansClientListByResourceGroupPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DdosProtectionPlansClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DdosProtectionPlansClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DdosProtectionPlansClientListByResourceGroupResponse page.
func (p *DdosProtectionPlansClientListByResourceGroupPager) PageResponse() DdosProtectionPlansClientListByResourceGroupResponse {
	return p.current
}

// DdosProtectionPlansClientListPager provides operations for iterating over paged responses.
type DdosProtectionPlansClientListPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DdosProtectionPlansClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DdosProtectionPlansClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DdosProtectionPlansClientListResponse page.
func (p *DdosProtectionPlansClientListPager) PageResponse() DdosProtectionPlansClientListResponse {
	return p.current
}

// DefaultSecurityRulesClientListPager provides operations for iterating over paged responses.
type DefaultSecurityRulesClientListPager struct {
	client    *DefaultSecurityRulesClient
	current   DefaultSecurityRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefaultSecurityRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DefaultSecurityRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DefaultSecurityRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DefaultSecurityRulesClientListResponse page.
func (p *DefaultSecurityRulesClientListPager) PageResponse() DefaultSecurityRulesClientListResponse {
	return p.current
}

// DscpConfigurationClientListAllPager provides operations for iterating over paged responses.
type DscpConfigurationClientListAllPager struct {
	client    *DscpConfigurationClient
	current   DscpConfigurationClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscpConfigurationClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscpConfigurationClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscpConfigurationClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscpConfigurationListResult.NextLink == nil || len(*p.current.DscpConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscpConfigurationClientListAllResponse page.
func (p *DscpConfigurationClientListAllPager) PageResponse() DscpConfigurationClientListAllResponse {
	return p.current
}

// DscpConfigurationClientListPager provides operations for iterating over paged responses.
type DscpConfigurationClientListPager struct {
	client    *DscpConfigurationClient
	current   DscpConfigurationClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DscpConfigurationClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DscpConfigurationClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DscpConfigurationClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DscpConfigurationListResult.NextLink == nil || len(*p.current.DscpConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DscpConfigurationClientListResponse page.
func (p *DscpConfigurationClientListPager) PageResponse() DscpConfigurationClientListResponse {
	return p.current
}

// ExpressRouteCircuitAuthorizationsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitAuthorizationsClientListPager struct {
	client    *ExpressRouteCircuitAuthorizationsClient
	current   ExpressRouteCircuitAuthorizationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitAuthorizationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitAuthorizationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitAuthorizationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationListResult.NextLink == nil || len(*p.current.AuthorizationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitAuthorizationsClientListResponse page.
func (p *ExpressRouteCircuitAuthorizationsClientListPager) PageResponse() ExpressRouteCircuitAuthorizationsClientListResponse {
	return p.current
}

// ExpressRouteCircuitConnectionsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitConnectionsClientListPager struct {
	client    *ExpressRouteCircuitConnectionsClient
	current   ExpressRouteCircuitConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitConnectionsClientListResponse page.
func (p *ExpressRouteCircuitConnectionsClientListPager) PageResponse() ExpressRouteCircuitConnectionsClientListResponse {
	return p.current
}

// ExpressRouteCircuitPeeringsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitPeeringsClientListPager struct {
	client    *ExpressRouteCircuitPeeringsClient
	current   ExpressRouteCircuitPeeringsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitPeeringsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitPeeringsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitPeeringsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitPeeringListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitPeeringsClientListResponse page.
func (p *ExpressRouteCircuitPeeringsClientListPager) PageResponse() ExpressRouteCircuitPeeringsClientListResponse {
	return p.current
}

// ExpressRouteCircuitsClientListAllPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsClientListAllPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitsClientListAllResponse page.
func (p *ExpressRouteCircuitsClientListAllPager) PageResponse() ExpressRouteCircuitsClientListAllResponse {
	return p.current
}

// ExpressRouteCircuitsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsClientListPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCircuitsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCircuitsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCircuitsClientListResponse page.
func (p *ExpressRouteCircuitsClientListPager) PageResponse() ExpressRouteCircuitsClientListResponse {
	return p.current
}

// ExpressRouteCrossConnectionPeeringsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionPeeringsClientListPager struct {
	client    *ExpressRouteCrossConnectionPeeringsClient
	current   ExpressRouteCrossConnectionPeeringsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionPeeringsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionPeeringsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionPeeringsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionPeeringList.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionPeeringList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionPeeringsClientListResponse page.
func (p *ExpressRouteCrossConnectionPeeringsClientListPager) PageResponse() ExpressRouteCrossConnectionPeeringsClientListResponse {
	return p.current
}

// ExpressRouteCrossConnectionsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsClientListByResourceGroupPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionsClientListByResourceGroupResponse page.
func (p *ExpressRouteCrossConnectionsClientListByResourceGroupPager) PageResponse() ExpressRouteCrossConnectionsClientListByResourceGroupResponse {
	return p.current
}

// ExpressRouteCrossConnectionsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsClientListPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteCrossConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteCrossConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteCrossConnectionsClientListResponse page.
func (p *ExpressRouteCrossConnectionsClientListPager) PageResponse() ExpressRouteCrossConnectionsClientListResponse {
	return p.current
}

// ExpressRouteLinksClientListPager provides operations for iterating over paged responses.
type ExpressRouteLinksClientListPager struct {
	client    *ExpressRouteLinksClient
	current   ExpressRouteLinksClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteLinksClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteLinksClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteLinksClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteLinkListResult.NextLink == nil || len(*p.current.ExpressRouteLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteLinksClientListResponse page.
func (p *ExpressRouteLinksClientListPager) PageResponse() ExpressRouteLinksClientListResponse {
	return p.current
}

// ExpressRoutePortsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRoutePortsClientListByResourceGroupPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsClientListByResourceGroupResponse page.
func (p *ExpressRoutePortsClientListByResourceGroupPager) PageResponse() ExpressRoutePortsClientListByResourceGroupResponse {
	return p.current
}

// ExpressRoutePortsClientListPager provides operations for iterating over paged responses.
type ExpressRoutePortsClientListPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsClientListResponse page.
func (p *ExpressRoutePortsClientListPager) PageResponse() ExpressRoutePortsClientListResponse {
	return p.current
}

// ExpressRoutePortsLocationsClientListPager provides operations for iterating over paged responses.
type ExpressRoutePortsLocationsClientListPager struct {
	client    *ExpressRoutePortsLocationsClient
	current   ExpressRoutePortsLocationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsLocationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRoutePortsLocationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRoutePortsLocationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortsLocationListResult.NextLink == nil || len(*p.current.ExpressRoutePortsLocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRoutePortsLocationsClientListResponse page.
func (p *ExpressRoutePortsLocationsClientListPager) PageResponse() ExpressRoutePortsLocationsClientListResponse {
	return p.current
}

// ExpressRouteServiceProvidersClientListPager provides operations for iterating over paged responses.
type ExpressRouteServiceProvidersClientListPager struct {
	client    *ExpressRouteServiceProvidersClient
	current   ExpressRouteServiceProvidersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteServiceProvidersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExpressRouteServiceProvidersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExpressRouteServiceProvidersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteServiceProviderListResult.NextLink == nil || len(*p.current.ExpressRouteServiceProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExpressRouteServiceProvidersClientListResponse page.
func (p *ExpressRouteServiceProvidersClientListPager) PageResponse() ExpressRouteServiceProvidersClientListResponse {
	return p.current
}

// FirewallPoliciesClientListAllPager provides operations for iterating over paged responses.
type FirewallPoliciesClientListAllPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPoliciesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPoliciesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPoliciesClientListAllResponse page.
func (p *FirewallPoliciesClientListAllPager) PageResponse() FirewallPoliciesClientListAllResponse {
	return p.current
}

// FirewallPoliciesClientListPager provides operations for iterating over paged responses.
type FirewallPoliciesClientListPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPoliciesClientListResponse page.
func (p *FirewallPoliciesClientListPager) PageResponse() FirewallPoliciesClientListResponse {
	return p.current
}

// FirewallPolicyRuleCollectionGroupsClientListPager provides operations for iterating over paged responses.
type FirewallPolicyRuleCollectionGroupsClientListPager struct {
	client    *FirewallPolicyRuleCollectionGroupsClient
	current   FirewallPolicyRuleCollectionGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPolicyRuleCollectionGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallPolicyRuleCollectionGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallPolicyRuleCollectionGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyRuleCollectionGroupListResult.NextLink == nil || len(*p.current.FirewallPolicyRuleCollectionGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallPolicyRuleCollectionGroupsClientListResponse page.
func (p *FirewallPolicyRuleCollectionGroupsClientListPager) PageResponse() FirewallPolicyRuleCollectionGroupsClientListResponse {
	return p.current
}

// FlowLogsClientListPager provides operations for iterating over paged responses.
type FlowLogsClientListPager struct {
	client    *FlowLogsClient
	current   FlowLogsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FlowLogsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FlowLogsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FlowLogsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FlowLogListResult.NextLink == nil || len(*p.current.FlowLogListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FlowLogsClientListResponse page.
func (p *FlowLogsClientListPager) PageResponse() FlowLogsClientListResponse {
	return p.current
}

// HubRouteTablesClientListPager provides operations for iterating over paged responses.
type HubRouteTablesClientListPager struct {
	client    *HubRouteTablesClient
	current   HubRouteTablesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubRouteTablesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HubRouteTablesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HubRouteTablesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListHubRouteTablesResult.NextLink == nil || len(*p.current.ListHubRouteTablesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HubRouteTablesClientListResponse page.
func (p *HubRouteTablesClientListPager) PageResponse() HubRouteTablesClientListResponse {
	return p.current
}

// HubVirtualNetworkConnectionsClientListPager provides operations for iterating over paged responses.
type HubVirtualNetworkConnectionsClientListPager struct {
	client    *HubVirtualNetworkConnectionsClient
	current   HubVirtualNetworkConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubVirtualNetworkConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *HubVirtualNetworkConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *HubVirtualNetworkConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListHubVirtualNetworkConnectionsResult.NextLink == nil || len(*p.current.ListHubVirtualNetworkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current HubVirtualNetworkConnectionsClientListResponse page.
func (p *HubVirtualNetworkConnectionsClientListPager) PageResponse() HubVirtualNetworkConnectionsClientListResponse {
	return p.current
}

// IPAllocationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IPAllocationsClientListByResourceGroupPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPAllocationsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPAllocationsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPAllocationsClientListByResourceGroupResponse page.
func (p *IPAllocationsClientListByResourceGroupPager) PageResponse() IPAllocationsClientListByResourceGroupResponse {
	return p.current
}

// IPAllocationsClientListPager provides operations for iterating over paged responses.
type IPAllocationsClientListPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPAllocationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPAllocationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPAllocationsClientListResponse page.
func (p *IPAllocationsClientListPager) PageResponse() IPAllocationsClientListResponse {
	return p.current
}

// IPGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IPGroupsClientListByResourceGroupPager struct {
	client    *IPGroupsClient
	current   IPGroupsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPGroupsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPGroupsClientListByResourceGroupResponse page.
func (p *IPGroupsClientListByResourceGroupPager) PageResponse() IPGroupsClientListByResourceGroupResponse {
	return p.current
}

// IPGroupsClientListPager provides operations for iterating over paged responses.
type IPGroupsClientListPager struct {
	client    *IPGroupsClient
	current   IPGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPGroupsClientListResponse page.
func (p *IPGroupsClientListPager) PageResponse() IPGroupsClientListResponse {
	return p.current
}

// InboundNatRulesClientListPager provides operations for iterating over paged responses.
type InboundNatRulesClientListPager struct {
	client    *InboundNatRulesClient
	current   InboundNatRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InboundNatRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InboundNatRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InboundNatRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InboundNatRuleListResult.NextLink == nil || len(*p.current.InboundNatRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InboundNatRulesClientListResponse page.
func (p *InboundNatRulesClientListPager) PageResponse() InboundNatRulesClientListResponse {
	return p.current
}

// InterfaceIPConfigurationsClientListPager provides operations for iterating over paged responses.
type InterfaceIPConfigurationsClientListPager struct {
	client    *InterfaceIPConfigurationsClient
	current   InterfaceIPConfigurationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceIPConfigurationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfaceIPConfigurationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfaceIPConfigurationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.InterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfaceIPConfigurationsClientListResponse page.
func (p *InterfaceIPConfigurationsClientListPager) PageResponse() InterfaceIPConfigurationsClientListResponse {
	return p.current
}

// InterfaceLoadBalancersClientListPager provides operations for iterating over paged responses.
type InterfaceLoadBalancersClientListPager struct {
	client    *InterfaceLoadBalancersClient
	current   InterfaceLoadBalancersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceLoadBalancersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfaceLoadBalancersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfaceLoadBalancersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceLoadBalancerListResult.NextLink == nil || len(*p.current.InterfaceLoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfaceLoadBalancersClientListResponse page.
func (p *InterfaceLoadBalancersClientListPager) PageResponse() InterfaceLoadBalancersClientListResponse {
	return p.current
}

// InterfaceTapConfigurationsClientListPager provides operations for iterating over paged responses.
type InterfaceTapConfigurationsClientListPager struct {
	client    *InterfaceTapConfigurationsClient
	current   InterfaceTapConfigurationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceTapConfigurationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfaceTapConfigurationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfaceTapConfigurationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceTapConfigurationListResult.NextLink == nil || len(*p.current.InterfaceTapConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfaceTapConfigurationsClientListResponse page.
func (p *InterfaceTapConfigurationsClientListPager) PageResponse() InterfaceTapConfigurationsClientListResponse {
	return p.current
}

// InterfacesClientListAllPager provides operations for iterating over paged responses.
type InterfacesClientListAllPager struct {
	client    *InterfacesClient
	current   InterfacesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListAllResponse page.
func (p *InterfacesClientListAllPager) PageResponse() InterfacesClientListAllResponse {
	return p.current
}

// InterfacesClientListCloudServiceNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListCloudServiceNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListCloudServiceNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListCloudServiceNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListCloudServiceNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListCloudServiceNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCloudServiceNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListCloudServiceNetworkInterfacesResponse page.
func (p *InterfacesClientListCloudServiceNetworkInterfacesPager) PageResponse() InterfacesClientListCloudServiceNetworkInterfacesResponse {
	return p.current
}

// InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCloudServiceRoleInstanceNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesResponse page.
func (p *InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesPager) PageResponse() InterfacesClientListCloudServiceRoleInstanceNetworkInterfacesResponse {
	return p.current
}

// InterfacesClientListPager provides operations for iterating over paged responses.
type InterfacesClientListPager struct {
	client    *InterfacesClient
	current   InterfacesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListResponse page.
func (p *InterfacesClientListPager) PageResponse() InterfacesClientListResponse {
	return p.current
}

// InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.InterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetIPConfigurationsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse page.
func (p *InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager) PageResponse() InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse {
	return p.current
}

// InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse page.
func (p *InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager) PageResponse() InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse {
	return p.current
}

// InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetVMNetworkInterfacesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse page.
func (p *InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager) PageResponse() InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse {
	return p.current
}

// LoadBalancerBackendAddressPoolsClientListPager provides operations for iterating over paged responses.
type LoadBalancerBackendAddressPoolsClientListPager struct {
	client    *LoadBalancerBackendAddressPoolsClient
	current   LoadBalancerBackendAddressPoolsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerBackendAddressPoolsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerBackendAddressPoolsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerBackendAddressPoolsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerBackendAddressPoolListResult.NextLink == nil || len(*p.current.LoadBalancerBackendAddressPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerBackendAddressPoolsClientListResponse page.
func (p *LoadBalancerBackendAddressPoolsClientListPager) PageResponse() LoadBalancerBackendAddressPoolsClientListResponse {
	return p.current
}

// LoadBalancerFrontendIPConfigurationsClientListPager provides operations for iterating over paged responses.
type LoadBalancerFrontendIPConfigurationsClientListPager struct {
	client    *LoadBalancerFrontendIPConfigurationsClient
	current   LoadBalancerFrontendIPConfigurationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerFrontendIPConfigurationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerFrontendIPConfigurationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerFrontendIPConfigurationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink == nil || len(*p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerFrontendIPConfigurationsClientListResponse page.
func (p *LoadBalancerFrontendIPConfigurationsClientListPager) PageResponse() LoadBalancerFrontendIPConfigurationsClientListResponse {
	return p.current
}

// LoadBalancerLoadBalancingRulesClientListPager provides operations for iterating over paged responses.
type LoadBalancerLoadBalancingRulesClientListPager struct {
	client    *LoadBalancerLoadBalancingRulesClient
	current   LoadBalancerLoadBalancingRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerLoadBalancingRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerLoadBalancingRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerLoadBalancingRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerLoadBalancingRuleListResult.NextLink == nil || len(*p.current.LoadBalancerLoadBalancingRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerLoadBalancingRulesClientListResponse page.
func (p *LoadBalancerLoadBalancingRulesClientListPager) PageResponse() LoadBalancerLoadBalancingRulesClientListResponse {
	return p.current
}

// LoadBalancerNetworkInterfacesClientListPager provides operations for iterating over paged responses.
type LoadBalancerNetworkInterfacesClientListPager struct {
	client    *LoadBalancerNetworkInterfacesClient
	current   LoadBalancerNetworkInterfacesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerNetworkInterfacesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerNetworkInterfacesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerNetworkInterfacesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerNetworkInterfacesClientListResponse page.
func (p *LoadBalancerNetworkInterfacesClientListPager) PageResponse() LoadBalancerNetworkInterfacesClientListResponse {
	return p.current
}

// LoadBalancerOutboundRulesClientListPager provides operations for iterating over paged responses.
type LoadBalancerOutboundRulesClientListPager struct {
	client    *LoadBalancerOutboundRulesClient
	current   LoadBalancerOutboundRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerOutboundRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerOutboundRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerOutboundRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerOutboundRuleListResult.NextLink == nil || len(*p.current.LoadBalancerOutboundRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerOutboundRulesClientListResponse page.
func (p *LoadBalancerOutboundRulesClientListPager) PageResponse() LoadBalancerOutboundRulesClientListResponse {
	return p.current
}

// LoadBalancerProbesClientListPager provides operations for iterating over paged responses.
type LoadBalancerProbesClientListPager struct {
	client    *LoadBalancerProbesClient
	current   LoadBalancerProbesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerProbesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancerProbesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancerProbesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerProbeListResult.NextLink == nil || len(*p.current.LoadBalancerProbeListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancerProbesClientListResponse page.
func (p *LoadBalancerProbesClientListPager) PageResponse() LoadBalancerProbesClientListResponse {
	return p.current
}

// LoadBalancersClientListAllPager provides operations for iterating over paged responses.
type LoadBalancersClientListAllPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancersClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancersClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancersClientListAllResponse page.
func (p *LoadBalancersClientListAllPager) PageResponse() LoadBalancersClientListAllResponse {
	return p.current
}

// LoadBalancersClientListPager provides operations for iterating over paged responses.
type LoadBalancersClientListPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LoadBalancersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LoadBalancersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LoadBalancersClientListResponse page.
func (p *LoadBalancersClientListPager) PageResponse() LoadBalancersClientListResponse {
	return p.current
}

// LocalNetworkGatewaysClientListPager provides operations for iterating over paged responses.
type LocalNetworkGatewaysClientListPager struct {
	client    *LocalNetworkGatewaysClient
	current   LocalNetworkGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocalNetworkGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LocalNetworkGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LocalNetworkGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LocalNetworkGatewayListResult.NextLink == nil || len(*p.current.LocalNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LocalNetworkGatewaysClientListResponse page.
func (p *LocalNetworkGatewaysClientListPager) PageResponse() LocalNetworkGatewaysClientListResponse {
	return p.current
}

// ManagementClientDisconnectActiveSessionsPager provides operations for iterating over paged responses.
type ManagementClientDisconnectActiveSessionsPager struct {
	client    *ManagementClient
	current   ManagementClientDisconnectActiveSessionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagementClientDisconnectActiveSessionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagementClientDisconnectActiveSessionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagementClientDisconnectActiveSessionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionSessionDeleteResult.NextLink == nil || len(*p.current.BastionSessionDeleteResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.disconnectActiveSessionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagementClientDisconnectActiveSessionsResponse page.
func (p *ManagementClientDisconnectActiveSessionsPager) PageResponse() ManagementClientDisconnectActiveSessionsResponse {
	return p.current
}

// ManagementClientGetActiveSessionsPager provides operations for iterating over paged responses.
type ManagementClientGetActiveSessionsPager struct {
	client  *ManagementClient
	current ManagementClientGetActiveSessionsResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *ManagementClientGetActiveSessionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagementClientGetActiveSessionsPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionActiveSessionListResult.NextLink == nil || len(*p.current.BastionActiveSessionListResult.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionActiveSessionListResult.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getActiveSessionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagementClientGetActiveSessionsResponse page.
func (p *ManagementClientGetActiveSessionsPager) PageResponse() ManagementClientGetActiveSessionsResponse {
	return p.current
}

// ManagementClientGetBastionShareableLinkPager provides operations for iterating over paged responses.
type ManagementClientGetBastionShareableLinkPager struct {
	client    *ManagementClient
	current   ManagementClientGetBastionShareableLinkResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagementClientGetBastionShareableLinkResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagementClientGetBastionShareableLinkPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagementClientGetBastionShareableLinkPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getBastionShareableLinkHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagementClientGetBastionShareableLinkResponse page.
func (p *ManagementClientGetBastionShareableLinkPager) PageResponse() ManagementClientGetBastionShareableLinkResponse {
	return p.current
}

// ManagementClientPutBastionShareableLinkPager provides operations for iterating over paged responses.
type ManagementClientPutBastionShareableLinkPager struct {
	client  *ManagementClient
	current ManagementClientPutBastionShareableLinkResponse
	err     error
	second  bool
}

// Err returns the last error encountered while paging.
func (p *ManagementClientPutBastionShareableLinkPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagementClientPutBastionShareableLinkPager) NextPage(ctx context.Context) bool {
	if !p.second {
		p.second = true
		return true
	} else if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionShareableLinkListResult.NextLink)
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.putBastionShareableLinkHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagementClientPutBastionShareableLinkResponse page.
func (p *ManagementClientPutBastionShareableLinkPager) PageResponse() ManagementClientPutBastionShareableLinkResponse {
	return p.current
}

// NatGatewaysClientListAllPager provides operations for iterating over paged responses.
type NatGatewaysClientListAllPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatGatewaysClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatGatewaysClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatGatewaysClientListAllResponse page.
func (p *NatGatewaysClientListAllPager) PageResponse() NatGatewaysClientListAllResponse {
	return p.current
}

// NatGatewaysClientListPager provides operations for iterating over paged responses.
type NatGatewaysClientListPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatGatewaysClientListResponse page.
func (p *NatGatewaysClientListPager) PageResponse() NatGatewaysClientListResponse {
	return p.current
}

// NatRulesClientListByVPNGatewayPager provides operations for iterating over paged responses.
type NatRulesClientListByVPNGatewayPager struct {
	client    *NatRulesClient
	current   NatRulesClientListByVPNGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatRulesClientListByVPNGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *NatRulesClientListByVPNGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *NatRulesClientListByVPNGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewayNatRulesResult.NextLink == nil || len(*p.current.ListVPNGatewayNatRulesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVPNGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current NatRulesClientListByVPNGatewayResponse page.
func (p *NatRulesClientListByVPNGatewayPager) PageResponse() NatRulesClientListByVPNGatewayResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// P2SVPNGatewaysClientListByResourceGroupPager provides operations for iterating over paged responses.
type P2SVPNGatewaysClientListByResourceGroupPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *P2SVPNGatewaysClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *P2SVPNGatewaysClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current P2SVPNGatewaysClientListByResourceGroupResponse page.
func (p *P2SVPNGatewaysClientListByResourceGroupPager) PageResponse() P2SVPNGatewaysClientListByResourceGroupResponse {
	return p.current
}

// P2SVPNGatewaysClientListPager provides operations for iterating over paged responses.
type P2SVPNGatewaysClientListPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *P2SVPNGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *P2SVPNGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current P2SVPNGatewaysClientListResponse page.
func (p *P2SVPNGatewaysClientListPager) PageResponse() P2SVPNGatewaysClientListResponse {
	return p.current
}

// PeerExpressRouteCircuitConnectionsClientListPager provides operations for iterating over paged responses.
type PeerExpressRouteCircuitConnectionsClientListPager struct {
	client    *PeerExpressRouteCircuitConnectionsClient
	current   PeerExpressRouteCircuitConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PeerExpressRouteCircuitConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PeerExpressRouteCircuitConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PeerExpressRouteCircuitConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PeerExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.PeerExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PeerExpressRouteCircuitConnectionsClientListResponse page.
func (p *PeerExpressRouteCircuitConnectionsClientListPager) PageResponse() PeerExpressRouteCircuitConnectionsClientListResponse {
	return p.current
}

// PrivateDNSZoneGroupsClientListPager provides operations for iterating over paged responses.
type PrivateDNSZoneGroupsClientListPager struct {
	client    *PrivateDNSZoneGroupsClient
	current   PrivateDNSZoneGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateDNSZoneGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateDNSZoneGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateDNSZoneGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateDNSZoneGroupListResult.NextLink == nil || len(*p.current.PrivateDNSZoneGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateDNSZoneGroupsClientListResponse page.
func (p *PrivateDNSZoneGroupsClientListPager) PageResponse() PrivateDNSZoneGroupsClientListResponse {
	return p.current
}

// PrivateEndpointsClientListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateEndpointsClientListBySubscriptionPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointsClientListBySubscriptionResponse page.
func (p *PrivateEndpointsClientListBySubscriptionPager) PageResponse() PrivateEndpointsClientListBySubscriptionResponse {
	return p.current
}

// PrivateEndpointsClientListPager provides operations for iterating over paged responses.
type PrivateEndpointsClientListPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointsClientListResponse page.
func (p *PrivateEndpointsClientListPager) PageResponse() PrivateEndpointsClientListResponse {
	return p.current
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse page.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager) PageResponse() PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse {
	return p.current
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse page.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager) PageResponse() PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse {
	return p.current
}

// PrivateLinkServicesClientListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListBySubscriptionPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesClientListBySubscriptionResponse page.
func (p *PrivateLinkServicesClientListBySubscriptionPager) PageResponse() PrivateLinkServicesClientListBySubscriptionResponse {
	return p.current
}

// PrivateLinkServicesClientListPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesClientListResponse page.
func (p *PrivateLinkServicesClientListPager) PageResponse() PrivateLinkServicesClientListResponse {
	return p.current
}

// PrivateLinkServicesClientListPrivateEndpointConnectionsPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListPrivateEndpointConnectionsPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListPrivateEndpointConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListPrivateEndpointConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkServicesClientListPrivateEndpointConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkServicesClientListPrivateEndpointConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listPrivateEndpointConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkServicesClientListPrivateEndpointConnectionsResponse page.
func (p *PrivateLinkServicesClientListPrivateEndpointConnectionsPager) PageResponse() PrivateLinkServicesClientListPrivateEndpointConnectionsResponse {
	return p.current
}

// ProfilesClientListAllPager provides operations for iterating over paged responses.
type ProfilesClientListAllPager struct {
	client    *ProfilesClient
	current   ProfilesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListAllResponse page.
func (p *ProfilesClientListAllPager) PageResponse() ProfilesClientListAllResponse {
	return p.current
}

// ProfilesClientListPager provides operations for iterating over paged responses.
type ProfilesClientListPager struct {
	client    *ProfilesClient
	current   ProfilesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProfilesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProfilesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProfilesClientListResponse page.
func (p *ProfilesClientListPager) PageResponse() ProfilesClientListResponse {
	return p.current
}

// PublicIPAddressesClientListAllPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListAllPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListAllResponse page.
func (p *PublicIPAddressesClientListAllPager) PageResponse() PublicIPAddressesClientListAllResponse {
	return p.current
}

// PublicIPAddressesClientListCloudServicePublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListCloudServicePublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListCloudServicePublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListCloudServicePublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListCloudServicePublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListCloudServicePublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCloudServicePublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListCloudServicePublicIPAddressesResponse page.
func (p *PublicIPAddressesClientListCloudServicePublicIPAddressesPager) PageResponse() PublicIPAddressesClientListCloudServicePublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCloudServiceRoleInstancePublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesResponse page.
func (p *PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesPager) PageResponse() PublicIPAddressesClientListCloudServiceRoleInstancePublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesClientListPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListResponse page.
func (p *PublicIPAddressesClientListPager) PageResponse() PublicIPAddressesClientListResponse {
	return p.current
}

// PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetPublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse page.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager) PageResponse() PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse {
	return p.current
}

// PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listVirtualMachineScaleSetVMPublicIPAddressesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse page.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager) PageResponse() PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse {
	return p.current
}

// PublicIPPrefixesClientListAllPager provides operations for iterating over paged responses.
type PublicIPPrefixesClientListAllPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPPrefixesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPPrefixesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPPrefixesClientListAllResponse page.
func (p *PublicIPPrefixesClientListAllPager) PageResponse() PublicIPPrefixesClientListAllResponse {
	return p.current
}

// PublicIPPrefixesClientListPager provides operations for iterating over paged responses.
type PublicIPPrefixesClientListPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PublicIPPrefixesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PublicIPPrefixesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PublicIPPrefixesClientListResponse page.
func (p *PublicIPPrefixesClientListPager) PageResponse() PublicIPPrefixesClientListResponse {
	return p.current
}

// RouteFilterRulesClientListByRouteFilterPager provides operations for iterating over paged responses.
type RouteFilterRulesClientListByRouteFilterPager struct {
	client    *RouteFilterRulesClient
	current   RouteFilterRulesClientListByRouteFilterResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFilterRulesClientListByRouteFilterResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFilterRulesClientListByRouteFilterPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFilterRulesClientListByRouteFilterPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterRuleListResult.NextLink == nil || len(*p.current.RouteFilterRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByRouteFilterHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFilterRulesClientListByRouteFilterResponse page.
func (p *RouteFilterRulesClientListByRouteFilterPager) PageResponse() RouteFilterRulesClientListByRouteFilterResponse {
	return p.current
}

// RouteFiltersClientListByResourceGroupPager provides operations for iterating over paged responses.
type RouteFiltersClientListByResourceGroupPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFiltersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFiltersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFiltersClientListByResourceGroupResponse page.
func (p *RouteFiltersClientListByResourceGroupPager) PageResponse() RouteFiltersClientListByResourceGroupResponse {
	return p.current
}

// RouteFiltersClientListPager provides operations for iterating over paged responses.
type RouteFiltersClientListPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteFiltersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteFiltersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteFiltersClientListResponse page.
func (p *RouteFiltersClientListPager) PageResponse() RouteFiltersClientListResponse {
	return p.current
}

// RouteTablesClientListAllPager provides operations for iterating over paged responses.
type RouteTablesClientListAllPager struct {
	client    *RouteTablesClient
	current   RouteTablesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteTablesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteTablesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteTablesClientListAllResponse page.
func (p *RouteTablesClientListAllPager) PageResponse() RouteTablesClientListAllResponse {
	return p.current
}

// RouteTablesClientListPager provides operations for iterating over paged responses.
type RouteTablesClientListPager struct {
	client    *RouteTablesClient
	current   RouteTablesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RouteTablesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RouteTablesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RouteTablesClientListResponse page.
func (p *RouteTablesClientListPager) PageResponse() RouteTablesClientListResponse {
	return p.current
}

// RoutesClientListPager provides operations for iterating over paged responses.
type RoutesClientListPager struct {
	client    *RoutesClient
	current   RoutesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoutesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoutesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoutesClientListResponse page.
func (p *RoutesClientListPager) PageResponse() RoutesClientListResponse {
	return p.current
}

// RoutingIntentClientListPager provides operations for iterating over paged responses.
type RoutingIntentClientListPager struct {
	client    *RoutingIntentClient
	current   RoutingIntentClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutingIntentClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RoutingIntentClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RoutingIntentClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListRoutingIntentResult.NextLink == nil || len(*p.current.ListRoutingIntentResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RoutingIntentClientListResponse page.
func (p *RoutingIntentClientListPager) PageResponse() RoutingIntentClientListResponse {
	return p.current
}

// SecurityGroupsClientListAllPager provides operations for iterating over paged responses.
type SecurityGroupsClientListAllPager struct {
	client    *SecurityGroupsClient
	current   SecurityGroupsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityGroupsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityGroupsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityGroupsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityGroupListResult.NextLink == nil || len(*p.current.SecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityGroupsClientListAllResponse page.
func (p *SecurityGroupsClientListAllPager) PageResponse() SecurityGroupsClientListAllResponse {
	return p.current
}

// SecurityGroupsClientListPager provides operations for iterating over paged responses.
type SecurityGroupsClientListPager struct {
	client    *SecurityGroupsClient
	current   SecurityGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityGroupListResult.NextLink == nil || len(*p.current.SecurityGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityGroupsClientListResponse page.
func (p *SecurityGroupsClientListPager) PageResponse() SecurityGroupsClientListResponse {
	return p.current
}

// SecurityPartnerProvidersClientListByResourceGroupPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersClientListByResourceGroupPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityPartnerProvidersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityPartnerProvidersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityPartnerProvidersClientListByResourceGroupResponse page.
func (p *SecurityPartnerProvidersClientListByResourceGroupPager) PageResponse() SecurityPartnerProvidersClientListByResourceGroupResponse {
	return p.current
}

// SecurityPartnerProvidersClientListPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersClientListPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityPartnerProvidersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityPartnerProvidersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityPartnerProvidersClientListResponse page.
func (p *SecurityPartnerProvidersClientListPager) PageResponse() SecurityPartnerProvidersClientListResponse {
	return p.current
}

// SecurityRulesClientListPager provides operations for iterating over paged responses.
type SecurityRulesClientListPager struct {
	client    *SecurityRulesClient
	current   SecurityRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityRulesClientListResponse page.
func (p *SecurityRulesClientListPager) PageResponse() SecurityRulesClientListResponse {
	return p.current
}

// ServiceEndpointPoliciesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesClientListByResourceGroupPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPoliciesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPoliciesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPoliciesClientListByResourceGroupResponse page.
func (p *ServiceEndpointPoliciesClientListByResourceGroupPager) PageResponse() ServiceEndpointPoliciesClientListByResourceGroupResponse {
	return p.current
}

// ServiceEndpointPoliciesClientListPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesClientListPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPoliciesClientListResponse page.
func (p *ServiceEndpointPoliciesClientListPager) PageResponse() ServiceEndpointPoliciesClientListResponse {
	return p.current
}

// ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager struct {
	client    *ServiceEndpointPolicyDefinitionsClient
	current   ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyDefinitionListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse page.
func (p *ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager) PageResponse() ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse {
	return p.current
}

// ServiceTagInformationClientListPager provides operations for iterating over paged responses.
type ServiceTagInformationClientListPager struct {
	client    *ServiceTagInformationClient
	current   ServiceTagInformationClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceTagInformationClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServiceTagInformationClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServiceTagInformationClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceTagInformationListResult.NextLink == nil || len(*p.current.ServiceTagInformationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServiceTagInformationClientListResponse page.
func (p *ServiceTagInformationClientListPager) PageResponse() ServiceTagInformationClientListResponse {
	return p.current
}

// SubnetsClientListPager provides operations for iterating over paged responses.
type SubnetsClientListPager struct {
	client    *SubnetsClient
	current   SubnetsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubnetsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubnetsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubnetsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubnetListResult.NextLink == nil || len(*p.current.SubnetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubnetsClientListResponse page.
func (p *SubnetsClientListPager) PageResponse() SubnetsClientListResponse {
	return p.current
}

// UsagesClientListPager provides operations for iterating over paged responses.
type UsagesClientListPager struct {
	client    *UsagesClient
	current   UsagesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsagesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsagesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsagesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsagesClientListResponse page.
func (p *UsagesClientListPager) PageResponse() UsagesClientListResponse {
	return p.current
}

// VPNConnectionsClientListByVPNGatewayPager provides operations for iterating over paged responses.
type VPNConnectionsClientListByVPNGatewayPager struct {
	client    *VPNConnectionsClient
	current   VPNConnectionsClientListByVPNGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNConnectionsClientListByVPNGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNConnectionsClientListByVPNGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNConnectionsClientListByVPNGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNConnectionsResult.NextLink == nil || len(*p.current.ListVPNConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVPNGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNConnectionsClientListByVPNGatewayResponse page.
func (p *VPNConnectionsClientListByVPNGatewayPager) PageResponse() VPNConnectionsClientListByVPNGatewayResponse {
	return p.current
}

// VPNGatewaysClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNGatewaysClientListByResourceGroupPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNGatewaysClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNGatewaysClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNGatewaysClientListByResourceGroupResponse page.
func (p *VPNGatewaysClientListByResourceGroupPager) PageResponse() VPNGatewaysClientListByResourceGroupResponse {
	return p.current
}

// VPNGatewaysClientListPager provides operations for iterating over paged responses.
type VPNGatewaysClientListPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNGatewaysClientListResponse page.
func (p *VPNGatewaysClientListPager) PageResponse() VPNGatewaysClientListResponse {
	return p.current
}

// VPNLinkConnectionsClientListByVPNConnectionPager provides operations for iterating over paged responses.
type VPNLinkConnectionsClientListByVPNConnectionPager struct {
	client    *VPNLinkConnectionsClient
	current   VPNLinkConnectionsClientListByVPNConnectionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNLinkConnectionsClientListByVPNConnectionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNLinkConnectionsClientListByVPNConnectionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNLinkConnectionsClientListByVPNConnectionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinkConnectionsResult.NextLink == nil || len(*p.current.ListVPNSiteLinkConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVPNConnectionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNLinkConnectionsClientListByVPNConnectionResponse page.
func (p *VPNLinkConnectionsClientListByVPNConnectionPager) PageResponse() VPNLinkConnectionsClientListByVPNConnectionResponse {
	return p.current
}

// VPNServerConfigurationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNServerConfigurationsClientListByResourceGroupPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNServerConfigurationsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNServerConfigurationsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNServerConfigurationsClientListByResourceGroupResponse page.
func (p *VPNServerConfigurationsClientListByResourceGroupPager) PageResponse() VPNServerConfigurationsClientListByResourceGroupResponse {
	return p.current
}

// VPNServerConfigurationsClientListPager provides operations for iterating over paged responses.
type VPNServerConfigurationsClientListPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNServerConfigurationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNServerConfigurationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNServerConfigurationsClientListResponse page.
func (p *VPNServerConfigurationsClientListPager) PageResponse() VPNServerConfigurationsClientListResponse {
	return p.current
}

// VPNSiteLinksClientListByVPNSitePager provides operations for iterating over paged responses.
type VPNSiteLinksClientListByVPNSitePager struct {
	client    *VPNSiteLinksClient
	current   VPNSiteLinksClientListByVPNSiteResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSiteLinksClientListByVPNSiteResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSiteLinksClientListByVPNSitePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSiteLinksClientListByVPNSitePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinksResult.NextLink == nil || len(*p.current.ListVPNSiteLinksResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVPNSiteHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSiteLinksClientListByVPNSiteResponse page.
func (p *VPNSiteLinksClientListByVPNSitePager) PageResponse() VPNSiteLinksClientListByVPNSiteResponse {
	return p.current
}

// VPNSitesClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNSitesClientListByResourceGroupPager struct {
	client    *VPNSitesClient
	current   VPNSitesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSitesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSitesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSitesClientListByResourceGroupResponse page.
func (p *VPNSitesClientListByResourceGroupPager) PageResponse() VPNSitesClientListByResourceGroupResponse {
	return p.current
}

// VPNSitesClientListPager provides operations for iterating over paged responses.
type VPNSitesClientListPager struct {
	client    *VPNSitesClient
	current   VPNSitesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VPNSitesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VPNSitesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VPNSitesClientListResponse page.
func (p *VPNSitesClientListPager) PageResponse() VPNSitesClientListResponse {
	return p.current
}

// VirtualApplianceSKUsClientListPager provides operations for iterating over paged responses.
type VirtualApplianceSKUsClientListPager struct {
	client    *VirtualApplianceSKUsClient
	current   VirtualApplianceSKUsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualApplianceSKUsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualApplianceSKUsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualApplianceSKUsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceSKUListResult.NextLink == nil || len(*p.current.VirtualApplianceSKUListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualApplianceSKUsClientListResponse page.
func (p *VirtualApplianceSKUsClientListPager) PageResponse() VirtualApplianceSKUsClientListResponse {
	return p.current
}

// VirtualApplianceSitesClientListPager provides operations for iterating over paged responses.
type VirtualApplianceSitesClientListPager struct {
	client    *VirtualApplianceSitesClient
	current   VirtualApplianceSitesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualApplianceSitesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualApplianceSitesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualApplianceSitesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceSiteListResult.NextLink == nil || len(*p.current.VirtualApplianceSiteListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualApplianceSitesClientListResponse page.
func (p *VirtualApplianceSitesClientListPager) PageResponse() VirtualApplianceSitesClientListResponse {
	return p.current
}

// VirtualAppliancesClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualAppliancesClientListByResourceGroupPager struct {
	client    *VirtualAppliancesClient
	current   VirtualAppliancesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualAppliancesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualAppliancesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualAppliancesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceListResult.NextLink == nil || len(*p.current.VirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualAppliancesClientListByResourceGroupResponse page.
func (p *VirtualAppliancesClientListByResourceGroupPager) PageResponse() VirtualAppliancesClientListByResourceGroupResponse {
	return p.current
}

// VirtualAppliancesClientListPager provides operations for iterating over paged responses.
type VirtualAppliancesClientListPager struct {
	client    *VirtualAppliancesClient
	current   VirtualAppliancesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualAppliancesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualAppliancesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualAppliancesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceListResult.NextLink == nil || len(*p.current.VirtualApplianceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualAppliancesClientListResponse page.
func (p *VirtualAppliancesClientListPager) PageResponse() VirtualAppliancesClientListResponse {
	return p.current
}

// VirtualHubBgpConnectionsClientListPager provides operations for iterating over paged responses.
type VirtualHubBgpConnectionsClientListPager struct {
	client    *VirtualHubBgpConnectionsClient
	current   VirtualHubBgpConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubBgpConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubBgpConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubBgpConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubBgpConnectionResults.NextLink == nil || len(*p.current.ListVirtualHubBgpConnectionResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubBgpConnectionsClientListResponse page.
func (p *VirtualHubBgpConnectionsClientListPager) PageResponse() VirtualHubBgpConnectionsClientListResponse {
	return p.current
}

// VirtualHubIPConfigurationClientListPager provides operations for iterating over paged responses.
type VirtualHubIPConfigurationClientListPager struct {
	client    *VirtualHubIPConfigurationClient
	current   VirtualHubIPConfigurationClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubIPConfigurationClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubIPConfigurationClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubIPConfigurationClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubIPConfigurationResults.NextLink == nil || len(*p.current.ListVirtualHubIPConfigurationResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubIPConfigurationClientListResponse page.
func (p *VirtualHubIPConfigurationClientListPager) PageResponse() VirtualHubIPConfigurationClientListResponse {
	return p.current
}

// VirtualHubRouteTableV2SClientListPager provides operations for iterating over paged responses.
type VirtualHubRouteTableV2SClientListPager struct {
	client    *VirtualHubRouteTableV2SClient
	current   VirtualHubRouteTableV2SClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubRouteTableV2SClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubRouteTableV2SClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubRouteTableV2SClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubRouteTableV2SResult.NextLink == nil || len(*p.current.ListVirtualHubRouteTableV2SResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubRouteTableV2SClientListResponse page.
func (p *VirtualHubRouteTableV2SClientListPager) PageResponse() VirtualHubRouteTableV2SClientListResponse {
	return p.current
}

// VirtualHubsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualHubsClientListByResourceGroupPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubsClientListByResourceGroupResponse page.
func (p *VirtualHubsClientListByResourceGroupPager) PageResponse() VirtualHubsClientListByResourceGroupResponse {
	return p.current
}

// VirtualHubsClientListPager provides operations for iterating over paged responses.
type VirtualHubsClientListPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualHubsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualHubsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualHubsClientListResponse page.
func (p *VirtualHubsClientListPager) PageResponse() VirtualHubsClientListResponse {
	return p.current
}

// VirtualNetworkGatewayConnectionsClientListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewayConnectionsClientListPager struct {
	client    *VirtualNetworkGatewayConnectionsClient
	current   VirtualNetworkGatewayConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewayConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewayConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewayConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayConnectionListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewayConnectionsClientListResponse page.
func (p *VirtualNetworkGatewayConnectionsClientListPager) PageResponse() VirtualNetworkGatewayConnectionsClientListResponse {
	return p.current
}

// VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayPager provides operations for iterating over paged responses.
type VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayPager struct {
	client    *VirtualNetworkGatewayNatRulesClient
	current   VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualNetworkGatewayNatRulesResult.NextLink == nil || len(*p.current.ListVirtualNetworkGatewayNatRulesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVirtualNetworkGatewayHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayResponse page.
func (p *VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayPager) PageResponse() VirtualNetworkGatewayNatRulesClientListByVirtualNetworkGatewayResponse {
	return p.current
}

// VirtualNetworkGatewaysClientListConnectionsPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysClientListConnectionsPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysClientListConnectionsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysClientListConnectionsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewaysClientListConnectionsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewaysClientListConnectionsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListConnectionsResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListConnectionsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listConnectionsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewaysClientListConnectionsResponse page.
func (p *VirtualNetworkGatewaysClientListConnectionsPager) PageResponse() VirtualNetworkGatewaysClientListConnectionsResponse {
	return p.current
}

// VirtualNetworkGatewaysClientListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysClientListPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkGatewaysClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkGatewaysClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkGatewaysClientListResponse page.
func (p *VirtualNetworkGatewaysClientListPager) PageResponse() VirtualNetworkGatewaysClientListResponse {
	return p.current
}

// VirtualNetworkPeeringsClientListPager provides operations for iterating over paged responses.
type VirtualNetworkPeeringsClientListPager struct {
	client    *VirtualNetworkPeeringsClient
	current   VirtualNetworkPeeringsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkPeeringsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkPeeringsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkPeeringsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkPeeringListResult.NextLink == nil || len(*p.current.VirtualNetworkPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkPeeringsClientListResponse page.
func (p *VirtualNetworkPeeringsClientListPager) PageResponse() VirtualNetworkPeeringsClientListResponse {
	return p.current
}

// VirtualNetworkTapsClientListAllPager provides operations for iterating over paged responses.
type VirtualNetworkTapsClientListAllPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkTapsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkTapsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkTapsClientListAllResponse page.
func (p *VirtualNetworkTapsClientListAllPager) PageResponse() VirtualNetworkTapsClientListAllResponse {
	return p.current
}

// VirtualNetworkTapsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualNetworkTapsClientListByResourceGroupPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkTapsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkTapsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkTapsClientListByResourceGroupResponse page.
func (p *VirtualNetworkTapsClientListByResourceGroupPager) PageResponse() VirtualNetworkTapsClientListByResourceGroupResponse {
	return p.current
}

// VirtualNetworksClientListAllPager provides operations for iterating over paged responses.
type VirtualNetworksClientListAllPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksClientListAllResponse page.
func (p *VirtualNetworksClientListAllPager) PageResponse() VirtualNetworksClientListAllResponse {
	return p.current
}

// VirtualNetworksClientListPager provides operations for iterating over paged responses.
type VirtualNetworksClientListPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksClientListResponse page.
func (p *VirtualNetworksClientListPager) PageResponse() VirtualNetworksClientListResponse {
	return p.current
}

// VirtualNetworksClientListUsagePager provides operations for iterating over paged responses.
type VirtualNetworksClientListUsagePager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListUsageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListUsageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworksClientListUsagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworksClientListUsagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListUsageResult.NextLink == nil || len(*p.current.VirtualNetworkListUsageResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listUsageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworksClientListUsageResponse page.
func (p *VirtualNetworksClientListUsagePager) PageResponse() VirtualNetworksClientListUsageResponse {
	return p.current
}

// VirtualRouterPeeringsClientListPager provides operations for iterating over paged responses.
type VirtualRouterPeeringsClientListPager struct {
	client    *VirtualRouterPeeringsClient
	current   VirtualRouterPeeringsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRouterPeeringsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRouterPeeringsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRouterPeeringsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterPeeringListResult.NextLink == nil || len(*p.current.VirtualRouterPeeringListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRouterPeeringsClientListResponse page.
func (p *VirtualRouterPeeringsClientListPager) PageResponse() VirtualRouterPeeringsClientListResponse {
	return p.current
}

// VirtualRoutersClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualRoutersClientListByResourceGroupPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRoutersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRoutersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRoutersClientListByResourceGroupResponse page.
func (p *VirtualRoutersClientListByResourceGroupPager) PageResponse() VirtualRoutersClientListByResourceGroupResponse {
	return p.current
}

// VirtualRoutersClientListPager provides operations for iterating over paged responses.
type VirtualRoutersClientListPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualRoutersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualRoutersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualRoutersClientListResponse page.
func (p *VirtualRoutersClientListPager) PageResponse() VirtualRoutersClientListResponse {
	return p.current
}

// VirtualWansClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualWansClientListByResourceGroupPager struct {
	client    *VirtualWansClient
	current   VirtualWansClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualWansClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualWansClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualWansClientListByResourceGroupResponse page.
func (p *VirtualWansClientListByResourceGroupPager) PageResponse() VirtualWansClientListByResourceGroupResponse {
	return p.current
}

// VirtualWansClientListPager provides operations for iterating over paged responses.
type VirtualWansClientListPager struct {
	client    *VirtualWansClient
	current   VirtualWansClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualWansClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualWansClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualWansClientListResponse page.
func (p *VirtualWansClientListPager) PageResponse() VirtualWansClientListResponse {
	return p.current
}

// WebApplicationFirewallPoliciesClientListAllPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesClientListAllPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebApplicationFirewallPoliciesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebApplicationFirewallPoliciesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebApplicationFirewallPoliciesClientListAllResponse page.
func (p *WebApplicationFirewallPoliciesClientListAllPager) PageResponse() WebApplicationFirewallPoliciesClientListAllResponse {
	return p.current
}

// WebApplicationFirewallPoliciesClientListPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesClientListPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebApplicationFirewallPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebApplicationFirewallPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebApplicationFirewallPoliciesClientListResponse page.
func (p *WebApplicationFirewallPoliciesClientListPager) PageResponse() WebApplicationFirewallPoliciesClientListResponse {
	return p.current
}

// WebCategoriesClientListBySubscriptionPager provides operations for iterating over paged responses.
type WebCategoriesClientListBySubscriptionPager struct {
	client    *WebCategoriesClient
	current   WebCategoriesClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebCategoriesClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WebCategoriesClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WebCategoriesClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureWebCategoryListResult.NextLink == nil || len(*p.current.AzureWebCategoryListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WebCategoriesClientListBySubscriptionResponse page.
func (p *WebCategoriesClientListBySubscriptionPager) PageResponse() WebCategoriesClientListBySubscriptionResponse {
	return p.current
}
