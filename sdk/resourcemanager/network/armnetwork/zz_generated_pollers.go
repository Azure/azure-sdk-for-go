//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// ApplicationGatewayPrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewayPrivateEndpointConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewayPrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewayPrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewayPrivateEndpointConnectionsDeleteResponse will be returned.
func (p *ApplicationGatewayPrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionsDeleteResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewayPrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewayPrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewayPrivateEndpointConnectionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewayPrivateEndpointConnectionsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewayPrivateEndpointConnectionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewayPrivateEndpointConnectionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewayPrivateEndpointConnectionsUpdateResponse will be returned.
func (p *ApplicationGatewayPrivateEndpointConnectionsUpdatePoller) FinalResponse(ctx context.Context) (ApplicationGatewayPrivateEndpointConnectionsUpdateResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGatewayPrivateEndpointConnection)
	if err != nil {
		return ApplicationGatewayPrivateEndpointConnectionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewayPrivateEndpointConnectionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysBackendHealthOnDemandPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysBackendHealthOnDemandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysBackendHealthOnDemandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysBackendHealthOnDemandResponse will be returned.
func (p *ApplicationGatewaysBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewaysBackendHealthOnDemandResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return ApplicationGatewaysBackendHealthOnDemandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysBackendHealthPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysBackendHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysBackendHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysBackendHealthResponse will be returned.
func (p *ApplicationGatewaysBackendHealthPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthResponse, error) {
	respType := ApplicationGatewaysBackendHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return ApplicationGatewaysBackendHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysBackendHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysCreateOrUpdateResponse will be returned.
func (p *ApplicationGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ApplicationGatewaysCreateOrUpdateResponse, error) {
	respType := ApplicationGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGateway)
	if err != nil {
		return ApplicationGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysDeleteResponse will be returned.
func (p *ApplicationGatewaysDeletePoller) FinalResponse(ctx context.Context) (ApplicationGatewaysDeleteResponse, error) {
	respType := ApplicationGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysStartPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysStartResponse will be returned.
func (p *ApplicationGatewaysStartPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysStartResponse, error) {
	respType := ApplicationGatewaysStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationGatewaysStopPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationGatewaysStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationGatewaysStopResponse will be returned.
func (p *ApplicationGatewaysStopPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysStopResponse, error) {
	respType := ApplicationGatewaysStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationGatewaysStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationSecurityGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationSecurityGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationSecurityGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationSecurityGroupsCreateOrUpdateResponse will be returned.
func (p *ApplicationSecurityGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupsCreateOrUpdateResponse, error) {
	respType := ApplicationSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationSecurityGroup)
	if err != nil {
		return ApplicationSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationSecurityGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ApplicationSecurityGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationSecurityGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ApplicationSecurityGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ApplicationSecurityGroupsDeleteResponse will be returned.
func (p *ApplicationSecurityGroupsDeletePoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupsDeleteResponse, error) {
	respType := ApplicationSecurityGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ApplicationSecurityGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AzureFirewallsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AzureFirewallsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AzureFirewallsCreateOrUpdateResponse will be returned.
func (p *AzureFirewallsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AzureFirewallsCreateOrUpdateResponse, error) {
	respType := AzureFirewallsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AzureFirewallsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AzureFirewallsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AzureFirewallsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AzureFirewallsDeleteResponse will be returned.
func (p *AzureFirewallsDeletePoller) FinalResponse(ctx context.Context) (AzureFirewallsDeleteResponse, error) {
	respType := AzureFirewallsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AzureFirewallsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AzureFirewallsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AzureFirewallsUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AzureFirewallsUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AzureFirewallsUpdateTagsResponse will be returned.
func (p *AzureFirewallsUpdateTagsPoller) FinalResponse(ctx context.Context) (AzureFirewallsUpdateTagsResponse, error) {
	respType := AzureFirewallsUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AzureFirewallsUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BastionHostsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BastionHostsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BastionHostsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BastionHostsCreateOrUpdateResponse will be returned.
func (p *BastionHostsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BastionHostsCreateOrUpdateResponse, error) {
	respType := BastionHostsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BastionHost)
	if err != nil {
		return BastionHostsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BastionHostsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BastionHostsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BastionHostsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BastionHostsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BastionHostsDeleteResponse will be returned.
func (p *BastionHostsDeletePoller) FinalResponse(ctx context.Context) (BastionHostsDeleteResponse, error) {
	respType := BastionHostsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BastionHostsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BastionHostsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BastionHostsUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BastionHostsUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BastionHostsUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BastionHostsUpdateTagsResponse will be returned.
func (p *BastionHostsUpdateTagsPoller) FinalResponse(ctx context.Context) (BastionHostsUpdateTagsResponse, error) {
	respType := BastionHostsUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BastionHost)
	if err != nil {
		return BastionHostsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BastionHostsUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectionMonitorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectionMonitorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectionMonitorsCreateOrUpdateResponse will be returned.
func (p *ConnectionMonitorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ConnectionMonitorsCreateOrUpdateResponse, error) {
	respType := ConnectionMonitorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionMonitorResult)
	if err != nil {
		return ConnectionMonitorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectionMonitorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectionMonitorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectionMonitorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectionMonitorsDeleteResponse will be returned.
func (p *ConnectionMonitorsDeletePoller) FinalResponse(ctx context.Context) (ConnectionMonitorsDeleteResponse, error) {
	respType := ConnectionMonitorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectionMonitorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectionMonitorsQueryPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectionMonitorsQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectionMonitorsQueryResponse will be returned.
func (p *ConnectionMonitorsQueryPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsQueryResponse, error) {
	respType := ConnectionMonitorsQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionMonitorQueryResult)
	if err != nil {
		return ConnectionMonitorsQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectionMonitorsQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectionMonitorsStartPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectionMonitorsStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectionMonitorsStartResponse will be returned.
func (p *ConnectionMonitorsStartPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsStartResponse, error) {
	respType := ConnectionMonitorsStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectionMonitorsStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectionMonitorsStopPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectionMonitorsStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectionMonitorsStopResponse will be returned.
func (p *ConnectionMonitorsStopPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsStopResponse, error) {
	respType := ConnectionMonitorsStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectionMonitorsStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CustomIPPrefixesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CustomIPPrefixesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CustomIPPrefixesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CustomIPPrefixesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CustomIPPrefixesCreateOrUpdateResponse will be returned.
func (p *CustomIPPrefixesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (CustomIPPrefixesCreateOrUpdateResponse, error) {
	respType := CustomIPPrefixesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomIPPrefix)
	if err != nil {
		return CustomIPPrefixesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CustomIPPrefixesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CustomIPPrefixesDeletePoller provides polling facilities until the operation reaches a terminal state.
type CustomIPPrefixesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CustomIPPrefixesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CustomIPPrefixesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CustomIPPrefixesDeleteResponse will be returned.
func (p *CustomIPPrefixesDeletePoller) FinalResponse(ctx context.Context) (CustomIPPrefixesDeleteResponse, error) {
	respType := CustomIPPrefixesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CustomIPPrefixesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CustomIPPrefixesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DdosCustomPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosCustomPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DdosCustomPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DdosCustomPoliciesCreateOrUpdateResponse will be returned.
func (p *DdosCustomPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DdosCustomPoliciesCreateOrUpdateResponse, error) {
	respType := DdosCustomPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DdosCustomPolicy)
	if err != nil {
		return DdosCustomPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DdosCustomPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DdosCustomPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosCustomPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DdosCustomPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DdosCustomPoliciesDeleteResponse will be returned.
func (p *DdosCustomPoliciesDeletePoller) FinalResponse(ctx context.Context) (DdosCustomPoliciesDeleteResponse, error) {
	respType := DdosCustomPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DdosCustomPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DdosCustomPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DdosProtectionPlansCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosProtectionPlansCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DdosProtectionPlansCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DdosProtectionPlansCreateOrUpdateResponse will be returned.
func (p *DdosProtectionPlansCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DdosProtectionPlansCreateOrUpdateResponse, error) {
	respType := DdosProtectionPlansCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DdosProtectionPlan)
	if err != nil {
		return DdosProtectionPlansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DdosProtectionPlansCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DdosProtectionPlansDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosProtectionPlansDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DdosProtectionPlansDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DdosProtectionPlansDeleteResponse will be returned.
func (p *DdosProtectionPlansDeletePoller) FinalResponse(ctx context.Context) (DdosProtectionPlansDeleteResponse, error) {
	respType := DdosProtectionPlansDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DdosProtectionPlansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DdosProtectionPlansDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DscpConfigurationCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DscpConfigurationCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DscpConfigurationCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DscpConfigurationCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DscpConfigurationCreateOrUpdateResponse will be returned.
func (p *DscpConfigurationCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DscpConfigurationCreateOrUpdateResponse, error) {
	respType := DscpConfigurationCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DscpConfiguration)
	if err != nil {
		return DscpConfigurationCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DscpConfigurationCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DscpConfigurationDeletePoller provides polling facilities until the operation reaches a terminal state.
type DscpConfigurationDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DscpConfigurationDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DscpConfigurationDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DscpConfigurationDeleteResponse will be returned.
func (p *DscpConfigurationDeletePoller) FinalResponse(ctx context.Context) (DscpConfigurationDeleteResponse, error) {
	respType := DscpConfigurationDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DscpConfigurationDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DscpConfigurationDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitAuthorizationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitAuthorizationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitAuthorizationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitAuthorizationsDeleteResponse will be returned.
func (p *ExpressRouteCircuitAuthorizationsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsDeleteResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitAuthorizationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitConnectionsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCircuitConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitConnection)
	if err != nil {
		return ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitConnectionsDeleteResponse will be returned.
func (p *ExpressRouteCircuitConnectionsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsDeleteResponse, error) {
	respType := ExpressRouteCircuitConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitPeeringsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCircuitPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitPeering)
	if err != nil {
		return ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitPeeringsDeleteResponse will be returned.
func (p *ExpressRouteCircuitPeeringsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsDeleteResponse, error) {
	respType := ExpressRouteCircuitPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCircuitsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuit)
	if err != nil {
		return ExpressRouteCircuitsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitsDeleteResponse will be returned.
func (p *ExpressRouteCircuitsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsDeleteResponse, error) {
	respType := ExpressRouteCircuitsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitsListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListArpTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsListArpTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitsListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitsListArpTableResponse will be returned.
func (p *ExpressRouteCircuitsListArpTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListArpTableResponse, error) {
	respType := ExpressRouteCircuitsListArpTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitsListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitsListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListRoutesTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitsListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitsListRoutesTableResponse will be returned.
func (p *ExpressRouteCircuitsListRoutesTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitsListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCircuitsListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListRoutesTableSummaryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCircuitsListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCircuitsListRoutesTableSummaryResponse will be returned.
func (p *ExpressRouteCircuitsListRoutesTableSummaryPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableSummaryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCircuitsListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteConnectionsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteConnection)
	if err != nil {
		return ExpressRouteConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteConnectionsDeleteResponse will be returned.
func (p *ExpressRouteConnectionsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionsDeleteResponse, error) {
	respType := ExpressRouteConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringsDeleteResponse will be returned.
func (p *ExpressRouteCrossConnectionPeeringsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsDeleteResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionsCreateOrUpdateResponse will be returned.
func (p *ExpressRouteCrossConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnection)
	if err != nil {
		return ExpressRouteCrossConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionsListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListArpTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsListArpTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionsListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionsListArpTableResponse will be returned.
func (p *ExpressRouteCrossConnectionsListArpTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListArpTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListArpTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionsListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionsListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListRoutesTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionsListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionsListRoutesTableResponse will be returned.
func (p *ExpressRouteCrossConnectionsListRoutesTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionsListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListRoutesTableSummaryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteCrossConnectionsListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteCrossConnectionsListRoutesTableSummaryResponse will be returned.
func (p *ExpressRouteCrossConnectionsListRoutesTableSummaryPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteCrossConnectionsListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteGatewaysCreateOrUpdateResponse will be returned.
func (p *ExpressRouteGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteGatewaysCreateOrUpdateResponse, error) {
	respType := ExpressRouteGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteGatewaysDeleteResponse will be returned.
func (p *ExpressRouteGatewaysDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteGatewaysDeleteResponse, error) {
	respType := ExpressRouteGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRouteGatewaysUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteGatewaysUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRouteGatewaysUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRouteGatewaysUpdateTagsResponse will be returned.
func (p *ExpressRouteGatewaysUpdateTagsPoller) FinalResponse(ctx context.Context) (ExpressRouteGatewaysUpdateTagsResponse, error) {
	respType := ExpressRouteGatewaysUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRouteGatewaysUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRoutePortsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRoutePortsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRoutePortsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRoutePortsCreateOrUpdateResponse will be returned.
func (p *ExpressRoutePortsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRoutePortsCreateOrUpdateResponse, error) {
	respType := ExpressRoutePortsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRoutePort)
	if err != nil {
		return ExpressRoutePortsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRoutePortsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExpressRoutePortsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRoutePortsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExpressRoutePortsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExpressRoutePortsDeleteResponse will be returned.
func (p *ExpressRoutePortsDeletePoller) FinalResponse(ctx context.Context) (ExpressRoutePortsDeleteResponse, error) {
	respType := ExpressRoutePortsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRoutePortsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExpressRoutePortsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FirewallPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FirewallPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FirewallPoliciesCreateOrUpdateResponse will be returned.
func (p *FirewallPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FirewallPoliciesCreateOrUpdateResponse, error) {
	respType := FirewallPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FirewallPolicy)
	if err != nil {
		return FirewallPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FirewallPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FirewallPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FirewallPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FirewallPoliciesDeleteResponse will be returned.
func (p *FirewallPoliciesDeletePoller) FinalResponse(ctx context.Context) (FirewallPoliciesDeleteResponse, error) {
	respType := FirewallPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FirewallPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse will be returned.
func (p *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FirewallPolicyRuleCollectionGroup)
	if err != nil {
		return FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FirewallPolicyRuleCollectionGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleCollectionGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPolicyRuleCollectionGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FirewallPolicyRuleCollectionGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FirewallPolicyRuleCollectionGroupsDeleteResponse will be returned.
func (p *FirewallPolicyRuleCollectionGroupsDeletePoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleCollectionGroupsDeleteResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FirewallPolicyRuleCollectionGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FirewallPolicyRuleCollectionGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FlowLogsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FlowLogsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FlowLogsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FlowLogsCreateOrUpdateResponse will be returned.
func (p *FlowLogsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FlowLogsCreateOrUpdateResponse, error) {
	respType := FlowLogsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLog)
	if err != nil {
		return FlowLogsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FlowLogsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FlowLogsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FlowLogsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FlowLogsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FlowLogsDeleteResponse will be returned.
func (p *FlowLogsDeletePoller) FinalResponse(ctx context.Context) (FlowLogsDeleteResponse, error) {
	respType := FlowLogsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FlowLogsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FlowLogsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// HubRouteTablesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type HubRouteTablesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *HubRouteTablesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *HubRouteTablesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final HubRouteTablesCreateOrUpdateResponse will be returned.
func (p *HubRouteTablesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (HubRouteTablesCreateOrUpdateResponse, error) {
	respType := HubRouteTablesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.HubRouteTable)
	if err != nil {
		return HubRouteTablesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *HubRouteTablesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// HubRouteTablesDeletePoller provides polling facilities until the operation reaches a terminal state.
type HubRouteTablesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *HubRouteTablesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *HubRouteTablesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final HubRouteTablesDeleteResponse will be returned.
func (p *HubRouteTablesDeletePoller) FinalResponse(ctx context.Context) (HubRouteTablesDeleteResponse, error) {
	respType := HubRouteTablesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return HubRouteTablesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *HubRouteTablesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// HubVirtualNetworkConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type HubVirtualNetworkConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *HubVirtualNetworkConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *HubVirtualNetworkConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final HubVirtualNetworkConnectionsCreateOrUpdateResponse will be returned.
func (p *HubVirtualNetworkConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionsCreateOrUpdateResponse, error) {
	respType := HubVirtualNetworkConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.HubVirtualNetworkConnection)
	if err != nil {
		return HubVirtualNetworkConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *HubVirtualNetworkConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// HubVirtualNetworkConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type HubVirtualNetworkConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *HubVirtualNetworkConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *HubVirtualNetworkConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final HubVirtualNetworkConnectionsDeleteResponse will be returned.
func (p *HubVirtualNetworkConnectionsDeletePoller) FinalResponse(ctx context.Context) (HubVirtualNetworkConnectionsDeleteResponse, error) {
	respType := HubVirtualNetworkConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return HubVirtualNetworkConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *HubVirtualNetworkConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPAllocationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPAllocationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPAllocationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPAllocationsCreateOrUpdateResponse will be returned.
func (p *IPAllocationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPAllocationsCreateOrUpdateResponse, error) {
	respType := IPAllocationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPAllocation)
	if err != nil {
		return IPAllocationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPAllocationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPAllocationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPAllocationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPAllocationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPAllocationsDeleteResponse will be returned.
func (p *IPAllocationsDeletePoller) FinalResponse(ctx context.Context) (IPAllocationsDeleteResponse, error) {
	respType := IPAllocationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IPAllocationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPAllocationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPGroupsCreateOrUpdateResponse will be returned.
func (p *IPGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPGroupsCreateOrUpdateResponse, error) {
	respType := IPGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPGroup)
	if err != nil {
		return IPGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPGroupsDeleteResponse will be returned.
func (p *IPGroupsDeletePoller) FinalResponse(ctx context.Context) (IPGroupsDeleteResponse, error) {
	respType := IPGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IPGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InboundNatRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InboundNatRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InboundNatRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InboundNatRulesCreateOrUpdateResponse will be returned.
func (p *InboundNatRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InboundNatRulesCreateOrUpdateResponse, error) {
	respType := InboundNatRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InboundNatRule)
	if err != nil {
		return InboundNatRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InboundNatRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InboundNatRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InboundNatRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InboundNatRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InboundNatRulesDeleteResponse will be returned.
func (p *InboundNatRulesDeletePoller) FinalResponse(ctx context.Context) (InboundNatRulesDeleteResponse, error) {
	respType := InboundNatRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InboundNatRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InboundNatRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InboundSecurityRuleCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InboundSecurityRuleCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InboundSecurityRuleCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InboundSecurityRuleCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InboundSecurityRuleCreateOrUpdateResponse will be returned.
func (p *InboundSecurityRuleCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InboundSecurityRuleCreateOrUpdateResponse, error) {
	respType := InboundSecurityRuleCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InboundSecurityRule)
	if err != nil {
		return InboundSecurityRuleCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InboundSecurityRuleCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancerBackendAddressPoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancerBackendAddressPoolsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancerBackendAddressPoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancerBackendAddressPoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancerBackendAddressPoolsCreateOrUpdateResponse will be returned.
func (p *LoadBalancerBackendAddressPoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LoadBalancerBackendAddressPoolsCreateOrUpdateResponse, error) {
	respType := LoadBalancerBackendAddressPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackendAddressPool)
	if err != nil {
		return LoadBalancerBackendAddressPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancerBackendAddressPoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancerBackendAddressPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancerBackendAddressPoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancerBackendAddressPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancerBackendAddressPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancerBackendAddressPoolsDeleteResponse will be returned.
func (p *LoadBalancerBackendAddressPoolsDeletePoller) FinalResponse(ctx context.Context) (LoadBalancerBackendAddressPoolsDeleteResponse, error) {
	respType := LoadBalancerBackendAddressPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LoadBalancerBackendAddressPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancerBackendAddressPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancersCreateOrUpdateResponse will be returned.
func (p *LoadBalancersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LoadBalancersCreateOrUpdateResponse, error) {
	respType := LoadBalancersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LoadBalancer)
	if err != nil {
		return LoadBalancersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancersDeletePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancersDeleteResponse will be returned.
func (p *LoadBalancersDeletePoller) FinalResponse(ctx context.Context) (LoadBalancersDeleteResponse, error) {
	respType := LoadBalancersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LoadBalancersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancersListInboundNatRulePortMappingsPoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersListInboundNatRulePortMappingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersListInboundNatRulePortMappingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancersListInboundNatRulePortMappingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancersListInboundNatRulePortMappingsResponse will be returned.
func (p *LoadBalancersListInboundNatRulePortMappingsPoller) FinalResponse(ctx context.Context) (LoadBalancersListInboundNatRulePortMappingsResponse, error) {
	respType := LoadBalancersListInboundNatRulePortMappingsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackendAddressInboundNatRulePortMappings)
	if err != nil {
		return LoadBalancersListInboundNatRulePortMappingsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancersListInboundNatRulePortMappingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LoadBalancersSwapPublicIPAddressesPoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersSwapPublicIPAddressesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersSwapPublicIPAddressesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LoadBalancersSwapPublicIPAddressesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LoadBalancersSwapPublicIPAddressesResponse will be returned.
func (p *LoadBalancersSwapPublicIPAddressesPoller) FinalResponse(ctx context.Context) (LoadBalancersSwapPublicIPAddressesResponse, error) {
	respType := LoadBalancersSwapPublicIPAddressesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LoadBalancersSwapPublicIPAddressesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LoadBalancersSwapPublicIPAddressesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LocalNetworkGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LocalNetworkGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LocalNetworkGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LocalNetworkGatewaysCreateOrUpdateResponse will be returned.
func (p *LocalNetworkGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LocalNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := LocalNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LocalNetworkGateway)
	if err != nil {
		return LocalNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LocalNetworkGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LocalNetworkGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LocalNetworkGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LocalNetworkGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LocalNetworkGatewaysDeleteResponse will be returned.
func (p *LocalNetworkGatewaysDeletePoller) FinalResponse(ctx context.Context) (LocalNetworkGatewaysDeleteResponse, error) {
	respType := LocalNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LocalNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LocalNetworkGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NatGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NatGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NatGatewaysCreateOrUpdateResponse will be returned.
func (p *NatGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NatGatewaysCreateOrUpdateResponse, error) {
	respType := NatGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NatGateway)
	if err != nil {
		return NatGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NatGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NatGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NatGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NatGatewaysDeleteResponse will be returned.
func (p *NatGatewaysDeletePoller) FinalResponse(ctx context.Context) (NatGatewaysDeleteResponse, error) {
	respType := NatGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NatGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NatGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NatRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NatRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NatRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NatRulesCreateOrUpdateResponse will be returned.
func (p *NatRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NatRulesCreateOrUpdateResponse, error) {
	respType := NatRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGatewayNatRule)
	if err != nil {
		return NatRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NatRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NatRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NatRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NatRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NatRulesDeleteResponse will be returned.
func (p *NatRulesDeletePoller) FinalResponse(ctx context.Context) (NatRulesDeleteResponse, error) {
	respType := NatRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NatRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NatRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfaceTapConfigurationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfaceTapConfigurationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfaceTapConfigurationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfaceTapConfigurationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfaceTapConfigurationsCreateOrUpdateResponse will be returned.
func (p *NetworkInterfaceTapConfigurationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsCreateOrUpdateResponse, error) {
	respType := NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfaceTapConfigurationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfaceTapConfigurationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfaceTapConfigurationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfaceTapConfigurationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfaceTapConfigurationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfaceTapConfigurationsDeleteResponse will be returned.
func (p *NetworkInterfaceTapConfigurationsDeletePoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsDeleteResponse, error) {
	respType := NetworkInterfaceTapConfigurationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkInterfaceTapConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfaceTapConfigurationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfacesCreateOrUpdateResponse will be returned.
func (p *NetworkInterfacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkInterfacesCreateOrUpdateResponse, error) {
	respType := NetworkInterfacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkInterface)
	if err != nil {
		return NetworkInterfacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfacesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfacesDeleteResponse will be returned.
func (p *NetworkInterfacesDeletePoller) FinalResponse(ctx context.Context) (NetworkInterfacesDeleteResponse, error) {
	respType := NetworkInterfacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkInterfacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfacesGetEffectiveRouteTablePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesGetEffectiveRouteTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfacesGetEffectiveRouteTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfacesGetEffectiveRouteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfacesGetEffectiveRouteTableResponse will be returned.
func (p *NetworkInterfacesGetEffectiveRouteTablePoller) FinalResponse(ctx context.Context) (NetworkInterfacesGetEffectiveRouteTableResponse, error) {
	respType := NetworkInterfacesGetEffectiveRouteTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EffectiveRouteListResult)
	if err != nil {
		return NetworkInterfacesGetEffectiveRouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfacesGetEffectiveRouteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse will be returned.
func (p *NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller) FinalResponse(ctx context.Context) (NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse, error) {
	respType := NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkManagementClientDeleteBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientDeleteBastionShareableLinkPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkManagementClientDeleteBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkManagementClientDeleteBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkManagementClientDeleteBastionShareableLinkResponse will be returned.
func (p *NetworkManagementClientDeleteBastionShareableLinkPoller) FinalResponse(ctx context.Context) (NetworkManagementClientDeleteBastionShareableLinkResponse, error) {
	respType := NetworkManagementClientDeleteBastionShareableLinkResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkManagementClientDeleteBastionShareableLinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkManagementClientDeleteBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse will be returned.
func (p *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) FinalResponse(ctx context.Context) (NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	respType := NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNProfileResponse)
	if err != nil {
		return NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkManagementClientGetActiveSessionsPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientGetActiveSessionsPoller struct {
	pt     *azcore.Poller
	client *NetworkManagementClient
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkManagementClientGetActiveSessionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkManagementClientGetActiveSessionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final *NetworkManagementClientGetActiveSessionsPager will be returned.
func (p *NetworkManagementClientGetActiveSessionsPoller) FinalResponse(ctx context.Context) (*NetworkManagementClientGetActiveSessionsPager, error) {
	respType := &NetworkManagementClientGetActiveSessionsPager{client: p.client}
	if _, err := p.pt.FinalResponse(ctx, &respType.current.BastionActiveSessionListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkManagementClientGetActiveSessionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkManagementClientPutBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientPutBastionShareableLinkPoller struct {
	pt     *azcore.Poller
	client *NetworkManagementClient
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkManagementClientPutBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkManagementClientPutBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final *NetworkManagementClientPutBastionShareableLinkPager will be returned.
func (p *NetworkManagementClientPutBastionShareableLinkPoller) FinalResponse(ctx context.Context) (*NetworkManagementClientPutBastionShareableLinkPager, error) {
	respType := &NetworkManagementClientPutBastionShareableLinkPager{client: p.client}
	if _, err := p.pt.FinalResponse(ctx, &respType.current.BastionShareableLinkListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkManagementClientPutBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkProfilesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkProfilesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkProfilesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkProfilesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkProfilesDeleteResponse will be returned.
func (p *NetworkProfilesDeletePoller) FinalResponse(ctx context.Context) (NetworkProfilesDeleteResponse, error) {
	respType := NetworkProfilesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkProfilesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkProfilesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkSecurityGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkSecurityGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkSecurityGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkSecurityGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkSecurityGroupsCreateOrUpdateResponse will be returned.
func (p *NetworkSecurityGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupsCreateOrUpdateResponse, error) {
	respType := NetworkSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkSecurityGroup)
	if err != nil {
		return NetworkSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkSecurityGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkSecurityGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkSecurityGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkSecurityGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkSecurityGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkSecurityGroupsDeleteResponse will be returned.
func (p *NetworkSecurityGroupsDeletePoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupsDeleteResponse, error) {
	respType := NetworkSecurityGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkSecurityGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkVirtualAppliancesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkVirtualAppliancesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkVirtualAppliancesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkVirtualAppliancesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkVirtualAppliancesCreateOrUpdateResponse will be returned.
func (p *NetworkVirtualAppliancesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkVirtualAppliancesCreateOrUpdateResponse, error) {
	respType := NetworkVirtualAppliancesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkVirtualAppliance)
	if err != nil {
		return NetworkVirtualAppliancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkVirtualAppliancesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkVirtualAppliancesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkVirtualAppliancesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkVirtualAppliancesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkVirtualAppliancesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkVirtualAppliancesDeleteResponse will be returned.
func (p *NetworkVirtualAppliancesDeletePoller) FinalResponse(ctx context.Context) (NetworkVirtualAppliancesDeleteResponse, error) {
	respType := NetworkVirtualAppliancesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkVirtualAppliancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkVirtualAppliancesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersCheckConnectivityPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersCheckConnectivityPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersCheckConnectivityPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersCheckConnectivityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersCheckConnectivityResponse will be returned.
func (p *NetworkWatchersCheckConnectivityPoller) FinalResponse(ctx context.Context) (NetworkWatchersCheckConnectivityResponse, error) {
	respType := NetworkWatchersCheckConnectivityResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectivityInformation)
	if err != nil {
		return NetworkWatchersCheckConnectivityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersCheckConnectivityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersDeleteResponse will be returned.
func (p *NetworkWatchersDeletePoller) FinalResponse(ctx context.Context) (NetworkWatchersDeleteResponse, error) {
	respType := NetworkWatchersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkWatchersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetAzureReachabilityReportPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetAzureReachabilityReportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetAzureReachabilityReportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetAzureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetAzureReachabilityReportResponse will be returned.
func (p *NetworkWatchersGetAzureReachabilityReportPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetAzureReachabilityReportResponse, error) {
	respType := NetworkWatchersGetAzureReachabilityReportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureReachabilityReport)
	if err != nil {
		return NetworkWatchersGetAzureReachabilityReportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetAzureReachabilityReportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetFlowLogStatusPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetFlowLogStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetFlowLogStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetFlowLogStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetFlowLogStatusResponse will be returned.
func (p *NetworkWatchersGetFlowLogStatusPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetFlowLogStatusResponse, error) {
	respType := NetworkWatchersGetFlowLogStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersGetFlowLogStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetFlowLogStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetNetworkConfigurationDiagnosticPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetNetworkConfigurationDiagnosticPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetNetworkConfigurationDiagnosticPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetNetworkConfigurationDiagnosticPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetNetworkConfigurationDiagnosticResponse will be returned.
func (p *NetworkWatchersGetNetworkConfigurationDiagnosticPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetNetworkConfigurationDiagnosticResponse, error) {
	respType := NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetNetworkConfigurationDiagnosticPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetNextHopPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetNextHopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetNextHopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetNextHopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetNextHopResponse will be returned.
func (p *NetworkWatchersGetNextHopPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetNextHopResponse, error) {
	respType := NetworkWatchersGetNextHopResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NextHopResult)
	if err != nil {
		return NetworkWatchersGetNextHopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetNextHopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetTroubleshootingPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetTroubleshootingPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetTroubleshootingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetTroubleshootingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetTroubleshootingResponse will be returned.
func (p *NetworkWatchersGetTroubleshootingPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetTroubleshootingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetTroubleshootingResultPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetTroubleshootingResultPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetTroubleshootingResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetTroubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetTroubleshootingResultResponse will be returned.
func (p *NetworkWatchersGetTroubleshootingResultPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResultResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResultResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetTroubleshootingResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersGetVMSecurityRulesPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetVMSecurityRulesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersGetVMSecurityRulesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersGetVMSecurityRulesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersGetVMSecurityRulesResponse will be returned.
func (p *NetworkWatchersGetVMSecurityRulesPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetVMSecurityRulesResponse, error) {
	respType := NetworkWatchersGetVMSecurityRulesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityGroupViewResult)
	if err != nil {
		return NetworkWatchersGetVMSecurityRulesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersGetVMSecurityRulesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersListAvailableProvidersPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersListAvailableProvidersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersListAvailableProvidersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersListAvailableProvidersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersListAvailableProvidersResponse will be returned.
func (p *NetworkWatchersListAvailableProvidersPoller) FinalResponse(ctx context.Context) (NetworkWatchersListAvailableProvidersResponse, error) {
	respType := NetworkWatchersListAvailableProvidersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AvailableProvidersList)
	if err != nil {
		return NetworkWatchersListAvailableProvidersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersListAvailableProvidersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersSetFlowLogConfigurationPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersSetFlowLogConfigurationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersSetFlowLogConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersSetFlowLogConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersSetFlowLogConfigurationResponse will be returned.
func (p *NetworkWatchersSetFlowLogConfigurationPoller) FinalResponse(ctx context.Context) (NetworkWatchersSetFlowLogConfigurationResponse, error) {
	respType := NetworkWatchersSetFlowLogConfigurationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersSetFlowLogConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersSetFlowLogConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NetworkWatchersVerifyIPFlowPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersVerifyIPFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NetworkWatchersVerifyIPFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NetworkWatchersVerifyIPFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NetworkWatchersVerifyIPFlowResponse will be returned.
func (p *NetworkWatchersVerifyIPFlowPoller) FinalResponse(ctx context.Context) (NetworkWatchersVerifyIPFlowResponse, error) {
	respType := NetworkWatchersVerifyIPFlowResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VerificationIPFlowResult)
	if err != nil {
		return NetworkWatchersVerifyIPFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NetworkWatchersVerifyIPFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysCreateOrUpdateResponse will be returned.
func (p *P2SVPNGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysCreateOrUpdateResponse, error) {
	respType := P2SVPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysDeleteResponse will be returned.
func (p *P2SVPNGatewaysDeletePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysDeleteResponse, error) {
	respType := P2SVPNGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return P2SVPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse will be returned.
func (p *P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse, error) {
	respType := P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGenerateVPNProfilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysGenerateVPNProfileResponse will be returned.
func (p *P2SVPNGatewaysGenerateVPNProfilePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGenerateVPNProfileResponse, error) {
	respType := P2SVPNGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNProfileResponse)
	if err != nil {
		return P2SVPNGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse will be returned.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNConnectionHealth)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGetP2SVPNConnectionHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysGetP2SVPNConnectionHealthResponse will be returned.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysGetP2SVPNConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysResetPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysResetResponse will be returned.
func (p *P2SVPNGatewaysResetPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysResetResponse, error) {
	respType := P2SVPNGatewaysResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// P2SVPNGatewaysUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *P2SVPNGatewaysUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final P2SVPNGatewaysUpdateTagsResponse will be returned.
func (p *P2SVPNGatewaysUpdateTagsPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysUpdateTagsResponse, error) {
	respType := P2SVPNGatewaysUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *P2SVPNGatewaysUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PacketCapturesCreatePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PacketCapturesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PacketCapturesCreateResponse will be returned.
func (p *PacketCapturesCreatePoller) FinalResponse(ctx context.Context) (PacketCapturesCreateResponse, error) {
	respType := PacketCapturesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PacketCaptureResult)
	if err != nil {
		return PacketCapturesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PacketCapturesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PacketCapturesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PacketCapturesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PacketCapturesDeleteResponse will be returned.
func (p *PacketCapturesDeletePoller) FinalResponse(ctx context.Context) (PacketCapturesDeleteResponse, error) {
	respType := PacketCapturesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PacketCapturesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PacketCapturesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PacketCapturesGetStatusPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesGetStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesGetStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PacketCapturesGetStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PacketCapturesGetStatusResponse will be returned.
func (p *PacketCapturesGetStatusPoller) FinalResponse(ctx context.Context) (PacketCapturesGetStatusResponse, error) {
	respType := PacketCapturesGetStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return PacketCapturesGetStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PacketCapturesGetStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PacketCapturesStopPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PacketCapturesStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PacketCapturesStopResponse will be returned.
func (p *PacketCapturesStopPoller) FinalResponse(ctx context.Context) (PacketCapturesStopResponse, error) {
	respType := PacketCapturesStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PacketCapturesStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PacketCapturesStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateDNSZoneGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateDNSZoneGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateDNSZoneGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateDNSZoneGroupsCreateOrUpdateResponse will be returned.
func (p *PrivateDNSZoneGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsCreateOrUpdateResponse, error) {
	respType := PrivateDNSZoneGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateDNSZoneGroup)
	if err != nil {
		return PrivateDNSZoneGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateDNSZoneGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateDNSZoneGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateDNSZoneGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateDNSZoneGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateDNSZoneGroupsDeleteResponse will be returned.
func (p *PrivateDNSZoneGroupsDeletePoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsDeleteResponse, error) {
	respType := PrivateDNSZoneGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateDNSZoneGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateDNSZoneGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointsCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpoint)
	if err != nil {
		return PrivateEndpointsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointsDeleteResponse will be returned.
func (p *PrivateEndpointsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointsDeleteResponse, error) {
	respType := PrivateEndpointsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse will be returned.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse will be returned.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkServicesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkServicesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkServicesCreateOrUpdateResponse will be returned.
func (p *PrivateLinkServicesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCreateOrUpdateResponse, error) {
	respType := PrivateLinkServicesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkService)
	if err != nil {
		return PrivateLinkServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkServicesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkServicesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkServicesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkServicesDeleteResponse will be returned.
func (p *PrivateLinkServicesDeletePoller) FinalResponse(ctx context.Context) (PrivateLinkServicesDeleteResponse, error) {
	respType := PrivateLinkServicesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkServicesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkServicesDeletePrivateEndpointConnectionPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesDeletePrivateEndpointConnectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesDeletePrivateEndpointConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkServicesDeletePrivateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkServicesDeletePrivateEndpointConnectionResponse will be returned.
func (p *PrivateLinkServicesDeletePrivateEndpointConnectionPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesDeletePrivateEndpointConnectionResponse, error) {
	respType := PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkServicesDeletePrivateEndpointConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PublicIPAddressesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPAddressesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PublicIPAddressesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PublicIPAddressesCreateOrUpdateResponse will be returned.
func (p *PublicIPAddressesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PublicIPAddressesCreateOrUpdateResponse, error) {
	respType := PublicIPAddressesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PublicIPAddress)
	if err != nil {
		return PublicIPAddressesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PublicIPAddressesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PublicIPAddressesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPAddressesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PublicIPAddressesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PublicIPAddressesDeleteResponse will be returned.
func (p *PublicIPAddressesDeletePoller) FinalResponse(ctx context.Context) (PublicIPAddressesDeleteResponse, error) {
	respType := PublicIPAddressesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PublicIPAddressesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PublicIPAddressesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PublicIPPrefixesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPPrefixesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PublicIPPrefixesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PublicIPPrefixesCreateOrUpdateResponse will be returned.
func (p *PublicIPPrefixesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PublicIPPrefixesCreateOrUpdateResponse, error) {
	respType := PublicIPPrefixesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PublicIPPrefix)
	if err != nil {
		return PublicIPPrefixesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PublicIPPrefixesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PublicIPPrefixesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPPrefixesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PublicIPPrefixesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PublicIPPrefixesDeleteResponse will be returned.
func (p *PublicIPPrefixesDeletePoller) FinalResponse(ctx context.Context) (PublicIPPrefixesDeleteResponse, error) {
	respType := PublicIPPrefixesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PublicIPPrefixesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PublicIPPrefixesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteFilterRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFilterRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteFilterRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteFilterRulesCreateOrUpdateResponse will be returned.
func (p *RouteFilterRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteFilterRulesCreateOrUpdateResponse, error) {
	respType := RouteFilterRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteFilterRule)
	if err != nil {
		return RouteFilterRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteFilterRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteFilterRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFilterRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteFilterRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteFilterRulesDeleteResponse will be returned.
func (p *RouteFilterRulesDeletePoller) FinalResponse(ctx context.Context) (RouteFilterRulesDeleteResponse, error) {
	respType := RouteFilterRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteFilterRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteFilterRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteFiltersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFiltersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteFiltersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteFiltersCreateOrUpdateResponse will be returned.
func (p *RouteFiltersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteFiltersCreateOrUpdateResponse, error) {
	respType := RouteFiltersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteFilter)
	if err != nil {
		return RouteFiltersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteFiltersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteFiltersDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFiltersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteFiltersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteFiltersDeleteResponse will be returned.
func (p *RouteFiltersDeletePoller) FinalResponse(ctx context.Context) (RouteFiltersDeleteResponse, error) {
	respType := RouteFiltersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteFiltersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteFiltersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteTablesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteTablesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteTablesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteTablesCreateOrUpdateResponse will be returned.
func (p *RouteTablesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteTablesCreateOrUpdateResponse, error) {
	respType := RouteTablesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteTable)
	if err != nil {
		return RouteTablesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteTablesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RouteTablesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteTablesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RouteTablesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RouteTablesDeleteResponse will be returned.
func (p *RouteTablesDeletePoller) FinalResponse(ctx context.Context) (RouteTablesDeleteResponse, error) {
	respType := RouteTablesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteTablesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RouteTablesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutesCreateOrUpdateResponse will be returned.
func (p *RoutesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RoutesCreateOrUpdateResponse, error) {
	respType := RoutesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutesDeleteResponse will be returned.
func (p *RoutesDeletePoller) FinalResponse(ctx context.Context) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RoutesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutingIntentCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutingIntentCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutingIntentCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutingIntentCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutingIntentCreateOrUpdateResponse will be returned.
func (p *RoutingIntentCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RoutingIntentCreateOrUpdateResponse, error) {
	respType := RoutingIntentCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RoutingIntent)
	if err != nil {
		return RoutingIntentCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutingIntentCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RoutingIntentDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutingIntentDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutingIntentDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RoutingIntentDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RoutingIntentDeleteResponse will be returned.
func (p *RoutingIntentDeletePoller) FinalResponse(ctx context.Context) (RoutingIntentDeleteResponse, error) {
	respType := RoutingIntentDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RoutingIntentDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RoutingIntentDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityPartnerProvidersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPartnerProvidersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityPartnerProvidersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityPartnerProvidersCreateOrUpdateResponse will be returned.
func (p *SecurityPartnerProvidersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SecurityPartnerProvidersCreateOrUpdateResponse, error) {
	respType := SecurityPartnerProvidersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPartnerProvider)
	if err != nil {
		return SecurityPartnerProvidersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityPartnerProvidersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityPartnerProvidersDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPartnerProvidersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityPartnerProvidersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityPartnerProvidersDeleteResponse will be returned.
func (p *SecurityPartnerProvidersDeletePoller) FinalResponse(ctx context.Context) (SecurityPartnerProvidersDeleteResponse, error) {
	respType := SecurityPartnerProvidersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityPartnerProvidersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityPartnerProvidersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityRulesCreateOrUpdateResponse will be returned.
func (p *SecurityRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SecurityRulesCreateOrUpdateResponse, error) {
	respType := SecurityRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityRule)
	if err != nil {
		return SecurityRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SecurityRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SecurityRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SecurityRulesDeleteResponse will be returned.
func (p *SecurityRulesDeletePoller) FinalResponse(ctx context.Context) (SecurityRulesDeleteResponse, error) {
	respType := SecurityRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SecurityRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServiceEndpointPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServiceEndpointPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServiceEndpointPoliciesCreateOrUpdateResponse will be returned.
func (p *ServiceEndpointPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServiceEndpointPoliciesCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceEndpointPolicy)
	if err != nil {
		return ServiceEndpointPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServiceEndpointPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServiceEndpointPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServiceEndpointPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServiceEndpointPoliciesDeleteResponse will be returned.
func (p *ServiceEndpointPoliciesDeletePoller) FinalResponse(ctx context.Context) (ServiceEndpointPoliciesDeleteResponse, error) {
	respType := ServiceEndpointPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServiceEndpointPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServiceEndpointPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse will be returned.
func (p *ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServiceEndpointPolicyDefinitionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPolicyDefinitionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServiceEndpointPolicyDefinitionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServiceEndpointPolicyDefinitionsDeleteResponse will be returned.
func (p *ServiceEndpointPolicyDefinitionsDeletePoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsDeleteResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServiceEndpointPolicyDefinitionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SubnetsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SubnetsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SubnetsCreateOrUpdateResponse will be returned.
func (p *SubnetsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SubnetsCreateOrUpdateResponse, error) {
	respType := SubnetsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Subnet)
	if err != nil {
		return SubnetsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SubnetsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SubnetsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SubnetsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SubnetsDeleteResponse will be returned.
func (p *SubnetsDeletePoller) FinalResponse(ctx context.Context) (SubnetsDeleteResponse, error) {
	respType := SubnetsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SubnetsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SubnetsPrepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsPrepareNetworkPoliciesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsPrepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SubnetsPrepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SubnetsPrepareNetworkPoliciesResponse will be returned.
func (p *SubnetsPrepareNetworkPoliciesPoller) FinalResponse(ctx context.Context) (SubnetsPrepareNetworkPoliciesResponse, error) {
	respType := SubnetsPrepareNetworkPoliciesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsPrepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SubnetsPrepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SubnetsUnprepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsUnprepareNetworkPoliciesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsUnprepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SubnetsUnprepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SubnetsUnprepareNetworkPoliciesResponse will be returned.
func (p *SubnetsUnprepareNetworkPoliciesPoller) FinalResponse(ctx context.Context) (SubnetsUnprepareNetworkPoliciesResponse, error) {
	respType := SubnetsUnprepareNetworkPoliciesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsUnprepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SubnetsUnprepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNConnectionsCreateOrUpdateResponse will be returned.
func (p *VPNConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNConnectionsCreateOrUpdateResponse, error) {
	respType := VPNConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNConnection)
	if err != nil {
		return VPNConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNConnectionsDeleteResponse will be returned.
func (p *VPNConnectionsDeletePoller) FinalResponse(ctx context.Context) (VPNConnectionsDeleteResponse, error) {
	respType := VPNConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNConnectionsStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNConnectionsStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNConnectionsStartPacketCaptureResponse will be returned.
func (p *VPNConnectionsStartPacketCapturePoller) FinalResponse(ctx context.Context) (VPNConnectionsStartPacketCaptureResponse, error) {
	respType := VPNConnectionsStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VPNConnectionsStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNConnectionsStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNConnectionsStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNConnectionsStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNConnectionsStopPacketCaptureResponse will be returned.
func (p *VPNConnectionsStopPacketCapturePoller) FinalResponse(ctx context.Context) (VPNConnectionsStopPacketCaptureResponse, error) {
	respType := VPNConnectionsStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VPNConnectionsStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNConnectionsStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysCreateOrUpdateResponse will be returned.
func (p *VPNGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNGatewaysCreateOrUpdateResponse, error) {
	respType := VPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysDeleteResponse will be returned.
func (p *VPNGatewaysDeletePoller) FinalResponse(ctx context.Context) (VPNGatewaysDeleteResponse, error) {
	respType := VPNGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysResetPoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysResetResponse will be returned.
func (p *VPNGatewaysResetPoller) FinalResponse(ctx context.Context) (VPNGatewaysResetResponse, error) {
	respType := VPNGatewaysResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysStartPacketCaptureResponse will be returned.
func (p *VPNGatewaysStartPacketCapturePoller) FinalResponse(ctx context.Context) (VPNGatewaysStartPacketCaptureResponse, error) {
	respType := VPNGatewaysStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VPNGatewaysStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysStopPacketCaptureResponse will be returned.
func (p *VPNGatewaysStopPacketCapturePoller) FinalResponse(ctx context.Context) (VPNGatewaysStopPacketCaptureResponse, error) {
	respType := VPNGatewaysStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VPNGatewaysStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNGatewaysUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNGatewaysUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNGatewaysUpdateTagsResponse will be returned.
func (p *VPNGatewaysUpdateTagsPoller) FinalResponse(ctx context.Context) (VPNGatewaysUpdateTagsResponse, error) {
	respType := VPNGatewaysUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNGatewaysUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNLinkConnectionsGetIkeSasPoller provides polling facilities until the operation reaches a terminal state.
type VPNLinkConnectionsGetIkeSasPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNLinkConnectionsGetIkeSasPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNLinkConnectionsGetIkeSasPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNLinkConnectionsGetIkeSasResponse will be returned.
func (p *VPNLinkConnectionsGetIkeSasPoller) FinalResponse(ctx context.Context) (VPNLinkConnectionsGetIkeSasResponse, error) {
	respType := VPNLinkConnectionsGetIkeSasResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VPNLinkConnectionsGetIkeSasResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNLinkConnectionsGetIkeSasPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNLinkConnectionsResetConnectionPoller provides polling facilities until the operation reaches a terminal state.
type VPNLinkConnectionsResetConnectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNLinkConnectionsResetConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNLinkConnectionsResetConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNLinkConnectionsResetConnectionResponse will be returned.
func (p *VPNLinkConnectionsResetConnectionPoller) FinalResponse(ctx context.Context) (VPNLinkConnectionsResetConnectionResponse, error) {
	respType := VPNLinkConnectionsResetConnectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNLinkConnectionsResetConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNLinkConnectionsResetConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNServerConfigurationsAssociatedWithVirtualWanListPoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsAssociatedWithVirtualWanListPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanListPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNServerConfigurationsAssociatedWithVirtualWanListResponse will be returned.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanListPoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsAssociatedWithVirtualWanListResponse, error) {
	respType := VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNServerConfigurationsResponse)
	if err != nil {
		return VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNServerConfigurationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNServerConfigurationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNServerConfigurationsCreateOrUpdateResponse will be returned.
func (p *VPNServerConfigurationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsCreateOrUpdateResponse, error) {
	respType := VPNServerConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNServerConfiguration)
	if err != nil {
		return VPNServerConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNServerConfigurationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNServerConfigurationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNServerConfigurationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNServerConfigurationsDeleteResponse will be returned.
func (p *VPNServerConfigurationsDeletePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsDeleteResponse, error) {
	respType := VPNServerConfigurationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNServerConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNServerConfigurationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNSitesConfigurationDownloadPoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesConfigurationDownloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesConfigurationDownloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNSitesConfigurationDownloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNSitesConfigurationDownloadResponse will be returned.
func (p *VPNSitesConfigurationDownloadPoller) FinalResponse(ctx context.Context) (VPNSitesConfigurationDownloadResponse, error) {
	respType := VPNSitesConfigurationDownloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNSitesConfigurationDownloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNSitesConfigurationDownloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNSitesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNSitesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNSitesCreateOrUpdateResponse will be returned.
func (p *VPNSitesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNSitesCreateOrUpdateResponse, error) {
	respType := VPNSitesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNSite)
	if err != nil {
		return VPNSitesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNSitesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VPNSitesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VPNSitesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VPNSitesDeleteResponse will be returned.
func (p *VPNSitesDeletePoller) FinalResponse(ctx context.Context) (VPNSitesDeleteResponse, error) {
	respType := VPNSitesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNSitesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VPNSitesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualApplianceSitesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualApplianceSitesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualApplianceSitesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualApplianceSitesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualApplianceSitesCreateOrUpdateResponse will be returned.
func (p *VirtualApplianceSitesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualApplianceSitesCreateOrUpdateResponse, error) {
	respType := VirtualApplianceSitesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualApplianceSite)
	if err != nil {
		return VirtualApplianceSitesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualApplianceSitesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualApplianceSitesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualApplianceSitesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualApplianceSitesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualApplianceSitesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualApplianceSitesDeleteResponse will be returned.
func (p *VirtualApplianceSitesDeletePoller) FinalResponse(ctx context.Context) (VirtualApplianceSitesDeleteResponse, error) {
	respType := VirtualApplianceSitesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualApplianceSitesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualApplianceSitesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubBgpConnectionCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubBgpConnectionCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubBgpConnectionCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubBgpConnectionCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubBgpConnectionCreateOrUpdateResponse will be returned.
func (p *VirtualHubBgpConnectionCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubBgpConnectionCreateOrUpdateResponse, error) {
	respType := VirtualHubBgpConnectionCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BgpConnection)
	if err != nil {
		return VirtualHubBgpConnectionCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubBgpConnectionCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubBgpConnectionDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubBgpConnectionDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubBgpConnectionDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubBgpConnectionDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubBgpConnectionDeleteResponse will be returned.
func (p *VirtualHubBgpConnectionDeletePoller) FinalResponse(ctx context.Context) (VirtualHubBgpConnectionDeleteResponse, error) {
	respType := VirtualHubBgpConnectionDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubBgpConnectionDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubBgpConnectionDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubBgpConnectionsListAdvertisedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubBgpConnectionsListAdvertisedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubBgpConnectionsListAdvertisedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubBgpConnectionsListAdvertisedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubBgpConnectionsListAdvertisedRoutesResponse will be returned.
func (p *VirtualHubBgpConnectionsListAdvertisedRoutesPoller) FinalResponse(ctx context.Context) (VirtualHubBgpConnectionsListAdvertisedRoutesResponse, error) {
	respType := VirtualHubBgpConnectionsListAdvertisedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PeerRouteList)
	if err != nil {
		return VirtualHubBgpConnectionsListAdvertisedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubBgpConnectionsListAdvertisedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubBgpConnectionsListLearnedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubBgpConnectionsListLearnedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubBgpConnectionsListLearnedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubBgpConnectionsListLearnedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubBgpConnectionsListLearnedRoutesResponse will be returned.
func (p *VirtualHubBgpConnectionsListLearnedRoutesPoller) FinalResponse(ctx context.Context) (VirtualHubBgpConnectionsListLearnedRoutesResponse, error) {
	respType := VirtualHubBgpConnectionsListLearnedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PeerRouteList)
	if err != nil {
		return VirtualHubBgpConnectionsListLearnedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubBgpConnectionsListLearnedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubIPConfigurationCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubIPConfigurationCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubIPConfigurationCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubIPConfigurationCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubIPConfigurationCreateOrUpdateResponse will be returned.
func (p *VirtualHubIPConfigurationCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubIPConfigurationCreateOrUpdateResponse, error) {
	respType := VirtualHubIPConfigurationCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.HubIPConfiguration)
	if err != nil {
		return VirtualHubIPConfigurationCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubIPConfigurationCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubIPConfigurationDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubIPConfigurationDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubIPConfigurationDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubIPConfigurationDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubIPConfigurationDeleteResponse will be returned.
func (p *VirtualHubIPConfigurationDeletePoller) FinalResponse(ctx context.Context) (VirtualHubIPConfigurationDeleteResponse, error) {
	respType := VirtualHubIPConfigurationDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubIPConfigurationDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubIPConfigurationDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubRouteTableV2SCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubRouteTableV2SCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubRouteTableV2SCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubRouteTableV2SCreateOrUpdateResponse will be returned.
func (p *VirtualHubRouteTableV2SCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SCreateOrUpdateResponse, error) {
	respType := VirtualHubRouteTableV2SCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualHubRouteTableV2)
	if err != nil {
		return VirtualHubRouteTableV2SCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubRouteTableV2SCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubRouteTableV2SDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubRouteTableV2SDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubRouteTableV2SDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubRouteTableV2SDeleteResponse will be returned.
func (p *VirtualHubRouteTableV2SDeletePoller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SDeleteResponse, error) {
	respType := VirtualHubRouteTableV2SDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubRouteTableV2SDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubRouteTableV2SDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubsCreateOrUpdateResponse will be returned.
func (p *VirtualHubsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubsCreateOrUpdateResponse, error) {
	respType := VirtualHubsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualHub)
	if err != nil {
		return VirtualHubsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubsDeleteResponse will be returned.
func (p *VirtualHubsDeletePoller) FinalResponse(ctx context.Context) (VirtualHubsDeleteResponse, error) {
	respType := VirtualHubsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualHubsGetEffectiveVirtualHubRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsGetEffectiveVirtualHubRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubsGetEffectiveVirtualHubRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualHubsGetEffectiveVirtualHubRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualHubsGetEffectiveVirtualHubRoutesResponse will be returned.
func (p *VirtualHubsGetEffectiveVirtualHubRoutesPoller) FinalResponse(ctx context.Context) (VirtualHubsGetEffectiveVirtualHubRoutesResponse, error) {
	respType := VirtualHubsGetEffectiveVirtualHubRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubsGetEffectiveVirtualHubRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualHubsGetEffectiveVirtualHubRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsDeleteResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsDeleteResponse, error) {
	respType := VirtualNetworkGatewayConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewayConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsGetIkeSasPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsGetIkeSasPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsGetIkeSasPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsGetIkeSasPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsGetIkeSasResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsGetIkeSasPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsGetIkeSasResponse, error) {
	respType := VirtualNetworkGatewayConnectionsGetIkeSasResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsGetIkeSasResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsGetIkeSasPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsResetConnectionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsResetConnectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsResetConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsResetConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsResetConnectionResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsResetConnectionPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsResetConnectionResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetConnectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewayConnectionsResetConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsResetConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsResetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsResetSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsResetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsResetSharedKeyResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsResetSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsResetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionResetSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsResetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsSetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsSetSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsSetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsSetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsSetSharedKeyResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsSetSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsSetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsSetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsStartPacketCaptureResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsStartPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsStopPacketCaptureResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsStopPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayConnectionsUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayConnectionsUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsUpdateTagsResponse will be returned.
func (p *VirtualNetworkGatewayConnectionsUpdateTagsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewayConnectionsUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayConnectionsUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayNatRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayNatRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayNatRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayNatRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayNatRulesCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkGatewayNatRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayNatRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayNatRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGatewayNatRule)
	if err != nil {
		return VirtualNetworkGatewayNatRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayNatRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewayNatRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayNatRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayNatRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewayNatRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewayNatRulesDeleteResponse will be returned.
func (p *VirtualNetworkGatewayNatRulesDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayNatRulesDeleteResponse, error) {
	respType := VirtualNetworkGatewayNatRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewayNatRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewayNatRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysDeleteResponse will be returned.
func (p *VirtualNetworkGatewaysDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDeleteResponse, error) {
	respType := VirtualNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse will be returned.
func (p *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	respType := VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGenerateVPNProfilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGenerateVPNProfileResponse will be returned.
func (p *VirtualNetworkGatewaysGenerateVPNProfilePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGenerateVPNProfileResponse, error) {
	respType := VirtualNetworkGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGeneratevpnclientpackagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGeneratevpnclientpackagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGeneratevpnclientpackagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGeneratevpnclientpackagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGeneratevpnclientpackageResponse will be returned.
func (p *VirtualNetworkGatewaysGeneratevpnclientpackagePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGeneratevpnclientpackageResponse, error) {
	respType := VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGeneratevpnclientpackagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetAdvertisedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetAdvertisedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetAdvertisedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetAdvertisedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetAdvertisedRoutesResponse will be returned.
func (p *VirtualNetworkGatewaysGetAdvertisedRoutesPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetAdvertisedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetAdvertisedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetBgpPeerStatusPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetBgpPeerStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetBgpPeerStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetBgpPeerStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetBgpPeerStatusResponse will be returned.
func (p *VirtualNetworkGatewaysGetBgpPeerStatusPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetBgpPeerStatusResponse, error) {
	respType := VirtualNetworkGatewaysGetBgpPeerStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BgpPeerStatusListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetBgpPeerStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetBgpPeerStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetLearnedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetLearnedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetLearnedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetLearnedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetLearnedRoutesResponse will be returned.
func (p *VirtualNetworkGatewaysGetLearnedRoutesPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetLearnedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetLearnedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetLearnedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetLearnedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetVPNProfilePackageURLPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVPNProfilePackageURLPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetVPNProfilePackageURLPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetVPNProfilePackageURLPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetVPNProfilePackageURLResponse will be returned.
func (p *VirtualNetworkGatewaysGetVPNProfilePackageURLPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVPNProfilePackageURLResponse, error) {
	respType := VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetVPNProfilePackageURLPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse will be returned.
func (p *VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse will be returned.
func (p *VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysResetPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysResetResponse will be returned.
func (p *VirtualNetworkGatewaysResetPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetResponse, error) {
	respType := VirtualNetworkGatewaysResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysResetVPNClientSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysResetVPNClientSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysResetVPNClientSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysResetVPNClientSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysResetVPNClientSharedKeyResponse will be returned.
func (p *VirtualNetworkGatewaysResetVPNClientSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetVPNClientSharedKeyResponse, error) {
	respType := VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysResetVPNClientSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse will be returned.
func (p *VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysStartPacketCaptureResponse will be returned.
func (p *VirtualNetworkGatewaysStartPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysStopPacketCaptureResponse will be returned.
func (p *VirtualNetworkGatewaysStopPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkGatewaysUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkGatewaysUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkGatewaysUpdateTagsResponse will be returned.
func (p *VirtualNetworkGatewaysUpdateTagsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewaysUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkGatewaysUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkPeeringsCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkPeering)
	if err != nil {
		return VirtualNetworkPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkPeeringsDeleteResponse will be returned.
func (p *VirtualNetworkPeeringsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringsDeleteResponse, error) {
	respType := VirtualNetworkPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkTapsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkTapsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkTapsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkTapsCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkTapsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkTapsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkTapsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkTap)
	if err != nil {
		return VirtualNetworkTapsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkTapsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkTapsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkTapsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkTapsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkTapsDeleteResponse will be returned.
func (p *VirtualNetworkTapsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkTapsDeleteResponse, error) {
	respType := VirtualNetworkTapsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkTapsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkTapsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworksCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworksCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworksCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworksCreateOrUpdateResponse will be returned.
func (p *VirtualNetworksCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworksCreateOrUpdateResponse, error) {
	respType := VirtualNetworksCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetwork)
	if err != nil {
		return VirtualNetworksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworksCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworksDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworksDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworksDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworksDeleteResponse will be returned.
func (p *VirtualNetworksDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworksDeleteResponse, error) {
	respType := VirtualNetworksDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworksDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworksDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualRouterPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRouterPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualRouterPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualRouterPeeringsCreateOrUpdateResponse will be returned.
func (p *VirtualRouterPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualRouterPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualRouterPeering)
	if err != nil {
		return VirtualRouterPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualRouterPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualRouterPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRouterPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualRouterPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualRouterPeeringsDeleteResponse will be returned.
func (p *VirtualRouterPeeringsDeletePoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringsDeleteResponse, error) {
	respType := VirtualRouterPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualRouterPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualRouterPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualRoutersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRoutersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualRoutersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualRoutersCreateOrUpdateResponse will be returned.
func (p *VirtualRoutersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualRoutersCreateOrUpdateResponse, error) {
	respType := VirtualRoutersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualRouter)
	if err != nil {
		return VirtualRoutersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualRoutersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualRoutersDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRoutersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualRoutersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualRoutersDeleteResponse will be returned.
func (p *VirtualRoutersDeletePoller) FinalResponse(ctx context.Context) (VirtualRoutersDeleteResponse, error) {
	respType := VirtualRoutersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualRoutersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualRoutersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualWansCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualWansCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualWansCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualWansCreateOrUpdateResponse will be returned.
func (p *VirtualWansCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualWansCreateOrUpdateResponse, error) {
	respType := VirtualWansCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualWAN)
	if err != nil {
		return VirtualWansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualWansCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualWansDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualWansDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualWansDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualWansDeleteResponse will be returned.
func (p *VirtualWansDeletePoller) FinalResponse(ctx context.Context) (VirtualWansDeleteResponse, error) {
	respType := VirtualWansDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualWansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualWansDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WebApplicationFirewallPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type WebApplicationFirewallPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WebApplicationFirewallPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WebApplicationFirewallPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WebApplicationFirewallPoliciesDeleteResponse will be returned.
func (p *WebApplicationFirewallPoliciesDeletePoller) FinalResponse(ctx context.Context) (WebApplicationFirewallPoliciesDeleteResponse, error) {
	respType := WebApplicationFirewallPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WebApplicationFirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WebApplicationFirewallPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
