//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationGatewayPrivateEndpointConnectionsDeletePollerResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.Delete.
type ApplicationGatewayPrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewayPrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewayPrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewayPrivateEndpointConnectionsDeleteResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewayPrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationGatewayPrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationGatewayPrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewayPrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewayPrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewayPrivateEndpointConnectionsDeleteResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.Delete.
type ApplicationGatewayPrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewayPrivateEndpointConnectionsGetResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.Get.
type ApplicationGatewayPrivateEndpointConnectionsGetResponse struct {
	ApplicationGatewayPrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewayPrivateEndpointConnectionsGetResult contains the result from method ApplicationGatewayPrivateEndpointConnections.Get.
type ApplicationGatewayPrivateEndpointConnectionsGetResult struct {
	ApplicationGatewayPrivateEndpointConnection
}

// ApplicationGatewayPrivateEndpointConnectionsListResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.List.
type ApplicationGatewayPrivateEndpointConnectionsListResponse struct {
	ApplicationGatewayPrivateEndpointConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewayPrivateEndpointConnectionsListResult contains the result from method ApplicationGatewayPrivateEndpointConnections.List.
type ApplicationGatewayPrivateEndpointConnectionsListResult struct {
	ApplicationGatewayPrivateEndpointConnectionListResult
}

// ApplicationGatewayPrivateEndpointConnectionsUpdatePollerResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.Update.
type ApplicationGatewayPrivateEndpointConnectionsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewayPrivateEndpointConnectionsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewayPrivateEndpointConnectionsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewayPrivateEndpointConnectionsUpdateResponse, error) {
	respType := ApplicationGatewayPrivateEndpointConnectionsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayPrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewayPrivateEndpointConnectionsUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationGatewayPrivateEndpointConnectionsUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationGatewayPrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewayPrivateEndpointConnectionsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewayPrivateEndpointConnectionsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewayPrivateEndpointConnectionsUpdateResponse contains the response from method ApplicationGatewayPrivateEndpointConnections.Update.
type ApplicationGatewayPrivateEndpointConnectionsUpdateResponse struct {
	ApplicationGatewayPrivateEndpointConnectionsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewayPrivateEndpointConnectionsUpdateResult contains the result from method ApplicationGatewayPrivateEndpointConnections.Update.
type ApplicationGatewayPrivateEndpointConnectionsUpdateResult struct {
	ApplicationGatewayPrivateEndpointConnection
}

// ApplicationGatewayPrivateLinkResourcesListResponse contains the response from method ApplicationGatewayPrivateLinkResources.List.
type ApplicationGatewayPrivateLinkResourcesListResponse struct {
	ApplicationGatewayPrivateLinkResourcesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewayPrivateLinkResourcesListResult contains the result from method ApplicationGatewayPrivateLinkResources.List.
type ApplicationGatewayPrivateLinkResourcesListResult struct {
	ApplicationGatewayPrivateLinkResourceListResult
}

// ApplicationGatewaysBackendHealthOnDemandPollerResponse contains the response from method ApplicationGateways.BackendHealthOnDemand.
type ApplicationGatewaysBackendHealthOnDemandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysBackendHealthOnDemandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysBackendHealthOnDemandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewaysBackendHealthOnDemandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysBackendHealthOnDemandPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysBackendHealthOnDemandPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealthOnDemand", token, client.pl, client.backendHealthOnDemandHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysBackendHealthOnDemandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysBackendHealthOnDemandResponse contains the response from method ApplicationGateways.BackendHealthOnDemand.
type ApplicationGatewaysBackendHealthOnDemandResponse struct {
	ApplicationGatewaysBackendHealthOnDemandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysBackendHealthOnDemandResult contains the result from method ApplicationGateways.BackendHealthOnDemand.
type ApplicationGatewaysBackendHealthOnDemandResult struct {
	ApplicationGatewayBackendHealthOnDemand
}

// ApplicationGatewaysBackendHealthPollerResponse contains the response from method ApplicationGateways.BackendHealth.
type ApplicationGatewaysBackendHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysBackendHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysBackendHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysBackendHealthResponse, error) {
	respType := ApplicationGatewaysBackendHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysBackendHealthPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysBackendHealthPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealth", token, client.pl, client.backendHealthHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysBackendHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysBackendHealthResponse contains the response from method ApplicationGateways.BackendHealth.
type ApplicationGatewaysBackendHealthResponse struct {
	ApplicationGatewaysBackendHealthResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysBackendHealthResult contains the result from method ApplicationGateways.BackendHealth.
type ApplicationGatewaysBackendHealthResult struct {
	ApplicationGatewayBackendHealth
}

// ApplicationGatewaysCreateOrUpdatePollerResponse contains the response from method ApplicationGateways.CreateOrUpdate.
type ApplicationGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysCreateOrUpdateResponse, error) {
	respType := ApplicationGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysCreateOrUpdateResponse contains the response from method ApplicationGateways.CreateOrUpdate.
type ApplicationGatewaysCreateOrUpdateResponse struct {
	ApplicationGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysCreateOrUpdateResult contains the result from method ApplicationGateways.CreateOrUpdate.
type ApplicationGatewaysCreateOrUpdateResult struct {
	ApplicationGateway
}

// ApplicationGatewaysDeletePollerResponse contains the response from method ApplicationGateways.Delete.
type ApplicationGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysDeleteResponse, error) {
	respType := ApplicationGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysDeletePollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysDeletePollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysDeleteResponse contains the response from method ApplicationGateways.Delete.
type ApplicationGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysGetResponse contains the response from method ApplicationGateways.Get.
type ApplicationGatewaysGetResponse struct {
	ApplicationGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysGetResult contains the result from method ApplicationGateways.Get.
type ApplicationGatewaysGetResult struct {
	ApplicationGateway
}

// ApplicationGatewaysGetSSLPredefinedPolicyResponse contains the response from method ApplicationGateways.GetSSLPredefinedPolicy.
type ApplicationGatewaysGetSSLPredefinedPolicyResponse struct {
	ApplicationGatewaysGetSSLPredefinedPolicyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysGetSSLPredefinedPolicyResult contains the result from method ApplicationGateways.GetSSLPredefinedPolicy.
type ApplicationGatewaysGetSSLPredefinedPolicyResult struct {
	ApplicationGatewaySSLPredefinedPolicy
}

// ApplicationGatewaysListAllResponse contains the response from method ApplicationGateways.ListAll.
type ApplicationGatewaysListAllResponse struct {
	ApplicationGatewaysListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAllResult contains the result from method ApplicationGateways.ListAll.
type ApplicationGatewaysListAllResult struct {
	ApplicationGatewayListResult
}

// ApplicationGatewaysListAvailableRequestHeadersResponse contains the response from method ApplicationGateways.ListAvailableRequestHeaders.
type ApplicationGatewaysListAvailableRequestHeadersResponse struct {
	ApplicationGatewaysListAvailableRequestHeadersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableRequestHeadersResult contains the result from method ApplicationGateways.ListAvailableRequestHeaders.
type ApplicationGatewaysListAvailableRequestHeadersResult struct {
	// Response for ApplicationGatewayAvailableRequestHeaders API service call.
	StringArray []*string
}

// ApplicationGatewaysListAvailableResponseHeadersResponse contains the response from method ApplicationGateways.ListAvailableResponseHeaders.
type ApplicationGatewaysListAvailableResponseHeadersResponse struct {
	ApplicationGatewaysListAvailableResponseHeadersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableResponseHeadersResult contains the result from method ApplicationGateways.ListAvailableResponseHeaders.
type ApplicationGatewaysListAvailableResponseHeadersResult struct {
	// Response for ApplicationGatewayAvailableResponseHeaders API service call.
	StringArray []*string
}

// ApplicationGatewaysListAvailableSSLOptionsResponse contains the response from method ApplicationGateways.ListAvailableSSLOptions.
type ApplicationGatewaysListAvailableSSLOptionsResponse struct {
	ApplicationGatewaysListAvailableSSLOptionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableSSLOptionsResult contains the result from method ApplicationGateways.ListAvailableSSLOptions.
type ApplicationGatewaysListAvailableSSLOptionsResult struct {
	ApplicationGatewayAvailableSSLOptions
}

// ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse contains the response from method ApplicationGateways.ListAvailableSSLPredefinedPolicies.
type ApplicationGatewaysListAvailableSSLPredefinedPoliciesResponse struct {
	ApplicationGatewaysListAvailableSSLPredefinedPoliciesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableSSLPredefinedPoliciesResult contains the result from method ApplicationGateways.ListAvailableSSLPredefinedPolicies.
type ApplicationGatewaysListAvailableSSLPredefinedPoliciesResult struct {
	ApplicationGatewayAvailableSSLPredefinedPolicies
}

// ApplicationGatewaysListAvailableServerVariablesResponse contains the response from method ApplicationGateways.ListAvailableServerVariables.
type ApplicationGatewaysListAvailableServerVariablesResponse struct {
	ApplicationGatewaysListAvailableServerVariablesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableServerVariablesResult contains the result from method ApplicationGateways.ListAvailableServerVariables.
type ApplicationGatewaysListAvailableServerVariablesResult struct {
	// Response for ApplicationGatewayAvailableServerVariables API service call.
	StringArray []*string
}

// ApplicationGatewaysListAvailableWafRuleSetsResponse contains the response from method ApplicationGateways.ListAvailableWafRuleSets.
type ApplicationGatewaysListAvailableWafRuleSetsResponse struct {
	ApplicationGatewaysListAvailableWafRuleSetsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListAvailableWafRuleSetsResult contains the result from method ApplicationGateways.ListAvailableWafRuleSets.
type ApplicationGatewaysListAvailableWafRuleSetsResult struct {
	ApplicationGatewayAvailableWafRuleSetsResult
}

// ApplicationGatewaysListResponse contains the response from method ApplicationGateways.List.
type ApplicationGatewaysListResponse struct {
	ApplicationGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysListResult contains the result from method ApplicationGateways.List.
type ApplicationGatewaysListResult struct {
	ApplicationGatewayListResult
}

// ApplicationGatewaysStartPollerResponse contains the response from method ApplicationGateways.Start.
type ApplicationGatewaysStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysStartResponse, error) {
	respType := ApplicationGatewaysStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysStartPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysStartPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysStartResponse contains the response from method ApplicationGateways.Start.
type ApplicationGatewaysStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysStopPollerResponse contains the response from method ApplicationGateways.Stop.
type ApplicationGatewaysStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysStopResponse, error) {
	respType := ApplicationGatewaysStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysStopPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysStopPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysStopResponse contains the response from method ApplicationGateways.Stop.
type ApplicationGatewaysStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysUpdateTagsResponse contains the response from method ApplicationGateways.UpdateTags.
type ApplicationGatewaysUpdateTagsResponse struct {
	ApplicationGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysUpdateTagsResult contains the result from method ApplicationGateways.UpdateTags.
type ApplicationGatewaysUpdateTagsResult struct {
	ApplicationGateway
}

// ApplicationSecurityGroupsCreateOrUpdatePollerResponse contains the response from method ApplicationSecurityGroups.CreateOrUpdate.
type ApplicationSecurityGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationSecurityGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationSecurityGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsCreateOrUpdateResponse, error) {
	respType := ApplicationSecurityGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationSecurityGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationSecurityGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationSecurityGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationSecurityGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationSecurityGroupsCreateOrUpdateResponse contains the response from method ApplicationSecurityGroups.CreateOrUpdate.
type ApplicationSecurityGroupsCreateOrUpdateResponse struct {
	ApplicationSecurityGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsCreateOrUpdateResult contains the result from method ApplicationSecurityGroups.CreateOrUpdate.
type ApplicationSecurityGroupsCreateOrUpdateResult struct {
	ApplicationSecurityGroup
}

// ApplicationSecurityGroupsDeletePollerResponse contains the response from method ApplicationSecurityGroups.Delete.
type ApplicationSecurityGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationSecurityGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationSecurityGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsDeleteResponse, error) {
	respType := ApplicationSecurityGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationSecurityGroupsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationSecurityGroupsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationSecurityGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationSecurityGroupsDeleteResponse contains the response from method ApplicationSecurityGroups.Delete.
type ApplicationSecurityGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsGetResponse contains the response from method ApplicationSecurityGroups.Get.
type ApplicationSecurityGroupsGetResponse struct {
	ApplicationSecurityGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsGetResult contains the result from method ApplicationSecurityGroups.Get.
type ApplicationSecurityGroupsGetResult struct {
	ApplicationSecurityGroup
}

// ApplicationSecurityGroupsListAllResponse contains the response from method ApplicationSecurityGroups.ListAll.
type ApplicationSecurityGroupsListAllResponse struct {
	ApplicationSecurityGroupsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsListAllResult contains the result from method ApplicationSecurityGroups.ListAll.
type ApplicationSecurityGroupsListAllResult struct {
	ApplicationSecurityGroupListResult
}

// ApplicationSecurityGroupsListResponse contains the response from method ApplicationSecurityGroups.List.
type ApplicationSecurityGroupsListResponse struct {
	ApplicationSecurityGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsListResult contains the result from method ApplicationSecurityGroups.List.
type ApplicationSecurityGroupsListResult struct {
	ApplicationSecurityGroupListResult
}

// ApplicationSecurityGroupsUpdateTagsResponse contains the response from method ApplicationSecurityGroups.UpdateTags.
type ApplicationSecurityGroupsUpdateTagsResponse struct {
	ApplicationSecurityGroupsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsUpdateTagsResult contains the result from method ApplicationSecurityGroups.UpdateTags.
type ApplicationSecurityGroupsUpdateTagsResult struct {
	ApplicationSecurityGroup
}

// AvailableDelegationsListResponse contains the response from method AvailableDelegations.List.
type AvailableDelegationsListResponse struct {
	AvailableDelegationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableDelegationsListResult contains the result from method AvailableDelegations.List.
type AvailableDelegationsListResult struct {
	AvailableDelegationsResult
}

// AvailableEndpointServicesListResponse contains the response from method AvailableEndpointServices.List.
type AvailableEndpointServicesListResponse struct {
	AvailableEndpointServicesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableEndpointServicesListResult contains the result from method AvailableEndpointServices.List.
type AvailableEndpointServicesListResult struct {
	EndpointServicesListResult
}

// AvailablePrivateEndpointTypesListByResourceGroupResponse contains the response from method AvailablePrivateEndpointTypes.ListByResourceGroup.
type AvailablePrivateEndpointTypesListByResourceGroupResponse struct {
	AvailablePrivateEndpointTypesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailablePrivateEndpointTypesListByResourceGroupResult contains the result from method AvailablePrivateEndpointTypes.ListByResourceGroup.
type AvailablePrivateEndpointTypesListByResourceGroupResult struct {
	AvailablePrivateEndpointTypesResult
}

// AvailablePrivateEndpointTypesListResponse contains the response from method AvailablePrivateEndpointTypes.List.
type AvailablePrivateEndpointTypesListResponse struct {
	AvailablePrivateEndpointTypesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailablePrivateEndpointTypesListResult contains the result from method AvailablePrivateEndpointTypes.List.
type AvailablePrivateEndpointTypesListResult struct {
	AvailablePrivateEndpointTypesResult
}

// AvailableResourceGroupDelegationsListResponse contains the response from method AvailableResourceGroupDelegations.List.
type AvailableResourceGroupDelegationsListResponse struct {
	AvailableResourceGroupDelegationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableResourceGroupDelegationsListResult contains the result from method AvailableResourceGroupDelegations.List.
type AvailableResourceGroupDelegationsListResult struct {
	AvailableDelegationsResult
}

// AvailableServiceAliasesListByResourceGroupResponse contains the response from method AvailableServiceAliases.ListByResourceGroup.
type AvailableServiceAliasesListByResourceGroupResponse struct {
	AvailableServiceAliasesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableServiceAliasesListByResourceGroupResult contains the result from method AvailableServiceAliases.ListByResourceGroup.
type AvailableServiceAliasesListByResourceGroupResult struct {
	AvailableServiceAliasesResult
}

// AvailableServiceAliasesListResponse contains the response from method AvailableServiceAliases.List.
type AvailableServiceAliasesListResponse struct {
	AvailableServiceAliasesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableServiceAliasesListResult contains the result from method AvailableServiceAliases.List.
type AvailableServiceAliasesListResult struct {
	AvailableServiceAliasesResult
}

// AzureFirewallFqdnTagsListAllResponse contains the response from method AzureFirewallFqdnTags.ListAll.
type AzureFirewallFqdnTagsListAllResponse struct {
	AzureFirewallFqdnTagsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallFqdnTagsListAllResult contains the result from method AzureFirewallFqdnTags.ListAll.
type AzureFirewallFqdnTagsListAllResult struct {
	AzureFirewallFqdnTagListResult
}

// AzureFirewallsCreateOrUpdatePollerResponse contains the response from method AzureFirewalls.CreateOrUpdate.
type AzureFirewallsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsCreateOrUpdateResponse, error) {
	respType := AzureFirewallsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AzureFirewallsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsCreateOrUpdateResponse contains the response from method AzureFirewalls.CreateOrUpdate.
type AzureFirewallsCreateOrUpdateResponse struct {
	AzureFirewallsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsCreateOrUpdateResult contains the result from method AzureFirewalls.CreateOrUpdate.
type AzureFirewallsCreateOrUpdateResult struct {
	AzureFirewall
}

// AzureFirewallsDeletePollerResponse contains the response from method AzureFirewalls.Delete.
type AzureFirewallsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsDeleteResponse, error) {
	respType := AzureFirewallsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsDeletePollerResponse from the provided client and resume token.
func (l *AzureFirewallsDeletePollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsDeleteResponse contains the response from method AzureFirewalls.Delete.
type AzureFirewallsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsGetResponse contains the response from method AzureFirewalls.Get.
type AzureFirewallsGetResponse struct {
	AzureFirewallsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsGetResult contains the result from method AzureFirewalls.Get.
type AzureFirewallsGetResult struct {
	AzureFirewall
}

// AzureFirewallsListAllResponse contains the response from method AzureFirewalls.ListAll.
type AzureFirewallsListAllResponse struct {
	AzureFirewallsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsListAllResult contains the result from method AzureFirewalls.ListAll.
type AzureFirewallsListAllResult struct {
	AzureFirewallListResult
}

// AzureFirewallsListResponse contains the response from method AzureFirewalls.List.
type AzureFirewallsListResponse struct {
	AzureFirewallsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsListResult contains the result from method AzureFirewalls.List.
type AzureFirewallsListResult struct {
	AzureFirewallListResult
}

// AzureFirewallsUpdateTagsPollerResponse contains the response from method AzureFirewalls.UpdateTags.
type AzureFirewallsUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsUpdateTagsResponse, error) {
	respType := AzureFirewallsUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsUpdateTagsPollerResponse from the provided client and resume token.
func (l *AzureFirewallsUpdateTagsPollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsUpdateTagsResponse contains the response from method AzureFirewalls.UpdateTags.
type AzureFirewallsUpdateTagsResponse struct {
	AzureFirewallsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsUpdateTagsResult contains the result from method AzureFirewalls.UpdateTags.
type AzureFirewallsUpdateTagsResult struct {
	AzureFirewall
}

// BastionHostsCreateOrUpdatePollerResponse contains the response from method BastionHosts.CreateOrUpdate.
type BastionHostsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BastionHostsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BastionHostsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsCreateOrUpdateResponse, error) {
	respType := BastionHostsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BastionHost)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BastionHostsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BastionHostsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BastionHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BastionHostsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &BastionHostsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BastionHostsCreateOrUpdateResponse contains the response from method BastionHosts.CreateOrUpdate.
type BastionHostsCreateOrUpdateResponse struct {
	BastionHostsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsCreateOrUpdateResult contains the result from method BastionHosts.CreateOrUpdate.
type BastionHostsCreateOrUpdateResult struct {
	BastionHost
}

// BastionHostsDeletePollerResponse contains the response from method BastionHosts.Delete.
type BastionHostsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BastionHostsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BastionHostsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsDeleteResponse, error) {
	respType := BastionHostsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BastionHostsDeletePollerResponse from the provided client and resume token.
func (l *BastionHostsDeletePollerResponse) Resume(ctx context.Context, client *BastionHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BastionHostsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &BastionHostsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BastionHostsDeleteResponse contains the response from method BastionHosts.Delete.
type BastionHostsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsGetResponse contains the response from method BastionHosts.Get.
type BastionHostsGetResponse struct {
	BastionHostsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsGetResult contains the result from method BastionHosts.Get.
type BastionHostsGetResult struct {
	BastionHost
}

// BastionHostsListByResourceGroupResponse contains the response from method BastionHosts.ListByResourceGroup.
type BastionHostsListByResourceGroupResponse struct {
	BastionHostsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsListByResourceGroupResult contains the result from method BastionHosts.ListByResourceGroup.
type BastionHostsListByResourceGroupResult struct {
	BastionHostListResult
}

// BastionHostsListResponse contains the response from method BastionHosts.List.
type BastionHostsListResponse struct {
	BastionHostsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsListResult contains the result from method BastionHosts.List.
type BastionHostsListResult struct {
	BastionHostListResult
}

// BastionHostsUpdateTagsPollerResponse contains the response from method BastionHosts.UpdateTags.
type BastionHostsUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BastionHostsUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BastionHostsUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsUpdateTagsResponse, error) {
	respType := BastionHostsUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BastionHost)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BastionHostsUpdateTagsPollerResponse from the provided client and resume token.
func (l *BastionHostsUpdateTagsPollerResponse) Resume(ctx context.Context, client *BastionHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BastionHostsClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &BastionHostsUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BastionHostsUpdateTagsResponse contains the response from method BastionHosts.UpdateTags.
type BastionHostsUpdateTagsResponse struct {
	BastionHostsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsUpdateTagsResult contains the result from method BastionHosts.UpdateTags.
type BastionHostsUpdateTagsResult struct {
	BastionHost
}

// BgpServiceCommunitiesListResponse contains the response from method BgpServiceCommunities.List.
type BgpServiceCommunitiesListResponse struct {
	BgpServiceCommunitiesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BgpServiceCommunitiesListResult contains the result from method BgpServiceCommunities.List.
type BgpServiceCommunitiesListResult struct {
	BgpServiceCommunityListResult
}

// ConnectionMonitorsCreateOrUpdatePollerResponse contains the response from method ConnectionMonitors.CreateOrUpdate.
type ConnectionMonitorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsCreateOrUpdateResponse, error) {
	respType := ConnectionMonitorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsCreateOrUpdateResponse contains the response from method ConnectionMonitors.CreateOrUpdate.
type ConnectionMonitorsCreateOrUpdateResponse struct {
	ConnectionMonitorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsCreateOrUpdateResult contains the result from method ConnectionMonitors.CreateOrUpdate.
type ConnectionMonitorsCreateOrUpdateResult struct {
	ConnectionMonitorResult
}

// ConnectionMonitorsDeletePollerResponse contains the response from method ConnectionMonitors.Delete.
type ConnectionMonitorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsDeleteResponse, error) {
	respType := ConnectionMonitorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsDeletePollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsDeletePollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsDeleteResponse contains the response from method ConnectionMonitors.Delete.
type ConnectionMonitorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsGetResponse contains the response from method ConnectionMonitors.Get.
type ConnectionMonitorsGetResponse struct {
	ConnectionMonitorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsGetResult contains the result from method ConnectionMonitors.Get.
type ConnectionMonitorsGetResult struct {
	ConnectionMonitorResult
}

// ConnectionMonitorsListResponse contains the response from method ConnectionMonitors.List.
type ConnectionMonitorsListResponse struct {
	ConnectionMonitorsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsListResult contains the result from method ConnectionMonitors.List.
type ConnectionMonitorsListResult struct {
	ConnectionMonitorListResult
}

// ConnectionMonitorsQueryPollerResponse contains the response from method ConnectionMonitors.Query.
type ConnectionMonitorsQueryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsQueryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsQueryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsQueryResponse, error) {
	respType := ConnectionMonitorsQueryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorQueryResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsQueryPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsQueryPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Query", token, client.pl, client.queryHandleError)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsQueryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsQueryResponse contains the response from method ConnectionMonitors.Query.
type ConnectionMonitorsQueryResponse struct {
	ConnectionMonitorsQueryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsQueryResult contains the result from method ConnectionMonitors.Query.
type ConnectionMonitorsQueryResult struct {
	ConnectionMonitorQueryResult
}

// ConnectionMonitorsStartPollerResponse contains the response from method ConnectionMonitors.Start.
type ConnectionMonitorsStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsStartResponse, error) {
	respType := ConnectionMonitorsStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsStartPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsStartPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsStartResponse contains the response from method ConnectionMonitors.Start.
type ConnectionMonitorsStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsStopPollerResponse contains the response from method ConnectionMonitors.Stop.
type ConnectionMonitorsStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsStopResponse, error) {
	respType := ConnectionMonitorsStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsStopPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsStopPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsStopResponse contains the response from method ConnectionMonitors.Stop.
type ConnectionMonitorsStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsUpdateTagsResponse contains the response from method ConnectionMonitors.UpdateTags.
type ConnectionMonitorsUpdateTagsResponse struct {
	ConnectionMonitorsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsUpdateTagsResult contains the result from method ConnectionMonitors.UpdateTags.
type ConnectionMonitorsUpdateTagsResult struct {
	ConnectionMonitorResult
}

// CustomIPPrefixesCreateOrUpdatePollerResponse contains the response from method CustomIPPrefixes.CreateOrUpdate.
type CustomIPPrefixesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomIPPrefixesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomIPPrefixesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomIPPrefixesCreateOrUpdateResponse, error) {
	respType := CustomIPPrefixesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomIPPrefix)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomIPPrefixesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CustomIPPrefixesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CustomIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomIPPrefixesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &CustomIPPrefixesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomIPPrefixesCreateOrUpdateResponse contains the response from method CustomIPPrefixes.CreateOrUpdate.
type CustomIPPrefixesCreateOrUpdateResponse struct {
	CustomIPPrefixesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesCreateOrUpdateResult contains the result from method CustomIPPrefixes.CreateOrUpdate.
type CustomIPPrefixesCreateOrUpdateResult struct {
	CustomIPPrefix
}

// CustomIPPrefixesDeletePollerResponse contains the response from method CustomIPPrefixes.Delete.
type CustomIPPrefixesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomIPPrefixesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomIPPrefixesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomIPPrefixesDeleteResponse, error) {
	respType := CustomIPPrefixesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a CustomIPPrefixesDeletePollerResponse from the provided client and resume token.
func (l *CustomIPPrefixesDeletePollerResponse) Resume(ctx context.Context, client *CustomIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomIPPrefixesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &CustomIPPrefixesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// CustomIPPrefixesDeleteResponse contains the response from method CustomIPPrefixes.Delete.
type CustomIPPrefixesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesGetResponse contains the response from method CustomIPPrefixes.Get.
type CustomIPPrefixesGetResponse struct {
	CustomIPPrefixesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesGetResult contains the result from method CustomIPPrefixes.Get.
type CustomIPPrefixesGetResult struct {
	CustomIPPrefix
}

// CustomIPPrefixesListAllResponse contains the response from method CustomIPPrefixes.ListAll.
type CustomIPPrefixesListAllResponse struct {
	CustomIPPrefixesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesListAllResult contains the result from method CustomIPPrefixes.ListAll.
type CustomIPPrefixesListAllResult struct {
	CustomIPPrefixListResult
}

// CustomIPPrefixesListResponse contains the response from method CustomIPPrefixes.List.
type CustomIPPrefixesListResponse struct {
	CustomIPPrefixesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesListResult contains the result from method CustomIPPrefixes.List.
type CustomIPPrefixesListResult struct {
	CustomIPPrefixListResult
}

// CustomIPPrefixesUpdateTagsResponse contains the response from method CustomIPPrefixes.UpdateTags.
type CustomIPPrefixesUpdateTagsResponse struct {
	CustomIPPrefixesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CustomIPPrefixesUpdateTagsResult contains the result from method CustomIPPrefixes.UpdateTags.
type CustomIPPrefixesUpdateTagsResult struct {
	CustomIPPrefix
}

// DdosCustomPoliciesCreateOrUpdatePollerResponse contains the response from method DdosCustomPolicies.CreateOrUpdate.
type DdosCustomPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosCustomPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosCustomPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesCreateOrUpdateResponse, error) {
	respType := DdosCustomPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DdosCustomPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosCustomPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DdosCustomPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DdosCustomPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DdosCustomPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosCustomPoliciesCreateOrUpdateResponse contains the response from method DdosCustomPolicies.CreateOrUpdate.
type DdosCustomPoliciesCreateOrUpdateResponse struct {
	DdosCustomPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesCreateOrUpdateResult contains the result from method DdosCustomPolicies.CreateOrUpdate.
type DdosCustomPoliciesCreateOrUpdateResult struct {
	DdosCustomPolicy
}

// DdosCustomPoliciesDeletePollerResponse contains the response from method DdosCustomPolicies.Delete.
type DdosCustomPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosCustomPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosCustomPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesDeleteResponse, error) {
	respType := DdosCustomPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosCustomPoliciesDeletePollerResponse from the provided client and resume token.
func (l *DdosCustomPoliciesDeletePollerResponse) Resume(ctx context.Context, client *DdosCustomPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DdosCustomPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosCustomPoliciesDeleteResponse contains the response from method DdosCustomPolicies.Delete.
type DdosCustomPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesGetResponse contains the response from method DdosCustomPolicies.Get.
type DdosCustomPoliciesGetResponse struct {
	DdosCustomPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesGetResult contains the result from method DdosCustomPolicies.Get.
type DdosCustomPoliciesGetResult struct {
	DdosCustomPolicy
}

// DdosCustomPoliciesUpdateTagsResponse contains the response from method DdosCustomPolicies.UpdateTags.
type DdosCustomPoliciesUpdateTagsResponse struct {
	DdosCustomPoliciesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesUpdateTagsResult contains the result from method DdosCustomPolicies.UpdateTags.
type DdosCustomPoliciesUpdateTagsResult struct {
	DdosCustomPolicy
}

// DdosProtectionPlansCreateOrUpdatePollerResponse contains the response from method DdosProtectionPlans.CreateOrUpdate.
type DdosProtectionPlansCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosProtectionPlansCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosProtectionPlansCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansCreateOrUpdateResponse, error) {
	respType := DdosProtectionPlansCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DdosProtectionPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosProtectionPlansCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DdosProtectionPlansCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DdosProtectionPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DdosProtectionPlansCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosProtectionPlansCreateOrUpdateResponse contains the response from method DdosProtectionPlans.CreateOrUpdate.
type DdosProtectionPlansCreateOrUpdateResponse struct {
	DdosProtectionPlansCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansCreateOrUpdateResult contains the result from method DdosProtectionPlans.CreateOrUpdate.
type DdosProtectionPlansCreateOrUpdateResult struct {
	DdosProtectionPlan
}

// DdosProtectionPlansDeletePollerResponse contains the response from method DdosProtectionPlans.Delete.
type DdosProtectionPlansDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosProtectionPlansDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosProtectionPlansDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansDeleteResponse, error) {
	respType := DdosProtectionPlansDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosProtectionPlansDeletePollerResponse from the provided client and resume token.
func (l *DdosProtectionPlansDeletePollerResponse) Resume(ctx context.Context, client *DdosProtectionPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DdosProtectionPlansDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosProtectionPlansDeleteResponse contains the response from method DdosProtectionPlans.Delete.
type DdosProtectionPlansDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansGetResponse contains the response from method DdosProtectionPlans.Get.
type DdosProtectionPlansGetResponse struct {
	DdosProtectionPlansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansGetResult contains the result from method DdosProtectionPlans.Get.
type DdosProtectionPlansGetResult struct {
	DdosProtectionPlan
}

// DdosProtectionPlansListByResourceGroupResponse contains the response from method DdosProtectionPlans.ListByResourceGroup.
type DdosProtectionPlansListByResourceGroupResponse struct {
	DdosProtectionPlansListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansListByResourceGroupResult contains the result from method DdosProtectionPlans.ListByResourceGroup.
type DdosProtectionPlansListByResourceGroupResult struct {
	DdosProtectionPlanListResult
}

// DdosProtectionPlansListResponse contains the response from method DdosProtectionPlans.List.
type DdosProtectionPlansListResponse struct {
	DdosProtectionPlansListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansListResult contains the result from method DdosProtectionPlans.List.
type DdosProtectionPlansListResult struct {
	DdosProtectionPlanListResult
}

// DdosProtectionPlansUpdateTagsResponse contains the response from method DdosProtectionPlans.UpdateTags.
type DdosProtectionPlansUpdateTagsResponse struct {
	DdosProtectionPlansUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansUpdateTagsResult contains the result from method DdosProtectionPlans.UpdateTags.
type DdosProtectionPlansUpdateTagsResult struct {
	DdosProtectionPlan
}

// DefaultSecurityRulesGetResponse contains the response from method DefaultSecurityRules.Get.
type DefaultSecurityRulesGetResponse struct {
	DefaultSecurityRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DefaultSecurityRulesGetResult contains the result from method DefaultSecurityRules.Get.
type DefaultSecurityRulesGetResult struct {
	SecurityRule
}

// DefaultSecurityRulesListResponse contains the response from method DefaultSecurityRules.List.
type DefaultSecurityRulesListResponse struct {
	DefaultSecurityRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DefaultSecurityRulesListResult contains the result from method DefaultSecurityRules.List.
type DefaultSecurityRulesListResult struct {
	SecurityRuleListResult
}

// DscpConfigurationCreateOrUpdatePollerResponse contains the response from method DscpConfiguration.CreateOrUpdate.
type DscpConfigurationCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DscpConfigurationCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DscpConfigurationCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DscpConfigurationCreateOrUpdateResponse, error) {
	respType := DscpConfigurationCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DscpConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DscpConfigurationCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DscpConfigurationCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DscpConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DscpConfigurationClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DscpConfigurationCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DscpConfigurationCreateOrUpdateResponse contains the response from method DscpConfiguration.CreateOrUpdate.
type DscpConfigurationCreateOrUpdateResponse struct {
	DscpConfigurationCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DscpConfigurationCreateOrUpdateResult contains the result from method DscpConfiguration.CreateOrUpdate.
type DscpConfigurationCreateOrUpdateResult struct {
	DscpConfiguration
}

// DscpConfigurationDeletePollerResponse contains the response from method DscpConfiguration.Delete.
type DscpConfigurationDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DscpConfigurationDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DscpConfigurationDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DscpConfigurationDeleteResponse, error) {
	respType := DscpConfigurationDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DscpConfigurationDeletePollerResponse from the provided client and resume token.
func (l *DscpConfigurationDeletePollerResponse) Resume(ctx context.Context, client *DscpConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DscpConfigurationClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DscpConfigurationDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DscpConfigurationDeleteResponse contains the response from method DscpConfiguration.Delete.
type DscpConfigurationDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DscpConfigurationGetResponse contains the response from method DscpConfiguration.Get.
type DscpConfigurationGetResponse struct {
	DscpConfigurationGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DscpConfigurationGetResult contains the result from method DscpConfiguration.Get.
type DscpConfigurationGetResult struct {
	DscpConfiguration
}

// DscpConfigurationListAllResponse contains the response from method DscpConfiguration.ListAll.
type DscpConfigurationListAllResponse struct {
	DscpConfigurationListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DscpConfigurationListAllResult contains the result from method DscpConfiguration.ListAll.
type DscpConfigurationListAllResult struct {
	DscpConfigurationListResult
}

// DscpConfigurationListResponse contains the response from method DscpConfiguration.List.
type DscpConfigurationListResponse struct {
	DscpConfigurationListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DscpConfigurationListResultEnvelope contains the result from method DscpConfiguration.List.
type DscpConfigurationListResultEnvelope struct {
	DscpConfigurationListResult
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitAuthorizations.CreateOrUpdate.
type ExpressRouteCircuitAuthorizationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitAuthorizationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitAuthorizationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitAuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse contains the response from method ExpressRouteCircuitAuthorizations.CreateOrUpdate.
type ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse struct {
	ExpressRouteCircuitAuthorizationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdateResult contains the result from method ExpressRouteCircuitAuthorizations.CreateOrUpdate.
type ExpressRouteCircuitAuthorizationsCreateOrUpdateResult struct {
	ExpressRouteCircuitAuthorization
}

// ExpressRouteCircuitAuthorizationsDeletePollerResponse contains the response from method ExpressRouteCircuitAuthorizations.Delete.
type ExpressRouteCircuitAuthorizationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitAuthorizationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitAuthorizationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsDeleteResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitAuthorizationsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitAuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitAuthorizationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitAuthorizationsDeleteResponse contains the response from method ExpressRouteCircuitAuthorizations.Delete.
type ExpressRouteCircuitAuthorizationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsGetResponse contains the response from method ExpressRouteCircuitAuthorizations.Get.
type ExpressRouteCircuitAuthorizationsGetResponse struct {
	ExpressRouteCircuitAuthorizationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsGetResult contains the result from method ExpressRouteCircuitAuthorizations.Get.
type ExpressRouteCircuitAuthorizationsGetResult struct {
	ExpressRouteCircuitAuthorization
}

// ExpressRouteCircuitAuthorizationsListResponse contains the response from method ExpressRouteCircuitAuthorizations.List.
type ExpressRouteCircuitAuthorizationsListResponse struct {
	ExpressRouteCircuitAuthorizationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsListResult contains the result from method ExpressRouteCircuitAuthorizations.List.
type ExpressRouteCircuitAuthorizationsListResult struct {
	AuthorizationListResult
}

// ExpressRouteCircuitConnectionsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitConnections.CreateOrUpdate.
type ExpressRouteCircuitConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitConnectionsCreateOrUpdateResponse contains the response from method ExpressRouteCircuitConnections.CreateOrUpdate.
type ExpressRouteCircuitConnectionsCreateOrUpdateResponse struct {
	ExpressRouteCircuitConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsCreateOrUpdateResult contains the result from method ExpressRouteCircuitConnections.CreateOrUpdate.
type ExpressRouteCircuitConnectionsCreateOrUpdateResult struct {
	ExpressRouteCircuitConnection
}

// ExpressRouteCircuitConnectionsDeletePollerResponse contains the response from method ExpressRouteCircuitConnections.Delete.
type ExpressRouteCircuitConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsDeleteResponse, error) {
	respType := ExpressRouteCircuitConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitConnectionsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitConnectionsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitConnectionsDeleteResponse contains the response from method ExpressRouteCircuitConnections.Delete.
type ExpressRouteCircuitConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsGetResponse contains the response from method ExpressRouteCircuitConnections.Get.
type ExpressRouteCircuitConnectionsGetResponse struct {
	ExpressRouteCircuitConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsGetResult contains the result from method ExpressRouteCircuitConnections.Get.
type ExpressRouteCircuitConnectionsGetResult struct {
	ExpressRouteCircuitConnection
}

// ExpressRouteCircuitConnectionsListResponse contains the response from method ExpressRouteCircuitConnections.List.
type ExpressRouteCircuitConnectionsListResponse struct {
	ExpressRouteCircuitConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsListResult contains the result from method ExpressRouteCircuitConnections.List.
type ExpressRouteCircuitConnectionsListResult struct {
	ExpressRouteCircuitConnectionListResult
}

// ExpressRouteCircuitPeeringsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitPeerings.CreateOrUpdate.
type ExpressRouteCircuitPeeringsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitPeeringsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitPeeringsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitPeeringsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitPeeringsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitPeeringsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitPeeringsCreateOrUpdateResponse contains the response from method ExpressRouteCircuitPeerings.CreateOrUpdate.
type ExpressRouteCircuitPeeringsCreateOrUpdateResponse struct {
	ExpressRouteCircuitPeeringsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsCreateOrUpdateResult contains the result from method ExpressRouteCircuitPeerings.CreateOrUpdate.
type ExpressRouteCircuitPeeringsCreateOrUpdateResult struct {
	ExpressRouteCircuitPeering
}

// ExpressRouteCircuitPeeringsDeletePollerResponse contains the response from method ExpressRouteCircuitPeerings.Delete.
type ExpressRouteCircuitPeeringsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitPeeringsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitPeeringsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsDeleteResponse, error) {
	respType := ExpressRouteCircuitPeeringsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitPeeringsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitPeeringsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitPeeringsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitPeeringsDeleteResponse contains the response from method ExpressRouteCircuitPeerings.Delete.
type ExpressRouteCircuitPeeringsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsGetResponse contains the response from method ExpressRouteCircuitPeerings.Get.
type ExpressRouteCircuitPeeringsGetResponse struct {
	ExpressRouteCircuitPeeringsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsGetResult contains the result from method ExpressRouteCircuitPeerings.Get.
type ExpressRouteCircuitPeeringsGetResult struct {
	ExpressRouteCircuitPeering
}

// ExpressRouteCircuitPeeringsListResponse contains the response from method ExpressRouteCircuitPeerings.List.
type ExpressRouteCircuitPeeringsListResponse struct {
	ExpressRouteCircuitPeeringsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsListResult contains the result from method ExpressRouteCircuitPeerings.List.
type ExpressRouteCircuitPeeringsListResult struct {
	ExpressRouteCircuitPeeringListResult
}

// ExpressRouteCircuitsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuits.CreateOrUpdate.
type ExpressRouteCircuitsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuit)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsCreateOrUpdateResponse contains the response from method ExpressRouteCircuits.CreateOrUpdate.
type ExpressRouteCircuitsCreateOrUpdateResponse struct {
	ExpressRouteCircuitsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsCreateOrUpdateResult contains the result from method ExpressRouteCircuits.CreateOrUpdate.
type ExpressRouteCircuitsCreateOrUpdateResult struct {
	ExpressRouteCircuit
}

// ExpressRouteCircuitsDeletePollerResponse contains the response from method ExpressRouteCircuits.Delete.
type ExpressRouteCircuitsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsDeleteResponse, error) {
	respType := ExpressRouteCircuitsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsDeleteResponse contains the response from method ExpressRouteCircuits.Delete.
type ExpressRouteCircuitsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsGetPeeringStatsResponse contains the response from method ExpressRouteCircuits.GetPeeringStats.
type ExpressRouteCircuitsGetPeeringStatsResponse struct {
	ExpressRouteCircuitsGetPeeringStatsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsGetPeeringStatsResult contains the result from method ExpressRouteCircuits.GetPeeringStats.
type ExpressRouteCircuitsGetPeeringStatsResult struct {
	ExpressRouteCircuitStats
}

// ExpressRouteCircuitsGetResponse contains the response from method ExpressRouteCircuits.Get.
type ExpressRouteCircuitsGetResponse struct {
	ExpressRouteCircuitsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsGetResult contains the result from method ExpressRouteCircuits.Get.
type ExpressRouteCircuitsGetResult struct {
	ExpressRouteCircuit
}

// ExpressRouteCircuitsGetStatsResponse contains the response from method ExpressRouteCircuits.GetStats.
type ExpressRouteCircuitsGetStatsResponse struct {
	ExpressRouteCircuitsGetStatsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsGetStatsResult contains the result from method ExpressRouteCircuits.GetStats.
type ExpressRouteCircuitsGetStatsResult struct {
	ExpressRouteCircuitStats
}

// ExpressRouteCircuitsListAllResponse contains the response from method ExpressRouteCircuits.ListAll.
type ExpressRouteCircuitsListAllResponse struct {
	ExpressRouteCircuitsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsListAllResult contains the result from method ExpressRouteCircuits.ListAll.
type ExpressRouteCircuitsListAllResult struct {
	ExpressRouteCircuitListResult
}

// ExpressRouteCircuitsListArpTablePollerResponse contains the response from method ExpressRouteCircuits.ListArpTable.
type ExpressRouteCircuitsListArpTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsListArpTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsListArpTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListArpTableResponse, error) {
	respType := ExpressRouteCircuitsListArpTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsListArpTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsListArpTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListArpTable", token, client.pl, client.listArpTableHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsListArpTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsListArpTableResponse contains the response from method ExpressRouteCircuits.ListArpTable.
type ExpressRouteCircuitsListArpTableResponse struct {
	ExpressRouteCircuitsListArpTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsListArpTableResult contains the result from method ExpressRouteCircuits.ListArpTable.
type ExpressRouteCircuitsListArpTableResult struct {
	ExpressRouteCircuitsArpTableListResult
}

// ExpressRouteCircuitsListResponse contains the response from method ExpressRouteCircuits.List.
type ExpressRouteCircuitsListResponse struct {
	ExpressRouteCircuitsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsListResult contains the result from method ExpressRouteCircuits.List.
type ExpressRouteCircuitsListResult struct {
	ExpressRouteCircuitListResult
}

// ExpressRouteCircuitsListRoutesTablePollerResponse contains the response from method ExpressRouteCircuits.ListRoutesTable.
type ExpressRouteCircuitsListRoutesTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsListRoutesTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsListRoutesTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListRoutesTableResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsListRoutesTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsListRoutesTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTable", token, client.pl, client.listRoutesTableHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsListRoutesTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsListRoutesTableResponse contains the response from method ExpressRouteCircuits.ListRoutesTable.
type ExpressRouteCircuitsListRoutesTableResponse struct {
	ExpressRouteCircuitsListRoutesTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsListRoutesTableResult contains the result from method ExpressRouteCircuits.ListRoutesTable.
type ExpressRouteCircuitsListRoutesTableResult struct {
	ExpressRouteCircuitsRoutesTableListResult
}

// ExpressRouteCircuitsListRoutesTableSummaryPollerResponse contains the response from method ExpressRouteCircuits.ListRoutesTableSummary.
type ExpressRouteCircuitsListRoutesTableSummaryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsListRoutesTableSummaryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsListRoutesTableSummaryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableSummaryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsListRoutesTableSummaryPollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsListRoutesTableSummaryPollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTableSummary", token, client.pl, client.listRoutesTableSummaryHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsListRoutesTableSummaryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsListRoutesTableSummaryResponse contains the response from method ExpressRouteCircuits.ListRoutesTableSummary.
type ExpressRouteCircuitsListRoutesTableSummaryResponse struct {
	ExpressRouteCircuitsListRoutesTableSummaryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsListRoutesTableSummaryResult contains the result from method ExpressRouteCircuits.ListRoutesTableSummary.
type ExpressRouteCircuitsListRoutesTableSummaryResult struct {
	ExpressRouteCircuitsRoutesTableSummaryListResult
}

// ExpressRouteCircuitsUpdateTagsResponse contains the response from method ExpressRouteCircuits.UpdateTags.
type ExpressRouteCircuitsUpdateTagsResponse struct {
	ExpressRouteCircuitsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsUpdateTagsResult contains the result from method ExpressRouteCircuits.UpdateTags.
type ExpressRouteCircuitsUpdateTagsResult struct {
	ExpressRouteCircuit
}

// ExpressRouteConnectionsCreateOrUpdatePollerResponse contains the response from method ExpressRouteConnections.CreateOrUpdate.
type ExpressRouteConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteConnectionsCreateOrUpdateResponse contains the response from method ExpressRouteConnections.CreateOrUpdate.
type ExpressRouteConnectionsCreateOrUpdateResponse struct {
	ExpressRouteConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsCreateOrUpdateResult contains the result from method ExpressRouteConnections.CreateOrUpdate.
type ExpressRouteConnectionsCreateOrUpdateResult struct {
	ExpressRouteConnection
}

// ExpressRouteConnectionsDeletePollerResponse contains the response from method ExpressRouteConnections.Delete.
type ExpressRouteConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsDeleteResponse, error) {
	respType := ExpressRouteConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteConnectionsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteConnectionsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteConnectionsDeleteResponse contains the response from method ExpressRouteConnections.Delete.
type ExpressRouteConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsGetResponse contains the response from method ExpressRouteConnections.Get.
type ExpressRouteConnectionsGetResponse struct {
	ExpressRouteConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsGetResult contains the result from method ExpressRouteConnections.Get.
type ExpressRouteConnectionsGetResult struct {
	ExpressRouteConnection
}

// ExpressRouteConnectionsListResponse contains the response from method ExpressRouteConnections.List.
type ExpressRouteConnectionsListResponse struct {
	ExpressRouteConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsListResult contains the result from method ExpressRouteConnections.List.
type ExpressRouteConnectionsListResult struct {
	ExpressRouteConnectionList
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCrossConnectionPeerings.CreateOrUpdate.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionPeeringsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionPeeringsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse contains the response from method ExpressRouteCrossConnectionPeerings.CreateOrUpdate.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse struct {
	ExpressRouteCrossConnectionPeeringsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdateResult contains the result from method ExpressRouteCrossConnectionPeerings.CreateOrUpdate.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdateResult struct {
	ExpressRouteCrossConnectionPeering
}

// ExpressRouteCrossConnectionPeeringsDeletePollerResponse contains the response from method ExpressRouteCrossConnectionPeerings.Delete.
type ExpressRouteCrossConnectionPeeringsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionPeeringsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionPeeringsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsDeleteResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionPeeringsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionPeeringsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionPeeringsDeleteResponse contains the response from method ExpressRouteCrossConnectionPeerings.Delete.
type ExpressRouteCrossConnectionPeeringsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsGetResponse contains the response from method ExpressRouteCrossConnectionPeerings.Get.
type ExpressRouteCrossConnectionPeeringsGetResponse struct {
	ExpressRouteCrossConnectionPeeringsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsGetResult contains the result from method ExpressRouteCrossConnectionPeerings.Get.
type ExpressRouteCrossConnectionPeeringsGetResult struct {
	ExpressRouteCrossConnectionPeering
}

// ExpressRouteCrossConnectionPeeringsListResponse contains the response from method ExpressRouteCrossConnectionPeerings.List.
type ExpressRouteCrossConnectionPeeringsListResponse struct {
	ExpressRouteCrossConnectionPeeringsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsListResult contains the result from method ExpressRouteCrossConnectionPeerings.List.
type ExpressRouteCrossConnectionPeeringsListResult struct {
	ExpressRouteCrossConnectionPeeringList
}

// ExpressRouteCrossConnectionsCreateOrUpdatePollerResponse contains the response from method ExpressRouteCrossConnections.CreateOrUpdate.
type ExpressRouteCrossConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsCreateOrUpdateResponse contains the response from method ExpressRouteCrossConnections.CreateOrUpdate.
type ExpressRouteCrossConnectionsCreateOrUpdateResponse struct {
	ExpressRouteCrossConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsCreateOrUpdateResult contains the result from method ExpressRouteCrossConnections.CreateOrUpdate.
type ExpressRouteCrossConnectionsCreateOrUpdateResult struct {
	ExpressRouteCrossConnection
}

// ExpressRouteCrossConnectionsGetResponse contains the response from method ExpressRouteCrossConnections.Get.
type ExpressRouteCrossConnectionsGetResponse struct {
	ExpressRouteCrossConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsGetResult contains the result from method ExpressRouteCrossConnections.Get.
type ExpressRouteCrossConnectionsGetResult struct {
	ExpressRouteCrossConnection
}

// ExpressRouteCrossConnectionsListArpTablePollerResponse contains the response from method ExpressRouteCrossConnections.ListArpTable.
type ExpressRouteCrossConnectionsListArpTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsListArpTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsListArpTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListArpTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListArpTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsListArpTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionsListArpTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListArpTable", token, client.pl, client.listArpTableHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsListArpTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsListArpTableResponse contains the response from method ExpressRouteCrossConnections.ListArpTable.
type ExpressRouteCrossConnectionsListArpTableResponse struct {
	ExpressRouteCrossConnectionsListArpTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsListArpTableResult contains the result from method ExpressRouteCrossConnections.ListArpTable.
type ExpressRouteCrossConnectionsListArpTableResult struct {
	ExpressRouteCircuitsArpTableListResult
}

// ExpressRouteCrossConnectionsListByResourceGroupResponse contains the response from method ExpressRouteCrossConnections.ListByResourceGroup.
type ExpressRouteCrossConnectionsListByResourceGroupResponse struct {
	ExpressRouteCrossConnectionsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsListByResourceGroupResult contains the result from method ExpressRouteCrossConnections.ListByResourceGroup.
type ExpressRouteCrossConnectionsListByResourceGroupResult struct {
	ExpressRouteCrossConnectionListResult
}

// ExpressRouteCrossConnectionsListResponse contains the response from method ExpressRouteCrossConnections.List.
type ExpressRouteCrossConnectionsListResponse struct {
	ExpressRouteCrossConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsListResult contains the result from method ExpressRouteCrossConnections.List.
type ExpressRouteCrossConnectionsListResult struct {
	ExpressRouteCrossConnectionListResult
}

// ExpressRouteCrossConnectionsListRoutesTablePollerResponse contains the response from method ExpressRouteCrossConnections.ListRoutesTable.
type ExpressRouteCrossConnectionsListRoutesTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsListRoutesTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsListRoutesTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListRoutesTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsListRoutesTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionsListRoutesTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTable", token, client.pl, client.listRoutesTableHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsListRoutesTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsListRoutesTableResponse contains the response from method ExpressRouteCrossConnections.ListRoutesTable.
type ExpressRouteCrossConnectionsListRoutesTableResponse struct {
	ExpressRouteCrossConnectionsListRoutesTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsListRoutesTableResult contains the result from method ExpressRouteCrossConnections.ListRoutesTable.
type ExpressRouteCrossConnectionsListRoutesTableResult struct {
	ExpressRouteCircuitsRoutesTableListResult
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryPollerResponse contains the response from method ExpressRouteCrossConnections.ListRoutesTableSummary.
type ExpressRouteCrossConnectionsListRoutesTableSummaryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsListRoutesTableSummaryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsListRoutesTableSummaryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsListRoutesTableSummaryPollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionsListRoutesTableSummaryPollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTableSummary", token, client.pl, client.listRoutesTableSummaryHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsListRoutesTableSummaryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryResponse contains the response from method ExpressRouteCrossConnections.ListRoutesTableSummary.
type ExpressRouteCrossConnectionsListRoutesTableSummaryResponse struct {
	ExpressRouteCrossConnectionsListRoutesTableSummaryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryResult contains the result from method ExpressRouteCrossConnections.ListRoutesTableSummary.
type ExpressRouteCrossConnectionsListRoutesTableSummaryResult struct {
	ExpressRouteCrossConnectionsRoutesTableSummaryListResult
}

// ExpressRouteCrossConnectionsUpdateTagsResponse contains the response from method ExpressRouteCrossConnections.UpdateTags.
type ExpressRouteCrossConnectionsUpdateTagsResponse struct {
	ExpressRouteCrossConnectionsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsUpdateTagsResult contains the result from method ExpressRouteCrossConnections.UpdateTags.
type ExpressRouteCrossConnectionsUpdateTagsResult struct {
	ExpressRouteCrossConnection
}

// ExpressRouteGatewaysCreateOrUpdatePollerResponse contains the response from method ExpressRouteGateways.CreateOrUpdate.
type ExpressRouteGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysCreateOrUpdateResponse, error) {
	respType := ExpressRouteGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteGatewaysCreateOrUpdateResponse contains the response from method ExpressRouteGateways.CreateOrUpdate.
type ExpressRouteGatewaysCreateOrUpdateResponse struct {
	ExpressRouteGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysCreateOrUpdateResult contains the result from method ExpressRouteGateways.CreateOrUpdate.
type ExpressRouteGatewaysCreateOrUpdateResult struct {
	ExpressRouteGateway
}

// ExpressRouteGatewaysDeletePollerResponse contains the response from method ExpressRouteGateways.Delete.
type ExpressRouteGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysDeleteResponse, error) {
	respType := ExpressRouteGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteGatewaysDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteGatewaysDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteGatewaysDeleteResponse contains the response from method ExpressRouteGateways.Delete.
type ExpressRouteGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysGetResponse contains the response from method ExpressRouteGateways.Get.
type ExpressRouteGatewaysGetResponse struct {
	ExpressRouteGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysGetResult contains the result from method ExpressRouteGateways.Get.
type ExpressRouteGatewaysGetResult struct {
	ExpressRouteGateway
}

// ExpressRouteGatewaysListByResourceGroupResponse contains the response from method ExpressRouteGateways.ListByResourceGroup.
type ExpressRouteGatewaysListByResourceGroupResponse struct {
	ExpressRouteGatewaysListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysListByResourceGroupResult contains the result from method ExpressRouteGateways.ListByResourceGroup.
type ExpressRouteGatewaysListByResourceGroupResult struct {
	ExpressRouteGatewayList
}

// ExpressRouteGatewaysListBySubscriptionResponse contains the response from method ExpressRouteGateways.ListBySubscription.
type ExpressRouteGatewaysListBySubscriptionResponse struct {
	ExpressRouteGatewaysListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysListBySubscriptionResult contains the result from method ExpressRouteGateways.ListBySubscription.
type ExpressRouteGatewaysListBySubscriptionResult struct {
	ExpressRouteGatewayList
}

// ExpressRouteGatewaysUpdateTagsPollerResponse contains the response from method ExpressRouteGateways.UpdateTags.
type ExpressRouteGatewaysUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteGatewaysUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteGatewaysUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysUpdateTagsResponse, error) {
	respType := ExpressRouteGatewaysUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteGatewaysUpdateTagsPollerResponse from the provided client and resume token.
func (l *ExpressRouteGatewaysUpdateTagsPollerResponse) Resume(ctx context.Context, client *ExpressRouteGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRouteGatewaysUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteGatewaysUpdateTagsResponse contains the response from method ExpressRouteGateways.UpdateTags.
type ExpressRouteGatewaysUpdateTagsResponse struct {
	ExpressRouteGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysUpdateTagsResult contains the result from method ExpressRouteGateways.UpdateTags.
type ExpressRouteGatewaysUpdateTagsResult struct {
	ExpressRouteGateway
}

// ExpressRouteLinksGetResponse contains the response from method ExpressRouteLinks.Get.
type ExpressRouteLinksGetResponse struct {
	ExpressRouteLinksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteLinksGetResult contains the result from method ExpressRouteLinks.Get.
type ExpressRouteLinksGetResult struct {
	ExpressRouteLink
}

// ExpressRouteLinksListResponse contains the response from method ExpressRouteLinks.List.
type ExpressRouteLinksListResponse struct {
	ExpressRouteLinksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteLinksListResult contains the result from method ExpressRouteLinks.List.
type ExpressRouteLinksListResult struct {
	ExpressRouteLinkListResult
}

// ExpressRoutePortsCreateOrUpdatePollerResponse contains the response from method ExpressRoutePorts.CreateOrUpdate.
type ExpressRoutePortsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRoutePortsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRoutePortsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsCreateOrUpdateResponse, error) {
	respType := ExpressRoutePortsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRoutePort)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRoutePortsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRoutePortsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRoutePortsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRoutePortsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRoutePortsCreateOrUpdateResponse contains the response from method ExpressRoutePorts.CreateOrUpdate.
type ExpressRoutePortsCreateOrUpdateResponse struct {
	ExpressRoutePortsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsCreateOrUpdateResult contains the result from method ExpressRoutePorts.CreateOrUpdate.
type ExpressRoutePortsCreateOrUpdateResult struct {
	ExpressRoutePort
}

// ExpressRoutePortsDeletePollerResponse contains the response from method ExpressRoutePorts.Delete.
type ExpressRoutePortsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRoutePortsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRoutePortsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsDeleteResponse, error) {
	respType := ExpressRoutePortsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRoutePortsDeletePollerResponse from the provided client and resume token.
func (l *ExpressRoutePortsDeletePollerResponse) Resume(ctx context.Context, client *ExpressRoutePortsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ExpressRoutePortsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRoutePortsDeleteResponse contains the response from method ExpressRoutePorts.Delete.
type ExpressRoutePortsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsGenerateLOAResponse contains the response from method ExpressRoutePorts.GenerateLOA.
type ExpressRoutePortsGenerateLOAResponse struct {
	ExpressRoutePortsGenerateLOAResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsGenerateLOAResult contains the result from method ExpressRoutePorts.GenerateLOA.
type ExpressRoutePortsGenerateLOAResult struct {
	GenerateExpressRoutePortsLOAResult
}

// ExpressRoutePortsGetResponse contains the response from method ExpressRoutePorts.Get.
type ExpressRoutePortsGetResponse struct {
	ExpressRoutePortsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsGetResult contains the result from method ExpressRoutePorts.Get.
type ExpressRoutePortsGetResult struct {
	ExpressRoutePort
}

// ExpressRoutePortsListByResourceGroupResponse contains the response from method ExpressRoutePorts.ListByResourceGroup.
type ExpressRoutePortsListByResourceGroupResponse struct {
	ExpressRoutePortsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsListByResourceGroupResult contains the result from method ExpressRoutePorts.ListByResourceGroup.
type ExpressRoutePortsListByResourceGroupResult struct {
	ExpressRoutePortListResult
}

// ExpressRoutePortsListResponse contains the response from method ExpressRoutePorts.List.
type ExpressRoutePortsListResponse struct {
	ExpressRoutePortsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsListResult contains the result from method ExpressRoutePorts.List.
type ExpressRoutePortsListResult struct {
	ExpressRoutePortListResult
}

// ExpressRoutePortsLocationsGetResponse contains the response from method ExpressRoutePortsLocations.Get.
type ExpressRoutePortsLocationsGetResponse struct {
	ExpressRoutePortsLocationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsLocationsGetResult contains the result from method ExpressRoutePortsLocations.Get.
type ExpressRoutePortsLocationsGetResult struct {
	ExpressRoutePortsLocation
}

// ExpressRoutePortsLocationsListResponse contains the response from method ExpressRoutePortsLocations.List.
type ExpressRoutePortsLocationsListResponse struct {
	ExpressRoutePortsLocationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsLocationsListResult contains the result from method ExpressRoutePortsLocations.List.
type ExpressRoutePortsLocationsListResult struct {
	ExpressRoutePortsLocationListResult
}

// ExpressRoutePortsUpdateTagsResponse contains the response from method ExpressRoutePorts.UpdateTags.
type ExpressRoutePortsUpdateTagsResponse struct {
	ExpressRoutePortsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsUpdateTagsResult contains the result from method ExpressRoutePorts.UpdateTags.
type ExpressRoutePortsUpdateTagsResult struct {
	ExpressRoutePort
}

// ExpressRouteServiceProvidersListResponse contains the response from method ExpressRouteServiceProviders.List.
type ExpressRouteServiceProvidersListResponse struct {
	ExpressRouteServiceProvidersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteServiceProvidersListResult contains the result from method ExpressRouteServiceProviders.List.
type ExpressRouteServiceProvidersListResult struct {
	ExpressRouteServiceProviderListResult
}

// FirewallPoliciesCreateOrUpdatePollerResponse contains the response from method FirewallPolicies.CreateOrUpdate.
type FirewallPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesCreateOrUpdateResponse, error) {
	respType := FirewallPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPoliciesCreateOrUpdateResponse contains the response from method FirewallPolicies.CreateOrUpdate.
type FirewallPoliciesCreateOrUpdateResponse struct {
	FirewallPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesCreateOrUpdateResult contains the result from method FirewallPolicies.CreateOrUpdate.
type FirewallPoliciesCreateOrUpdateResult struct {
	FirewallPolicy
}

// FirewallPoliciesDeletePollerResponse contains the response from method FirewallPolicies.Delete.
type FirewallPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesDeleteResponse, error) {
	respType := FirewallPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPoliciesDeletePollerResponse from the provided client and resume token.
func (l *FirewallPoliciesDeletePollerResponse) Resume(ctx context.Context, client *FirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPoliciesDeleteResponse contains the response from method FirewallPolicies.Delete.
type FirewallPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesGetResponse contains the response from method FirewallPolicies.Get.
type FirewallPoliciesGetResponse struct {
	FirewallPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesGetResult contains the result from method FirewallPolicies.Get.
type FirewallPoliciesGetResult struct {
	FirewallPolicy
}

// FirewallPoliciesListAllResponse contains the response from method FirewallPolicies.ListAll.
type FirewallPoliciesListAllResponse struct {
	FirewallPoliciesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesListAllResult contains the result from method FirewallPolicies.ListAll.
type FirewallPoliciesListAllResult struct {
	FirewallPolicyListResult
}

// FirewallPoliciesListResponse contains the response from method FirewallPolicies.List.
type FirewallPoliciesListResponse struct {
	FirewallPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesListResult contains the result from method FirewallPolicies.List.
type FirewallPoliciesListResult struct {
	FirewallPolicyListResult
}

// FirewallPolicyIdpsSignaturesFilterValuesListResponse contains the response from method FirewallPolicyIdpsSignaturesFilterValues.List.
type FirewallPolicyIdpsSignaturesFilterValuesListResponse struct {
	FirewallPolicyIdpsSignaturesFilterValuesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesFilterValuesListResult contains the result from method FirewallPolicyIdpsSignaturesFilterValues.List.
type FirewallPolicyIdpsSignaturesFilterValuesListResult struct {
	SignatureOverridesFilterValuesResponse
}

// FirewallPolicyIdpsSignaturesListResponse contains the response from method FirewallPolicyIdpsSignatures.List.
type FirewallPolicyIdpsSignaturesListResponse struct {
	FirewallPolicyIdpsSignaturesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesListResult contains the result from method FirewallPolicyIdpsSignatures.List.
type FirewallPolicyIdpsSignaturesListResult struct {
	QueryResults
}

// FirewallPolicyIdpsSignaturesOverridesGetResponse contains the response from method FirewallPolicyIdpsSignaturesOverrides.Get.
type FirewallPolicyIdpsSignaturesOverridesGetResponse struct {
	FirewallPolicyIdpsSignaturesOverridesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesOverridesGetResult contains the result from method FirewallPolicyIdpsSignaturesOverrides.Get.
type FirewallPolicyIdpsSignaturesOverridesGetResult struct {
	SignaturesOverrides
}

// FirewallPolicyIdpsSignaturesOverridesListResponse contains the response from method FirewallPolicyIdpsSignaturesOverrides.List.
type FirewallPolicyIdpsSignaturesOverridesListResponse struct {
	FirewallPolicyIdpsSignaturesOverridesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesOverridesListResult contains the result from method FirewallPolicyIdpsSignaturesOverrides.List.
type FirewallPolicyIdpsSignaturesOverridesListResult struct {
	SignaturesOverridesList
}

// FirewallPolicyIdpsSignaturesOverridesPatchResponse contains the response from method FirewallPolicyIdpsSignaturesOverrides.Patch.
type FirewallPolicyIdpsSignaturesOverridesPatchResponse struct {
	FirewallPolicyIdpsSignaturesOverridesPatchResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesOverridesPatchResult contains the result from method FirewallPolicyIdpsSignaturesOverrides.Patch.
type FirewallPolicyIdpsSignaturesOverridesPatchResult struct {
	SignaturesOverrides
}

// FirewallPolicyIdpsSignaturesOverridesPutResponse contains the response from method FirewallPolicyIdpsSignaturesOverrides.Put.
type FirewallPolicyIdpsSignaturesOverridesPutResponse struct {
	FirewallPolicyIdpsSignaturesOverridesPutResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyIdpsSignaturesOverridesPutResult contains the result from method FirewallPolicyIdpsSignaturesOverrides.Put.
type FirewallPolicyIdpsSignaturesOverridesPutResult struct {
	SignaturesOverrides
}

// FirewallPolicyRuleCollectionGroupsCreateOrUpdatePollerResponse contains the response from method FirewallPolicyRuleCollectionGroups.CreateOrUpdate.
type FirewallPolicyRuleCollectionGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPolicyRuleCollectionGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicyRuleCollectionGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPolicyRuleCollectionGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallPolicyRuleCollectionGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallPolicyRuleCollectionGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPolicyRuleCollectionGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallPolicyRuleCollectionGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse contains the response from method FirewallPolicyRuleCollectionGroups.CreateOrUpdate.
type FirewallPolicyRuleCollectionGroupsCreateOrUpdateResponse struct {
	FirewallPolicyRuleCollectionGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleCollectionGroupsCreateOrUpdateResult contains the result from method FirewallPolicyRuleCollectionGroups.CreateOrUpdate.
type FirewallPolicyRuleCollectionGroupsCreateOrUpdateResult struct {
	FirewallPolicyRuleCollectionGroup
}

// FirewallPolicyRuleCollectionGroupsDeletePollerResponse contains the response from method FirewallPolicyRuleCollectionGroups.Delete.
type FirewallPolicyRuleCollectionGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPolicyRuleCollectionGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPolicyRuleCollectionGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleCollectionGroupsDeleteResponse, error) {
	respType := FirewallPolicyRuleCollectionGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPolicyRuleCollectionGroupsDeletePollerResponse from the provided client and resume token.
func (l *FirewallPolicyRuleCollectionGroupsDeletePollerResponse) Resume(ctx context.Context, client *FirewallPolicyRuleCollectionGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPolicyRuleCollectionGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallPolicyRuleCollectionGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPolicyRuleCollectionGroupsDeleteResponse contains the response from method FirewallPolicyRuleCollectionGroups.Delete.
type FirewallPolicyRuleCollectionGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleCollectionGroupsGetResponse contains the response from method FirewallPolicyRuleCollectionGroups.Get.
type FirewallPolicyRuleCollectionGroupsGetResponse struct {
	FirewallPolicyRuleCollectionGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleCollectionGroupsGetResult contains the result from method FirewallPolicyRuleCollectionGroups.Get.
type FirewallPolicyRuleCollectionGroupsGetResult struct {
	FirewallPolicyRuleCollectionGroup
}

// FirewallPolicyRuleCollectionGroupsListResponse contains the response from method FirewallPolicyRuleCollectionGroups.List.
type FirewallPolicyRuleCollectionGroupsListResponse struct {
	FirewallPolicyRuleCollectionGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleCollectionGroupsListResult contains the result from method FirewallPolicyRuleCollectionGroups.List.
type FirewallPolicyRuleCollectionGroupsListResult struct {
	FirewallPolicyRuleCollectionGroupListResult
}

// FlowLogsCreateOrUpdatePollerResponse contains the response from method FlowLogs.CreateOrUpdate.
type FlowLogsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FlowLogsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FlowLogsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsCreateOrUpdateResponse, error) {
	respType := FlowLogsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLog)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FlowLogsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FlowLogsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FlowLogsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FlowLogsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FlowLogsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FlowLogsCreateOrUpdateResponse contains the response from method FlowLogs.CreateOrUpdate.
type FlowLogsCreateOrUpdateResponse struct {
	FlowLogsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsCreateOrUpdateResult contains the result from method FlowLogs.CreateOrUpdate.
type FlowLogsCreateOrUpdateResult struct {
	FlowLog
}

// FlowLogsDeletePollerResponse contains the response from method FlowLogs.Delete.
type FlowLogsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FlowLogsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FlowLogsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsDeleteResponse, error) {
	respType := FlowLogsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FlowLogsDeletePollerResponse from the provided client and resume token.
func (l *FlowLogsDeletePollerResponse) Resume(ctx context.Context, client *FlowLogsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FlowLogsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FlowLogsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FlowLogsDeleteResponse contains the response from method FlowLogs.Delete.
type FlowLogsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsGetResponse contains the response from method FlowLogs.Get.
type FlowLogsGetResponse struct {
	FlowLogsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsGetResult contains the result from method FlowLogs.Get.
type FlowLogsGetResult struct {
	FlowLog
}

// FlowLogsListResponse contains the response from method FlowLogs.List.
type FlowLogsListResponse struct {
	FlowLogsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsListResult contains the result from method FlowLogs.List.
type FlowLogsListResult struct {
	FlowLogListResult
}

// FlowLogsUpdateTagsResponse contains the response from method FlowLogs.UpdateTags.
type FlowLogsUpdateTagsResponse struct {
	FlowLogsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsUpdateTagsResult contains the result from method FlowLogs.UpdateTags.
type FlowLogsUpdateTagsResult struct {
	FlowLog
}

// HubRouteTablesCreateOrUpdatePollerResponse contains the response from method HubRouteTables.CreateOrUpdate.
type HubRouteTablesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HubRouteTablesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l HubRouteTablesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HubRouteTablesCreateOrUpdateResponse, error) {
	respType := HubRouteTablesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.HubRouteTable)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HubRouteTablesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *HubRouteTablesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *HubRouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("HubRouteTablesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &HubRouteTablesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HubRouteTablesCreateOrUpdateResponse contains the response from method HubRouteTables.CreateOrUpdate.
type HubRouteTablesCreateOrUpdateResponse struct {
	HubRouteTablesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubRouteTablesCreateOrUpdateResult contains the result from method HubRouteTables.CreateOrUpdate.
type HubRouteTablesCreateOrUpdateResult struct {
	HubRouteTable
}

// HubRouteTablesDeletePollerResponse contains the response from method HubRouteTables.Delete.
type HubRouteTablesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HubRouteTablesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l HubRouteTablesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HubRouteTablesDeleteResponse, error) {
	respType := HubRouteTablesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HubRouteTablesDeletePollerResponse from the provided client and resume token.
func (l *HubRouteTablesDeletePollerResponse) Resume(ctx context.Context, client *HubRouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("HubRouteTablesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &HubRouteTablesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HubRouteTablesDeleteResponse contains the response from method HubRouteTables.Delete.
type HubRouteTablesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubRouteTablesGetResponse contains the response from method HubRouteTables.Get.
type HubRouteTablesGetResponse struct {
	HubRouteTablesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubRouteTablesGetResult contains the result from method HubRouteTables.Get.
type HubRouteTablesGetResult struct {
	HubRouteTable
}

// HubRouteTablesListResponse contains the response from method HubRouteTables.List.
type HubRouteTablesListResponse struct {
	HubRouteTablesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubRouteTablesListResult contains the result from method HubRouteTables.List.
type HubRouteTablesListResult struct {
	ListHubRouteTablesResult
}

// HubVirtualNetworkConnectionsCreateOrUpdatePollerResponse contains the response from method HubVirtualNetworkConnections.CreateOrUpdate.
type HubVirtualNetworkConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HubVirtualNetworkConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l HubVirtualNetworkConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HubVirtualNetworkConnectionsCreateOrUpdateResponse, error) {
	respType := HubVirtualNetworkConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.HubVirtualNetworkConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HubVirtualNetworkConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *HubVirtualNetworkConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *HubVirtualNetworkConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("HubVirtualNetworkConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &HubVirtualNetworkConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HubVirtualNetworkConnectionsCreateOrUpdateResponse contains the response from method HubVirtualNetworkConnections.CreateOrUpdate.
type HubVirtualNetworkConnectionsCreateOrUpdateResponse struct {
	HubVirtualNetworkConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsCreateOrUpdateResult contains the result from method HubVirtualNetworkConnections.CreateOrUpdate.
type HubVirtualNetworkConnectionsCreateOrUpdateResult struct {
	HubVirtualNetworkConnection
}

// HubVirtualNetworkConnectionsDeletePollerResponse contains the response from method HubVirtualNetworkConnections.Delete.
type HubVirtualNetworkConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HubVirtualNetworkConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l HubVirtualNetworkConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HubVirtualNetworkConnectionsDeleteResponse, error) {
	respType := HubVirtualNetworkConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HubVirtualNetworkConnectionsDeletePollerResponse from the provided client and resume token.
func (l *HubVirtualNetworkConnectionsDeletePollerResponse) Resume(ctx context.Context, client *HubVirtualNetworkConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("HubVirtualNetworkConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &HubVirtualNetworkConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HubVirtualNetworkConnectionsDeleteResponse contains the response from method HubVirtualNetworkConnections.Delete.
type HubVirtualNetworkConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsGetResponse contains the response from method HubVirtualNetworkConnections.Get.
type HubVirtualNetworkConnectionsGetResponse struct {
	HubVirtualNetworkConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsGetResult contains the result from method HubVirtualNetworkConnections.Get.
type HubVirtualNetworkConnectionsGetResult struct {
	HubVirtualNetworkConnection
}

// HubVirtualNetworkConnectionsListResponse contains the response from method HubVirtualNetworkConnections.List.
type HubVirtualNetworkConnectionsListResponse struct {
	HubVirtualNetworkConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsListResult contains the result from method HubVirtualNetworkConnections.List.
type HubVirtualNetworkConnectionsListResult struct {
	ListHubVirtualNetworkConnectionsResult
}

// IPAllocationsCreateOrUpdatePollerResponse contains the response from method IPAllocations.CreateOrUpdate.
type IPAllocationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPAllocationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPAllocationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsCreateOrUpdateResponse, error) {
	respType := IPAllocationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IPAllocation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPAllocationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IPAllocationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IPAllocationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPAllocationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &IPAllocationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPAllocationsCreateOrUpdateResponse contains the response from method IPAllocations.CreateOrUpdate.
type IPAllocationsCreateOrUpdateResponse struct {
	IPAllocationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsCreateOrUpdateResult contains the result from method IPAllocations.CreateOrUpdate.
type IPAllocationsCreateOrUpdateResult struct {
	IPAllocation
}

// IPAllocationsDeletePollerResponse contains the response from method IPAllocations.Delete.
type IPAllocationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPAllocationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPAllocationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsDeleteResponse, error) {
	respType := IPAllocationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPAllocationsDeletePollerResponse from the provided client and resume token.
func (l *IPAllocationsDeletePollerResponse) Resume(ctx context.Context, client *IPAllocationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPAllocationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &IPAllocationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPAllocationsDeleteResponse contains the response from method IPAllocations.Delete.
type IPAllocationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsGetResponse contains the response from method IPAllocations.Get.
type IPAllocationsGetResponse struct {
	IPAllocationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsGetResult contains the result from method IPAllocations.Get.
type IPAllocationsGetResult struct {
	IPAllocation
}

// IPAllocationsListByResourceGroupResponse contains the response from method IPAllocations.ListByResourceGroup.
type IPAllocationsListByResourceGroupResponse struct {
	IPAllocationsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsListByResourceGroupResult contains the result from method IPAllocations.ListByResourceGroup.
type IPAllocationsListByResourceGroupResult struct {
	IPAllocationListResult
}

// IPAllocationsListResponse contains the response from method IPAllocations.List.
type IPAllocationsListResponse struct {
	IPAllocationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsListResult contains the result from method IPAllocations.List.
type IPAllocationsListResult struct {
	IPAllocationListResult
}

// IPAllocationsUpdateTagsResponse contains the response from method IPAllocations.UpdateTags.
type IPAllocationsUpdateTagsResponse struct {
	IPAllocationsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsUpdateTagsResult contains the result from method IPAllocations.UpdateTags.
type IPAllocationsUpdateTagsResult struct {
	IPAllocation
}

// IPGroupsCreateOrUpdatePollerResponse contains the response from method IPGroups.CreateOrUpdate.
type IPGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsCreateOrUpdateResponse, error) {
	respType := IPGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IPGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IPGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IPGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &IPGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPGroupsCreateOrUpdateResponse contains the response from method IPGroups.CreateOrUpdate.
type IPGroupsCreateOrUpdateResponse struct {
	IPGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsCreateOrUpdateResult contains the result from method IPGroups.CreateOrUpdate.
type IPGroupsCreateOrUpdateResult struct {
	IPGroup
}

// IPGroupsDeletePollerResponse contains the response from method IPGroups.Delete.
type IPGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsDeleteResponse, error) {
	respType := IPGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPGroupsDeletePollerResponse from the provided client and resume token.
func (l *IPGroupsDeletePollerResponse) Resume(ctx context.Context, client *IPGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &IPGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPGroupsDeleteResponse contains the response from method IPGroups.Delete.
type IPGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsGetResponse contains the response from method IPGroups.Get.
type IPGroupsGetResponse struct {
	IPGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsGetResult contains the result from method IPGroups.Get.
type IPGroupsGetResult struct {
	IPGroup
}

// IPGroupsListByResourceGroupResponse contains the response from method IPGroups.ListByResourceGroup.
type IPGroupsListByResourceGroupResponse struct {
	IPGroupsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsListByResourceGroupResult contains the result from method IPGroups.ListByResourceGroup.
type IPGroupsListByResourceGroupResult struct {
	IPGroupListResult
}

// IPGroupsListResponse contains the response from method IPGroups.List.
type IPGroupsListResponse struct {
	IPGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsListResult contains the result from method IPGroups.List.
type IPGroupsListResult struct {
	IPGroupListResult
}

// IPGroupsUpdateGroupsResponse contains the response from method IPGroups.UpdateGroups.
type IPGroupsUpdateGroupsResponse struct {
	IPGroupsUpdateGroupsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsUpdateGroupsResult contains the result from method IPGroups.UpdateGroups.
type IPGroupsUpdateGroupsResult struct {
	IPGroup
}

// InboundNatRulesCreateOrUpdatePollerResponse contains the response from method InboundNatRules.CreateOrUpdate.
type InboundNatRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InboundNatRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InboundNatRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesCreateOrUpdateResponse, error) {
	respType := InboundNatRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InboundNatRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InboundNatRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InboundNatRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InboundNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InboundNatRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &InboundNatRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InboundNatRulesCreateOrUpdateResponse contains the response from method InboundNatRules.CreateOrUpdate.
type InboundNatRulesCreateOrUpdateResponse struct {
	InboundNatRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesCreateOrUpdateResult contains the result from method InboundNatRules.CreateOrUpdate.
type InboundNatRulesCreateOrUpdateResult struct {
	InboundNatRule
}

// InboundNatRulesDeletePollerResponse contains the response from method InboundNatRules.Delete.
type InboundNatRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InboundNatRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InboundNatRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesDeleteResponse, error) {
	respType := InboundNatRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InboundNatRulesDeletePollerResponse from the provided client and resume token.
func (l *InboundNatRulesDeletePollerResponse) Resume(ctx context.Context, client *InboundNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InboundNatRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &InboundNatRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InboundNatRulesDeleteResponse contains the response from method InboundNatRules.Delete.
type InboundNatRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesGetResponse contains the response from method InboundNatRules.Get.
type InboundNatRulesGetResponse struct {
	InboundNatRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesGetResult contains the result from method InboundNatRules.Get.
type InboundNatRulesGetResult struct {
	InboundNatRule
}

// InboundNatRulesListResponse contains the response from method InboundNatRules.List.
type InboundNatRulesListResponse struct {
	InboundNatRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesListResult contains the result from method InboundNatRules.List.
type InboundNatRulesListResult struct {
	InboundNatRuleListResult
}

// InboundSecurityRuleCreateOrUpdatePollerResponse contains the response from method InboundSecurityRule.CreateOrUpdate.
type InboundSecurityRuleCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InboundSecurityRuleCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InboundSecurityRuleCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InboundSecurityRuleCreateOrUpdateResponse, error) {
	respType := InboundSecurityRuleCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InboundSecurityRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InboundSecurityRuleCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InboundSecurityRuleCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InboundSecurityRuleClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InboundSecurityRuleClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &InboundSecurityRuleCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InboundSecurityRuleCreateOrUpdateResponse contains the response from method InboundSecurityRule.CreateOrUpdate.
type InboundSecurityRuleCreateOrUpdateResponse struct {
	InboundSecurityRuleCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundSecurityRuleCreateOrUpdateResult contains the result from method InboundSecurityRule.CreateOrUpdate.
type InboundSecurityRuleCreateOrUpdateResult struct {
	InboundSecurityRule
}

// LoadBalancerBackendAddressPoolsCreateOrUpdatePollerResponse contains the response from method LoadBalancerBackendAddressPools.CreateOrUpdate.
type LoadBalancerBackendAddressPoolsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancerBackendAddressPoolsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancerBackendAddressPoolsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancerBackendAddressPoolsCreateOrUpdateResponse, error) {
	respType := LoadBalancerBackendAddressPoolsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackendAddressPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancerBackendAddressPoolsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LoadBalancerBackendAddressPoolsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LoadBalancerBackendAddressPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancerBackendAddressPoolsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancerBackendAddressPoolsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancerBackendAddressPoolsCreateOrUpdateResponse contains the response from method LoadBalancerBackendAddressPools.CreateOrUpdate.
type LoadBalancerBackendAddressPoolsCreateOrUpdateResponse struct {
	LoadBalancerBackendAddressPoolsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsCreateOrUpdateResult contains the result from method LoadBalancerBackendAddressPools.CreateOrUpdate.
type LoadBalancerBackendAddressPoolsCreateOrUpdateResult struct {
	BackendAddressPool
}

// LoadBalancerBackendAddressPoolsDeletePollerResponse contains the response from method LoadBalancerBackendAddressPools.Delete.
type LoadBalancerBackendAddressPoolsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancerBackendAddressPoolsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancerBackendAddressPoolsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancerBackendAddressPoolsDeleteResponse, error) {
	respType := LoadBalancerBackendAddressPoolsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancerBackendAddressPoolsDeletePollerResponse from the provided client and resume token.
func (l *LoadBalancerBackendAddressPoolsDeletePollerResponse) Resume(ctx context.Context, client *LoadBalancerBackendAddressPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancerBackendAddressPoolsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancerBackendAddressPoolsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancerBackendAddressPoolsDeleteResponse contains the response from method LoadBalancerBackendAddressPools.Delete.
type LoadBalancerBackendAddressPoolsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsGetResponse contains the response from method LoadBalancerBackendAddressPools.Get.
type LoadBalancerBackendAddressPoolsGetResponse struct {
	LoadBalancerBackendAddressPoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsGetResult contains the result from method LoadBalancerBackendAddressPools.Get.
type LoadBalancerBackendAddressPoolsGetResult struct {
	BackendAddressPool
}

// LoadBalancerBackendAddressPoolsListResponse contains the response from method LoadBalancerBackendAddressPools.List.
type LoadBalancerBackendAddressPoolsListResponse struct {
	LoadBalancerBackendAddressPoolsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsListResult contains the result from method LoadBalancerBackendAddressPools.List.
type LoadBalancerBackendAddressPoolsListResult struct {
	LoadBalancerBackendAddressPoolListResult
}

// LoadBalancerFrontendIPConfigurationsGetResponse contains the response from method LoadBalancerFrontendIPConfigurations.Get.
type LoadBalancerFrontendIPConfigurationsGetResponse struct {
	LoadBalancerFrontendIPConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerFrontendIPConfigurationsGetResult contains the result from method LoadBalancerFrontendIPConfigurations.Get.
type LoadBalancerFrontendIPConfigurationsGetResult struct {
	FrontendIPConfiguration
}

// LoadBalancerFrontendIPConfigurationsListResponse contains the response from method LoadBalancerFrontendIPConfigurations.List.
type LoadBalancerFrontendIPConfigurationsListResponse struct {
	LoadBalancerFrontendIPConfigurationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerFrontendIPConfigurationsListResult contains the result from method LoadBalancerFrontendIPConfigurations.List.
type LoadBalancerFrontendIPConfigurationsListResult struct {
	LoadBalancerFrontendIPConfigurationListResult
}

// LoadBalancerLoadBalancingRulesGetResponse contains the response from method LoadBalancerLoadBalancingRules.Get.
type LoadBalancerLoadBalancingRulesGetResponse struct {
	LoadBalancerLoadBalancingRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerLoadBalancingRulesGetResult contains the result from method LoadBalancerLoadBalancingRules.Get.
type LoadBalancerLoadBalancingRulesGetResult struct {
	LoadBalancingRule
}

// LoadBalancerLoadBalancingRulesListResponse contains the response from method LoadBalancerLoadBalancingRules.List.
type LoadBalancerLoadBalancingRulesListResponse struct {
	LoadBalancerLoadBalancingRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerLoadBalancingRulesListResult contains the result from method LoadBalancerLoadBalancingRules.List.
type LoadBalancerLoadBalancingRulesListResult struct {
	LoadBalancerLoadBalancingRuleListResult
}

// LoadBalancerNetworkInterfacesListResponse contains the response from method LoadBalancerNetworkInterfaces.List.
type LoadBalancerNetworkInterfacesListResponse struct {
	LoadBalancerNetworkInterfacesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerNetworkInterfacesListResult contains the result from method LoadBalancerNetworkInterfaces.List.
type LoadBalancerNetworkInterfacesListResult struct {
	NetworkInterfaceListResult
}

// LoadBalancerOutboundRulesGetResponse contains the response from method LoadBalancerOutboundRules.Get.
type LoadBalancerOutboundRulesGetResponse struct {
	LoadBalancerOutboundRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerOutboundRulesGetResult contains the result from method LoadBalancerOutboundRules.Get.
type LoadBalancerOutboundRulesGetResult struct {
	OutboundRule
}

// LoadBalancerOutboundRulesListResponse contains the response from method LoadBalancerOutboundRules.List.
type LoadBalancerOutboundRulesListResponse struct {
	LoadBalancerOutboundRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerOutboundRulesListResult contains the result from method LoadBalancerOutboundRules.List.
type LoadBalancerOutboundRulesListResult struct {
	LoadBalancerOutboundRuleListResult
}

// LoadBalancerProbesGetResponse contains the response from method LoadBalancerProbes.Get.
type LoadBalancerProbesGetResponse struct {
	LoadBalancerProbesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerProbesGetResult contains the result from method LoadBalancerProbes.Get.
type LoadBalancerProbesGetResult struct {
	Probe
}

// LoadBalancerProbesListResponse contains the response from method LoadBalancerProbes.List.
type LoadBalancerProbesListResponse struct {
	LoadBalancerProbesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerProbesListResult contains the result from method LoadBalancerProbes.List.
type LoadBalancerProbesListResult struct {
	LoadBalancerProbeListResult
}

// LoadBalancersCreateOrUpdatePollerResponse contains the response from method LoadBalancers.CreateOrUpdate.
type LoadBalancersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersCreateOrUpdateResponse, error) {
	respType := LoadBalancersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LoadBalancer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LoadBalancersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersCreateOrUpdateResponse contains the response from method LoadBalancers.CreateOrUpdate.
type LoadBalancersCreateOrUpdateResponse struct {
	LoadBalancersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersCreateOrUpdateResult contains the result from method LoadBalancers.CreateOrUpdate.
type LoadBalancersCreateOrUpdateResult struct {
	LoadBalancer
}

// LoadBalancersDeletePollerResponse contains the response from method LoadBalancers.Delete.
type LoadBalancersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersDeleteResponse, error) {
	respType := LoadBalancersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersDeletePollerResponse from the provided client and resume token.
func (l *LoadBalancersDeletePollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersDeleteResponse contains the response from method LoadBalancers.Delete.
type LoadBalancersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersGetResponse contains the response from method LoadBalancers.Get.
type LoadBalancersGetResponse struct {
	LoadBalancersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersGetResult contains the result from method LoadBalancers.Get.
type LoadBalancersGetResult struct {
	LoadBalancer
}

// LoadBalancersListAllResponse contains the response from method LoadBalancers.ListAll.
type LoadBalancersListAllResponse struct {
	LoadBalancersListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersListAllResult contains the result from method LoadBalancers.ListAll.
type LoadBalancersListAllResult struct {
	LoadBalancerListResult
}

// LoadBalancersListInboundNatRulePortMappingsPollerResponse contains the response from method LoadBalancers.ListInboundNatRulePortMappings.
type LoadBalancersListInboundNatRulePortMappingsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersListInboundNatRulePortMappingsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersListInboundNatRulePortMappingsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersListInboundNatRulePortMappingsResponse, error) {
	respType := LoadBalancersListInboundNatRulePortMappingsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackendAddressInboundNatRulePortMappings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersListInboundNatRulePortMappingsPollerResponse from the provided client and resume token.
func (l *LoadBalancersListInboundNatRulePortMappingsPollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.ListInboundNatRulePortMappings", token, client.pl, client.listInboundNatRulePortMappingsHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancersListInboundNatRulePortMappingsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersListInboundNatRulePortMappingsResponse contains the response from method LoadBalancers.ListInboundNatRulePortMappings.
type LoadBalancersListInboundNatRulePortMappingsResponse struct {
	LoadBalancersListInboundNatRulePortMappingsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersListInboundNatRulePortMappingsResult contains the result from method LoadBalancers.ListInboundNatRulePortMappings.
type LoadBalancersListInboundNatRulePortMappingsResult struct {
	BackendAddressInboundNatRulePortMappings
}

// LoadBalancersListResponse contains the response from method LoadBalancers.List.
type LoadBalancersListResponse struct {
	LoadBalancersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersListResult contains the result from method LoadBalancers.List.
type LoadBalancersListResult struct {
	LoadBalancerListResult
}

// LoadBalancersSwapPublicIPAddressesPollerResponse contains the response from method LoadBalancers.SwapPublicIPAddresses.
type LoadBalancersSwapPublicIPAddressesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersSwapPublicIPAddressesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersSwapPublicIPAddressesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersSwapPublicIPAddressesResponse, error) {
	respType := LoadBalancersSwapPublicIPAddressesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersSwapPublicIPAddressesPollerResponse from the provided client and resume token.
func (l *LoadBalancersSwapPublicIPAddressesPollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.SwapPublicIPAddresses", token, client.pl, client.swapPublicIPAddressesHandleError)
	if err != nil {
		return err
	}
	poller := &LoadBalancersSwapPublicIPAddressesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersSwapPublicIPAddressesResponse contains the response from method LoadBalancers.SwapPublicIPAddresses.
type LoadBalancersSwapPublicIPAddressesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersUpdateTagsResponse contains the response from method LoadBalancers.UpdateTags.
type LoadBalancersUpdateTagsResponse struct {
	LoadBalancersUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersUpdateTagsResult contains the result from method LoadBalancers.UpdateTags.
type LoadBalancersUpdateTagsResult struct {
	LoadBalancer
}

// LocalNetworkGatewaysCreateOrUpdatePollerResponse contains the response from method LocalNetworkGateways.CreateOrUpdate.
type LocalNetworkGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LocalNetworkGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LocalNetworkGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := LocalNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LocalNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LocalNetworkGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LocalNetworkGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LocalNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LocalNetworkGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LocalNetworkGatewaysCreateOrUpdateResponse contains the response from method LocalNetworkGateways.CreateOrUpdate.
type LocalNetworkGatewaysCreateOrUpdateResponse struct {
	LocalNetworkGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysCreateOrUpdateResult contains the result from method LocalNetworkGateways.CreateOrUpdate.
type LocalNetworkGatewaysCreateOrUpdateResult struct {
	LocalNetworkGateway
}

// LocalNetworkGatewaysDeletePollerResponse contains the response from method LocalNetworkGateways.Delete.
type LocalNetworkGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LocalNetworkGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LocalNetworkGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysDeleteResponse, error) {
	respType := LocalNetworkGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LocalNetworkGatewaysDeletePollerResponse from the provided client and resume token.
func (l *LocalNetworkGatewaysDeletePollerResponse) Resume(ctx context.Context, client *LocalNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LocalNetworkGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LocalNetworkGatewaysDeleteResponse contains the response from method LocalNetworkGateways.Delete.
type LocalNetworkGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysGetResponse contains the response from method LocalNetworkGateways.Get.
type LocalNetworkGatewaysGetResponse struct {
	LocalNetworkGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysGetResult contains the result from method LocalNetworkGateways.Get.
type LocalNetworkGatewaysGetResult struct {
	LocalNetworkGateway
}

// LocalNetworkGatewaysListResponse contains the response from method LocalNetworkGateways.List.
type LocalNetworkGatewaysListResponse struct {
	LocalNetworkGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysListResult contains the result from method LocalNetworkGateways.List.
type LocalNetworkGatewaysListResult struct {
	LocalNetworkGatewayListResult
}

// LocalNetworkGatewaysUpdateTagsResponse contains the response from method LocalNetworkGateways.UpdateTags.
type LocalNetworkGatewaysUpdateTagsResponse struct {
	LocalNetworkGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysUpdateTagsResult contains the result from method LocalNetworkGateways.UpdateTags.
type LocalNetworkGatewaysUpdateTagsResult struct {
	LocalNetworkGateway
}

// NatGatewaysCreateOrUpdatePollerResponse contains the response from method NatGateways.CreateOrUpdate.
type NatGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysCreateOrUpdateResponse, error) {
	respType := NatGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NatGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NatGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NatGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NatGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatGatewaysCreateOrUpdateResponse contains the response from method NatGateways.CreateOrUpdate.
type NatGatewaysCreateOrUpdateResponse struct {
	NatGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysCreateOrUpdateResult contains the result from method NatGateways.CreateOrUpdate.
type NatGatewaysCreateOrUpdateResult struct {
	NatGateway
}

// NatGatewaysDeletePollerResponse contains the response from method NatGateways.Delete.
type NatGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysDeleteResponse, error) {
	respType := NatGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatGatewaysDeletePollerResponse from the provided client and resume token.
func (l *NatGatewaysDeletePollerResponse) Resume(ctx context.Context, client *NatGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NatGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatGatewaysDeleteResponse contains the response from method NatGateways.Delete.
type NatGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysGetResponse contains the response from method NatGateways.Get.
type NatGatewaysGetResponse struct {
	NatGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysGetResult contains the result from method NatGateways.Get.
type NatGatewaysGetResult struct {
	NatGateway
}

// NatGatewaysListAllResponse contains the response from method NatGateways.ListAll.
type NatGatewaysListAllResponse struct {
	NatGatewaysListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysListAllResult contains the result from method NatGateways.ListAll.
type NatGatewaysListAllResult struct {
	NatGatewayListResult
}

// NatGatewaysListResponse contains the response from method NatGateways.List.
type NatGatewaysListResponse struct {
	NatGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysListResult contains the result from method NatGateways.List.
type NatGatewaysListResult struct {
	NatGatewayListResult
}

// NatGatewaysUpdateTagsResponse contains the response from method NatGateways.UpdateTags.
type NatGatewaysUpdateTagsResponse struct {
	NatGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysUpdateTagsResult contains the result from method NatGateways.UpdateTags.
type NatGatewaysUpdateTagsResult struct {
	NatGateway
}

// NatRulesCreateOrUpdatePollerResponse contains the response from method NatRules.CreateOrUpdate.
type NatRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatRulesCreateOrUpdateResponse, error) {
	respType := NatRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGatewayNatRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NatRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NatRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatRulesCreateOrUpdateResponse contains the response from method NatRules.CreateOrUpdate.
type NatRulesCreateOrUpdateResponse struct {
	NatRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatRulesCreateOrUpdateResult contains the result from method NatRules.CreateOrUpdate.
type NatRulesCreateOrUpdateResult struct {
	VPNGatewayNatRule
}

// NatRulesDeletePollerResponse contains the response from method NatRules.Delete.
type NatRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatRulesDeleteResponse, error) {
	respType := NatRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatRulesDeletePollerResponse from the provided client and resume token.
func (l *NatRulesDeletePollerResponse) Resume(ctx context.Context, client *NatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NatRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatRulesDeleteResponse contains the response from method NatRules.Delete.
type NatRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatRulesGetResponse contains the response from method NatRules.Get.
type NatRulesGetResponse struct {
	NatRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatRulesGetResult contains the result from method NatRules.Get.
type NatRulesGetResult struct {
	VPNGatewayNatRule
}

// NatRulesListByVPNGatewayResponse contains the response from method NatRules.ListByVPNGateway.
type NatRulesListByVPNGatewayResponse struct {
	NatRulesListByVPNGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatRulesListByVPNGatewayResult contains the result from method NatRules.ListByVPNGateway.
type NatRulesListByVPNGatewayResult struct {
	ListVPNGatewayNatRulesResult
}

// NetworkInterfaceIPConfigurationsGetResponse contains the response from method NetworkInterfaceIPConfigurations.Get.
type NetworkInterfaceIPConfigurationsGetResponse struct {
	NetworkInterfaceIPConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceIPConfigurationsGetResult contains the result from method NetworkInterfaceIPConfigurations.Get.
type NetworkInterfaceIPConfigurationsGetResult struct {
	NetworkInterfaceIPConfiguration
}

// NetworkInterfaceIPConfigurationsListResponse contains the response from method NetworkInterfaceIPConfigurations.List.
type NetworkInterfaceIPConfigurationsListResponse struct {
	NetworkInterfaceIPConfigurationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceIPConfigurationsListResult contains the result from method NetworkInterfaceIPConfigurations.List.
type NetworkInterfaceIPConfigurationsListResult struct {
	NetworkInterfaceIPConfigurationListResult
}

// NetworkInterfaceLoadBalancersListResponse contains the response from method NetworkInterfaceLoadBalancers.List.
type NetworkInterfaceLoadBalancersListResponse struct {
	NetworkInterfaceLoadBalancersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceLoadBalancersListResult contains the result from method NetworkInterfaceLoadBalancers.List.
type NetworkInterfaceLoadBalancersListResult struct {
	NetworkInterfaceLoadBalancerListResult
}

// NetworkInterfaceTapConfigurationsCreateOrUpdatePollerResponse contains the response from method NetworkInterfaceTapConfigurations.CreateOrUpdate.
type NetworkInterfaceTapConfigurationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfaceTapConfigurationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfaceTapConfigurationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfaceTapConfigurationsCreateOrUpdateResponse, error) {
	respType := NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfaceTapConfigurationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkInterfaceTapConfigurationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkInterfaceTapConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfaceTapConfigurationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfaceTapConfigurationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfaceTapConfigurationsCreateOrUpdateResponse contains the response from method NetworkInterfaceTapConfigurations.CreateOrUpdate.
type NetworkInterfaceTapConfigurationsCreateOrUpdateResponse struct {
	NetworkInterfaceTapConfigurationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceTapConfigurationsCreateOrUpdateResult contains the result from method NetworkInterfaceTapConfigurations.CreateOrUpdate.
type NetworkInterfaceTapConfigurationsCreateOrUpdateResult struct {
	NetworkInterfaceTapConfiguration
}

// NetworkInterfaceTapConfigurationsDeletePollerResponse contains the response from method NetworkInterfaceTapConfigurations.Delete.
type NetworkInterfaceTapConfigurationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfaceTapConfigurationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfaceTapConfigurationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfaceTapConfigurationsDeleteResponse, error) {
	respType := NetworkInterfaceTapConfigurationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfaceTapConfigurationsDeletePollerResponse from the provided client and resume token.
func (l *NetworkInterfaceTapConfigurationsDeletePollerResponse) Resume(ctx context.Context, client *NetworkInterfaceTapConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfaceTapConfigurationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfaceTapConfigurationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfaceTapConfigurationsDeleteResponse contains the response from method NetworkInterfaceTapConfigurations.Delete.
type NetworkInterfaceTapConfigurationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceTapConfigurationsGetResponse contains the response from method NetworkInterfaceTapConfigurations.Get.
type NetworkInterfaceTapConfigurationsGetResponse struct {
	NetworkInterfaceTapConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceTapConfigurationsGetResult contains the result from method NetworkInterfaceTapConfigurations.Get.
type NetworkInterfaceTapConfigurationsGetResult struct {
	NetworkInterfaceTapConfiguration
}

// NetworkInterfaceTapConfigurationsListResponse contains the response from method NetworkInterfaceTapConfigurations.List.
type NetworkInterfaceTapConfigurationsListResponse struct {
	NetworkInterfaceTapConfigurationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfaceTapConfigurationsListResult contains the result from method NetworkInterfaceTapConfigurations.List.
type NetworkInterfaceTapConfigurationsListResult struct {
	NetworkInterfaceTapConfigurationListResult
}

// NetworkInterfacesCreateOrUpdatePollerResponse contains the response from method NetworkInterfaces.CreateOrUpdate.
type NetworkInterfacesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfacesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfacesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesCreateOrUpdateResponse, error) {
	respType := NetworkInterfacesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkInterface)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfacesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkInterfacesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkInterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfacesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfacesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfacesCreateOrUpdateResponse contains the response from method NetworkInterfaces.CreateOrUpdate.
type NetworkInterfacesCreateOrUpdateResponse struct {
	NetworkInterfacesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesCreateOrUpdateResult contains the result from method NetworkInterfaces.CreateOrUpdate.
type NetworkInterfacesCreateOrUpdateResult struct {
	NetworkInterface
}

// NetworkInterfacesDeletePollerResponse contains the response from method NetworkInterfaces.Delete.
type NetworkInterfacesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfacesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfacesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesDeleteResponse, error) {
	respType := NetworkInterfacesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfacesDeletePollerResponse from the provided client and resume token.
func (l *NetworkInterfacesDeletePollerResponse) Resume(ctx context.Context, client *NetworkInterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfacesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfacesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfacesDeleteResponse contains the response from method NetworkInterfaces.Delete.
type NetworkInterfacesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetCloudServiceNetworkInterfaceResponse contains the response from method NetworkInterfaces.GetCloudServiceNetworkInterface.
type NetworkInterfacesGetCloudServiceNetworkInterfaceResponse struct {
	NetworkInterfacesGetCloudServiceNetworkInterfaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetCloudServiceNetworkInterfaceResult contains the result from method NetworkInterfaces.GetCloudServiceNetworkInterface.
type NetworkInterfacesGetCloudServiceNetworkInterfaceResult struct {
	NetworkInterface
}

// NetworkInterfacesGetEffectiveRouteTablePollerResponse contains the response from method NetworkInterfaces.GetEffectiveRouteTable.
type NetworkInterfacesGetEffectiveRouteTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfacesGetEffectiveRouteTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfacesGetEffectiveRouteTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesGetEffectiveRouteTableResponse, error) {
	respType := NetworkInterfacesGetEffectiveRouteTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.EffectiveRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfacesGetEffectiveRouteTablePollerResponse from the provided client and resume token.
func (l *NetworkInterfacesGetEffectiveRouteTablePollerResponse) Resume(ctx context.Context, client *NetworkInterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfacesClient.GetEffectiveRouteTable", token, client.pl, client.getEffectiveRouteTableHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfacesGetEffectiveRouteTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfacesGetEffectiveRouteTableResponse contains the response from method NetworkInterfaces.GetEffectiveRouteTable.
type NetworkInterfacesGetEffectiveRouteTableResponse struct {
	NetworkInterfacesGetEffectiveRouteTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetEffectiveRouteTableResult contains the result from method NetworkInterfaces.GetEffectiveRouteTable.
type NetworkInterfacesGetEffectiveRouteTableResult struct {
	EffectiveRouteListResult
}

// NetworkInterfacesGetResponse contains the response from method NetworkInterfaces.Get.
type NetworkInterfacesGetResponse struct {
	NetworkInterfacesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetResult contains the result from method NetworkInterfaces.Get.
type NetworkInterfacesGetResult struct {
	NetworkInterface
}

// NetworkInterfacesGetVirtualMachineScaleSetIPConfigurationResponse contains the response from method NetworkInterfaces.GetVirtualMachineScaleSetIPConfiguration.
type NetworkInterfacesGetVirtualMachineScaleSetIPConfigurationResponse struct {
	NetworkInterfacesGetVirtualMachineScaleSetIPConfigurationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetVirtualMachineScaleSetIPConfigurationResult contains the result from method NetworkInterfaces.GetVirtualMachineScaleSetIPConfiguration.
type NetworkInterfacesGetVirtualMachineScaleSetIPConfigurationResult struct {
	NetworkInterfaceIPConfiguration
}

// NetworkInterfacesGetVirtualMachineScaleSetNetworkInterfaceResponse contains the response from method NetworkInterfaces.GetVirtualMachineScaleSetNetworkInterface.
type NetworkInterfacesGetVirtualMachineScaleSetNetworkInterfaceResponse struct {
	NetworkInterfacesGetVirtualMachineScaleSetNetworkInterfaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesGetVirtualMachineScaleSetNetworkInterfaceResult contains the result from method NetworkInterfaces.GetVirtualMachineScaleSetNetworkInterface.
type NetworkInterfacesGetVirtualMachineScaleSetNetworkInterfaceResult struct {
	NetworkInterface
}

// NetworkInterfacesListAllResponse contains the response from method NetworkInterfaces.ListAll.
type NetworkInterfacesListAllResponse struct {
	NetworkInterfacesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListAllResult contains the result from method NetworkInterfaces.ListAll.
type NetworkInterfacesListAllResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesListCloudServiceNetworkInterfacesResponse contains the response from method NetworkInterfaces.ListCloudServiceNetworkInterfaces.
type NetworkInterfacesListCloudServiceNetworkInterfacesResponse struct {
	NetworkInterfacesListCloudServiceNetworkInterfacesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListCloudServiceNetworkInterfacesResult contains the result from method NetworkInterfaces.ListCloudServiceNetworkInterfaces.
type NetworkInterfacesListCloudServiceNetworkInterfacesResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse contains the response from method NetworkInterfaces.ListCloudServiceRoleInstanceNetworkInterfaces.
type NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResponse struct {
	NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResult contains the result from method NetworkInterfaces.ListCloudServiceRoleInstanceNetworkInterfaces.
type NetworkInterfacesListCloudServiceRoleInstanceNetworkInterfacesResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesListEffectiveNetworkSecurityGroupsPollerResponse contains the response from method NetworkInterfaces.ListEffectiveNetworkSecurityGroups.
type NetworkInterfacesListEffectiveNetworkSecurityGroupsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkInterfacesListEffectiveNetworkSecurityGroupsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse, error) {
	respType := NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkInterfacesListEffectiveNetworkSecurityGroupsPollerResponse from the provided client and resume token.
func (l *NetworkInterfacesListEffectiveNetworkSecurityGroupsPollerResponse) Resume(ctx context.Context, client *NetworkInterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkInterfacesClient.ListEffectiveNetworkSecurityGroups", token, client.pl, client.listEffectiveNetworkSecurityGroupsHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse contains the response from method NetworkInterfaces.ListEffectiveNetworkSecurityGroups.
type NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse struct {
	NetworkInterfacesListEffectiveNetworkSecurityGroupsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListEffectiveNetworkSecurityGroupsResult contains the result from method NetworkInterfaces.ListEffectiveNetworkSecurityGroups.
type NetworkInterfacesListEffectiveNetworkSecurityGroupsResult struct {
	EffectiveNetworkSecurityGroupListResult
}

// NetworkInterfacesListResponse contains the response from method NetworkInterfaces.List.
type NetworkInterfacesListResponse struct {
	NetworkInterfacesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListResult contains the result from method NetworkInterfaces.List.
type NetworkInterfacesListResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse contains the response from method NetworkInterfaces.ListVirtualMachineScaleSetIPConfigurations.
type NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResponse struct {
	NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResult contains the result from method NetworkInterfaces.ListVirtualMachineScaleSetIPConfigurations.
type NetworkInterfacesListVirtualMachineScaleSetIPConfigurationsResult struct {
	NetworkInterfaceIPConfigurationListResult
}

// NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse contains the response from method NetworkInterfaces.ListVirtualMachineScaleSetNetworkInterfaces.
type NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResponse struct {
	NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResult contains the result from method NetworkInterfaces.ListVirtualMachineScaleSetNetworkInterfaces.
type NetworkInterfacesListVirtualMachineScaleSetNetworkInterfacesResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse contains the response from method NetworkInterfaces.ListVirtualMachineScaleSetVMNetworkInterfaces.
type NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResponse struct {
	NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResult contains the result from method NetworkInterfaces.ListVirtualMachineScaleSetVMNetworkInterfaces.
type NetworkInterfacesListVirtualMachineScaleSetVMNetworkInterfacesResult struct {
	NetworkInterfaceListResult
}

// NetworkInterfacesUpdateTagsResponse contains the response from method NetworkInterfaces.UpdateTags.
type NetworkInterfacesUpdateTagsResponse struct {
	NetworkInterfacesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkInterfacesUpdateTagsResult contains the result from method NetworkInterfaces.UpdateTags.
type NetworkInterfacesUpdateTagsResult struct {
	NetworkInterface
}

// NetworkManagementClientCheckDNSNameAvailabilityResponse contains the response from method NetworkManagementClient.CheckDNSNameAvailability.
type NetworkManagementClientCheckDNSNameAvailabilityResponse struct {
	NetworkManagementClientCheckDNSNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientCheckDNSNameAvailabilityResult contains the result from method NetworkManagementClient.CheckDNSNameAvailability.
type NetworkManagementClientCheckDNSNameAvailabilityResult struct {
	DNSNameAvailabilityResult
}

// NetworkManagementClientDeleteBastionShareableLinkPollerResponse contains the response from method NetworkManagementClient.DeleteBastionShareableLink.
type NetworkManagementClientDeleteBastionShareableLinkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkManagementClientDeleteBastionShareableLinkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkManagementClientDeleteBastionShareableLinkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientDeleteBastionShareableLinkResponse, error) {
	respType := NetworkManagementClientDeleteBastionShareableLinkResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkManagementClientDeleteBastionShareableLinkPollerResponse from the provided client and resume token.
func (l *NetworkManagementClientDeleteBastionShareableLinkPollerResponse) Resume(ctx context.Context, client *NetworkManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkManagementClient.DeleteBastionShareableLink", token, client.pl, client.deleteBastionShareableLinkHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkManagementClientDeleteBastionShareableLinkPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkManagementClientDeleteBastionShareableLinkResponse contains the response from method NetworkManagementClient.DeleteBastionShareableLink.
type NetworkManagementClientDeleteBastionShareableLinkResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientDisconnectActiveSessionsResponse contains the response from method NetworkManagementClient.DisconnectActiveSessions.
type NetworkManagementClientDisconnectActiveSessionsResponse struct {
	NetworkManagementClientDisconnectActiveSessionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientDisconnectActiveSessionsResult contains the result from method NetworkManagementClient.DisconnectActiveSessions.
type NetworkManagementClientDisconnectActiveSessionsResult struct {
	BastionSessionDeleteResult
}

// NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse contains the response from method NetworkManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile.
type NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	respType := NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse from the provided client and resume token.
func (l *NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse) Resume(ctx context.Context, client *NetworkManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile", token, client.pl, client.generatevirtualwanvpnserverconfigurationvpnprofileHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse contains the response from method NetworkManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile.
type NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse struct {
	NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResult contains the result from method NetworkManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile.
type NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResult struct {
	VPNProfileResponse
}

// NetworkManagementClientGetActiveSessionsPollerResponse contains the response from method NetworkManagementClient.GetActiveSessions.
type NetworkManagementClientGetActiveSessionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkManagementClientGetActiveSessionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkManagementClientGetActiveSessionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (*NetworkManagementClientGetActiveSessionsPager, error) {
	respType := &NetworkManagementClientGetActiveSessionsPager{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.current.BastionActiveSessionListResult)
	if err != nil {
		return respType, err
	}
	respType.current.RawResponse = resp
	respType.client = l.Poller.client
	return respType, nil
}

// Resume rehydrates a NetworkManagementClientGetActiveSessionsPollerResponse from the provided client and resume token.
func (l *NetworkManagementClientGetActiveSessionsPollerResponse) Resume(ctx context.Context, client *NetworkManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkManagementClient.GetActiveSessions", token, client.pl, client.getActiveSessionsHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkManagementClientGetActiveSessionsPoller{
		pt:     pt,
		client: client,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkManagementClientGetActiveSessionsResponse contains the response from method NetworkManagementClient.GetActiveSessions.
type NetworkManagementClientGetActiveSessionsResponse struct {
	NetworkManagementClientGetActiveSessionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientGetActiveSessionsResult contains the result from method NetworkManagementClient.GetActiveSessions.
type NetworkManagementClientGetActiveSessionsResult struct {
	BastionActiveSessionListResult
}

// NetworkManagementClientGetBastionShareableLinkResponse contains the response from method NetworkManagementClient.GetBastionShareableLink.
type NetworkManagementClientGetBastionShareableLinkResponse struct {
	NetworkManagementClientGetBastionShareableLinkResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientGetBastionShareableLinkResult contains the result from method NetworkManagementClient.GetBastionShareableLink.
type NetworkManagementClientGetBastionShareableLinkResult struct {
	BastionShareableLinkListResult
}

// NetworkManagementClientPutBastionShareableLinkPollerResponse contains the response from method NetworkManagementClient.PutBastionShareableLink.
type NetworkManagementClientPutBastionShareableLinkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkManagementClientPutBastionShareableLinkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkManagementClientPutBastionShareableLinkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (*NetworkManagementClientPutBastionShareableLinkPager, error) {
	respType := &NetworkManagementClientPutBastionShareableLinkPager{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.current.BastionShareableLinkListResult)
	if err != nil {
		return respType, err
	}
	respType.current.RawResponse = resp
	respType.client = l.Poller.client
	return respType, nil
}

// Resume rehydrates a NetworkManagementClientPutBastionShareableLinkPollerResponse from the provided client and resume token.
func (l *NetworkManagementClientPutBastionShareableLinkPollerResponse) Resume(ctx context.Context, client *NetworkManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkManagementClient.PutBastionShareableLink", token, client.pl, client.putBastionShareableLinkHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkManagementClientPutBastionShareableLinkPoller{
		pt:     pt,
		client: client,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkManagementClientPutBastionShareableLinkResponse contains the response from method NetworkManagementClient.PutBastionShareableLink.
type NetworkManagementClientPutBastionShareableLinkResponse struct {
	NetworkManagementClientPutBastionShareableLinkResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientPutBastionShareableLinkResult contains the result from method NetworkManagementClient.PutBastionShareableLink.
type NetworkManagementClientPutBastionShareableLinkResult struct {
	BastionShareableLinkListResult
}

// NetworkManagementClientSupportedSecurityProvidersResponse contains the response from method NetworkManagementClient.SupportedSecurityProviders.
type NetworkManagementClientSupportedSecurityProvidersResponse struct {
	NetworkManagementClientSupportedSecurityProvidersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkManagementClientSupportedSecurityProvidersResult contains the result from method NetworkManagementClient.SupportedSecurityProviders.
type NetworkManagementClientSupportedSecurityProvidersResult struct {
	VirtualWanSecurityProviders
}

// NetworkProfilesCreateOrUpdateResponse contains the response from method NetworkProfiles.CreateOrUpdate.
type NetworkProfilesCreateOrUpdateResponse struct {
	NetworkProfilesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesCreateOrUpdateResult contains the result from method NetworkProfiles.CreateOrUpdate.
type NetworkProfilesCreateOrUpdateResult struct {
	NetworkProfile
}

// NetworkProfilesDeletePollerResponse contains the response from method NetworkProfiles.Delete.
type NetworkProfilesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkProfilesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkProfilesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkProfilesDeleteResponse, error) {
	respType := NetworkProfilesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkProfilesDeletePollerResponse from the provided client and resume token.
func (l *NetworkProfilesDeletePollerResponse) Resume(ctx context.Context, client *NetworkProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkProfilesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkProfilesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkProfilesDeleteResponse contains the response from method NetworkProfiles.Delete.
type NetworkProfilesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesGetResponse contains the response from method NetworkProfiles.Get.
type NetworkProfilesGetResponse struct {
	NetworkProfilesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesGetResult contains the result from method NetworkProfiles.Get.
type NetworkProfilesGetResult struct {
	NetworkProfile
}

// NetworkProfilesListAllResponse contains the response from method NetworkProfiles.ListAll.
type NetworkProfilesListAllResponse struct {
	NetworkProfilesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesListAllResult contains the result from method NetworkProfiles.ListAll.
type NetworkProfilesListAllResult struct {
	NetworkProfileListResult
}

// NetworkProfilesListResponse contains the response from method NetworkProfiles.List.
type NetworkProfilesListResponse struct {
	NetworkProfilesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesListResult contains the result from method NetworkProfiles.List.
type NetworkProfilesListResult struct {
	NetworkProfileListResult
}

// NetworkProfilesUpdateTagsResponse contains the response from method NetworkProfiles.UpdateTags.
type NetworkProfilesUpdateTagsResponse struct {
	NetworkProfilesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkProfilesUpdateTagsResult contains the result from method NetworkProfiles.UpdateTags.
type NetworkProfilesUpdateTagsResult struct {
	NetworkProfile
}

// NetworkSecurityGroupsCreateOrUpdatePollerResponse contains the response from method NetworkSecurityGroups.CreateOrUpdate.
type NetworkSecurityGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkSecurityGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkSecurityGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkSecurityGroupsCreateOrUpdateResponse, error) {
	respType := NetworkSecurityGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkSecurityGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkSecurityGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkSecurityGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkSecurityGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkSecurityGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkSecurityGroupsCreateOrUpdateResponse contains the response from method NetworkSecurityGroups.CreateOrUpdate.
type NetworkSecurityGroupsCreateOrUpdateResponse struct {
	NetworkSecurityGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsCreateOrUpdateResult contains the result from method NetworkSecurityGroups.CreateOrUpdate.
type NetworkSecurityGroupsCreateOrUpdateResult struct {
	NetworkSecurityGroup
}

// NetworkSecurityGroupsDeletePollerResponse contains the response from method NetworkSecurityGroups.Delete.
type NetworkSecurityGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkSecurityGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkSecurityGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkSecurityGroupsDeleteResponse, error) {
	respType := NetworkSecurityGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkSecurityGroupsDeletePollerResponse from the provided client and resume token.
func (l *NetworkSecurityGroupsDeletePollerResponse) Resume(ctx context.Context, client *NetworkSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkSecurityGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkSecurityGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkSecurityGroupsDeleteResponse contains the response from method NetworkSecurityGroups.Delete.
type NetworkSecurityGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsGetResponse contains the response from method NetworkSecurityGroups.Get.
type NetworkSecurityGroupsGetResponse struct {
	NetworkSecurityGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsGetResult contains the result from method NetworkSecurityGroups.Get.
type NetworkSecurityGroupsGetResult struct {
	NetworkSecurityGroup
}

// NetworkSecurityGroupsListAllResponse contains the response from method NetworkSecurityGroups.ListAll.
type NetworkSecurityGroupsListAllResponse struct {
	NetworkSecurityGroupsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsListAllResult contains the result from method NetworkSecurityGroups.ListAll.
type NetworkSecurityGroupsListAllResult struct {
	NetworkSecurityGroupListResult
}

// NetworkSecurityGroupsListResponse contains the response from method NetworkSecurityGroups.List.
type NetworkSecurityGroupsListResponse struct {
	NetworkSecurityGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsListResult contains the result from method NetworkSecurityGroups.List.
type NetworkSecurityGroupsListResult struct {
	NetworkSecurityGroupListResult
}

// NetworkSecurityGroupsUpdateTagsResponse contains the response from method NetworkSecurityGroups.UpdateTags.
type NetworkSecurityGroupsUpdateTagsResponse struct {
	NetworkSecurityGroupsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkSecurityGroupsUpdateTagsResult contains the result from method NetworkSecurityGroups.UpdateTags.
type NetworkSecurityGroupsUpdateTagsResult struct {
	NetworkSecurityGroup
}

// NetworkVirtualAppliancesCreateOrUpdatePollerResponse contains the response from method NetworkVirtualAppliances.CreateOrUpdate.
type NetworkVirtualAppliancesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkVirtualAppliancesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkVirtualAppliancesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkVirtualAppliancesCreateOrUpdateResponse, error) {
	respType := NetworkVirtualAppliancesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkVirtualAppliance)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkVirtualAppliancesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkVirtualAppliancesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkVirtualAppliancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkVirtualAppliancesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkVirtualAppliancesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkVirtualAppliancesCreateOrUpdateResponse contains the response from method NetworkVirtualAppliances.CreateOrUpdate.
type NetworkVirtualAppliancesCreateOrUpdateResponse struct {
	NetworkVirtualAppliancesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesCreateOrUpdateResult contains the result from method NetworkVirtualAppliances.CreateOrUpdate.
type NetworkVirtualAppliancesCreateOrUpdateResult struct {
	NetworkVirtualAppliance
}

// NetworkVirtualAppliancesDeletePollerResponse contains the response from method NetworkVirtualAppliances.Delete.
type NetworkVirtualAppliancesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkVirtualAppliancesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkVirtualAppliancesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkVirtualAppliancesDeleteResponse, error) {
	respType := NetworkVirtualAppliancesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkVirtualAppliancesDeletePollerResponse from the provided client and resume token.
func (l *NetworkVirtualAppliancesDeletePollerResponse) Resume(ctx context.Context, client *NetworkVirtualAppliancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkVirtualAppliancesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkVirtualAppliancesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkVirtualAppliancesDeleteResponse contains the response from method NetworkVirtualAppliances.Delete.
type NetworkVirtualAppliancesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesGetResponse contains the response from method NetworkVirtualAppliances.Get.
type NetworkVirtualAppliancesGetResponse struct {
	NetworkVirtualAppliancesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesGetResult contains the result from method NetworkVirtualAppliances.Get.
type NetworkVirtualAppliancesGetResult struct {
	NetworkVirtualAppliance
}

// NetworkVirtualAppliancesListByResourceGroupResponse contains the response from method NetworkVirtualAppliances.ListByResourceGroup.
type NetworkVirtualAppliancesListByResourceGroupResponse struct {
	NetworkVirtualAppliancesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesListByResourceGroupResult contains the result from method NetworkVirtualAppliances.ListByResourceGroup.
type NetworkVirtualAppliancesListByResourceGroupResult struct {
	NetworkVirtualApplianceListResult
}

// NetworkVirtualAppliancesListResponse contains the response from method NetworkVirtualAppliances.List.
type NetworkVirtualAppliancesListResponse struct {
	NetworkVirtualAppliancesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesListResult contains the result from method NetworkVirtualAppliances.List.
type NetworkVirtualAppliancesListResult struct {
	NetworkVirtualApplianceListResult
}

// NetworkVirtualAppliancesUpdateTagsResponse contains the response from method NetworkVirtualAppliances.UpdateTags.
type NetworkVirtualAppliancesUpdateTagsResponse struct {
	NetworkVirtualAppliancesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkVirtualAppliancesUpdateTagsResult contains the result from method NetworkVirtualAppliances.UpdateTags.
type NetworkVirtualAppliancesUpdateTagsResult struct {
	NetworkVirtualAppliance
}

// NetworkWatchersCheckConnectivityPollerResponse contains the response from method NetworkWatchers.CheckConnectivity.
type NetworkWatchersCheckConnectivityPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersCheckConnectivityPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersCheckConnectivityPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersCheckConnectivityResponse, error) {
	respType := NetworkWatchersCheckConnectivityResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectivityInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersCheckConnectivityPollerResponse from the provided client and resume token.
func (l *NetworkWatchersCheckConnectivityPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.CheckConnectivity", token, client.pl, client.checkConnectivityHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersCheckConnectivityPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersCheckConnectivityResponse contains the response from method NetworkWatchers.CheckConnectivity.
type NetworkWatchersCheckConnectivityResponse struct {
	NetworkWatchersCheckConnectivityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersCheckConnectivityResult contains the result from method NetworkWatchers.CheckConnectivity.
type NetworkWatchersCheckConnectivityResult struct {
	ConnectivityInformation
}

// NetworkWatchersCreateOrUpdateResponse contains the response from method NetworkWatchers.CreateOrUpdate.
type NetworkWatchersCreateOrUpdateResponse struct {
	NetworkWatchersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersCreateOrUpdateResult contains the result from method NetworkWatchers.CreateOrUpdate.
type NetworkWatchersCreateOrUpdateResult struct {
	NetworkWatcher
}

// NetworkWatchersDeletePollerResponse contains the response from method NetworkWatchers.Delete.
type NetworkWatchersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersDeleteResponse, error) {
	respType := NetworkWatchersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersDeletePollerResponse from the provided client and resume token.
func (l *NetworkWatchersDeletePollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersDeleteResponse contains the response from method NetworkWatchers.Delete.
type NetworkWatchersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetAzureReachabilityReportPollerResponse contains the response from method NetworkWatchers.GetAzureReachabilityReport.
type NetworkWatchersGetAzureReachabilityReportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetAzureReachabilityReportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetAzureReachabilityReportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetAzureReachabilityReportResponse, error) {
	respType := NetworkWatchersGetAzureReachabilityReportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureReachabilityReport)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetAzureReachabilityReportPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetAzureReachabilityReportPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetAzureReachabilityReport", token, client.pl, client.getAzureReachabilityReportHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetAzureReachabilityReportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetAzureReachabilityReportResponse contains the response from method NetworkWatchers.GetAzureReachabilityReport.
type NetworkWatchersGetAzureReachabilityReportResponse struct {
	NetworkWatchersGetAzureReachabilityReportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetAzureReachabilityReportResult contains the result from method NetworkWatchers.GetAzureReachabilityReport.
type NetworkWatchersGetAzureReachabilityReportResult struct {
	AzureReachabilityReport
}

// NetworkWatchersGetFlowLogStatusPollerResponse contains the response from method NetworkWatchers.GetFlowLogStatus.
type NetworkWatchersGetFlowLogStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetFlowLogStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetFlowLogStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetFlowLogStatusResponse, error) {
	respType := NetworkWatchersGetFlowLogStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetFlowLogStatusPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetFlowLogStatusPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetFlowLogStatus", token, client.pl, client.getFlowLogStatusHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetFlowLogStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetFlowLogStatusResponse contains the response from method NetworkWatchers.GetFlowLogStatus.
type NetworkWatchersGetFlowLogStatusResponse struct {
	NetworkWatchersGetFlowLogStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetFlowLogStatusResult contains the result from method NetworkWatchers.GetFlowLogStatus.
type NetworkWatchersGetFlowLogStatusResult struct {
	FlowLogInformation
}

// NetworkWatchersGetNetworkConfigurationDiagnosticPollerResponse contains the response from method NetworkWatchers.GetNetworkConfigurationDiagnostic.
type NetworkWatchersGetNetworkConfigurationDiagnosticPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetNetworkConfigurationDiagnosticPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetNetworkConfigurationDiagnosticPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetNetworkConfigurationDiagnosticResponse, error) {
	respType := NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetNetworkConfigurationDiagnosticPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetNetworkConfigurationDiagnosticPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetNetworkConfigurationDiagnostic", token, client.pl, client.getNetworkConfigurationDiagnosticHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetNetworkConfigurationDiagnosticPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetNetworkConfigurationDiagnosticResponse contains the response from method NetworkWatchers.GetNetworkConfigurationDiagnostic.
type NetworkWatchersGetNetworkConfigurationDiagnosticResponse struct {
	NetworkWatchersGetNetworkConfigurationDiagnosticResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetNetworkConfigurationDiagnosticResult contains the result from method NetworkWatchers.GetNetworkConfigurationDiagnostic.
type NetworkWatchersGetNetworkConfigurationDiagnosticResult struct {
	NetworkConfigurationDiagnosticResponse
}

// NetworkWatchersGetNextHopPollerResponse contains the response from method NetworkWatchers.GetNextHop.
type NetworkWatchersGetNextHopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetNextHopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetNextHopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetNextHopResponse, error) {
	respType := NetworkWatchersGetNextHopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NextHopResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetNextHopPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetNextHopPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetNextHop", token, client.pl, client.getNextHopHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetNextHopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetNextHopResponse contains the response from method NetworkWatchers.GetNextHop.
type NetworkWatchersGetNextHopResponse struct {
	NetworkWatchersGetNextHopResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetNextHopResult contains the result from method NetworkWatchers.GetNextHop.
type NetworkWatchersGetNextHopResult struct {
	NextHopResult
}

// NetworkWatchersGetResponse contains the response from method NetworkWatchers.Get.
type NetworkWatchersGetResponse struct {
	NetworkWatchersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetResult contains the result from method NetworkWatchers.Get.
type NetworkWatchersGetResult struct {
	NetworkWatcher
}

// NetworkWatchersGetTopologyResponse contains the response from method NetworkWatchers.GetTopology.
type NetworkWatchersGetTopologyResponse struct {
	NetworkWatchersGetTopologyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetTopologyResult contains the result from method NetworkWatchers.GetTopology.
type NetworkWatchersGetTopologyResult struct {
	Topology
}

// NetworkWatchersGetTroubleshootingPollerResponse contains the response from method NetworkWatchers.GetTroubleshooting.
type NetworkWatchersGetTroubleshootingPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetTroubleshootingPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetTroubleshootingPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetTroubleshootingResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetTroubleshootingPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetTroubleshootingPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetTroubleshooting", token, client.pl, client.getTroubleshootingHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetTroubleshootingPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetTroubleshootingResponse contains the response from method NetworkWatchers.GetTroubleshooting.
type NetworkWatchersGetTroubleshootingResponse struct {
	NetworkWatchersGetTroubleshootingResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetTroubleshootingResult contains the result from method NetworkWatchers.GetTroubleshooting.
type NetworkWatchersGetTroubleshootingResult struct {
	TroubleshootingResult
}

// NetworkWatchersGetTroubleshootingResultPollerResponse contains the response from method NetworkWatchers.GetTroubleshootingResult.
type NetworkWatchersGetTroubleshootingResultPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetTroubleshootingResultPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetTroubleshootingResultPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetTroubleshootingResultResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResultResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetTroubleshootingResultPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetTroubleshootingResultPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetTroubleshootingResult", token, client.pl, client.getTroubleshootingResultHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetTroubleshootingResultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetTroubleshootingResultResponse contains the response from method NetworkWatchers.GetTroubleshootingResult.
type NetworkWatchersGetTroubleshootingResultResponse struct {
	NetworkWatchersGetTroubleshootingResultResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetTroubleshootingResultResult contains the result from method NetworkWatchers.GetTroubleshootingResult.
type NetworkWatchersGetTroubleshootingResultResult struct {
	TroubleshootingResult
}

// NetworkWatchersGetVMSecurityRulesPollerResponse contains the response from method NetworkWatchers.GetVMSecurityRules.
type NetworkWatchersGetVMSecurityRulesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersGetVMSecurityRulesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersGetVMSecurityRulesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetVMSecurityRulesResponse, error) {
	respType := NetworkWatchersGetVMSecurityRulesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityGroupViewResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersGetVMSecurityRulesPollerResponse from the provided client and resume token.
func (l *NetworkWatchersGetVMSecurityRulesPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.GetVMSecurityRules", token, client.pl, client.getVMSecurityRulesHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersGetVMSecurityRulesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersGetVMSecurityRulesResponse contains the response from method NetworkWatchers.GetVMSecurityRules.
type NetworkWatchersGetVMSecurityRulesResponse struct {
	NetworkWatchersGetVMSecurityRulesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersGetVMSecurityRulesResult contains the result from method NetworkWatchers.GetVMSecurityRules.
type NetworkWatchersGetVMSecurityRulesResult struct {
	SecurityGroupViewResult
}

// NetworkWatchersListAllResponse contains the response from method NetworkWatchers.ListAll.
type NetworkWatchersListAllResponse struct {
	NetworkWatchersListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersListAllResult contains the result from method NetworkWatchers.ListAll.
type NetworkWatchersListAllResult struct {
	NetworkWatcherListResult
}

// NetworkWatchersListAvailableProvidersPollerResponse contains the response from method NetworkWatchers.ListAvailableProviders.
type NetworkWatchersListAvailableProvidersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersListAvailableProvidersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersListAvailableProvidersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersListAvailableProvidersResponse, error) {
	respType := NetworkWatchersListAvailableProvidersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AvailableProvidersList)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersListAvailableProvidersPollerResponse from the provided client and resume token.
func (l *NetworkWatchersListAvailableProvidersPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.ListAvailableProviders", token, client.pl, client.listAvailableProvidersHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersListAvailableProvidersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersListAvailableProvidersResponse contains the response from method NetworkWatchers.ListAvailableProviders.
type NetworkWatchersListAvailableProvidersResponse struct {
	NetworkWatchersListAvailableProvidersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersListAvailableProvidersResult contains the result from method NetworkWatchers.ListAvailableProviders.
type NetworkWatchersListAvailableProvidersResult struct {
	AvailableProvidersList
}

// NetworkWatchersListResponse contains the response from method NetworkWatchers.List.
type NetworkWatchersListResponse struct {
	NetworkWatchersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersListResult contains the result from method NetworkWatchers.List.
type NetworkWatchersListResult struct {
	NetworkWatcherListResult
}

// NetworkWatchersSetFlowLogConfigurationPollerResponse contains the response from method NetworkWatchers.SetFlowLogConfiguration.
type NetworkWatchersSetFlowLogConfigurationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersSetFlowLogConfigurationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersSetFlowLogConfigurationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersSetFlowLogConfigurationResponse, error) {
	respType := NetworkWatchersSetFlowLogConfigurationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersSetFlowLogConfigurationPollerResponse from the provided client and resume token.
func (l *NetworkWatchersSetFlowLogConfigurationPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.SetFlowLogConfiguration", token, client.pl, client.setFlowLogConfigurationHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersSetFlowLogConfigurationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersSetFlowLogConfigurationResponse contains the response from method NetworkWatchers.SetFlowLogConfiguration.
type NetworkWatchersSetFlowLogConfigurationResponse struct {
	NetworkWatchersSetFlowLogConfigurationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersSetFlowLogConfigurationResult contains the result from method NetworkWatchers.SetFlowLogConfiguration.
type NetworkWatchersSetFlowLogConfigurationResult struct {
	FlowLogInformation
}

// NetworkWatchersUpdateTagsResponse contains the response from method NetworkWatchers.UpdateTags.
type NetworkWatchersUpdateTagsResponse struct {
	NetworkWatchersUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersUpdateTagsResult contains the result from method NetworkWatchers.UpdateTags.
type NetworkWatchersUpdateTagsResult struct {
	NetworkWatcher
}

// NetworkWatchersVerifyIPFlowPollerResponse contains the response from method NetworkWatchers.VerifyIPFlow.
type NetworkWatchersVerifyIPFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkWatchersVerifyIPFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkWatchersVerifyIPFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersVerifyIPFlowResponse, error) {
	respType := NetworkWatchersVerifyIPFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VerificationIPFlowResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkWatchersVerifyIPFlowPollerResponse from the provided client and resume token.
func (l *NetworkWatchersVerifyIPFlowPollerResponse) Resume(ctx context.Context, client *NetworkWatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkWatchersClient.VerifyIPFlow", token, client.pl, client.verifyIPFlowHandleError)
	if err != nil {
		return err
	}
	poller := &NetworkWatchersVerifyIPFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkWatchersVerifyIPFlowResponse contains the response from method NetworkWatchers.VerifyIPFlow.
type NetworkWatchersVerifyIPFlowResponse struct {
	NetworkWatchersVerifyIPFlowResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkWatchersVerifyIPFlowResult contains the result from method NetworkWatchers.VerifyIPFlow.
type NetworkWatchersVerifyIPFlowResult struct {
	VerificationIPFlowResult
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// P2SVPNGatewaysCreateOrUpdatePollerResponse contains the response from method P2SVPNGateways.CreateOrUpdate.
type P2SVPNGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysCreateOrUpdateResponse, error) {
	respType := P2SVPNGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysCreateOrUpdateResponse contains the response from method P2SVPNGateways.CreateOrUpdate.
type P2SVPNGatewaysCreateOrUpdateResponse struct {
	P2SVPNGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysCreateOrUpdateResult contains the result from method P2SVPNGateways.CreateOrUpdate.
type P2SVPNGatewaysCreateOrUpdateResult struct {
	P2SVPNGateway
}

// P2SVPNGatewaysDeletePollerResponse contains the response from method P2SVPNGateways.Delete.
type P2SVPNGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysDeleteResponse, error) {
	respType := P2SVPNGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysDeletePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysDeletePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysDeleteResponse contains the response from method P2SVPNGateways.Delete.
type P2SVPNGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysDisconnectP2SVPNConnectionsPollerResponse contains the response from method P2SVPNGateways.DisconnectP2SVPNConnections.
type P2SVPNGatewaysDisconnectP2SVPNConnectionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysDisconnectP2SVPNConnectionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse, error) {
	respType := P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysDisconnectP2SVPNConnectionsPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysDisconnectP2SVPNConnectionsPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.DisconnectP2SVPNConnections", token, client.pl, client.disconnectP2SVPNConnectionsHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse contains the response from method P2SVPNGateways.DisconnectP2SVPNConnections.
type P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysGenerateVPNProfilePollerResponse contains the response from method P2SVPNGateways.GenerateVPNProfile.
type P2SVPNGatewaysGenerateVPNProfilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysGenerateVPNProfilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysGenerateVPNProfilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGenerateVPNProfileResponse, error) {
	respType := P2SVPNGatewaysGenerateVPNProfileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysGenerateVPNProfilePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysGenerateVPNProfilePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GenerateVPNProfile", token, client.pl, client.generateVPNProfileHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysGenerateVPNProfilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysGenerateVPNProfileResponse contains the response from method P2SVPNGateways.GenerateVPNProfile.
type P2SVPNGatewaysGenerateVPNProfileResponse struct {
	P2SVPNGatewaysGenerateVPNProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysGenerateVPNProfileResult contains the result from method P2SVPNGateways.GenerateVPNProfile.
type P2SVPNGatewaysGenerateVPNProfileResult struct {
	VPNProfileResponse
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPollerResponse contains the response from method P2SVPNGateways.GetP2SVPNConnectionHealthDetailed.
type P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNConnectionHealth)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealthDetailed", token, client.pl, client.getP2SVPNConnectionHealthDetailedHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse contains the response from method P2SVPNGateways.GetP2SVPNConnectionHealthDetailed.
type P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse struct {
	P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResult contains the result from method P2SVPNGateways.GetP2SVPNConnectionHealthDetailed.
type P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResult struct {
	P2SVPNConnectionHealth
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthPollerResponse contains the response from method P2SVPNGateways.GetP2SVPNConnectionHealth.
type P2SVPNGatewaysGetP2SVPNConnectionHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysGetP2SVPNConnectionHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysGetP2SVPNConnectionHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGetP2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysGetP2SVPNConnectionHealthPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysGetP2SVPNConnectionHealthPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealth", token, client.pl, client.getP2SVPNConnectionHealthHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysGetP2SVPNConnectionHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthResponse contains the response from method P2SVPNGateways.GetP2SVPNConnectionHealth.
type P2SVPNGatewaysGetP2SVPNConnectionHealthResponse struct {
	P2SVPNGatewaysGetP2SVPNConnectionHealthResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthResult contains the result from method P2SVPNGateways.GetP2SVPNConnectionHealth.
type P2SVPNGatewaysGetP2SVPNConnectionHealthResult struct {
	P2SVPNGateway
}

// P2SVPNGatewaysGetResponse contains the response from method P2SVPNGateways.Get.
type P2SVPNGatewaysGetResponse struct {
	P2SVPNGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysGetResult contains the result from method P2SVPNGateways.Get.
type P2SVPNGatewaysGetResult struct {
	P2SVPNGateway
}

// P2SVPNGatewaysListByResourceGroupResponse contains the response from method P2SVPNGateways.ListByResourceGroup.
type P2SVPNGatewaysListByResourceGroupResponse struct {
	P2SVPNGatewaysListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysListByResourceGroupResult contains the result from method P2SVPNGateways.ListByResourceGroup.
type P2SVPNGatewaysListByResourceGroupResult struct {
	ListP2SVPNGatewaysResult
}

// P2SVPNGatewaysListResponse contains the response from method P2SVPNGateways.List.
type P2SVPNGatewaysListResponse struct {
	P2SVPNGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysListResult contains the result from method P2SVPNGateways.List.
type P2SVPNGatewaysListResult struct {
	ListP2SVPNGatewaysResult
}

// P2SVPNGatewaysResetPollerResponse contains the response from method P2SVPNGateways.Reset.
type P2SVPNGatewaysResetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysResetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysResetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysResetResponse, error) {
	respType := P2SVPNGatewaysResetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysResetPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysResetPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.Reset", token, client.pl, client.resetHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysResetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysResetResponse contains the response from method P2SVPNGateways.Reset.
type P2SVPNGatewaysResetResponse struct {
	P2SVPNGatewaysResetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysResetResult contains the result from method P2SVPNGateways.Reset.
type P2SVPNGatewaysResetResult struct {
	P2SVPNGateway
}

// P2SVPNGatewaysUpdateTagsPollerResponse contains the response from method P2SVPNGateways.UpdateTags.
type P2SVPNGatewaysUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysUpdateTagsResponse, error) {
	respType := P2SVPNGatewaysUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysUpdateTagsPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysUpdateTagsPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysUpdateTagsResponse contains the response from method P2SVPNGateways.UpdateTags.
type P2SVPNGatewaysUpdateTagsResponse struct {
	P2SVPNGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysUpdateTagsResult contains the result from method P2SVPNGateways.UpdateTags.
type P2SVPNGatewaysUpdateTagsResult struct {
	P2SVPNGateway
}

// PacketCapturesCreatePollerResponse contains the response from method PacketCaptures.Create.
type PacketCapturesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesCreateResponse, error) {
	respType := PacketCapturesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesCreatePollerResponse from the provided client and resume token.
func (l *PacketCapturesCreatePollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &PacketCapturesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesCreateResponse contains the response from method PacketCaptures.Create.
type PacketCapturesCreateResponse struct {
	PacketCapturesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesCreateResult contains the result from method PacketCaptures.Create.
type PacketCapturesCreateResult struct {
	PacketCaptureResult
}

// PacketCapturesDeletePollerResponse contains the response from method PacketCaptures.Delete.
type PacketCapturesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesDeleteResponse, error) {
	respType := PacketCapturesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesDeletePollerResponse from the provided client and resume token.
func (l *PacketCapturesDeletePollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PacketCapturesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesDeleteResponse contains the response from method PacketCaptures.Delete.
type PacketCapturesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesGetResponse contains the response from method PacketCaptures.Get.
type PacketCapturesGetResponse struct {
	PacketCapturesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesGetResult contains the result from method PacketCaptures.Get.
type PacketCapturesGetResult struct {
	PacketCaptureResult
}

// PacketCapturesGetStatusPollerResponse contains the response from method PacketCaptures.GetStatus.
type PacketCapturesGetStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesGetStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesGetStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesGetStatusResponse, error) {
	respType := PacketCapturesGetStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesGetStatusPollerResponse from the provided client and resume token.
func (l *PacketCapturesGetStatusPollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.GetStatus", token, client.pl, client.getStatusHandleError)
	if err != nil {
		return err
	}
	poller := &PacketCapturesGetStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesGetStatusResponse contains the response from method PacketCaptures.GetStatus.
type PacketCapturesGetStatusResponse struct {
	PacketCapturesGetStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesGetStatusResult contains the result from method PacketCaptures.GetStatus.
type PacketCapturesGetStatusResult struct {
	PacketCaptureQueryStatusResult
}

// PacketCapturesListResponse contains the response from method PacketCaptures.List.
type PacketCapturesListResponse struct {
	PacketCapturesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesListResult contains the result from method PacketCaptures.List.
type PacketCapturesListResult struct {
	PacketCaptureListResult
}

// PacketCapturesStopPollerResponse contains the response from method PacketCaptures.Stop.
type PacketCapturesStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesStopResponse, error) {
	respType := PacketCapturesStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesStopPollerResponse from the provided client and resume token.
func (l *PacketCapturesStopPollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &PacketCapturesStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesStopResponse contains the response from method PacketCaptures.Stop.
type PacketCapturesStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PeerExpressRouteCircuitConnectionsGetResponse contains the response from method PeerExpressRouteCircuitConnections.Get.
type PeerExpressRouteCircuitConnectionsGetResponse struct {
	PeerExpressRouteCircuitConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PeerExpressRouteCircuitConnectionsGetResult contains the result from method PeerExpressRouteCircuitConnections.Get.
type PeerExpressRouteCircuitConnectionsGetResult struct {
	PeerExpressRouteCircuitConnection
}

// PeerExpressRouteCircuitConnectionsListResponse contains the response from method PeerExpressRouteCircuitConnections.List.
type PeerExpressRouteCircuitConnectionsListResponse struct {
	PeerExpressRouteCircuitConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PeerExpressRouteCircuitConnectionsListResult contains the result from method PeerExpressRouteCircuitConnections.List.
type PeerExpressRouteCircuitConnectionsListResult struct {
	PeerExpressRouteCircuitConnectionListResult
}

// PrivateDNSZoneGroupsCreateOrUpdatePollerResponse contains the response from method PrivateDNSZoneGroups.CreateOrUpdate.
type PrivateDNSZoneGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateDNSZoneGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateDNSZoneGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsCreateOrUpdateResponse, error) {
	respType := PrivateDNSZoneGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateDNSZoneGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateDNSZoneGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateDNSZoneGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateDNSZoneGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateDNSZoneGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateDNSZoneGroupsCreateOrUpdateResponse contains the response from method PrivateDNSZoneGroups.CreateOrUpdate.
type PrivateDNSZoneGroupsCreateOrUpdateResponse struct {
	PrivateDNSZoneGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsCreateOrUpdateResult contains the result from method PrivateDNSZoneGroups.CreateOrUpdate.
type PrivateDNSZoneGroupsCreateOrUpdateResult struct {
	PrivateDNSZoneGroup
}

// PrivateDNSZoneGroupsDeletePollerResponse contains the response from method PrivateDNSZoneGroups.Delete.
type PrivateDNSZoneGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateDNSZoneGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateDNSZoneGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsDeleteResponse, error) {
	respType := PrivateDNSZoneGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateDNSZoneGroupsDeletePollerResponse from the provided client and resume token.
func (l *PrivateDNSZoneGroupsDeletePollerResponse) Resume(ctx context.Context, client *PrivateDNSZoneGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateDNSZoneGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateDNSZoneGroupsDeleteResponse contains the response from method PrivateDNSZoneGroups.Delete.
type PrivateDNSZoneGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsGetResponse contains the response from method PrivateDNSZoneGroups.Get.
type PrivateDNSZoneGroupsGetResponse struct {
	PrivateDNSZoneGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsGetResult contains the result from method PrivateDNSZoneGroups.Get.
type PrivateDNSZoneGroupsGetResult struct {
	PrivateDNSZoneGroup
}

// PrivateDNSZoneGroupsListResponse contains the response from method PrivateDNSZoneGroups.List.
type PrivateDNSZoneGroupsListResponse struct {
	PrivateDNSZoneGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsListResult contains the result from method PrivateDNSZoneGroups.List.
type PrivateDNSZoneGroupsListResult struct {
	PrivateDNSZoneGroupListResult
}

// PrivateEndpointsCreateOrUpdatePollerResponse contains the response from method PrivateEndpoints.CreateOrUpdate.
type PrivateEndpointsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointsCreateOrUpdateResponse contains the response from method PrivateEndpoints.CreateOrUpdate.
type PrivateEndpointsCreateOrUpdateResponse struct {
	PrivateEndpointsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsCreateOrUpdateResult contains the result from method PrivateEndpoints.CreateOrUpdate.
type PrivateEndpointsCreateOrUpdateResult struct {
	PrivateEndpoint
}

// PrivateEndpointsDeletePollerResponse contains the response from method PrivateEndpoints.Delete.
type PrivateEndpointsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsDeleteResponse, error) {
	respType := PrivateEndpointsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointsDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointsDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointsDeleteResponse contains the response from method PrivateEndpoints.Delete.
type PrivateEndpointsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsGetResponse contains the response from method PrivateEndpoints.Get.
type PrivateEndpointsGetResponse struct {
	PrivateEndpointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsGetResult contains the result from method PrivateEndpoints.Get.
type PrivateEndpointsGetResult struct {
	PrivateEndpoint
}

// PrivateEndpointsListBySubscriptionResponse contains the response from method PrivateEndpoints.ListBySubscription.
type PrivateEndpointsListBySubscriptionResponse struct {
	PrivateEndpointsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsListBySubscriptionResult contains the result from method PrivateEndpoints.ListBySubscription.
type PrivateEndpointsListBySubscriptionResult struct {
	PrivateEndpointListResult
}

// PrivateEndpointsListResponse contains the response from method PrivateEndpoints.List.
type PrivateEndpointsListResponse struct {
	PrivateEndpointsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsListResult contains the result from method PrivateEndpoints.List.
type PrivateEndpointsListResult struct {
	PrivateEndpointListResult
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse contains the response from method PrivateLinkServices.CheckPrivateLinkServiceVisibilityByResourceGroup.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibilityByResourceGroup", token, client.pl, client.checkPrivateLinkServiceVisibilityByResourceGroupHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse contains the response from method PrivateLinkServices.CheckPrivateLinkServiceVisibilityByResourceGroup.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse struct {
	PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResult contains the result from method PrivateLinkServices.CheckPrivateLinkServiceVisibilityByResourceGroup.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResult struct {
	PrivateLinkServiceVisibility
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityPollerResponse contains the response from method PrivateLinkServices.CheckPrivateLinkServiceVisibility.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesCheckPrivateLinkServiceVisibilityPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesCheckPrivateLinkServiceVisibilityPollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesCheckPrivateLinkServiceVisibilityPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibility", token, client.pl, client.checkPrivateLinkServiceVisibilityHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse contains the response from method PrivateLinkServices.CheckPrivateLinkServiceVisibility.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse struct {
	PrivateLinkServicesCheckPrivateLinkServiceVisibilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityResult contains the result from method PrivateLinkServices.CheckPrivateLinkServiceVisibility.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityResult struct {
	PrivateLinkServiceVisibility
}

// PrivateLinkServicesCreateOrUpdatePollerResponse contains the response from method PrivateLinkServices.CreateOrUpdate.
type PrivateLinkServicesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCreateOrUpdateResponse, error) {
	respType := PrivateLinkServicesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesCreateOrUpdateResponse contains the response from method PrivateLinkServices.CreateOrUpdate.
type PrivateLinkServicesCreateOrUpdateResponse struct {
	PrivateLinkServicesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesCreateOrUpdateResult contains the result from method PrivateLinkServices.CreateOrUpdate.
type PrivateLinkServicesCreateOrUpdateResult struct {
	PrivateLinkService
}

// PrivateLinkServicesDeletePollerResponse contains the response from method PrivateLinkServices.Delete.
type PrivateLinkServicesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesDeleteResponse, error) {
	respType := PrivateLinkServicesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesDeletePollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesDeletePollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesDeletePrivateEndpointConnectionPollerResponse contains the response from method PrivateLinkServices.DeletePrivateEndpointConnection.
type PrivateLinkServicesDeletePrivateEndpointConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesDeletePrivateEndpointConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesDeletePrivateEndpointConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesDeletePrivateEndpointConnectionResponse, error) {
	respType := PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesDeletePrivateEndpointConnectionPollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesDeletePrivateEndpointConnectionPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.DeletePrivateEndpointConnection", token, client.pl, client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesDeletePrivateEndpointConnectionResponse contains the response from method PrivateLinkServices.DeletePrivateEndpointConnection.
type PrivateLinkServicesDeletePrivateEndpointConnectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesDeleteResponse contains the response from method PrivateLinkServices.Delete.
type PrivateLinkServicesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesGetPrivateEndpointConnectionResponse contains the response from method PrivateLinkServices.GetPrivateEndpointConnection.
type PrivateLinkServicesGetPrivateEndpointConnectionResponse struct {
	PrivateLinkServicesGetPrivateEndpointConnectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesGetPrivateEndpointConnectionResult contains the result from method PrivateLinkServices.GetPrivateEndpointConnection.
type PrivateLinkServicesGetPrivateEndpointConnectionResult struct {
	PrivateEndpointConnection
}

// PrivateLinkServicesGetResponse contains the response from method PrivateLinkServices.Get.
type PrivateLinkServicesGetResponse struct {
	PrivateLinkServicesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesGetResult contains the result from method PrivateLinkServices.Get.
type PrivateLinkServicesGetResult struct {
	PrivateLinkService
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse contains the response from method PrivateLinkServices.ListAutoApprovedPrivateLinkServicesByResourceGroup.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResponse struct {
	PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResult contains the result from method PrivateLinkServices.ListAutoApprovedPrivateLinkServicesByResourceGroup.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesByResourceGroupResult struct {
	AutoApprovedPrivateLinkServicesResult
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse contains the response from method PrivateLinkServices.ListAutoApprovedPrivateLinkServices.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesResponse struct {
	PrivateLinkServicesListAutoApprovedPrivateLinkServicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesListAutoApprovedPrivateLinkServicesResult contains the result from method PrivateLinkServices.ListAutoApprovedPrivateLinkServices.
type PrivateLinkServicesListAutoApprovedPrivateLinkServicesResult struct {
	AutoApprovedPrivateLinkServicesResult
}

// PrivateLinkServicesListBySubscriptionResponse contains the response from method PrivateLinkServices.ListBySubscription.
type PrivateLinkServicesListBySubscriptionResponse struct {
	PrivateLinkServicesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesListBySubscriptionResult contains the result from method PrivateLinkServices.ListBySubscription.
type PrivateLinkServicesListBySubscriptionResult struct {
	PrivateLinkServiceListResult
}

// PrivateLinkServicesListPrivateEndpointConnectionsResponse contains the response from method PrivateLinkServices.ListPrivateEndpointConnections.
type PrivateLinkServicesListPrivateEndpointConnectionsResponse struct {
	PrivateLinkServicesListPrivateEndpointConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesListPrivateEndpointConnectionsResult contains the result from method PrivateLinkServices.ListPrivateEndpointConnections.
type PrivateLinkServicesListPrivateEndpointConnectionsResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateLinkServicesListResponse contains the response from method PrivateLinkServices.List.
type PrivateLinkServicesListResponse struct {
	PrivateLinkServicesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesListResult contains the result from method PrivateLinkServices.List.
type PrivateLinkServicesListResult struct {
	PrivateLinkServiceListResult
}

// PrivateLinkServicesUpdatePrivateEndpointConnectionResponse contains the response from method PrivateLinkServices.UpdatePrivateEndpointConnection.
type PrivateLinkServicesUpdatePrivateEndpointConnectionResponse struct {
	PrivateLinkServicesUpdatePrivateEndpointConnectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesUpdatePrivateEndpointConnectionResult contains the result from method PrivateLinkServices.UpdatePrivateEndpointConnection.
type PrivateLinkServicesUpdatePrivateEndpointConnectionResult struct {
	PrivateEndpointConnection
}

// PublicIPAddressesCreateOrUpdatePollerResponse contains the response from method PublicIPAddresses.CreateOrUpdate.
type PublicIPAddressesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPAddressesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPAddressesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesCreateOrUpdateResponse, error) {
	respType := PublicIPAddressesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PublicIPAddress)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPAddressesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PublicIPAddressesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PublicIPAddressesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PublicIPAddressesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPAddressesCreateOrUpdateResponse contains the response from method PublicIPAddresses.CreateOrUpdate.
type PublicIPAddressesCreateOrUpdateResponse struct {
	PublicIPAddressesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesCreateOrUpdateResult contains the result from method PublicIPAddresses.CreateOrUpdate.
type PublicIPAddressesCreateOrUpdateResult struct {
	PublicIPAddress
}

// PublicIPAddressesDeletePollerResponse contains the response from method PublicIPAddresses.Delete.
type PublicIPAddressesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPAddressesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPAddressesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesDeleteResponse, error) {
	respType := PublicIPAddressesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPAddressesDeletePollerResponse from the provided client and resume token.
func (l *PublicIPAddressesDeletePollerResponse) Resume(ctx context.Context, client *PublicIPAddressesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PublicIPAddressesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPAddressesDeleteResponse contains the response from method PublicIPAddresses.Delete.
type PublicIPAddressesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesGetCloudServicePublicIPAddressResponse contains the response from method PublicIPAddresses.GetCloudServicePublicIPAddress.
type PublicIPAddressesGetCloudServicePublicIPAddressResponse struct {
	PublicIPAddressesGetCloudServicePublicIPAddressResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesGetCloudServicePublicIPAddressResult contains the result from method PublicIPAddresses.GetCloudServicePublicIPAddress.
type PublicIPAddressesGetCloudServicePublicIPAddressResult struct {
	PublicIPAddress
}

// PublicIPAddressesGetResponse contains the response from method PublicIPAddresses.Get.
type PublicIPAddressesGetResponse struct {
	PublicIPAddressesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesGetResult contains the result from method PublicIPAddresses.Get.
type PublicIPAddressesGetResult struct {
	PublicIPAddress
}

// PublicIPAddressesGetVirtualMachineScaleSetPublicIPAddressResponse contains the response from method PublicIPAddresses.GetVirtualMachineScaleSetPublicIPAddress.
type PublicIPAddressesGetVirtualMachineScaleSetPublicIPAddressResponse struct {
	PublicIPAddressesGetVirtualMachineScaleSetPublicIPAddressResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesGetVirtualMachineScaleSetPublicIPAddressResult contains the result from method PublicIPAddresses.GetVirtualMachineScaleSetPublicIPAddress.
type PublicIPAddressesGetVirtualMachineScaleSetPublicIPAddressResult struct {
	PublicIPAddress
}

// PublicIPAddressesListAllResponse contains the response from method PublicIPAddresses.ListAll.
type PublicIPAddressesListAllResponse struct {
	PublicIPAddressesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListAllResult contains the result from method PublicIPAddresses.ListAll.
type PublicIPAddressesListAllResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesListCloudServicePublicIPAddressesResponse contains the response from method PublicIPAddresses.ListCloudServicePublicIPAddresses.
type PublicIPAddressesListCloudServicePublicIPAddressesResponse struct {
	PublicIPAddressesListCloudServicePublicIPAddressesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListCloudServicePublicIPAddressesResult contains the result from method PublicIPAddresses.ListCloudServicePublicIPAddresses.
type PublicIPAddressesListCloudServicePublicIPAddressesResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse contains the response from method PublicIPAddresses.ListCloudServiceRoleInstancePublicIPAddresses.
type PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResponse struct {
	PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResult contains the result from method PublicIPAddresses.ListCloudServiceRoleInstancePublicIPAddresses.
type PublicIPAddressesListCloudServiceRoleInstancePublicIPAddressesResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesListResponse contains the response from method PublicIPAddresses.List.
type PublicIPAddressesListResponse struct {
	PublicIPAddressesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListResult contains the result from method PublicIPAddresses.List.
type PublicIPAddressesListResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse contains the response from method PublicIPAddresses.ListVirtualMachineScaleSetPublicIPAddresses.
type PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResponse struct {
	PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResult contains the result from method PublicIPAddresses.ListVirtualMachineScaleSetPublicIPAddresses.
type PublicIPAddressesListVirtualMachineScaleSetPublicIPAddressesResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse contains the response from method PublicIPAddresses.ListVirtualMachineScaleSetVMPublicIPAddresses.
type PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResponse struct {
	PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResult contains the result from method PublicIPAddresses.ListVirtualMachineScaleSetVMPublicIPAddresses.
type PublicIPAddressesListVirtualMachineScaleSetVMPublicIPAddressesResult struct {
	PublicIPAddressListResult
}

// PublicIPAddressesUpdateTagsResponse contains the response from method PublicIPAddresses.UpdateTags.
type PublicIPAddressesUpdateTagsResponse struct {
	PublicIPAddressesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesUpdateTagsResult contains the result from method PublicIPAddresses.UpdateTags.
type PublicIPAddressesUpdateTagsResult struct {
	PublicIPAddress
}

// PublicIPPrefixesCreateOrUpdatePollerResponse contains the response from method PublicIPPrefixes.CreateOrUpdate.
type PublicIPPrefixesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPPrefixesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPPrefixesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesCreateOrUpdateResponse, error) {
	respType := PublicIPPrefixesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PublicIPPrefix)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPPrefixesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PublicIPPrefixesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PublicIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PublicIPPrefixesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPPrefixesCreateOrUpdateResponse contains the response from method PublicIPPrefixes.CreateOrUpdate.
type PublicIPPrefixesCreateOrUpdateResponse struct {
	PublicIPPrefixesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesCreateOrUpdateResult contains the result from method PublicIPPrefixes.CreateOrUpdate.
type PublicIPPrefixesCreateOrUpdateResult struct {
	PublicIPPrefix
}

// PublicIPPrefixesDeletePollerResponse contains the response from method PublicIPPrefixes.Delete.
type PublicIPPrefixesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPPrefixesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPPrefixesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesDeleteResponse, error) {
	respType := PublicIPPrefixesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPPrefixesDeletePollerResponse from the provided client and resume token.
func (l *PublicIPPrefixesDeletePollerResponse) Resume(ctx context.Context, client *PublicIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PublicIPPrefixesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPPrefixesDeleteResponse contains the response from method PublicIPPrefixes.Delete.
type PublicIPPrefixesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesGetResponse contains the response from method PublicIPPrefixes.Get.
type PublicIPPrefixesGetResponse struct {
	PublicIPPrefixesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesGetResult contains the result from method PublicIPPrefixes.Get.
type PublicIPPrefixesGetResult struct {
	PublicIPPrefix
}

// PublicIPPrefixesListAllResponse contains the response from method PublicIPPrefixes.ListAll.
type PublicIPPrefixesListAllResponse struct {
	PublicIPPrefixesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesListAllResult contains the result from method PublicIPPrefixes.ListAll.
type PublicIPPrefixesListAllResult struct {
	PublicIPPrefixListResult
}

// PublicIPPrefixesListResponse contains the response from method PublicIPPrefixes.List.
type PublicIPPrefixesListResponse struct {
	PublicIPPrefixesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesListResult contains the result from method PublicIPPrefixes.List.
type PublicIPPrefixesListResult struct {
	PublicIPPrefixListResult
}

// PublicIPPrefixesUpdateTagsResponse contains the response from method PublicIPPrefixes.UpdateTags.
type PublicIPPrefixesUpdateTagsResponse struct {
	PublicIPPrefixesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesUpdateTagsResult contains the result from method PublicIPPrefixes.UpdateTags.
type PublicIPPrefixesUpdateTagsResult struct {
	PublicIPPrefix
}

// ResourceNavigationLinksListResponse contains the response from method ResourceNavigationLinks.List.
type ResourceNavigationLinksListResponse struct {
	ResourceNavigationLinksListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceNavigationLinksListResultEnvelope contains the result from method ResourceNavigationLinks.List.
type ResourceNavigationLinksListResultEnvelope struct {
	ResourceNavigationLinksListResult
}

// RouteFilterRulesCreateOrUpdatePollerResponse contains the response from method RouteFilterRules.CreateOrUpdate.
type RouteFilterRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFilterRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFilterRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesCreateOrUpdateResponse, error) {
	respType := RouteFilterRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteFilterRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFilterRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteFilterRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteFilterRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RouteFilterRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFilterRulesCreateOrUpdateResponse contains the response from method RouteFilterRules.CreateOrUpdate.
type RouteFilterRulesCreateOrUpdateResponse struct {
	RouteFilterRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesCreateOrUpdateResult contains the result from method RouteFilterRules.CreateOrUpdate.
type RouteFilterRulesCreateOrUpdateResult struct {
	RouteFilterRule
}

// RouteFilterRulesDeletePollerResponse contains the response from method RouteFilterRules.Delete.
type RouteFilterRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFilterRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFilterRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesDeleteResponse, error) {
	respType := RouteFilterRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFilterRulesDeletePollerResponse from the provided client and resume token.
func (l *RouteFilterRulesDeletePollerResponse) Resume(ctx context.Context, client *RouteFilterRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RouteFilterRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFilterRulesDeleteResponse contains the response from method RouteFilterRules.Delete.
type RouteFilterRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesGetResponse contains the response from method RouteFilterRules.Get.
type RouteFilterRulesGetResponse struct {
	RouteFilterRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesGetResult contains the result from method RouteFilterRules.Get.
type RouteFilterRulesGetResult struct {
	RouteFilterRule
}

// RouteFilterRulesListByRouteFilterResponse contains the response from method RouteFilterRules.ListByRouteFilter.
type RouteFilterRulesListByRouteFilterResponse struct {
	RouteFilterRulesListByRouteFilterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesListByRouteFilterResult contains the result from method RouteFilterRules.ListByRouteFilter.
type RouteFilterRulesListByRouteFilterResult struct {
	RouteFilterRuleListResult
}

// RouteFiltersCreateOrUpdatePollerResponse contains the response from method RouteFilters.CreateOrUpdate.
type RouteFiltersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFiltersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFiltersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersCreateOrUpdateResponse, error) {
	respType := RouteFiltersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteFilter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFiltersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteFiltersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteFiltersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFiltersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RouteFiltersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFiltersCreateOrUpdateResponse contains the response from method RouteFilters.CreateOrUpdate.
type RouteFiltersCreateOrUpdateResponse struct {
	RouteFiltersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersCreateOrUpdateResult contains the result from method RouteFilters.CreateOrUpdate.
type RouteFiltersCreateOrUpdateResult struct {
	RouteFilter
}

// RouteFiltersDeletePollerResponse contains the response from method RouteFilters.Delete.
type RouteFiltersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFiltersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFiltersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersDeleteResponse, error) {
	respType := RouteFiltersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFiltersDeletePollerResponse from the provided client and resume token.
func (l *RouteFiltersDeletePollerResponse) Resume(ctx context.Context, client *RouteFiltersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFiltersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RouteFiltersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFiltersDeleteResponse contains the response from method RouteFilters.Delete.
type RouteFiltersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersGetResponse contains the response from method RouteFilters.Get.
type RouteFiltersGetResponse struct {
	RouteFiltersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersGetResult contains the result from method RouteFilters.Get.
type RouteFiltersGetResult struct {
	RouteFilter
}

// RouteFiltersListByResourceGroupResponse contains the response from method RouteFilters.ListByResourceGroup.
type RouteFiltersListByResourceGroupResponse struct {
	RouteFiltersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersListByResourceGroupResult contains the result from method RouteFilters.ListByResourceGroup.
type RouteFiltersListByResourceGroupResult struct {
	RouteFilterListResult
}

// RouteFiltersListResponse contains the response from method RouteFilters.List.
type RouteFiltersListResponse struct {
	RouteFiltersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersListResult contains the result from method RouteFilters.List.
type RouteFiltersListResult struct {
	RouteFilterListResult
}

// RouteFiltersUpdateTagsResponse contains the response from method RouteFilters.UpdateTags.
type RouteFiltersUpdateTagsResponse struct {
	RouteFiltersUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersUpdateTagsResult contains the result from method RouteFilters.UpdateTags.
type RouteFiltersUpdateTagsResult struct {
	RouteFilter
}

// RouteTablesCreateOrUpdatePollerResponse contains the response from method RouteTables.CreateOrUpdate.
type RouteTablesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteTablesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteTablesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesCreateOrUpdateResponse, error) {
	respType := RouteTablesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteTable)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteTablesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteTablesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteTablesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RouteTablesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteTablesCreateOrUpdateResponse contains the response from method RouteTables.CreateOrUpdate.
type RouteTablesCreateOrUpdateResponse struct {
	RouteTablesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesCreateOrUpdateResult contains the result from method RouteTables.CreateOrUpdate.
type RouteTablesCreateOrUpdateResult struct {
	RouteTable
}

// RouteTablesDeletePollerResponse contains the response from method RouteTables.Delete.
type RouteTablesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteTablesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteTablesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesDeleteResponse, error) {
	respType := RouteTablesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteTablesDeletePollerResponse from the provided client and resume token.
func (l *RouteTablesDeletePollerResponse) Resume(ctx context.Context, client *RouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteTablesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RouteTablesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteTablesDeleteResponse contains the response from method RouteTables.Delete.
type RouteTablesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesGetResponse contains the response from method RouteTables.Get.
type RouteTablesGetResponse struct {
	RouteTablesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesGetResult contains the result from method RouteTables.Get.
type RouteTablesGetResult struct {
	RouteTable
}

// RouteTablesListAllResponse contains the response from method RouteTables.ListAll.
type RouteTablesListAllResponse struct {
	RouteTablesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesListAllResult contains the result from method RouteTables.ListAll.
type RouteTablesListAllResult struct {
	RouteTableListResult
}

// RouteTablesListResponse contains the response from method RouteTables.List.
type RouteTablesListResponse struct {
	RouteTablesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesListResult contains the result from method RouteTables.List.
type RouteTablesListResult struct {
	RouteTableListResult
}

// RouteTablesUpdateTagsResponse contains the response from method RouteTables.UpdateTags.
type RouteTablesUpdateTagsResponse struct {
	RouteTablesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesUpdateTagsResult contains the result from method RouteTables.UpdateTags.
type RouteTablesUpdateTagsResult struct {
	RouteTable
}

// RoutesCreateOrUpdatePollerResponse contains the response from method Routes.CreateOrUpdate.
type RoutesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesCreateOrUpdateResponse, error) {
	respType := RoutesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RoutesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RoutesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesCreateOrUpdateResponse contains the response from method Routes.CreateOrUpdate.
type RoutesCreateOrUpdateResponse struct {
	RoutesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesCreateOrUpdateResult contains the result from method Routes.CreateOrUpdate.
type RoutesCreateOrUpdateResult struct {
	Route
}

// RoutesDeletePollerResponse contains the response from method Routes.Delete.
type RoutesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesDeletePollerResponse from the provided client and resume token.
func (l *RoutesDeletePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RoutesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesDeleteResponse contains the response from method Routes.Delete.
type RoutesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesGetResponse contains the response from method Routes.Get.
type RoutesGetResponse struct {
	RoutesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesGetResult contains the result from method Routes.Get.
type RoutesGetResult struct {
	Route
}

// RoutesListResponse contains the response from method Routes.List.
type RoutesListResponse struct {
	RoutesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesListResult contains the result from method Routes.List.
type RoutesListResult struct {
	RouteListResult
}

// RoutingIntentCreateOrUpdatePollerResponse contains the response from method RoutingIntent.CreateOrUpdate.
type RoutingIntentCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutingIntentCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutingIntentCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutingIntentCreateOrUpdateResponse, error) {
	respType := RoutingIntentCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RoutingIntent)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutingIntentCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RoutingIntentCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RoutingIntentClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutingIntentClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RoutingIntentCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutingIntentCreateOrUpdateResponse contains the response from method RoutingIntent.CreateOrUpdate.
type RoutingIntentCreateOrUpdateResponse struct {
	RoutingIntentCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutingIntentCreateOrUpdateResult contains the result from method RoutingIntent.CreateOrUpdate.
type RoutingIntentCreateOrUpdateResult struct {
	RoutingIntent
}

// RoutingIntentDeletePollerResponse contains the response from method RoutingIntent.Delete.
type RoutingIntentDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutingIntentDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutingIntentDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutingIntentDeleteResponse, error) {
	respType := RoutingIntentDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutingIntentDeletePollerResponse from the provided client and resume token.
func (l *RoutingIntentDeletePollerResponse) Resume(ctx context.Context, client *RoutingIntentClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutingIntentClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RoutingIntentDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutingIntentDeleteResponse contains the response from method RoutingIntent.Delete.
type RoutingIntentDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutingIntentGetResponse contains the response from method RoutingIntent.Get.
type RoutingIntentGetResponse struct {
	RoutingIntentGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutingIntentGetResult contains the result from method RoutingIntent.Get.
type RoutingIntentGetResult struct {
	RoutingIntent
}

// RoutingIntentListResponse contains the response from method RoutingIntent.List.
type RoutingIntentListResponse struct {
	RoutingIntentListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutingIntentListResult contains the result from method RoutingIntent.List.
type RoutingIntentListResult struct {
	ListRoutingIntentResult
}

// SecurityPartnerProvidersCreateOrUpdatePollerResponse contains the response from method SecurityPartnerProviders.CreateOrUpdate.
type SecurityPartnerProvidersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPartnerProvidersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPartnerProvidersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersCreateOrUpdateResponse, error) {
	respType := SecurityPartnerProvidersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPartnerProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPartnerProvidersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecurityPartnerProvidersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecurityPartnerProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityPartnerProvidersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPartnerProvidersCreateOrUpdateResponse contains the response from method SecurityPartnerProviders.CreateOrUpdate.
type SecurityPartnerProvidersCreateOrUpdateResponse struct {
	SecurityPartnerProvidersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersCreateOrUpdateResult contains the result from method SecurityPartnerProviders.CreateOrUpdate.
type SecurityPartnerProvidersCreateOrUpdateResult struct {
	SecurityPartnerProvider
}

// SecurityPartnerProvidersDeletePollerResponse contains the response from method SecurityPartnerProviders.Delete.
type SecurityPartnerProvidersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPartnerProvidersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPartnerProvidersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersDeleteResponse, error) {
	respType := SecurityPartnerProvidersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPartnerProvidersDeletePollerResponse from the provided client and resume token.
func (l *SecurityPartnerProvidersDeletePollerResponse) Resume(ctx context.Context, client *SecurityPartnerProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityPartnerProvidersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPartnerProvidersDeleteResponse contains the response from method SecurityPartnerProviders.Delete.
type SecurityPartnerProvidersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersGetResponse contains the response from method SecurityPartnerProviders.Get.
type SecurityPartnerProvidersGetResponse struct {
	SecurityPartnerProvidersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersGetResult contains the result from method SecurityPartnerProviders.Get.
type SecurityPartnerProvidersGetResult struct {
	SecurityPartnerProvider
}

// SecurityPartnerProvidersListByResourceGroupResponse contains the response from method SecurityPartnerProviders.ListByResourceGroup.
type SecurityPartnerProvidersListByResourceGroupResponse struct {
	SecurityPartnerProvidersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersListByResourceGroupResult contains the result from method SecurityPartnerProviders.ListByResourceGroup.
type SecurityPartnerProvidersListByResourceGroupResult struct {
	SecurityPartnerProviderListResult
}

// SecurityPartnerProvidersListResponse contains the response from method SecurityPartnerProviders.List.
type SecurityPartnerProvidersListResponse struct {
	SecurityPartnerProvidersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersListResult contains the result from method SecurityPartnerProviders.List.
type SecurityPartnerProvidersListResult struct {
	SecurityPartnerProviderListResult
}

// SecurityPartnerProvidersUpdateTagsResponse contains the response from method SecurityPartnerProviders.UpdateTags.
type SecurityPartnerProvidersUpdateTagsResponse struct {
	SecurityPartnerProvidersUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersUpdateTagsResult contains the result from method SecurityPartnerProviders.UpdateTags.
type SecurityPartnerProvidersUpdateTagsResult struct {
	SecurityPartnerProvider
}

// SecurityRulesCreateOrUpdatePollerResponse contains the response from method SecurityRules.CreateOrUpdate.
type SecurityRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesCreateOrUpdateResponse, error) {
	respType := SecurityRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecurityRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecurityRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityRulesCreateOrUpdateResponse contains the response from method SecurityRules.CreateOrUpdate.
type SecurityRulesCreateOrUpdateResponse struct {
	SecurityRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesCreateOrUpdateResult contains the result from method SecurityRules.CreateOrUpdate.
type SecurityRulesCreateOrUpdateResult struct {
	SecurityRule
}

// SecurityRulesDeletePollerResponse contains the response from method SecurityRules.Delete.
type SecurityRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesDeleteResponse, error) {
	respType := SecurityRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityRulesDeletePollerResponse from the provided client and resume token.
func (l *SecurityRulesDeletePollerResponse) Resume(ctx context.Context, client *SecurityRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SecurityRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityRulesDeleteResponse contains the response from method SecurityRules.Delete.
type SecurityRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesGetResponse contains the response from method SecurityRules.Get.
type SecurityRulesGetResponse struct {
	SecurityRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesGetResult contains the result from method SecurityRules.Get.
type SecurityRulesGetResult struct {
	SecurityRule
}

// SecurityRulesListResponse contains the response from method SecurityRules.List.
type SecurityRulesListResponse struct {
	SecurityRulesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesListResult contains the result from method SecurityRules.List.
type SecurityRulesListResult struct {
	SecurityRuleListResult
}

// ServiceAssociationLinksListResponse contains the response from method ServiceAssociationLinks.List.
type ServiceAssociationLinksListResponse struct {
	ServiceAssociationLinksListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceAssociationLinksListResultEnvelope contains the result from method ServiceAssociationLinks.List.
type ServiceAssociationLinksListResultEnvelope struct {
	ServiceAssociationLinksListResult
}

// ServiceEndpointPoliciesCreateOrUpdatePollerResponse contains the response from method ServiceEndpointPolicies.CreateOrUpdate.
type ServiceEndpointPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPoliciesCreateOrUpdateResponse contains the response from method ServiceEndpointPolicies.CreateOrUpdate.
type ServiceEndpointPoliciesCreateOrUpdateResponse struct {
	ServiceEndpointPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesCreateOrUpdateResult contains the result from method ServiceEndpointPolicies.CreateOrUpdate.
type ServiceEndpointPoliciesCreateOrUpdateResult struct {
	ServiceEndpointPolicy
}

// ServiceEndpointPoliciesDeletePollerResponse contains the response from method ServiceEndpointPolicies.Delete.
type ServiceEndpointPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesDeleteResponse, error) {
	respType := ServiceEndpointPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPoliciesDeletePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPoliciesDeletePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPoliciesDeleteResponse contains the response from method ServiceEndpointPolicies.Delete.
type ServiceEndpointPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesGetResponse contains the response from method ServiceEndpointPolicies.Get.
type ServiceEndpointPoliciesGetResponse struct {
	ServiceEndpointPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesGetResult contains the result from method ServiceEndpointPolicies.Get.
type ServiceEndpointPoliciesGetResult struct {
	ServiceEndpointPolicy
}

// ServiceEndpointPoliciesListByResourceGroupResponse contains the response from method ServiceEndpointPolicies.ListByResourceGroup.
type ServiceEndpointPoliciesListByResourceGroupResponse struct {
	ServiceEndpointPoliciesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesListByResourceGroupResult contains the result from method ServiceEndpointPolicies.ListByResourceGroup.
type ServiceEndpointPoliciesListByResourceGroupResult struct {
	ServiceEndpointPolicyListResult
}

// ServiceEndpointPoliciesListResponse contains the response from method ServiceEndpointPolicies.List.
type ServiceEndpointPoliciesListResponse struct {
	ServiceEndpointPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesListResult contains the result from method ServiceEndpointPolicies.List.
type ServiceEndpointPoliciesListResult struct {
	ServiceEndpointPolicyListResult
}

// ServiceEndpointPoliciesUpdateTagsResponse contains the response from method ServiceEndpointPolicies.UpdateTags.
type ServiceEndpointPoliciesUpdateTagsResponse struct {
	ServiceEndpointPoliciesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesUpdateTagsResult contains the result from method ServiceEndpointPolicies.UpdateTags.
type ServiceEndpointPoliciesUpdateTagsResult struct {
	ServiceEndpointPolicy
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdatePollerResponse contains the response from method ServiceEndpointPolicyDefinitions.CreateOrUpdate.
type ServiceEndpointPolicyDefinitionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPolicyDefinitionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPolicyDefinitionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPolicyDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse contains the response from method ServiceEndpointPolicyDefinitions.CreateOrUpdate.
type ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse struct {
	ServiceEndpointPolicyDefinitionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdateResult contains the result from method ServiceEndpointPolicyDefinitions.CreateOrUpdate.
type ServiceEndpointPolicyDefinitionsCreateOrUpdateResult struct {
	ServiceEndpointPolicyDefinition
}

// ServiceEndpointPolicyDefinitionsDeletePollerResponse contains the response from method ServiceEndpointPolicyDefinitions.Delete.
type ServiceEndpointPolicyDefinitionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPolicyDefinitionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPolicyDefinitionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsDeleteResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsDeletePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPolicyDefinitionsDeletePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPolicyDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPolicyDefinitionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPolicyDefinitionsDeleteResponse contains the response from method ServiceEndpointPolicyDefinitions.Delete.
type ServiceEndpointPolicyDefinitionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsGetResponse contains the response from method ServiceEndpointPolicyDefinitions.Get.
type ServiceEndpointPolicyDefinitionsGetResponse struct {
	ServiceEndpointPolicyDefinitionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsGetResult contains the result from method ServiceEndpointPolicyDefinitions.Get.
type ServiceEndpointPolicyDefinitionsGetResult struct {
	ServiceEndpointPolicyDefinition
}

// ServiceEndpointPolicyDefinitionsListByResourceGroupResponse contains the response from method ServiceEndpointPolicyDefinitions.ListByResourceGroup.
type ServiceEndpointPolicyDefinitionsListByResourceGroupResponse struct {
	ServiceEndpointPolicyDefinitionsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsListByResourceGroupResult contains the result from method ServiceEndpointPolicyDefinitions.ListByResourceGroup.
type ServiceEndpointPolicyDefinitionsListByResourceGroupResult struct {
	ServiceEndpointPolicyDefinitionListResult
}

// ServiceTagInformationListResponse contains the response from method ServiceTagInformation.List.
type ServiceTagInformationListResponse struct {
	ServiceTagInformationListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTagInformationListResultEnvelope contains the result from method ServiceTagInformation.List.
type ServiceTagInformationListResultEnvelope struct {
	ServiceTagInformationListResult
}

// ServiceTagsListResponse contains the response from method ServiceTags.List.
type ServiceTagsListResponse struct {
	ServiceTagsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTagsListResultEnvelope contains the result from method ServiceTags.List.
type ServiceTagsListResultEnvelope struct {
	ServiceTagsListResult
}

// SubnetsCreateOrUpdatePollerResponse contains the response from method Subnets.CreateOrUpdate.
type SubnetsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsCreateOrUpdateResponse, error) {
	respType := SubnetsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Subnet)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SubnetsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SubnetsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsCreateOrUpdateResponse contains the response from method Subnets.CreateOrUpdate.
type SubnetsCreateOrUpdateResponse struct {
	SubnetsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsCreateOrUpdateResult contains the result from method Subnets.CreateOrUpdate.
type SubnetsCreateOrUpdateResult struct {
	Subnet
}

// SubnetsDeletePollerResponse contains the response from method Subnets.Delete.
type SubnetsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsDeleteResponse, error) {
	respType := SubnetsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsDeletePollerResponse from the provided client and resume token.
func (l *SubnetsDeletePollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SubnetsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsDeleteResponse contains the response from method Subnets.Delete.
type SubnetsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsGetResponse contains the response from method Subnets.Get.
type SubnetsGetResponse struct {
	SubnetsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsGetResult contains the result from method Subnets.Get.
type SubnetsGetResult struct {
	Subnet
}

// SubnetsListResponse contains the response from method Subnets.List.
type SubnetsListResponse struct {
	SubnetsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsListResult contains the result from method Subnets.List.
type SubnetsListResult struct {
	SubnetListResult
}

// SubnetsPrepareNetworkPoliciesPollerResponse contains the response from method Subnets.PrepareNetworkPolicies.
type SubnetsPrepareNetworkPoliciesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsPrepareNetworkPoliciesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsPrepareNetworkPoliciesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsPrepareNetworkPoliciesResponse, error) {
	respType := SubnetsPrepareNetworkPoliciesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsPrepareNetworkPoliciesPollerResponse from the provided client and resume token.
func (l *SubnetsPrepareNetworkPoliciesPollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.PrepareNetworkPolicies", token, client.pl, client.prepareNetworkPoliciesHandleError)
	if err != nil {
		return err
	}
	poller := &SubnetsPrepareNetworkPoliciesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsPrepareNetworkPoliciesResponse contains the response from method Subnets.PrepareNetworkPolicies.
type SubnetsPrepareNetworkPoliciesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsUnprepareNetworkPoliciesPollerResponse contains the response from method Subnets.UnprepareNetworkPolicies.
type SubnetsUnprepareNetworkPoliciesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsUnprepareNetworkPoliciesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsUnprepareNetworkPoliciesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsUnprepareNetworkPoliciesResponse, error) {
	respType := SubnetsUnprepareNetworkPoliciesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsUnprepareNetworkPoliciesPollerResponse from the provided client and resume token.
func (l *SubnetsUnprepareNetworkPoliciesPollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.UnprepareNetworkPolicies", token, client.pl, client.unprepareNetworkPoliciesHandleError)
	if err != nil {
		return err
	}
	poller := &SubnetsUnprepareNetworkPoliciesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsUnprepareNetworkPoliciesResponse contains the response from method Subnets.UnprepareNetworkPolicies.
type SubnetsUnprepareNetworkPoliciesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesListResponse contains the response from method Usages.List.
type UsagesListResponse struct {
	UsagesListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesListResultEnvelope contains the result from method Usages.List.
type UsagesListResultEnvelope struct {
	UsagesListResult
}

// VPNConnectionsCreateOrUpdatePollerResponse contains the response from method VPNConnections.CreateOrUpdate.
type VPNConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsCreateOrUpdateResponse, error) {
	respType := VPNConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsCreateOrUpdateResponse contains the response from method VPNConnections.CreateOrUpdate.
type VPNConnectionsCreateOrUpdateResponse struct {
	VPNConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsCreateOrUpdateResult contains the result from method VPNConnections.CreateOrUpdate.
type VPNConnectionsCreateOrUpdateResult struct {
	VPNConnection
}

// VPNConnectionsDeletePollerResponse contains the response from method VPNConnections.Delete.
type VPNConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsDeleteResponse, error) {
	respType := VPNConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsDeletePollerResponse from the provided client and resume token.
func (l *VPNConnectionsDeletePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsDeleteResponse contains the response from method VPNConnections.Delete.
type VPNConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsGetResponse contains the response from method VPNConnections.Get.
type VPNConnectionsGetResponse struct {
	VPNConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsGetResult contains the result from method VPNConnections.Get.
type VPNConnectionsGetResult struct {
	VPNConnection
}

// VPNConnectionsListByVPNGatewayResponse contains the response from method VPNConnections.ListByVPNGateway.
type VPNConnectionsListByVPNGatewayResponse struct {
	VPNConnectionsListByVPNGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsListByVPNGatewayResult contains the result from method VPNConnections.ListByVPNGateway.
type VPNConnectionsListByVPNGatewayResult struct {
	ListVPNConnectionsResult
}

// VPNConnectionsStartPacketCapturePollerResponse contains the response from method VPNConnections.StartPacketCapture.
type VPNConnectionsStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsStartPacketCaptureResponse, error) {
	respType := VPNConnectionsStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsStartPacketCapturePollerResponse from the provided client and resume token.
func (l *VPNConnectionsStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.StartPacketCapture", token, client.pl, client.startPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsStartPacketCaptureResponse contains the response from method VPNConnections.StartPacketCapture.
type VPNConnectionsStartPacketCaptureResponse struct {
	VPNConnectionsStartPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsStartPacketCaptureResult contains the result from method VPNConnections.StartPacketCapture.
type VPNConnectionsStartPacketCaptureResult struct {
	Value *string
}

// VPNConnectionsStopPacketCapturePollerResponse contains the response from method VPNConnections.StopPacketCapture.
type VPNConnectionsStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsStopPacketCaptureResponse, error) {
	respType := VPNConnectionsStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsStopPacketCapturePollerResponse from the provided client and resume token.
func (l *VPNConnectionsStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.StopPacketCapture", token, client.pl, client.stopPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsStopPacketCaptureResponse contains the response from method VPNConnections.StopPacketCapture.
type VPNConnectionsStopPacketCaptureResponse struct {
	VPNConnectionsStopPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsStopPacketCaptureResult contains the result from method VPNConnections.StopPacketCapture.
type VPNConnectionsStopPacketCaptureResult struct {
	Value *string
}

// VPNGatewaysCreateOrUpdatePollerResponse contains the response from method VPNGateways.CreateOrUpdate.
type VPNGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysCreateOrUpdateResponse, error) {
	respType := VPNGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysCreateOrUpdateResponse contains the response from method VPNGateways.CreateOrUpdate.
type VPNGatewaysCreateOrUpdateResponse struct {
	VPNGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysCreateOrUpdateResult contains the result from method VPNGateways.CreateOrUpdate.
type VPNGatewaysCreateOrUpdateResult struct {
	VPNGateway
}

// VPNGatewaysDeletePollerResponse contains the response from method VPNGateways.Delete.
type VPNGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysDeleteResponse, error) {
	respType := VPNGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysDeletePollerResponse from the provided client and resume token.
func (l *VPNGatewaysDeletePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysDeleteResponse contains the response from method VPNGateways.Delete.
type VPNGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysGetResponse contains the response from method VPNGateways.Get.
type VPNGatewaysGetResponse struct {
	VPNGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysGetResult contains the result from method VPNGateways.Get.
type VPNGatewaysGetResult struct {
	VPNGateway
}

// VPNGatewaysListByResourceGroupResponse contains the response from method VPNGateways.ListByResourceGroup.
type VPNGatewaysListByResourceGroupResponse struct {
	VPNGatewaysListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysListByResourceGroupResult contains the result from method VPNGateways.ListByResourceGroup.
type VPNGatewaysListByResourceGroupResult struct {
	ListVPNGatewaysResult
}

// VPNGatewaysListResponse contains the response from method VPNGateways.List.
type VPNGatewaysListResponse struct {
	VPNGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysListResult contains the result from method VPNGateways.List.
type VPNGatewaysListResult struct {
	ListVPNGatewaysResult
}

// VPNGatewaysResetPollerResponse contains the response from method VPNGateways.Reset.
type VPNGatewaysResetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysResetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysResetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysResetResponse, error) {
	respType := VPNGatewaysResetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysResetPollerResponse from the provided client and resume token.
func (l *VPNGatewaysResetPollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Reset", token, client.pl, client.resetHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysResetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysResetResponse contains the response from method VPNGateways.Reset.
type VPNGatewaysResetResponse struct {
	VPNGatewaysResetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysResetResult contains the result from method VPNGateways.Reset.
type VPNGatewaysResetResult struct {
	VPNGateway
}

// VPNGatewaysStartPacketCapturePollerResponse contains the response from method VPNGateways.StartPacketCapture.
type VPNGatewaysStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysStartPacketCaptureResponse, error) {
	respType := VPNGatewaysStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysStartPacketCapturePollerResponse from the provided client and resume token.
func (l *VPNGatewaysStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.StartPacketCapture", token, client.pl, client.startPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysStartPacketCaptureResponse contains the response from method VPNGateways.StartPacketCapture.
type VPNGatewaysStartPacketCaptureResponse struct {
	VPNGatewaysStartPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysStartPacketCaptureResult contains the result from method VPNGateways.StartPacketCapture.
type VPNGatewaysStartPacketCaptureResult struct {
	Value *string
}

// VPNGatewaysStopPacketCapturePollerResponse contains the response from method VPNGateways.StopPacketCapture.
type VPNGatewaysStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysStopPacketCaptureResponse, error) {
	respType := VPNGatewaysStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysStopPacketCapturePollerResponse from the provided client and resume token.
func (l *VPNGatewaysStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.StopPacketCapture", token, client.pl, client.stopPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysStopPacketCaptureResponse contains the response from method VPNGateways.StopPacketCapture.
type VPNGatewaysStopPacketCaptureResponse struct {
	VPNGatewaysStopPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysStopPacketCaptureResult contains the result from method VPNGateways.StopPacketCapture.
type VPNGatewaysStopPacketCaptureResult struct {
	Value *string
}

// VPNGatewaysUpdateTagsPollerResponse contains the response from method VPNGateways.UpdateTags.
type VPNGatewaysUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysUpdateTagsResponse, error) {
	respType := VPNGatewaysUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysUpdateTagsPollerResponse from the provided client and resume token.
func (l *VPNGatewaysUpdateTagsPollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysUpdateTagsResponse contains the response from method VPNGateways.UpdateTags.
type VPNGatewaysUpdateTagsResponse struct {
	VPNGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysUpdateTagsResult contains the result from method VPNGateways.UpdateTags.
type VPNGatewaysUpdateTagsResult struct {
	VPNGateway
}

// VPNLinkConnectionsGetIkeSasPollerResponse contains the response from method VPNLinkConnections.GetIkeSas.
type VPNLinkConnectionsGetIkeSasPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNLinkConnectionsGetIkeSasPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNLinkConnectionsGetIkeSasPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNLinkConnectionsGetIkeSasResponse, error) {
	respType := VPNLinkConnectionsGetIkeSasResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNLinkConnectionsGetIkeSasPollerResponse from the provided client and resume token.
func (l *VPNLinkConnectionsGetIkeSasPollerResponse) Resume(ctx context.Context, client *VPNLinkConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNLinkConnectionsClient.GetIkeSas", token, client.pl, client.getIkeSasHandleError)
	if err != nil {
		return err
	}
	poller := &VPNLinkConnectionsGetIkeSasPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNLinkConnectionsGetIkeSasResponse contains the response from method VPNLinkConnections.GetIkeSas.
type VPNLinkConnectionsGetIkeSasResponse struct {
	VPNLinkConnectionsGetIkeSasResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNLinkConnectionsGetIkeSasResult contains the result from method VPNLinkConnections.GetIkeSas.
type VPNLinkConnectionsGetIkeSasResult struct {
	Value *string
}

// VPNLinkConnectionsListByVPNConnectionResponse contains the response from method VPNLinkConnections.ListByVPNConnection.
type VPNLinkConnectionsListByVPNConnectionResponse struct {
	VPNLinkConnectionsListByVPNConnectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNLinkConnectionsListByVPNConnectionResult contains the result from method VPNLinkConnections.ListByVPNConnection.
type VPNLinkConnectionsListByVPNConnectionResult struct {
	ListVPNSiteLinkConnectionsResult
}

// VPNLinkConnectionsResetConnectionPollerResponse contains the response from method VPNLinkConnections.ResetConnection.
type VPNLinkConnectionsResetConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNLinkConnectionsResetConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNLinkConnectionsResetConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNLinkConnectionsResetConnectionResponse, error) {
	respType := VPNLinkConnectionsResetConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNLinkConnectionsResetConnectionPollerResponse from the provided client and resume token.
func (l *VPNLinkConnectionsResetConnectionPollerResponse) Resume(ctx context.Context, client *VPNLinkConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNLinkConnectionsClient.ResetConnection", token, client.pl, client.resetConnectionHandleError)
	if err != nil {
		return err
	}
	poller := &VPNLinkConnectionsResetConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNLinkConnectionsResetConnectionResponse contains the response from method VPNLinkConnections.ResetConnection.
type VPNLinkConnectionsResetConnectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsAssociatedWithVirtualWanListPollerResponse contains the response from method VPNServerConfigurationsAssociatedWithVirtualWan.List.
type VPNServerConfigurationsAssociatedWithVirtualWanListPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsAssociatedWithVirtualWanListPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsAssociatedWithVirtualWanListPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsAssociatedWithVirtualWanListResponse, error) {
	respType := VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfigurationsResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsAssociatedWithVirtualWanListPollerResponse from the provided client and resume token.
func (l *VPNServerConfigurationsAssociatedWithVirtualWanListPollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsAssociatedWithVirtualWanClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsAssociatedWithVirtualWanClient.List", token, client.pl, client.listHandleError)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsAssociatedWithVirtualWanListPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsAssociatedWithVirtualWanListResponse contains the response from method VPNServerConfigurationsAssociatedWithVirtualWan.List.
type VPNServerConfigurationsAssociatedWithVirtualWanListResponse struct {
	VPNServerConfigurationsAssociatedWithVirtualWanListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsAssociatedWithVirtualWanListResult contains the result from method VPNServerConfigurationsAssociatedWithVirtualWan.List.
type VPNServerConfigurationsAssociatedWithVirtualWanListResult struct {
	VPNServerConfigurationsResponse
}

// VPNServerConfigurationsCreateOrUpdatePollerResponse contains the response from method VPNServerConfigurations.CreateOrUpdate.
type VPNServerConfigurationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsCreateOrUpdateResponse, error) {
	respType := VPNServerConfigurationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNServerConfigurationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsCreateOrUpdateResponse contains the response from method VPNServerConfigurations.CreateOrUpdate.
type VPNServerConfigurationsCreateOrUpdateResponse struct {
	VPNServerConfigurationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsCreateOrUpdateResult contains the result from method VPNServerConfigurations.CreateOrUpdate.
type VPNServerConfigurationsCreateOrUpdateResult struct {
	VPNServerConfiguration
}

// VPNServerConfigurationsDeletePollerResponse contains the response from method VPNServerConfigurations.Delete.
type VPNServerConfigurationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsDeleteResponse, error) {
	respType := VPNServerConfigurationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsDeletePollerResponse from the provided client and resume token.
func (l *VPNServerConfigurationsDeletePollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsDeleteResponse contains the response from method VPNServerConfigurations.Delete.
type VPNServerConfigurationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsGetResponse contains the response from method VPNServerConfigurations.Get.
type VPNServerConfigurationsGetResponse struct {
	VPNServerConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsGetResult contains the result from method VPNServerConfigurations.Get.
type VPNServerConfigurationsGetResult struct {
	VPNServerConfiguration
}

// VPNServerConfigurationsListByResourceGroupResponse contains the response from method VPNServerConfigurations.ListByResourceGroup.
type VPNServerConfigurationsListByResourceGroupResponse struct {
	VPNServerConfigurationsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsListByResourceGroupResult contains the result from method VPNServerConfigurations.ListByResourceGroup.
type VPNServerConfigurationsListByResourceGroupResult struct {
	ListVPNServerConfigurationsResult
}

// VPNServerConfigurationsListResponse contains the response from method VPNServerConfigurations.List.
type VPNServerConfigurationsListResponse struct {
	VPNServerConfigurationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsListResult contains the result from method VPNServerConfigurations.List.
type VPNServerConfigurationsListResult struct {
	ListVPNServerConfigurationsResult
}

// VPNServerConfigurationsUpdateTagsResponse contains the response from method VPNServerConfigurations.UpdateTags.
type VPNServerConfigurationsUpdateTagsResponse struct {
	VPNServerConfigurationsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsUpdateTagsResult contains the result from method VPNServerConfigurations.UpdateTags.
type VPNServerConfigurationsUpdateTagsResult struct {
	VPNServerConfiguration
}

// VPNSiteLinkConnectionsGetResponse contains the response from method VPNSiteLinkConnections.Get.
type VPNSiteLinkConnectionsGetResponse struct {
	VPNSiteLinkConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinkConnectionsGetResult contains the result from method VPNSiteLinkConnections.Get.
type VPNSiteLinkConnectionsGetResult struct {
	VPNSiteLinkConnection
}

// VPNSiteLinksGetResponse contains the response from method VPNSiteLinks.Get.
type VPNSiteLinksGetResponse struct {
	VPNSiteLinksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinksGetResult contains the result from method VPNSiteLinks.Get.
type VPNSiteLinksGetResult struct {
	VPNSiteLink
}

// VPNSiteLinksListByVPNSiteResponse contains the response from method VPNSiteLinks.ListByVPNSite.
type VPNSiteLinksListByVPNSiteResponse struct {
	VPNSiteLinksListByVPNSiteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinksListByVPNSiteResult contains the result from method VPNSiteLinks.ListByVPNSite.
type VPNSiteLinksListByVPNSiteResult struct {
	ListVPNSiteLinksResult
}

// VPNSitesConfigurationDownloadPollerResponse contains the response from method VPNSitesConfiguration.Download.
type VPNSitesConfigurationDownloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesConfigurationDownloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesConfigurationDownloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesConfigurationDownloadResponse, error) {
	respType := VPNSitesConfigurationDownloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesConfigurationDownloadPollerResponse from the provided client and resume token.
func (l *VPNSitesConfigurationDownloadPollerResponse) Resume(ctx context.Context, client *VPNSitesConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesConfigurationClient.Download", token, client.pl, client.downloadHandleError)
	if err != nil {
		return err
	}
	poller := &VPNSitesConfigurationDownloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesConfigurationDownloadResponse contains the response from method VPNSitesConfiguration.Download.
type VPNSitesConfigurationDownloadResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesCreateOrUpdatePollerResponse contains the response from method VPNSites.CreateOrUpdate.
type VPNSitesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesCreateOrUpdateResponse, error) {
	respType := VPNSitesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNSite)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNSitesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VPNSitesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesCreateOrUpdateResponse contains the response from method VPNSites.CreateOrUpdate.
type VPNSitesCreateOrUpdateResponse struct {
	VPNSitesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesCreateOrUpdateResult contains the result from method VPNSites.CreateOrUpdate.
type VPNSitesCreateOrUpdateResult struct {
	VPNSite
}

// VPNSitesDeletePollerResponse contains the response from method VPNSites.Delete.
type VPNSitesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesDeleteResponse, error) {
	respType := VPNSitesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesDeletePollerResponse from the provided client and resume token.
func (l *VPNSitesDeletePollerResponse) Resume(ctx context.Context, client *VPNSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VPNSitesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesDeleteResponse contains the response from method VPNSites.Delete.
type VPNSitesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesGetResponse contains the response from method VPNSites.Get.
type VPNSitesGetResponse struct {
	VPNSitesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesGetResult contains the result from method VPNSites.Get.
type VPNSitesGetResult struct {
	VPNSite
}

// VPNSitesListByResourceGroupResponse contains the response from method VPNSites.ListByResourceGroup.
type VPNSitesListByResourceGroupResponse struct {
	VPNSitesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesListByResourceGroupResult contains the result from method VPNSites.ListByResourceGroup.
type VPNSitesListByResourceGroupResult struct {
	ListVPNSitesResult
}

// VPNSitesListResponse contains the response from method VPNSites.List.
type VPNSitesListResponse struct {
	VPNSitesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesListResult contains the result from method VPNSites.List.
type VPNSitesListResult struct {
	ListVPNSitesResult
}

// VPNSitesUpdateTagsResponse contains the response from method VPNSites.UpdateTags.
type VPNSitesUpdateTagsResponse struct {
	VPNSitesUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesUpdateTagsResult contains the result from method VPNSites.UpdateTags.
type VPNSitesUpdateTagsResult struct {
	VPNSite
}

// VirtualApplianceSKUsGetResponse contains the response from method VirtualApplianceSKUs.Get.
type VirtualApplianceSKUsGetResponse struct {
	VirtualApplianceSKUsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSKUsGetResult contains the result from method VirtualApplianceSKUs.Get.
type VirtualApplianceSKUsGetResult struct {
	NetworkVirtualApplianceSKU
}

// VirtualApplianceSKUsListResponse contains the response from method VirtualApplianceSKUs.List.
type VirtualApplianceSKUsListResponse struct {
	VirtualApplianceSKUsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSKUsListResult contains the result from method VirtualApplianceSKUs.List.
type VirtualApplianceSKUsListResult struct {
	NetworkVirtualApplianceSKUListResult
}

// VirtualApplianceSitesCreateOrUpdatePollerResponse contains the response from method VirtualApplianceSites.CreateOrUpdate.
type VirtualApplianceSitesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualApplianceSitesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualApplianceSitesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualApplianceSitesCreateOrUpdateResponse, error) {
	respType := VirtualApplianceSitesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualApplianceSite)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualApplianceSitesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualApplianceSitesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualApplianceSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualApplianceSitesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualApplianceSitesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualApplianceSitesCreateOrUpdateResponse contains the response from method VirtualApplianceSites.CreateOrUpdate.
type VirtualApplianceSitesCreateOrUpdateResponse struct {
	VirtualApplianceSitesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSitesCreateOrUpdateResult contains the result from method VirtualApplianceSites.CreateOrUpdate.
type VirtualApplianceSitesCreateOrUpdateResult struct {
	VirtualApplianceSite
}

// VirtualApplianceSitesDeletePollerResponse contains the response from method VirtualApplianceSites.Delete.
type VirtualApplianceSitesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualApplianceSitesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualApplianceSitesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualApplianceSitesDeleteResponse, error) {
	respType := VirtualApplianceSitesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualApplianceSitesDeletePollerResponse from the provided client and resume token.
func (l *VirtualApplianceSitesDeletePollerResponse) Resume(ctx context.Context, client *VirtualApplianceSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualApplianceSitesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualApplianceSitesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualApplianceSitesDeleteResponse contains the response from method VirtualApplianceSites.Delete.
type VirtualApplianceSitesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSitesGetResponse contains the response from method VirtualApplianceSites.Get.
type VirtualApplianceSitesGetResponse struct {
	VirtualApplianceSitesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSitesGetResult contains the result from method VirtualApplianceSites.Get.
type VirtualApplianceSitesGetResult struct {
	VirtualApplianceSite
}

// VirtualApplianceSitesListResponse contains the response from method VirtualApplianceSites.List.
type VirtualApplianceSitesListResponse struct {
	VirtualApplianceSitesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualApplianceSitesListResult contains the result from method VirtualApplianceSites.List.
type VirtualApplianceSitesListResult struct {
	NetworkVirtualApplianceSiteListResult
}

// VirtualHubBgpConnectionCreateOrUpdatePollerResponse contains the response from method VirtualHubBgpConnection.CreateOrUpdate.
type VirtualHubBgpConnectionCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubBgpConnectionCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubBgpConnectionCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubBgpConnectionCreateOrUpdateResponse, error) {
	respType := VirtualHubBgpConnectionCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BgpConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubBgpConnectionCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubBgpConnectionCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubBgpConnectionClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubBgpConnectionClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubBgpConnectionCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubBgpConnectionCreateOrUpdateResponse contains the response from method VirtualHubBgpConnection.CreateOrUpdate.
type VirtualHubBgpConnectionCreateOrUpdateResponse struct {
	VirtualHubBgpConnectionCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionCreateOrUpdateResult contains the result from method VirtualHubBgpConnection.CreateOrUpdate.
type VirtualHubBgpConnectionCreateOrUpdateResult struct {
	BgpConnection
}

// VirtualHubBgpConnectionDeletePollerResponse contains the response from method VirtualHubBgpConnection.Delete.
type VirtualHubBgpConnectionDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubBgpConnectionDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubBgpConnectionDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubBgpConnectionDeleteResponse, error) {
	respType := VirtualHubBgpConnectionDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubBgpConnectionDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubBgpConnectionDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubBgpConnectionClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubBgpConnectionClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubBgpConnectionDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubBgpConnectionDeleteResponse contains the response from method VirtualHubBgpConnection.Delete.
type VirtualHubBgpConnectionDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionGetResponse contains the response from method VirtualHubBgpConnection.Get.
type VirtualHubBgpConnectionGetResponse struct {
	VirtualHubBgpConnectionGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionGetResult contains the result from method VirtualHubBgpConnection.Get.
type VirtualHubBgpConnectionGetResult struct {
	BgpConnection
}

// VirtualHubBgpConnectionsListAdvertisedRoutesPollerResponse contains the response from method VirtualHubBgpConnections.ListAdvertisedRoutes.
type VirtualHubBgpConnectionsListAdvertisedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubBgpConnectionsListAdvertisedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubBgpConnectionsListAdvertisedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubBgpConnectionsListAdvertisedRoutesResponse, error) {
	respType := VirtualHubBgpConnectionsListAdvertisedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PeerRouteList)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubBgpConnectionsListAdvertisedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualHubBgpConnectionsListAdvertisedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualHubBgpConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubBgpConnectionsClient.ListAdvertisedRoutes", token, client.pl, client.listAdvertisedRoutesHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubBgpConnectionsListAdvertisedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubBgpConnectionsListAdvertisedRoutesResponse contains the response from method VirtualHubBgpConnections.ListAdvertisedRoutes.
type VirtualHubBgpConnectionsListAdvertisedRoutesResponse struct {
	VirtualHubBgpConnectionsListAdvertisedRoutesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionsListAdvertisedRoutesResult contains the result from method VirtualHubBgpConnections.ListAdvertisedRoutes.
type VirtualHubBgpConnectionsListAdvertisedRoutesResult struct {
	PeerRouteList
}

// VirtualHubBgpConnectionsListLearnedRoutesPollerResponse contains the response from method VirtualHubBgpConnections.ListLearnedRoutes.
type VirtualHubBgpConnectionsListLearnedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubBgpConnectionsListLearnedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubBgpConnectionsListLearnedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubBgpConnectionsListLearnedRoutesResponse, error) {
	respType := VirtualHubBgpConnectionsListLearnedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PeerRouteList)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubBgpConnectionsListLearnedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualHubBgpConnectionsListLearnedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualHubBgpConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubBgpConnectionsClient.ListLearnedRoutes", token, client.pl, client.listLearnedRoutesHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubBgpConnectionsListLearnedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubBgpConnectionsListLearnedRoutesResponse contains the response from method VirtualHubBgpConnections.ListLearnedRoutes.
type VirtualHubBgpConnectionsListLearnedRoutesResponse struct {
	VirtualHubBgpConnectionsListLearnedRoutesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionsListLearnedRoutesResult contains the result from method VirtualHubBgpConnections.ListLearnedRoutes.
type VirtualHubBgpConnectionsListLearnedRoutesResult struct {
	PeerRouteList
}

// VirtualHubBgpConnectionsListResponse contains the response from method VirtualHubBgpConnections.List.
type VirtualHubBgpConnectionsListResponse struct {
	VirtualHubBgpConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubBgpConnectionsListResult contains the result from method VirtualHubBgpConnections.List.
type VirtualHubBgpConnectionsListResult struct {
	ListVirtualHubBgpConnectionResults
}

// VirtualHubIPConfigurationCreateOrUpdatePollerResponse contains the response from method VirtualHubIPConfiguration.CreateOrUpdate.
type VirtualHubIPConfigurationCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubIPConfigurationCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubIPConfigurationCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubIPConfigurationCreateOrUpdateResponse, error) {
	respType := VirtualHubIPConfigurationCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.HubIPConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubIPConfigurationCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubIPConfigurationCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubIPConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubIPConfigurationClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubIPConfigurationCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubIPConfigurationCreateOrUpdateResponse contains the response from method VirtualHubIPConfiguration.CreateOrUpdate.
type VirtualHubIPConfigurationCreateOrUpdateResponse struct {
	VirtualHubIPConfigurationCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubIPConfigurationCreateOrUpdateResult contains the result from method VirtualHubIPConfiguration.CreateOrUpdate.
type VirtualHubIPConfigurationCreateOrUpdateResult struct {
	HubIPConfiguration
}

// VirtualHubIPConfigurationDeletePollerResponse contains the response from method VirtualHubIPConfiguration.Delete.
type VirtualHubIPConfigurationDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubIPConfigurationDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubIPConfigurationDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubIPConfigurationDeleteResponse, error) {
	respType := VirtualHubIPConfigurationDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubIPConfigurationDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubIPConfigurationDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubIPConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubIPConfigurationClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubIPConfigurationDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubIPConfigurationDeleteResponse contains the response from method VirtualHubIPConfiguration.Delete.
type VirtualHubIPConfigurationDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubIPConfigurationGetResponse contains the response from method VirtualHubIPConfiguration.Get.
type VirtualHubIPConfigurationGetResponse struct {
	VirtualHubIPConfigurationGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubIPConfigurationGetResult contains the result from method VirtualHubIPConfiguration.Get.
type VirtualHubIPConfigurationGetResult struct {
	HubIPConfiguration
}

// VirtualHubIPConfigurationListResponse contains the response from method VirtualHubIPConfiguration.List.
type VirtualHubIPConfigurationListResponse struct {
	VirtualHubIPConfigurationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubIPConfigurationListResult contains the result from method VirtualHubIPConfiguration.List.
type VirtualHubIPConfigurationListResult struct {
	ListVirtualHubIPConfigurationResults
}

// VirtualHubRouteTableV2SCreateOrUpdatePollerResponse contains the response from method VirtualHubRouteTableV2S.CreateOrUpdate.
type VirtualHubRouteTableV2SCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubRouteTableV2SCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubRouteTableV2SCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SCreateOrUpdateResponse, error) {
	respType := VirtualHubRouteTableV2SCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualHubRouteTableV2)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubRouteTableV2SCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubRouteTableV2SCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubRouteTableV2SClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubRouteTableV2SCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubRouteTableV2SCreateOrUpdateResponse contains the response from method VirtualHubRouteTableV2S.CreateOrUpdate.
type VirtualHubRouteTableV2SCreateOrUpdateResponse struct {
	VirtualHubRouteTableV2SCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SCreateOrUpdateResult contains the result from method VirtualHubRouteTableV2S.CreateOrUpdate.
type VirtualHubRouteTableV2SCreateOrUpdateResult struct {
	VirtualHubRouteTableV2
}

// VirtualHubRouteTableV2SDeletePollerResponse contains the response from method VirtualHubRouteTableV2S.Delete.
type VirtualHubRouteTableV2SDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubRouteTableV2SDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubRouteTableV2SDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SDeleteResponse, error) {
	respType := VirtualHubRouteTableV2SDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubRouteTableV2SDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubRouteTableV2SDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubRouteTableV2SClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubRouteTableV2SDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubRouteTableV2SDeleteResponse contains the response from method VirtualHubRouteTableV2S.Delete.
type VirtualHubRouteTableV2SDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SGetResponse contains the response from method VirtualHubRouteTableV2S.Get.
type VirtualHubRouteTableV2SGetResponse struct {
	VirtualHubRouteTableV2SGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SGetResult contains the result from method VirtualHubRouteTableV2S.Get.
type VirtualHubRouteTableV2SGetResult struct {
	VirtualHubRouteTableV2
}

// VirtualHubRouteTableV2SListResponse contains the response from method VirtualHubRouteTableV2S.List.
type VirtualHubRouteTableV2SListResponse struct {
	VirtualHubRouteTableV2SListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SListResult contains the result from method VirtualHubRouteTableV2S.List.
type VirtualHubRouteTableV2SListResult struct {
	ListVirtualHubRouteTableV2SResult
}

// VirtualHubsCreateOrUpdatePollerResponse contains the response from method VirtualHubs.CreateOrUpdate.
type VirtualHubsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsCreateOrUpdateResponse, error) {
	respType := VirtualHubsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualHub)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubsCreateOrUpdateResponse contains the response from method VirtualHubs.CreateOrUpdate.
type VirtualHubsCreateOrUpdateResponse struct {
	VirtualHubsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsCreateOrUpdateResult contains the result from method VirtualHubs.CreateOrUpdate.
type VirtualHubsCreateOrUpdateResult struct {
	VirtualHub
}

// VirtualHubsDeletePollerResponse contains the response from method VirtualHubs.Delete.
type VirtualHubsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsDeleteResponse, error) {
	respType := VirtualHubsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubsDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubsDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubsDeleteResponse contains the response from method VirtualHubs.Delete.
type VirtualHubsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsGetEffectiveVirtualHubRoutesPollerResponse contains the response from method VirtualHubs.GetEffectiveVirtualHubRoutes.
type VirtualHubsGetEffectiveVirtualHubRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubsGetEffectiveVirtualHubRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubsGetEffectiveVirtualHubRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsGetEffectiveVirtualHubRoutesResponse, error) {
	respType := VirtualHubsGetEffectiveVirtualHubRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubsGetEffectiveVirtualHubRoutesPollerResponse from the provided client and resume token.
func (l *VirtualHubsGetEffectiveVirtualHubRoutesPollerResponse) Resume(ctx context.Context, client *VirtualHubsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubsClient.GetEffectiveVirtualHubRoutes", token, client.pl, client.getEffectiveVirtualHubRoutesHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualHubsGetEffectiveVirtualHubRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubsGetEffectiveVirtualHubRoutesResponse contains the response from method VirtualHubs.GetEffectiveVirtualHubRoutes.
type VirtualHubsGetEffectiveVirtualHubRoutesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsGetResponse contains the response from method VirtualHubs.Get.
type VirtualHubsGetResponse struct {
	VirtualHubsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsGetResult contains the result from method VirtualHubs.Get.
type VirtualHubsGetResult struct {
	VirtualHub
}

// VirtualHubsListByResourceGroupResponse contains the response from method VirtualHubs.ListByResourceGroup.
type VirtualHubsListByResourceGroupResponse struct {
	VirtualHubsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsListByResourceGroupResult contains the result from method VirtualHubs.ListByResourceGroup.
type VirtualHubsListByResourceGroupResult struct {
	ListVirtualHubsResult
}

// VirtualHubsListResponse contains the response from method VirtualHubs.List.
type VirtualHubsListResponse struct {
	VirtualHubsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsListResult contains the result from method VirtualHubs.List.
type VirtualHubsListResult struct {
	ListVirtualHubsResult
}

// VirtualHubsUpdateTagsResponse contains the response from method VirtualHubs.UpdateTags.
type VirtualHubsUpdateTagsResponse struct {
	VirtualHubsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsUpdateTagsResult contains the result from method VirtualHubs.UpdateTags.
type VirtualHubsUpdateTagsResult struct {
	VirtualHub
}

// VirtualNetworkGatewayConnectionsCreateOrUpdatePollerResponse contains the response from method VirtualNetworkGatewayConnections.CreateOrUpdate.
type VirtualNetworkGatewayConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsCreateOrUpdateResponse contains the response from method VirtualNetworkGatewayConnections.CreateOrUpdate.
type VirtualNetworkGatewayConnectionsCreateOrUpdateResponse struct {
	VirtualNetworkGatewayConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsCreateOrUpdateResult contains the result from method VirtualNetworkGatewayConnections.CreateOrUpdate.
type VirtualNetworkGatewayConnectionsCreateOrUpdateResult struct {
	VirtualNetworkGatewayConnection
}

// VirtualNetworkGatewayConnectionsDeletePollerResponse contains the response from method VirtualNetworkGatewayConnections.Delete.
type VirtualNetworkGatewayConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsDeleteResponse, error) {
	respType := VirtualNetworkGatewayConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsDeleteResponse contains the response from method VirtualNetworkGatewayConnections.Delete.
type VirtualNetworkGatewayConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsGetIkeSasPollerResponse contains the response from method VirtualNetworkGatewayConnections.GetIkeSas.
type VirtualNetworkGatewayConnectionsGetIkeSasPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsGetIkeSasPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsGetIkeSasPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsGetIkeSasResponse, error) {
	respType := VirtualNetworkGatewayConnectionsGetIkeSasResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsGetIkeSasPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsGetIkeSasPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.GetIkeSas", token, client.pl, client.getIkeSasHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsGetIkeSasPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsGetIkeSasResponse contains the response from method VirtualNetworkGatewayConnections.GetIkeSas.
type VirtualNetworkGatewayConnectionsGetIkeSasResponse struct {
	VirtualNetworkGatewayConnectionsGetIkeSasResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsGetIkeSasResult contains the result from method VirtualNetworkGatewayConnections.GetIkeSas.
type VirtualNetworkGatewayConnectionsGetIkeSasResult struct {
	Value *string
}

// VirtualNetworkGatewayConnectionsGetResponse contains the response from method VirtualNetworkGatewayConnections.Get.
type VirtualNetworkGatewayConnectionsGetResponse struct {
	VirtualNetworkGatewayConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsGetResult contains the result from method VirtualNetworkGatewayConnections.Get.
type VirtualNetworkGatewayConnectionsGetResult struct {
	VirtualNetworkGatewayConnection
}

// VirtualNetworkGatewayConnectionsGetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnections.GetSharedKey.
type VirtualNetworkGatewayConnectionsGetSharedKeyResponse struct {
	VirtualNetworkGatewayConnectionsGetSharedKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsGetSharedKeyResult contains the result from method VirtualNetworkGatewayConnections.GetSharedKey.
type VirtualNetworkGatewayConnectionsGetSharedKeyResult struct {
	ConnectionSharedKey
}

// VirtualNetworkGatewayConnectionsListResponse contains the response from method VirtualNetworkGatewayConnections.List.
type VirtualNetworkGatewayConnectionsListResponse struct {
	VirtualNetworkGatewayConnectionsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsListResult contains the result from method VirtualNetworkGatewayConnections.List.
type VirtualNetworkGatewayConnectionsListResult struct {
	VirtualNetworkGatewayConnectionListResult
}

// VirtualNetworkGatewayConnectionsResetConnectionPollerResponse contains the response from method VirtualNetworkGatewayConnections.ResetConnection.
type VirtualNetworkGatewayConnectionsResetConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsResetConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsResetConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsResetConnectionResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsResetConnectionPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsResetConnectionPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.ResetConnection", token, client.pl, client.resetConnectionHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsResetConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsResetConnectionResponse contains the response from method VirtualNetworkGatewayConnections.ResetConnection.
type VirtualNetworkGatewayConnectionsResetConnectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsResetSharedKeyPollerResponse contains the response from method VirtualNetworkGatewayConnections.ResetSharedKey.
type VirtualNetworkGatewayConnectionsResetSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsResetSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsResetSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsResetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionResetSharedKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsResetSharedKeyPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsResetSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.ResetSharedKey", token, client.pl, client.resetSharedKeyHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsResetSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsResetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnections.ResetSharedKey.
type VirtualNetworkGatewayConnectionsResetSharedKeyResponse struct {
	VirtualNetworkGatewayConnectionsResetSharedKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsResetSharedKeyResult contains the result from method VirtualNetworkGatewayConnections.ResetSharedKey.
type VirtualNetworkGatewayConnectionsResetSharedKeyResult struct {
	ConnectionResetSharedKey
}

// VirtualNetworkGatewayConnectionsSetSharedKeyPollerResponse contains the response from method VirtualNetworkGatewayConnections.SetSharedKey.
type VirtualNetworkGatewayConnectionsSetSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsSetSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsSetSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsSetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionSharedKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsSetSharedKeyPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsSetSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.SetSharedKey", token, client.pl, client.setSharedKeyHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsSetSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsSetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnections.SetSharedKey.
type VirtualNetworkGatewayConnectionsSetSharedKeyResponse struct {
	VirtualNetworkGatewayConnectionsSetSharedKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsSetSharedKeyResult contains the result from method VirtualNetworkGatewayConnections.SetSharedKey.
type VirtualNetworkGatewayConnectionsSetSharedKeyResult struct {
	ConnectionSharedKey
}

// VirtualNetworkGatewayConnectionsStartPacketCapturePollerResponse contains the response from method VirtualNetworkGatewayConnections.StartPacketCapture.
type VirtualNetworkGatewayConnectionsStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsStartPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StartPacketCapture", token, client.pl, client.startPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsStartPacketCaptureResponse contains the response from method VirtualNetworkGatewayConnections.StartPacketCapture.
type VirtualNetworkGatewayConnectionsStartPacketCaptureResponse struct {
	VirtualNetworkGatewayConnectionsStartPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsStartPacketCaptureResult contains the result from method VirtualNetworkGatewayConnections.StartPacketCapture.
type VirtualNetworkGatewayConnectionsStartPacketCaptureResult struct {
	Value *string
}

// VirtualNetworkGatewayConnectionsStopPacketCapturePollerResponse contains the response from method VirtualNetworkGatewayConnections.StopPacketCapture.
type VirtualNetworkGatewayConnectionsStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsStopPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StopPacketCapture", token, client.pl, client.stopPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsStopPacketCaptureResponse contains the response from method VirtualNetworkGatewayConnections.StopPacketCapture.
type VirtualNetworkGatewayConnectionsStopPacketCaptureResponse struct {
	VirtualNetworkGatewayConnectionsStopPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsStopPacketCaptureResult contains the result from method VirtualNetworkGatewayConnections.StopPacketCapture.
type VirtualNetworkGatewayConnectionsStopPacketCaptureResult struct {
	Value *string
}

// VirtualNetworkGatewayConnectionsUpdateTagsPollerResponse contains the response from method VirtualNetworkGatewayConnections.UpdateTags.
type VirtualNetworkGatewayConnectionsUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewayConnectionsUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsUpdateTagsPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsUpdateTagsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsUpdateTagsResponse contains the response from method VirtualNetworkGatewayConnections.UpdateTags.
type VirtualNetworkGatewayConnectionsUpdateTagsResponse struct {
	VirtualNetworkGatewayConnectionsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsUpdateTagsResult contains the result from method VirtualNetworkGatewayConnections.UpdateTags.
type VirtualNetworkGatewayConnectionsUpdateTagsResult struct {
	VirtualNetworkGatewayConnection
}

// VirtualNetworkGatewayNatRulesCreateOrUpdatePollerResponse contains the response from method VirtualNetworkGatewayNatRules.CreateOrUpdate.
type VirtualNetworkGatewayNatRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayNatRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayNatRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayNatRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayNatRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayNatRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayNatRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayNatRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayNatRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayNatRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayNatRulesCreateOrUpdateResponse contains the response from method VirtualNetworkGatewayNatRules.CreateOrUpdate.
type VirtualNetworkGatewayNatRulesCreateOrUpdateResponse struct {
	VirtualNetworkGatewayNatRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayNatRulesCreateOrUpdateResult contains the result from method VirtualNetworkGatewayNatRules.CreateOrUpdate.
type VirtualNetworkGatewayNatRulesCreateOrUpdateResult struct {
	VirtualNetworkGatewayNatRule
}

// VirtualNetworkGatewayNatRulesDeletePollerResponse contains the response from method VirtualNetworkGatewayNatRules.Delete.
type VirtualNetworkGatewayNatRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayNatRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayNatRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayNatRulesDeleteResponse, error) {
	respType := VirtualNetworkGatewayNatRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayNatRulesDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayNatRulesDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayNatRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayNatRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayNatRulesDeleteResponse contains the response from method VirtualNetworkGatewayNatRules.Delete.
type VirtualNetworkGatewayNatRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayNatRulesGetResponse contains the response from method VirtualNetworkGatewayNatRules.Get.
type VirtualNetworkGatewayNatRulesGetResponse struct {
	VirtualNetworkGatewayNatRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayNatRulesGetResult contains the result from method VirtualNetworkGatewayNatRules.Get.
type VirtualNetworkGatewayNatRulesGetResult struct {
	VirtualNetworkGatewayNatRule
}

// VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse contains the response from method VirtualNetworkGatewayNatRules.ListByVirtualNetworkGateway.
type VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResponse struct {
	VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResult contains the result from method VirtualNetworkGatewayNatRules.ListByVirtualNetworkGateway.
type VirtualNetworkGatewayNatRulesListByVirtualNetworkGatewayResult struct {
	ListVirtualNetworkGatewayNatRulesResult
}

// VirtualNetworkGatewaysCreateOrUpdatePollerResponse contains the response from method VirtualNetworkGateways.CreateOrUpdate.
type VirtualNetworkGatewaysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysCreateOrUpdateResponse contains the response from method VirtualNetworkGateways.CreateOrUpdate.
type VirtualNetworkGatewaysCreateOrUpdateResponse struct {
	VirtualNetworkGatewaysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysCreateOrUpdateResult contains the result from method VirtualNetworkGateways.CreateOrUpdate.
type VirtualNetworkGatewaysCreateOrUpdateResult struct {
	VirtualNetworkGateway
}

// VirtualNetworkGatewaysDeletePollerResponse contains the response from method VirtualNetworkGateways.Delete.
type VirtualNetworkGatewaysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysDeleteResponse, error) {
	respType := VirtualNetworkGatewaysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysDeleteResponse contains the response from method VirtualNetworkGateways.Delete.
type VirtualNetworkGatewaysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse contains the response from method VirtualNetworkGateways.DisconnectVirtualNetworkGatewayVPNConnections.
type VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	respType := VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.DisconnectVirtualNetworkGatewayVPNConnections", token, client.pl, client.disconnectVirtualNetworkGatewayVPNConnectionsHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse contains the response from method VirtualNetworkGateways.DisconnectVirtualNetworkGatewayVPNConnections.
type VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGenerateVPNProfilePollerResponse contains the response from method VirtualNetworkGateways.GenerateVPNProfile.
type VirtualNetworkGatewaysGenerateVPNProfilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGenerateVPNProfilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGenerateVPNProfilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGenerateVPNProfileResponse, error) {
	respType := VirtualNetworkGatewaysGenerateVPNProfileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGenerateVPNProfilePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGenerateVPNProfilePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GenerateVPNProfile", token, client.pl, client.generateVPNProfileHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGenerateVPNProfilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGenerateVPNProfileResponse contains the response from method VirtualNetworkGateways.GenerateVPNProfile.
type VirtualNetworkGatewaysGenerateVPNProfileResponse struct {
	VirtualNetworkGatewaysGenerateVPNProfileResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGenerateVPNProfileResult contains the result from method VirtualNetworkGateways.GenerateVPNProfile.
type VirtualNetworkGatewaysGenerateVPNProfileResult struct {
	Value *string
}

// VirtualNetworkGatewaysGeneratevpnclientpackagePollerResponse contains the response from method VirtualNetworkGateways.Generatevpnclientpackage.
type VirtualNetworkGatewaysGeneratevpnclientpackagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGeneratevpnclientpackagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGeneratevpnclientpackagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGeneratevpnclientpackageResponse, error) {
	respType := VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGeneratevpnclientpackagePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGeneratevpnclientpackagePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Generatevpnclientpackage", token, client.pl, client.generatevpnclientpackageHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGeneratevpnclientpackagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGeneratevpnclientpackageResponse contains the response from method VirtualNetworkGateways.Generatevpnclientpackage.
type VirtualNetworkGatewaysGeneratevpnclientpackageResponse struct {
	VirtualNetworkGatewaysGeneratevpnclientpackageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGeneratevpnclientpackageResult contains the result from method VirtualNetworkGateways.Generatevpnclientpackage.
type VirtualNetworkGatewaysGeneratevpnclientpackageResult struct {
	Value *string
}

// VirtualNetworkGatewaysGetAdvertisedRoutesPollerResponse contains the response from method VirtualNetworkGateways.GetAdvertisedRoutes.
type VirtualNetworkGatewaysGetAdvertisedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetAdvertisedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetAdvertisedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetAdvertisedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetAdvertisedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetAdvertisedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetAdvertisedRoutes", token, client.pl, client.getAdvertisedRoutesHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetAdvertisedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetAdvertisedRoutesResponse contains the response from method VirtualNetworkGateways.GetAdvertisedRoutes.
type VirtualNetworkGatewaysGetAdvertisedRoutesResponse struct {
	VirtualNetworkGatewaysGetAdvertisedRoutesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetAdvertisedRoutesResult contains the result from method VirtualNetworkGateways.GetAdvertisedRoutes.
type VirtualNetworkGatewaysGetAdvertisedRoutesResult struct {
	GatewayRouteListResult
}

// VirtualNetworkGatewaysGetBgpPeerStatusPollerResponse contains the response from method VirtualNetworkGateways.GetBgpPeerStatus.
type VirtualNetworkGatewaysGetBgpPeerStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetBgpPeerStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetBgpPeerStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetBgpPeerStatusResponse, error) {
	respType := VirtualNetworkGatewaysGetBgpPeerStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BgpPeerStatusListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetBgpPeerStatusPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetBgpPeerStatusPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetBgpPeerStatus", token, client.pl, client.getBgpPeerStatusHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetBgpPeerStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetBgpPeerStatusResponse contains the response from method VirtualNetworkGateways.GetBgpPeerStatus.
type VirtualNetworkGatewaysGetBgpPeerStatusResponse struct {
	VirtualNetworkGatewaysGetBgpPeerStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetBgpPeerStatusResult contains the result from method VirtualNetworkGateways.GetBgpPeerStatus.
type VirtualNetworkGatewaysGetBgpPeerStatusResult struct {
	BgpPeerStatusListResult
}

// VirtualNetworkGatewaysGetLearnedRoutesPollerResponse contains the response from method VirtualNetworkGateways.GetLearnedRoutes.
type VirtualNetworkGatewaysGetLearnedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetLearnedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetLearnedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetLearnedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetLearnedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetLearnedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetLearnedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetLearnedRoutes", token, client.pl, client.getLearnedRoutesHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetLearnedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetLearnedRoutesResponse contains the response from method VirtualNetworkGateways.GetLearnedRoutes.
type VirtualNetworkGatewaysGetLearnedRoutesResponse struct {
	VirtualNetworkGatewaysGetLearnedRoutesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetLearnedRoutesResult contains the result from method VirtualNetworkGateways.GetLearnedRoutes.
type VirtualNetworkGatewaysGetLearnedRoutesResult struct {
	GatewayRouteListResult
}

// VirtualNetworkGatewaysGetResponse contains the response from method VirtualNetworkGateways.Get.
type VirtualNetworkGatewaysGetResponse struct {
	VirtualNetworkGatewaysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetResult contains the result from method VirtualNetworkGateways.Get.
type VirtualNetworkGatewaysGetResult struct {
	VirtualNetworkGateway
}

// VirtualNetworkGatewaysGetVPNProfilePackageURLPollerResponse contains the response from method VirtualNetworkGateways.GetVPNProfilePackageURL.
type VirtualNetworkGatewaysGetVPNProfilePackageURLPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetVPNProfilePackageURLPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetVPNProfilePackageURLPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVPNProfilePackageURLResponse, error) {
	respType := VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetVPNProfilePackageURLPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetVPNProfilePackageURLPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVPNProfilePackageURL", token, client.pl, client.getVPNProfilePackageURLHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetVPNProfilePackageURLPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetVPNProfilePackageURLResponse contains the response from method VirtualNetworkGateways.GetVPNProfilePackageURL.
type VirtualNetworkGatewaysGetVPNProfilePackageURLResponse struct {
	VirtualNetworkGatewaysGetVPNProfilePackageURLResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetVPNProfilePackageURLResult contains the result from method VirtualNetworkGateways.GetVPNProfilePackageURL.
type VirtualNetworkGatewaysGetVPNProfilePackageURLResult struct {
	Value *string
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthPollerResponse contains the response from method VirtualNetworkGateways.GetVpnclientConnectionHealth.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetVpnclientConnectionHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetVpnclientConnectionHealthPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetVpnclientConnectionHealthPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientConnectionHealth", token, client.pl, client.getVpnclientConnectionHealthHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse contains the response from method VirtualNetworkGateways.GetVpnclientConnectionHealth.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse struct {
	VirtualNetworkGatewaysGetVpnclientConnectionHealthResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthResult contains the result from method VirtualNetworkGateways.GetVpnclientConnectionHealth.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthResult struct {
	VPNClientConnectionHealthDetailListResult
}

// VirtualNetworkGatewaysGetVpnclientIPSecParametersPollerResponse contains the response from method VirtualNetworkGateways.GetVpnclientIPSecParameters.
type VirtualNetworkGatewaysGetVpnclientIPSecParametersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysGetVpnclientIPSecParametersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysGetVpnclientIPSecParametersPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysGetVpnclientIPSecParametersPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientIPSecParameters", token, client.pl, client.getVpnclientIPSecParametersHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse contains the response from method VirtualNetworkGateways.GetVpnclientIPSecParameters.
type VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse struct {
	VirtualNetworkGatewaysGetVpnclientIPSecParametersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysGetVpnclientIPSecParametersResult contains the result from method VirtualNetworkGateways.GetVpnclientIPSecParameters.
type VirtualNetworkGatewaysGetVpnclientIPSecParametersResult struct {
	VPNClientIPsecParameters
}

// VirtualNetworkGatewaysListConnectionsResponse contains the response from method VirtualNetworkGateways.ListConnections.
type VirtualNetworkGatewaysListConnectionsResponse struct {
	VirtualNetworkGatewaysListConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysListConnectionsResult contains the result from method VirtualNetworkGateways.ListConnections.
type VirtualNetworkGatewaysListConnectionsResult struct {
	VirtualNetworkGatewayListConnectionsResult
}

// VirtualNetworkGatewaysListResponse contains the response from method VirtualNetworkGateways.List.
type VirtualNetworkGatewaysListResponse struct {
	VirtualNetworkGatewaysListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysListResult contains the result from method VirtualNetworkGateways.List.
type VirtualNetworkGatewaysListResult struct {
	VirtualNetworkGatewayListResult
}

// VirtualNetworkGatewaysResetPollerResponse contains the response from method VirtualNetworkGateways.Reset.
type VirtualNetworkGatewaysResetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysResetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysResetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysResetResponse, error) {
	respType := VirtualNetworkGatewaysResetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysResetPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysResetPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Reset", token, client.pl, client.resetHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysResetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysResetResponse contains the response from method VirtualNetworkGateways.Reset.
type VirtualNetworkGatewaysResetResponse struct {
	VirtualNetworkGatewaysResetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysResetResult contains the result from method VirtualNetworkGateways.Reset.
type VirtualNetworkGatewaysResetResult struct {
	VirtualNetworkGateway
}

// VirtualNetworkGatewaysResetVPNClientSharedKeyPollerResponse contains the response from method VirtualNetworkGateways.ResetVPNClientSharedKey.
type VirtualNetworkGatewaysResetVPNClientSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysResetVPNClientSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysResetVPNClientSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysResetVPNClientSharedKeyResponse, error) {
	respType := VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysResetVPNClientSharedKeyPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysResetVPNClientSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.ResetVPNClientSharedKey", token, client.pl, client.resetVPNClientSharedKeyHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysResetVPNClientSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysResetVPNClientSharedKeyResponse contains the response from method VirtualNetworkGateways.ResetVPNClientSharedKey.
type VirtualNetworkGatewaysResetVPNClientSharedKeyResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysSetVpnclientIPSecParametersPollerResponse contains the response from method VirtualNetworkGateways.SetVpnclientIPSecParameters.
type VirtualNetworkGatewaysSetVpnclientIPSecParametersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysSetVpnclientIPSecParametersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysSetVpnclientIPSecParametersPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysSetVpnclientIPSecParametersPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.SetVpnclientIPSecParameters", token, client.pl, client.setVpnclientIPSecParametersHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse contains the response from method VirtualNetworkGateways.SetVpnclientIPSecParameters.
type VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse struct {
	VirtualNetworkGatewaysSetVpnclientIPSecParametersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysSetVpnclientIPSecParametersResult contains the result from method VirtualNetworkGateways.SetVpnclientIPSecParameters.
type VirtualNetworkGatewaysSetVpnclientIPSecParametersResult struct {
	VPNClientIPsecParameters
}

// VirtualNetworkGatewaysStartPacketCapturePollerResponse contains the response from method VirtualNetworkGateways.StartPacketCapture.
type VirtualNetworkGatewaysStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysStartPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StartPacketCapture", token, client.pl, client.startPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysStartPacketCaptureResponse contains the response from method VirtualNetworkGateways.StartPacketCapture.
type VirtualNetworkGatewaysStartPacketCaptureResponse struct {
	VirtualNetworkGatewaysStartPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysStartPacketCaptureResult contains the result from method VirtualNetworkGateways.StartPacketCapture.
type VirtualNetworkGatewaysStartPacketCaptureResult struct {
	Value *string
}

// VirtualNetworkGatewaysStopPacketCapturePollerResponse contains the response from method VirtualNetworkGateways.StopPacketCapture.
type VirtualNetworkGatewaysStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysStopPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StopPacketCapture", token, client.pl, client.stopPacketCaptureHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysStopPacketCaptureResponse contains the response from method VirtualNetworkGateways.StopPacketCapture.
type VirtualNetworkGatewaysStopPacketCaptureResponse struct {
	VirtualNetworkGatewaysStopPacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysStopPacketCaptureResult contains the result from method VirtualNetworkGateways.StopPacketCapture.
type VirtualNetworkGatewaysStopPacketCaptureResult struct {
	Value *string
}

// VirtualNetworkGatewaysSupportedVPNDevicesResponse contains the response from method VirtualNetworkGateways.SupportedVPNDevices.
type VirtualNetworkGatewaysSupportedVPNDevicesResponse struct {
	VirtualNetworkGatewaysSupportedVPNDevicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysSupportedVPNDevicesResult contains the result from method VirtualNetworkGateways.SupportedVPNDevices.
type VirtualNetworkGatewaysSupportedVPNDevicesResult struct {
	Value *string
}

// VirtualNetworkGatewaysUpdateTagsPollerResponse contains the response from method VirtualNetworkGateways.UpdateTags.
type VirtualNetworkGatewaysUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewaysUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysUpdateTagsPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysUpdateTagsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.UpdateTags", token, client.pl, client.updateTagsHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysUpdateTagsResponse contains the response from method VirtualNetworkGateways.UpdateTags.
type VirtualNetworkGatewaysUpdateTagsResponse struct {
	VirtualNetworkGatewaysUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysUpdateTagsResult contains the result from method VirtualNetworkGateways.UpdateTags.
type VirtualNetworkGatewaysUpdateTagsResult struct {
	VirtualNetworkGateway
}

// VirtualNetworkGatewaysVPNDeviceConfigurationScriptResponse contains the response from method VirtualNetworkGateways.VPNDeviceConfigurationScript.
type VirtualNetworkGatewaysVPNDeviceConfigurationScriptResponse struct {
	VirtualNetworkGatewaysVPNDeviceConfigurationScriptResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysVPNDeviceConfigurationScriptResult contains the result from method VirtualNetworkGateways.VPNDeviceConfigurationScript.
type VirtualNetworkGatewaysVPNDeviceConfigurationScriptResult struct {
	Value *string
}

// VirtualNetworkPeeringsCreateOrUpdatePollerResponse contains the response from method VirtualNetworkPeerings.CreateOrUpdate.
type VirtualNetworkPeeringsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkPeeringsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkPeeringsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkPeeringsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkPeeringsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkPeeringsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkPeeringsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkPeeringsCreateOrUpdateResponse contains the response from method VirtualNetworkPeerings.CreateOrUpdate.
type VirtualNetworkPeeringsCreateOrUpdateResponse struct {
	VirtualNetworkPeeringsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsCreateOrUpdateResult contains the result from method VirtualNetworkPeerings.CreateOrUpdate.
type VirtualNetworkPeeringsCreateOrUpdateResult struct {
	VirtualNetworkPeering
}

// VirtualNetworkPeeringsDeletePollerResponse contains the response from method VirtualNetworkPeerings.Delete.
type VirtualNetworkPeeringsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkPeeringsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkPeeringsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsDeleteResponse, error) {
	respType := VirtualNetworkPeeringsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkPeeringsDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkPeeringsDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkPeeringsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkPeeringsDeleteResponse contains the response from method VirtualNetworkPeerings.Delete.
type VirtualNetworkPeeringsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsGetResponse contains the response from method VirtualNetworkPeerings.Get.
type VirtualNetworkPeeringsGetResponse struct {
	VirtualNetworkPeeringsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsGetResult contains the result from method VirtualNetworkPeerings.Get.
type VirtualNetworkPeeringsGetResult struct {
	VirtualNetworkPeering
}

// VirtualNetworkPeeringsListResponse contains the response from method VirtualNetworkPeerings.List.
type VirtualNetworkPeeringsListResponse struct {
	VirtualNetworkPeeringsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsListResult contains the result from method VirtualNetworkPeerings.List.
type VirtualNetworkPeeringsListResult struct {
	VirtualNetworkPeeringListResult
}

// VirtualNetworkTapsCreateOrUpdatePollerResponse contains the response from method VirtualNetworkTaps.CreateOrUpdate.
type VirtualNetworkTapsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkTapsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkTapsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkTapsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkTap)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkTapsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkTapsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkTapsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkTapsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkTapsCreateOrUpdateResponse contains the response from method VirtualNetworkTaps.CreateOrUpdate.
type VirtualNetworkTapsCreateOrUpdateResponse struct {
	VirtualNetworkTapsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsCreateOrUpdateResult contains the result from method VirtualNetworkTaps.CreateOrUpdate.
type VirtualNetworkTapsCreateOrUpdateResult struct {
	VirtualNetworkTap
}

// VirtualNetworkTapsDeletePollerResponse contains the response from method VirtualNetworkTaps.Delete.
type VirtualNetworkTapsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkTapsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkTapsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsDeleteResponse, error) {
	respType := VirtualNetworkTapsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkTapsDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkTapsDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkTapsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkTapsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkTapsDeleteResponse contains the response from method VirtualNetworkTaps.Delete.
type VirtualNetworkTapsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsGetResponse contains the response from method VirtualNetworkTaps.Get.
type VirtualNetworkTapsGetResponse struct {
	VirtualNetworkTapsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsGetResult contains the result from method VirtualNetworkTaps.Get.
type VirtualNetworkTapsGetResult struct {
	VirtualNetworkTap
}

// VirtualNetworkTapsListAllResponse contains the response from method VirtualNetworkTaps.ListAll.
type VirtualNetworkTapsListAllResponse struct {
	VirtualNetworkTapsListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsListAllResult contains the result from method VirtualNetworkTaps.ListAll.
type VirtualNetworkTapsListAllResult struct {
	VirtualNetworkTapListResult
}

// VirtualNetworkTapsListByResourceGroupResponse contains the response from method VirtualNetworkTaps.ListByResourceGroup.
type VirtualNetworkTapsListByResourceGroupResponse struct {
	VirtualNetworkTapsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsListByResourceGroupResult contains the result from method VirtualNetworkTaps.ListByResourceGroup.
type VirtualNetworkTapsListByResourceGroupResult struct {
	VirtualNetworkTapListResult
}

// VirtualNetworkTapsUpdateTagsResponse contains the response from method VirtualNetworkTaps.UpdateTags.
type VirtualNetworkTapsUpdateTagsResponse struct {
	VirtualNetworkTapsUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsUpdateTagsResult contains the result from method VirtualNetworkTaps.UpdateTags.
type VirtualNetworkTapsUpdateTagsResult struct {
	VirtualNetworkTap
}

// VirtualNetworksCheckIPAddressAvailabilityResponse contains the response from method VirtualNetworks.CheckIPAddressAvailability.
type VirtualNetworksCheckIPAddressAvailabilityResponse struct {
	VirtualNetworksCheckIPAddressAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksCheckIPAddressAvailabilityResult contains the result from method VirtualNetworks.CheckIPAddressAvailability.
type VirtualNetworksCheckIPAddressAvailabilityResult struct {
	IPAddressAvailabilityResult
}

// VirtualNetworksCreateOrUpdatePollerResponse contains the response from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksCreateOrUpdateResponse, error) {
	respType := VirtualNetworksCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetwork)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworksCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksCreateOrUpdateResponse contains the response from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdateResponse struct {
	VirtualNetworksCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksCreateOrUpdateResult contains the result from method VirtualNetworks.CreateOrUpdate.
type VirtualNetworksCreateOrUpdateResult struct {
	VirtualNetwork
}

// VirtualNetworksDeletePollerResponse contains the response from method VirtualNetworks.Delete.
type VirtualNetworksDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksDeleteResponse, error) {
	respType := VirtualNetworksDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworksDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksDeleteResponse contains the response from method VirtualNetworks.Delete.
type VirtualNetworksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksGetResponse contains the response from method VirtualNetworks.Get.
type VirtualNetworksGetResponse struct {
	VirtualNetworksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksGetResult contains the result from method VirtualNetworks.Get.
type VirtualNetworksGetResult struct {
	VirtualNetwork
}

// VirtualNetworksListAllResponse contains the response from method VirtualNetworks.ListAll.
type VirtualNetworksListAllResponse struct {
	VirtualNetworksListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksListAllResult contains the result from method VirtualNetworks.ListAll.
type VirtualNetworksListAllResult struct {
	VirtualNetworkListResult
}

// VirtualNetworksListResponse contains the response from method VirtualNetworks.List.
type VirtualNetworksListResponse struct {
	VirtualNetworksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksListResult contains the result from method VirtualNetworks.List.
type VirtualNetworksListResult struct {
	VirtualNetworkListResult
}

// VirtualNetworksListUsageResponse contains the response from method VirtualNetworks.ListUsage.
type VirtualNetworksListUsageResponse struct {
	VirtualNetworksListUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksListUsageResult contains the result from method VirtualNetworks.ListUsage.
type VirtualNetworksListUsageResult struct {
	VirtualNetworkListUsageResult
}

// VirtualNetworksUpdateTagsResponse contains the response from method VirtualNetworks.UpdateTags.
type VirtualNetworksUpdateTagsResponse struct {
	VirtualNetworksUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksUpdateTagsResult contains the result from method VirtualNetworks.UpdateTags.
type VirtualNetworksUpdateTagsResult struct {
	VirtualNetwork
}

// VirtualRouterPeeringsCreateOrUpdatePollerResponse contains the response from method VirtualRouterPeerings.CreateOrUpdate.
type VirtualRouterPeeringsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRouterPeeringsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRouterPeeringsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualRouterPeeringsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualRouterPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRouterPeeringsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualRouterPeeringsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualRouterPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualRouterPeeringsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRouterPeeringsCreateOrUpdateResponse contains the response from method VirtualRouterPeerings.CreateOrUpdate.
type VirtualRouterPeeringsCreateOrUpdateResponse struct {
	VirtualRouterPeeringsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsCreateOrUpdateResult contains the result from method VirtualRouterPeerings.CreateOrUpdate.
type VirtualRouterPeeringsCreateOrUpdateResult struct {
	VirtualRouterPeering
}

// VirtualRouterPeeringsDeletePollerResponse contains the response from method VirtualRouterPeerings.Delete.
type VirtualRouterPeeringsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRouterPeeringsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRouterPeeringsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsDeleteResponse, error) {
	respType := VirtualRouterPeeringsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRouterPeeringsDeletePollerResponse from the provided client and resume token.
func (l *VirtualRouterPeeringsDeletePollerResponse) Resume(ctx context.Context, client *VirtualRouterPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualRouterPeeringsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRouterPeeringsDeleteResponse contains the response from method VirtualRouterPeerings.Delete.
type VirtualRouterPeeringsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsGetResponse contains the response from method VirtualRouterPeerings.Get.
type VirtualRouterPeeringsGetResponse struct {
	VirtualRouterPeeringsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsGetResult contains the result from method VirtualRouterPeerings.Get.
type VirtualRouterPeeringsGetResult struct {
	VirtualRouterPeering
}

// VirtualRouterPeeringsListResponse contains the response from method VirtualRouterPeerings.List.
type VirtualRouterPeeringsListResponse struct {
	VirtualRouterPeeringsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsListResult contains the result from method VirtualRouterPeerings.List.
type VirtualRouterPeeringsListResult struct {
	VirtualRouterPeeringListResult
}

// VirtualRoutersCreateOrUpdatePollerResponse contains the response from method VirtualRouters.CreateOrUpdate.
type VirtualRoutersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRoutersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRoutersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersCreateOrUpdateResponse, error) {
	respType := VirtualRoutersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualRouter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRoutersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualRoutersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualRoutersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRoutersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualRoutersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRoutersCreateOrUpdateResponse contains the response from method VirtualRouters.CreateOrUpdate.
type VirtualRoutersCreateOrUpdateResponse struct {
	VirtualRoutersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersCreateOrUpdateResult contains the result from method VirtualRouters.CreateOrUpdate.
type VirtualRoutersCreateOrUpdateResult struct {
	VirtualRouter
}

// VirtualRoutersDeletePollerResponse contains the response from method VirtualRouters.Delete.
type VirtualRoutersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRoutersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRoutersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersDeleteResponse, error) {
	respType := VirtualRoutersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRoutersDeletePollerResponse from the provided client and resume token.
func (l *VirtualRoutersDeletePollerResponse) Resume(ctx context.Context, client *VirtualRoutersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRoutersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualRoutersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRoutersDeleteResponse contains the response from method VirtualRouters.Delete.
type VirtualRoutersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersGetResponse contains the response from method VirtualRouters.Get.
type VirtualRoutersGetResponse struct {
	VirtualRoutersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersGetResult contains the result from method VirtualRouters.Get.
type VirtualRoutersGetResult struct {
	VirtualRouter
}

// VirtualRoutersListByResourceGroupResponse contains the response from method VirtualRouters.ListByResourceGroup.
type VirtualRoutersListByResourceGroupResponse struct {
	VirtualRoutersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersListByResourceGroupResult contains the result from method VirtualRouters.ListByResourceGroup.
type VirtualRoutersListByResourceGroupResult struct {
	VirtualRouterListResult
}

// VirtualRoutersListResponse contains the response from method VirtualRouters.List.
type VirtualRoutersListResponse struct {
	VirtualRoutersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersListResult contains the result from method VirtualRouters.List.
type VirtualRoutersListResult struct {
	VirtualRouterListResult
}

// VirtualWansCreateOrUpdatePollerResponse contains the response from method VirtualWans.CreateOrUpdate.
type VirtualWansCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualWansCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualWansCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansCreateOrUpdateResponse, error) {
	respType := VirtualWansCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualWAN)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualWansCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualWansCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualWansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualWansClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualWansCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualWansCreateOrUpdateResponse contains the response from method VirtualWans.CreateOrUpdate.
type VirtualWansCreateOrUpdateResponse struct {
	VirtualWansCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansCreateOrUpdateResult contains the result from method VirtualWans.CreateOrUpdate.
type VirtualWansCreateOrUpdateResult struct {
	VirtualWAN
}

// VirtualWansDeletePollerResponse contains the response from method VirtualWans.Delete.
type VirtualWansDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualWansDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualWansDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansDeleteResponse, error) {
	respType := VirtualWansDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualWansDeletePollerResponse from the provided client and resume token.
func (l *VirtualWansDeletePollerResponse) Resume(ctx context.Context, client *VirtualWansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualWansClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualWansDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualWansDeleteResponse contains the response from method VirtualWans.Delete.
type VirtualWansDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansGetResponse contains the response from method VirtualWans.Get.
type VirtualWansGetResponse struct {
	VirtualWansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansGetResult contains the result from method VirtualWans.Get.
type VirtualWansGetResult struct {
	VirtualWAN
}

// VirtualWansListByResourceGroupResponse contains the response from method VirtualWans.ListByResourceGroup.
type VirtualWansListByResourceGroupResponse struct {
	VirtualWansListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansListByResourceGroupResult contains the result from method VirtualWans.ListByResourceGroup.
type VirtualWansListByResourceGroupResult struct {
	ListVirtualWANsResult
}

// VirtualWansListResponse contains the response from method VirtualWans.List.
type VirtualWansListResponse struct {
	VirtualWansListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansListResult contains the result from method VirtualWans.List.
type VirtualWansListResult struct {
	ListVirtualWANsResult
}

// VirtualWansUpdateTagsResponse contains the response from method VirtualWans.UpdateTags.
type VirtualWansUpdateTagsResponse struct {
	VirtualWansUpdateTagsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansUpdateTagsResult contains the result from method VirtualWans.UpdateTags.
type VirtualWansUpdateTagsResult struct {
	VirtualWAN
}

// WebApplicationFirewallPoliciesCreateOrUpdateResponse contains the response from method WebApplicationFirewallPolicies.CreateOrUpdate.
type WebApplicationFirewallPoliciesCreateOrUpdateResponse struct {
	WebApplicationFirewallPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesCreateOrUpdateResult contains the result from method WebApplicationFirewallPolicies.CreateOrUpdate.
type WebApplicationFirewallPoliciesCreateOrUpdateResult struct {
	WebApplicationFirewallPolicy
}

// WebApplicationFirewallPoliciesDeletePollerResponse contains the response from method WebApplicationFirewallPolicies.Delete.
type WebApplicationFirewallPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WebApplicationFirewallPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WebApplicationFirewallPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WebApplicationFirewallPoliciesDeleteResponse, error) {
	respType := WebApplicationFirewallPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WebApplicationFirewallPoliciesDeletePollerResponse from the provided client and resume token.
func (l *WebApplicationFirewallPoliciesDeletePollerResponse) Resume(ctx context.Context, client *WebApplicationFirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WebApplicationFirewallPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &WebApplicationFirewallPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WebApplicationFirewallPoliciesDeleteResponse contains the response from method WebApplicationFirewallPolicies.Delete.
type WebApplicationFirewallPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesGetResponse contains the response from method WebApplicationFirewallPolicies.Get.
type WebApplicationFirewallPoliciesGetResponse struct {
	WebApplicationFirewallPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesGetResult contains the result from method WebApplicationFirewallPolicies.Get.
type WebApplicationFirewallPoliciesGetResult struct {
	WebApplicationFirewallPolicy
}

// WebApplicationFirewallPoliciesListAllResponse contains the response from method WebApplicationFirewallPolicies.ListAll.
type WebApplicationFirewallPoliciesListAllResponse struct {
	WebApplicationFirewallPoliciesListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesListAllResult contains the result from method WebApplicationFirewallPolicies.ListAll.
type WebApplicationFirewallPoliciesListAllResult struct {
	WebApplicationFirewallPolicyListResult
}

// WebApplicationFirewallPoliciesListResponse contains the response from method WebApplicationFirewallPolicies.List.
type WebApplicationFirewallPoliciesListResponse struct {
	WebApplicationFirewallPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesListResult contains the result from method WebApplicationFirewallPolicies.List.
type WebApplicationFirewallPoliciesListResult struct {
	WebApplicationFirewallPolicyListResult
}

// WebCategoriesGetResponse contains the response from method WebCategories.Get.
type WebCategoriesGetResponse struct {
	WebCategoriesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebCategoriesGetResult contains the result from method WebCategories.Get.
type WebCategoriesGetResult struct {
	AzureWebCategory
}

// WebCategoriesListBySubscriptionResponse contains the response from method WebCategories.ListBySubscription.
type WebCategoriesListBySubscriptionResponse struct {
	WebCategoriesListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebCategoriesListBySubscriptionResult contains the result from method WebCategories.ListBySubscription.
type WebCategoriesListBySubscriptionResult struct {
	AzureWebCategoryListResult
}
