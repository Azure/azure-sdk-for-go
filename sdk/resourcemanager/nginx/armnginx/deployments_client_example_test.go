// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armnginx_test

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/nginx/armnginx/v3"
	"log"
)

// Generated from example definition: 2025-03-01-preview/NginxDeployments_CreateOrUpdate_MaximumSet_Gen.json
func ExampleDeploymentsClient_BeginCreateOrUpdate() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	poller, err := clientFactory.NewDeploymentsClient().BeginCreateOrUpdate(ctx, "rgopenapi", "myDeployment", armnginx.Deployment{
		Properties: &armnginx.DeploymentProperties{
			NginxVersion: to.Ptr("yjvomuondmj"),
			NetworkProfile: &armnginx.NetworkProfile{
				FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
					PublicIPAddresses: []*armnginx.PublicIPAddress{
						{
							ID: to.Ptr("shguvav"),
						},
					},
					PrivateIPAddresses: []*armnginx.PrivateIPAddress{
						{
							PrivateIPAddress:          to.Ptr("psbnydlzwdttexeljdcfh"),
							PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
							SubnetID:                  to.Ptr("fquufbmeybmmxbcapozztvgklo"),
						},
					},
				},
				NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
					SubnetID: to.Ptr("wtidvwudwuyshctyjuiv"),
				},
			},
			IPAddress:                to.Ptr("ztsmoltljnhmnw"),
			EnableDiagnosticsSupport: to.Ptr(true),
			Logging: &armnginx.Logging{
				StorageAccount: &armnginx.StorageAccount{
					AccountName:   to.Ptr("klwctfc"),
					ContainerName: to.Ptr("dnsmftkoexjreeyarenzftg"),
				},
			},
			ScalingProperties: &armnginx.DeploymentScalingProperties{
				Capacity: to.Ptr[int32](3),
				AutoScaleSettings: &armnginx.AutoScaleSettings{
					Profiles: []*armnginx.ScaleProfile{
						{
							Name: to.Ptr("qgaibobr"),
							Capacity: &armnginx.ScaleProfileCapacity{
								Min: to.Ptr[int32](2),
								Max: to.Ptr[int32](30),
							},
						},
					},
				},
			},
			AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
				UpgradeChannel: to.Ptr("zwvmombsq"),
			},
			UserProfile: &armnginx.DeploymentUserProfile{
				PreferredEmail: to.Ptr("chugdttufphvokedpqrsmo"),
			},
			NginxAppProtect: &armnginx.AppProtect{
				WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
					ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
				},
				WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
					WafRelease: to.Ptr("tdvqtrlcningpzdvllxaxqqzjptb"),
					AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("mekbngveszzhp"),
						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
					},
					BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("mekbngveszzhp"),
						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
					},
					ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("mekbngveszzhp"),
						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
					},
					ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
						WafEngineVersion: to.Ptr("scg"),
						WafNginxVersion:  to.Ptr("hfjknnvbjsajpnsfroplemgzngn"),
					},
				},
			},
			DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
		},
		Identity: &armnginx.ManagedServiceIdentity{
			Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
			UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
				"key480": {},
			},
		},
		SKU: &armnginx.SKU{
			Name:     to.Ptr("piebonukrltsa"),
			Tier:     to.Ptr(armnginx.SKUTierFree),
			Size:     to.Ptr("sfhkuwcnxnactqtclqfwt"),
			Family:   to.Ptr("gfcpwwvwri"),
			Capacity: to.Ptr[int32](27),
		},
		Tags: map[string]*string{
			"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
		},
		Location: to.Ptr("dmy"),
	}, nil)
	if err != nil {
		log.Fatalf("failed to finish the request: %v", err)
	}
	res, err := poller.PollUntilDone(ctx, nil)
	if err != nil {
		log.Fatalf("failed to pull the result: %v", err)
	}
	// You could use response here. We use blank identifier for just demo purposes.
	_ = res
	// If the HTTP response code is 200 as defined in example definition, your response structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
	// res = armnginx.DeploymentsClientCreateOrUpdateResponse{
	// 	Deployment: &armnginx.Deployment{
	// 		Properties: &armnginx.DeploymentProperties{
	// 			ProvisioningState: to.Ptr(armnginx.ProvisioningStateAccepted),
	// 			NginxVersion: to.Ptr("yjvomuondmj"),
	// 			NetworkProfile: &armnginx.NetworkProfile{
	// 				FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
	// 					PublicIPAddresses: []*armnginx.PublicIPAddress{
	// 						{
	// 							ID: to.Ptr("shguvav"),
	// 						},
	// 					},
	// 					PrivateIPAddresses: []*armnginx.PrivateIPAddress{
	// 						{
	// 							PrivateIPAddress: to.Ptr("psbnydlzwdttexeljdcfh"),
	// 							PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
	// 							SubnetID: to.Ptr("fquufbmeybmmxbcapozztvgklo"),
	// 						},
	// 					},
	// 				},
	// 				NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
	// 					SubnetID: to.Ptr("wtidvwudwuyshctyjuiv"),
	// 				},
	// 			},
	// 			IPAddress: to.Ptr("ztsmoltljnhmnw"),
	// 			EnableDiagnosticsSupport: to.Ptr(true),
	// 			Logging: &armnginx.Logging{
	// 				StorageAccount: &armnginx.StorageAccount{
	// 					AccountName: to.Ptr("klwctfc"),
	// 					ContainerName: to.Ptr("dnsmftkoexjreeyarenzftg"),
	// 				},
	// 			},
	// 			ScalingProperties: &armnginx.DeploymentScalingProperties{
	// 				Capacity: to.Ptr[int32](3),
	// 				AutoScaleSettings: &armnginx.AutoScaleSettings{
	// 					Profiles: []*armnginx.ScaleProfile{
	// 						{
	// 							Name: to.Ptr("qgaibobr"),
	// 							Capacity: &armnginx.ScaleProfileCapacity{
	// 								Min: to.Ptr[int32](2),
	// 								Max: to.Ptr[int32](30),
	// 							},
	// 						},
	// 					},
	// 				},
	// 			},
	// 			AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
	// 				UpgradeChannel: to.Ptr("zwvmombsq"),
	// 			},
	// 			UserProfile: &armnginx.DeploymentUserProfile{
	// 				PreferredEmail: to.Ptr("chugdttufphvokedpqrsmo"),
	// 			},
	// 			NginxAppProtect: &armnginx.AppProtect{
	// 				WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
	// 					ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
	// 				},
	// 				WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
	// 					WafRelease: to.Ptr("tdvqtrlcningpzdvllxaxqqzjptb"),
	// 					AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
	// 						WafEngineVersion: to.Ptr("scg"),
	// 						WafNginxVersion: to.Ptr("hfjknnvbjsajpnsfroplemgzngn"),
	// 					},
	// 				},
	// 			},
	// 			DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
	// 		},
	// 		Identity: &armnginx.ManagedServiceIdentity{
	// 			PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			TenantID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
	// 			UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
	// 				"key480": &armnginx.UserAssignedIdentity{
	// 					PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 					ClientID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 				},
	// 			},
	// 		},
	// 		SKU: &armnginx.SKU{
	// 			Name: to.Ptr("piebonukrltsa"),
	// 			Tier: to.Ptr(armnginx.SKUTierFree),
	// 			Size: to.Ptr("sfhkuwcnxnactqtclqfwt"),
	// 			Family: to.Ptr("gfcpwwvwri"),
	// 			Capacity: to.Ptr[int32](27),
	// 		},
	// 		Tags: map[string]*string{
	// 			"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
	// 		},
	// 		Location: to.Ptr("dmy"),
	// 		ID: to.Ptr("/subscriptions/333F7B80-063D-40E5-975B-6E3C3CAC8296/resourceGroups/rgopenapi/providers/NGINX.NGINXPLUS/nginxDeployments/myDeployment"),
	// 		Name: to.Ptr("zpngfjhytajcvheoayopelklmzzpk"),
	// 		Type: to.Ptr("cxgktqvbtlxwjzc"),
	// 		SystemData: &armnginx.SystemData{
	// 			CreatedBy: to.Ptr("qokpyvbgqgcdpafqbhyfiftwgu"),
	// 			CreatedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			CreatedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.647Z"); return t}()),
	// 			LastModifiedBy: to.Ptr("vvkvcyipmssjflaauflxmvqnox"),
	// 			LastModifiedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			LastModifiedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.648Z"); return t}()),
	// 		},
	// 	},
	// }
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_Delete_MaximumSet_Gen.json
func ExampleDeploymentsClient_BeginDelete() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	poller, err := clientFactory.NewDeploymentsClient().BeginDelete(ctx, "rgopenapi", "myDeployment", nil)
	if err != nil {
		log.Fatalf("failed to finish the request: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, nil)
	if err != nil {
		log.Fatalf("failed to pull the result: %v", err)
	}
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_Get_MaximumSet_Gen.json
func ExampleDeploymentsClient_Get() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	res, err := clientFactory.NewDeploymentsClient().Get(ctx, "rgopenapi", "myDeployment", nil)
	if err != nil {
		log.Fatalf("failed to finish the request: %v", err)
	}
	// You could use response here. We use blank identifier for just demo purposes.
	_ = res
	// If the HTTP response code is 200 as defined in example definition, your response structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
	// res = armnginx.DeploymentsClientGetResponse{
	// 	Deployment: &armnginx.Deployment{
	// 		Properties: &armnginx.DeploymentProperties{
	// 			ProvisioningState: to.Ptr(armnginx.ProvisioningStateAccepted),
	// 			NginxVersion: to.Ptr("yjvomuondmj"),
	// 			NetworkProfile: &armnginx.NetworkProfile{
	// 				FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
	// 					PublicIPAddresses: []*armnginx.PublicIPAddress{
	// 						{
	// 							ID: to.Ptr("shguvav"),
	// 						},
	// 					},
	// 					PrivateIPAddresses: []*armnginx.PrivateIPAddress{
	// 						{
	// 							PrivateIPAddress: to.Ptr("psbnydlzwdttexeljdcfh"),
	// 							PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
	// 							SubnetID: to.Ptr("fquufbmeybmmxbcapozztvgklo"),
	// 						},
	// 					},
	// 				},
	// 				NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
	// 					SubnetID: to.Ptr("wtidvwudwuyshctyjuiv"),
	// 				},
	// 			},
	// 			IPAddress: to.Ptr("ztsmoltljnhmnw"),
	// 			EnableDiagnosticsSupport: to.Ptr(true),
	// 			Logging: &armnginx.Logging{
	// 				StorageAccount: &armnginx.StorageAccount{
	// 					AccountName: to.Ptr("klwctfc"),
	// 					ContainerName: to.Ptr("dnsmftkoexjreeyarenzftg"),
	// 				},
	// 			},
	// 			ScalingProperties: &armnginx.DeploymentScalingProperties{
	// 				Capacity: to.Ptr[int32](3),
	// 				AutoScaleSettings: &armnginx.AutoScaleSettings{
	// 					Profiles: []*armnginx.ScaleProfile{
	// 						{
	// 							Name: to.Ptr("qgaibobr"),
	// 							Capacity: &armnginx.ScaleProfileCapacity{
	// 								Min: to.Ptr[int32](2),
	// 								Max: to.Ptr[int32](30),
	// 							},
	// 						},
	// 					},
	// 				},
	// 			},
	// 			AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
	// 				UpgradeChannel: to.Ptr("zwvmombsq"),
	// 			},
	// 			UserProfile: &armnginx.DeploymentUserProfile{
	// 				PreferredEmail: to.Ptr("chugdttufphvokedpqrsmo"),
	// 			},
	// 			NginxAppProtect: &armnginx.AppProtect{
	// 				WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
	// 					ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
	// 				},
	// 				WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
	// 					WafRelease: to.Ptr("tdvqtrlcningpzdvllxaxqqzjptb"),
	// 					AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("mekbngveszzhp"),
	// 						RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
	// 					},
	// 					ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
	// 						WafEngineVersion: to.Ptr("scg"),
	// 						WafNginxVersion: to.Ptr("hfjknnvbjsajpnsfroplemgzngn"),
	// 					},
	// 				},
	// 			},
	// 			DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
	// 		},
	// 		Identity: &armnginx.ManagedServiceIdentity{
	// 			PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			TenantID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
	// 			UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
	// 				"key480": &armnginx.UserAssignedIdentity{
	// 					PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 					ClientID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 				},
	// 			},
	// 		},
	// 		SKU: &armnginx.SKU{
	// 			Name: to.Ptr("piebonukrltsa"),
	// 			Tier: to.Ptr(armnginx.SKUTierFree),
	// 			Size: to.Ptr("sfhkuwcnxnactqtclqfwt"),
	// 			Family: to.Ptr("gfcpwwvwri"),
	// 			Capacity: to.Ptr[int32](27),
	// 		},
	// 		Tags: map[string]*string{
	// 			"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
	// 		},
	// 		Location: to.Ptr("dmy"),
	// 		ID: to.Ptr("/subscriptions/333F7B80-063D-40E5-975B-6E3C3CAC8296/resourceGroups/rgopenapi/providers/NGINX.NGINXPLUS/nginxDeployments/myDeployment"),
	// 		Name: to.Ptr("zpngfjhytajcvheoayopelklmzzpk"),
	// 		Type: to.Ptr("cxgktqvbtlxwjzc"),
	// 		SystemData: &armnginx.SystemData{
	// 			CreatedBy: to.Ptr("qokpyvbgqgcdpafqbhyfiftwgu"),
	// 			CreatedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			CreatedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.647Z"); return t}()),
	// 			LastModifiedBy: to.Ptr("vvkvcyipmssjflaauflxmvqnox"),
	// 			LastModifiedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			LastModifiedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.648Z"); return t}()),
	// 		},
	// 	},
	// }
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_ListByResourceGroup_MaximumSet_Gen.json
func ExampleDeploymentsClient_NewListByResourceGroupPager() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	pager := clientFactory.NewDeploymentsClient().NewListByResourceGroupPager("rgopenapi", nil)
	for pager.More() {
		page, err := pager.NextPage(ctx)
		if err != nil {
			log.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range page.Value {
			// You could use page here. We use blank identifier for just demo purposes.
			_ = v
		}
		// If the HTTP response code is 200 as defined in example definition, your page structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
		// page = armnginx.DeploymentsClientListByResourceGroupResponse{
		// 	DeploymentListResult: armnginx.DeploymentListResult{
		// 		Value: []*armnginx.Deployment{
		// 			{
		// 				Properties: &armnginx.DeploymentProperties{
		// 					ProvisioningState: to.Ptr(armnginx.ProvisioningStateAccepted),
		// 					NginxVersion: to.Ptr("yjvomuondmj"),
		// 					NetworkProfile: &armnginx.NetworkProfile{
		// 						FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
		// 							PublicIPAddresses: []*armnginx.PublicIPAddress{
		// 								{
		// 									ID: to.Ptr("shguvav"),
		// 								},
		// 							},
		// 							PrivateIPAddresses: []*armnginx.PrivateIPAddress{
		// 								{
		// 									PrivateIPAddress: to.Ptr("psbnydlzwdttexeljdcfh"),
		// 									PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
		// 									SubnetID: to.Ptr("fquufbmeybmmxbcapozztvgklo"),
		// 								},
		// 							},
		// 						},
		// 						NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
		// 							SubnetID: to.Ptr("wtidvwudwuyshctyjuiv"),
		// 						},
		// 					},
		// 					IPAddress: to.Ptr("ztsmoltljnhmnw"),
		// 					EnableDiagnosticsSupport: to.Ptr(true),
		// 					Logging: &armnginx.Logging{
		// 						StorageAccount: &armnginx.StorageAccount{
		// 							AccountName: to.Ptr("klwctfc"),
		// 							ContainerName: to.Ptr("dnsmftkoexjreeyarenzftg"),
		// 						},
		// 					},
		// 					ScalingProperties: &armnginx.DeploymentScalingProperties{
		// 						Capacity: to.Ptr[int32](3),
		// 						AutoScaleSettings: &armnginx.AutoScaleSettings{
		// 							Profiles: []*armnginx.ScaleProfile{
		// 								{
		// 									Name: to.Ptr("qgaibobr"),
		// 									Capacity: &armnginx.ScaleProfileCapacity{
		// 										Min: to.Ptr[int32](2),
		// 										Max: to.Ptr[int32](30),
		// 									},
		// 								},
		// 							},
		// 						},
		// 					},
		// 					AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
		// 						UpgradeChannel: to.Ptr("zwvmombsq"),
		// 					},
		// 					UserProfile: &armnginx.DeploymentUserProfile{
		// 						PreferredEmail: to.Ptr("chugdttufphvokedpqrsmo"),
		// 					},
		// 					NginxAppProtect: &armnginx.AppProtect{
		// 						WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
		// 							ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
		// 						},
		// 						WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
		// 							WafRelease: to.Ptr("tdvqtrlcningpzdvllxaxqqzjptb"),
		// 							AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
		// 								WafEngineVersion: to.Ptr("scg"),
		// 								WafNginxVersion: to.Ptr("hfjknnvbjsajpnsfroplemgzngn"),
		// 							},
		// 						},
		// 					},
		// 					DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
		// 				},
		// 				Identity: &armnginx.ManagedServiceIdentity{
		// 					PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 					TenantID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 					Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
		// 					UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
		// 						"key480": &armnginx.UserAssignedIdentity{
		// 							PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 							ClientID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 						},
		// 					},
		// 				},
		// 				SKU: &armnginx.SKU{
		// 					Name: to.Ptr("piebonukrltsa"),
		// 					Tier: to.Ptr(armnginx.SKUTierFree),
		// 					Size: to.Ptr("sfhkuwcnxnactqtclqfwt"),
		// 					Family: to.Ptr("gfcpwwvwri"),
		// 					Capacity: to.Ptr[int32](27),
		// 				},
		// 				Tags: map[string]*string{
		// 					"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
		// 				},
		// 				Location: to.Ptr("dmy"),
		// 				ID: to.Ptr("/subscriptions/333F7B80-063D-40E5-975B-6E3C3CAC8296/resourceGroups/rgopenapi/providers/NGINX.NGINXPLUS/nginxDeployments/zpngfjhytajcvheoayopelklmzzpk"),
		// 				Name: to.Ptr("zpngfjhytajcvheoayopelklmzzpk"),
		// 				Type: to.Ptr("cxgktqvbtlxwjzc"),
		// 				SystemData: &armnginx.SystemData{
		// 					CreatedBy: to.Ptr("qokpyvbgqgcdpafqbhyfiftwgu"),
		// 					CreatedByType: to.Ptr(armnginx.CreatedByTypeUser),
		// 					CreatedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.647Z"); return t}()),
		// 					LastModifiedBy: to.Ptr("vvkvcyipmssjflaauflxmvqnox"),
		// 					LastModifiedByType: to.Ptr(armnginx.CreatedByTypeUser),
		// 					LastModifiedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.648Z"); return t}()),
		// 				},
		// 			},
		// 		},
		// 		NextLink: to.Ptr("https://microsoft.com/a"),
		// 	},
		// }
	}
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_ListBySubscription_MaximumSet_Gen.json
func ExampleDeploymentsClient_NewListBySubscriptionPager() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	pager := clientFactory.NewDeploymentsClient().NewListBySubscriptionPager(nil)
	for pager.More() {
		page, err := pager.NextPage(ctx)
		if err != nil {
			log.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range page.Value {
			// You could use page here. We use blank identifier for just demo purposes.
			_ = v
		}
		// If the HTTP response code is 200 as defined in example definition, your page structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
		// page = armnginx.DeploymentsClientListBySubscriptionResponse{
		// 	DeploymentListResult: armnginx.DeploymentListResult{
		// 		Value: []*armnginx.Deployment{
		// 			{
		// 				Properties: &armnginx.DeploymentProperties{
		// 					ProvisioningState: to.Ptr(armnginx.ProvisioningStateAccepted),
		// 					NginxVersion: to.Ptr("yjvomuondmj"),
		// 					NetworkProfile: &armnginx.NetworkProfile{
		// 						FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
		// 							PublicIPAddresses: []*armnginx.PublicIPAddress{
		// 								{
		// 									ID: to.Ptr("shguvav"),
		// 								},
		// 							},
		// 							PrivateIPAddresses: []*armnginx.PrivateIPAddress{
		// 								{
		// 									PrivateIPAddress: to.Ptr("psbnydlzwdttexeljdcfh"),
		// 									PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
		// 									SubnetID: to.Ptr("fquufbmeybmmxbcapozztvgklo"),
		// 								},
		// 							},
		// 						},
		// 						NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
		// 							SubnetID: to.Ptr("wtidvwudwuyshctyjuiv"),
		// 						},
		// 					},
		// 					IPAddress: to.Ptr("ztsmoltljnhmnw"),
		// 					EnableDiagnosticsSupport: to.Ptr(true),
		// 					Logging: &armnginx.Logging{
		// 						StorageAccount: &armnginx.StorageAccount{
		// 							AccountName: to.Ptr("klwctfc"),
		// 							ContainerName: to.Ptr("dnsmftkoexjreeyarenzftg"),
		// 						},
		// 					},
		// 					ScalingProperties: &armnginx.DeploymentScalingProperties{
		// 						Capacity: to.Ptr[int32](3),
		// 						AutoScaleSettings: &armnginx.AutoScaleSettings{
		// 							Profiles: []*armnginx.ScaleProfile{
		// 								{
		// 									Name: to.Ptr("qgaibobr"),
		// 									Capacity: &armnginx.ScaleProfileCapacity{
		// 										Min: to.Ptr[int32](2),
		// 										Max: to.Ptr[int32](30),
		// 									},
		// 								},
		// 							},
		// 						},
		// 					},
		// 					AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
		// 						UpgradeChannel: to.Ptr("zwvmombsq"),
		// 					},
		// 					UserProfile: &armnginx.DeploymentUserProfile{
		// 						PreferredEmail: to.Ptr("chugdttufphvokedpqrsmo"),
		// 					},
		// 					NginxAppProtect: &armnginx.AppProtect{
		// 						WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
		// 							ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
		// 						},
		// 						WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
		// 							WafRelease: to.Ptr("tdvqtrlcningpzdvllxaxqqzjptb"),
		// 							AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
		// 								Version: to.Ptr("mekbngveszzhp"),
		// 								RevisionDatetime: to.Ptr("uouamocdpdcehamsmydwmpzui"),
		// 							},
		// 							ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
		// 								WafEngineVersion: to.Ptr("scg"),
		// 								WafNginxVersion: to.Ptr("hfjknnvbjsajpnsfroplemgzngn"),
		// 							},
		// 						},
		// 					},
		// 					DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
		// 				},
		// 				Identity: &armnginx.ManagedServiceIdentity{
		// 					PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 					TenantID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 					Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
		// 					UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
		// 						"key480": &armnginx.UserAssignedIdentity{
		// 							PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 							ClientID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
		// 						},
		// 					},
		// 				},
		// 				SKU: &armnginx.SKU{
		// 					Name: to.Ptr("piebonukrltsa"),
		// 					Tier: to.Ptr(armnginx.SKUTierFree),
		// 					Size: to.Ptr("sfhkuwcnxnactqtclqfwt"),
		// 					Family: to.Ptr("gfcpwwvwri"),
		// 					Capacity: to.Ptr[int32](27),
		// 				},
		// 				Tags: map[string]*string{
		// 					"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
		// 				},
		// 				Location: to.Ptr("dmy"),
		// 				ID: to.Ptr("/subscriptions/333F7B80-063D-40E5-975B-6E3C3CAC8296/resourceGroups/rgopenapi/providers/NGINX.NGINXPLUS/nginxDeployments/zpngfjhytajcvheoayopelklmzzpk"),
		// 				Name: to.Ptr("zpngfjhytajcvheoayopelklmzzpk"),
		// 				Type: to.Ptr("cxgktqvbtlxwjzc"),
		// 				SystemData: &armnginx.SystemData{
		// 					CreatedBy: to.Ptr("qokpyvbgqgcdpafqbhyfiftwgu"),
		// 					CreatedByType: to.Ptr(armnginx.CreatedByTypeUser),
		// 					CreatedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.647Z"); return t}()),
		// 					LastModifiedBy: to.Ptr("vvkvcyipmssjflaauflxmvqnox"),
		// 					LastModifiedByType: to.Ptr(armnginx.CreatedByTypeUser),
		// 					LastModifiedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.648Z"); return t}()),
		// 				},
		// 			},
		// 		},
		// 		NextLink: to.Ptr("https://microsoft.com/a"),
		// 	},
		// }
	}
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_ListDefaultWafPolicies_MaximumSet_Gen.json
func ExampleDeploymentsClient_ListDefaultWafPolicies() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	res, err := clientFactory.NewDeploymentsClient().ListDefaultWafPolicies(ctx, "rgopenapi", "myDeployment", nil)
	if err != nil {
		log.Fatalf("failed to finish the request: %v", err)
	}
	// You could use response here. We use blank identifier for just demo purposes.
	_ = res
	// If the HTTP response code is 200 as defined in example definition, your response structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
	// res = armnginx.DeploymentsClientListDefaultWafPoliciesResponse{
	// 	DeploymentDefaultWafPolicyListResponse: &armnginx.DeploymentDefaultWafPolicyListResponse{
	// 		Value: []*armnginx.DeploymentDefaultWafPolicy{
	// 			{
	// 				Content: []byte("Y29udGVudDE="),
	// 				Filepath: to.Ptr("mntwhvphybxsugtkf"),
	// 			},
	// 		},
	// 		NextLink: to.Ptr("tzbhzngebcjjqycrdwrxzkmyejfs"),
	// 	},
	// }
}

// Generated from example definition: 2025-03-01-preview/NginxDeployments_Update_MaximumSet_Gen.json
func ExampleDeploymentsClient_Update() {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain a credential: %v", err)
	}
	ctx := context.Background()
	clientFactory, err := armnginx.NewClientFactory("333F7B80-063D-40E5-975B-6E3C3CAC8296", cred, nil)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}
	res, err := clientFactory.NewDeploymentsClient().Update(ctx, "rgopenapi", "myDeployment", armnginx.DeploymentUpdate{
		Identity: &armnginx.ManagedServiceIdentity{
			Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
			UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
				"key337": {},
			},
		},
		SKU: &armnginx.SKU{
			Name:     to.Ptr("iccbcaojxhefokrdozqgdrllblzg"),
			Tier:     to.Ptr(armnginx.SKUTierFree),
			Size:     to.Ptr("cggqadyh"),
			Family:   to.Ptr("suykyfprhrlgpmsoufdrqokmqpp"),
			Capacity: to.Ptr[int32](5),
		},
		Tags: map[string]*string{
			"key5701": to.Ptr("gplzuuljzalcbbvm"),
		},
		Properties: &armnginx.DeploymentUpdateProperties{
			NginxVersion: to.Ptr("vtzduzvjepaooanrkbxscijwealiuh"),
			NetworkProfile: &armnginx.NetworkProfile{
				FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
					PublicIPAddresses: []*armnginx.PublicIPAddress{
						{
							ID: to.Ptr("shguvav"),
						},
					},
					PrivateIPAddresses: []*armnginx.PrivateIPAddress{
						{
							PrivateIPAddress:          to.Ptr("psbnydlzwdttexeljdcfh"),
							PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
							SubnetID:                  to.Ptr("fquufbmeybmmxbcapozztvgklo"),
						},
					},
				},
				NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
					SubnetID: to.Ptr("qquluyeug"),
				},
			},
			IPAddress:                to.Ptr("s"),
			EnableDiagnosticsSupport: to.Ptr(true),
			Logging: &armnginx.Logging{
				StorageAccount: &armnginx.StorageAccount{
					AccountName:   to.Ptr("abkrcmhgcltbxuylszapyfm"),
					ContainerName: to.Ptr("efgsyusocjaprhscvmgwrbucwbskm"),
				},
			},
			ScalingProperties: &armnginx.DeploymentScalingProperties{
				Capacity: to.Ptr[int32](19),
				AutoScaleSettings: &armnginx.AutoScaleSettings{
					Profiles: []*armnginx.ScaleProfile{
						{
							Name: to.Ptr("qgaibobr"),
							Capacity: &armnginx.ScaleProfileCapacity{
								Min: to.Ptr[int32](2),
								Max: to.Ptr[int32](30),
							},
						},
					},
				},
			},
			AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
				UpgradeChannel: to.Ptr("ymprjrocuishkfwxjq"),
			},
			UserProfile: &armnginx.DeploymentUserProfile{
				PreferredEmail: to.Ptr("nxqrabztuufzbdnmgqfg"),
			},
			NginxAppProtect: &armnginx.AppProtect{
				WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
					ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
				},
				WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
					WafRelease: to.Ptr("onmxvdxdnlzovetdqte"),
					AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("lpejes"),
						RevisionDatetime: to.Ptr("rknwqymfap"),
					},
					BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("lpejes"),
						RevisionDatetime: to.Ptr("rknwqymfap"),
					},
					ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
						Version:          to.Ptr("lpejes"),
						RevisionDatetime: to.Ptr("rknwqymfap"),
					},
					ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
						WafEngineVersion: to.Ptr("obyyywbsvealqqnyrywe"),
						WafNginxVersion:  to.Ptr("ulptzjmifyyxdobni"),
					},
				},
			},
			DataplaneAPIEndpoint: to.Ptr("kbiufuqmpq"),
		},
	}, nil)
	if err != nil {
		log.Fatalf("failed to finish the request: %v", err)
	}
	// You could use response here. We use blank identifier for just demo purposes.
	_ = res
	// If the HTTP response code is 200 as defined in example definition, your response structure would look as follows. Please pay attention that all the values in the output are fake values for just demo purposes.
	// res = armnginx.DeploymentsClientUpdateResponse{
	// 	Deployment: &armnginx.Deployment{
	// 		Properties: &armnginx.DeploymentProperties{
	// 			ProvisioningState: to.Ptr(armnginx.ProvisioningStateAccepted),
	// 			NginxVersion: to.Ptr("yjvomuondmj"),
	// 			NetworkProfile: &armnginx.NetworkProfile{
	// 				FrontEndIPConfiguration: &armnginx.FrontendIPConfiguration{
	// 					PublicIPAddresses: []*armnginx.PublicIPAddress{
	// 						{
	// 							ID: to.Ptr("shguvav"),
	// 						},
	// 					},
	// 					PrivateIPAddresses: []*armnginx.PrivateIPAddress{
	// 						{
	// 							PrivateIPAddress: to.Ptr("psbnydlzwdttexeljdcfh"),
	// 							PrivateIPAllocationMethod: to.Ptr(armnginx.PrivateIPAllocationMethodStatic),
	// 							SubnetID: to.Ptr("fquufbmeybmmxbcapozztvgklo"),
	// 						},
	// 					},
	// 				},
	// 				NetworkInterfaceConfiguration: &armnginx.NetworkInterfaceConfiguration{
	// 					SubnetID: to.Ptr("qquluyeug"),
	// 				},
	// 			},
	// 			IPAddress: to.Ptr("ztsmoltljnhmnw"),
	// 			EnableDiagnosticsSupport: to.Ptr(true),
	// 			Logging: &armnginx.Logging{
	// 				StorageAccount: &armnginx.StorageAccount{
	// 					AccountName: to.Ptr("abkrcmhgcltbxuylszapyfm"),
	// 					ContainerName: to.Ptr("efgsyusocjaprhscvmgwrbucwbskm"),
	// 				},
	// 			},
	// 			ScalingProperties: &armnginx.DeploymentScalingProperties{
	// 				Capacity: to.Ptr[int32](19),
	// 				AutoScaleSettings: &armnginx.AutoScaleSettings{
	// 					Profiles: []*armnginx.ScaleProfile{
	// 						{
	// 							Name: to.Ptr("qgaibobr"),
	// 							Capacity: &armnginx.ScaleProfileCapacity{
	// 								Min: to.Ptr[int32](2),
	// 								Max: to.Ptr[int32](30),
	// 							},
	// 						},
	// 					},
	// 				},
	// 			},
	// 			AutoUpgradeProfile: &armnginx.AutoUpgradeProfile{
	// 				UpgradeChannel: to.Ptr("ymprjrocuishkfwxjq"),
	// 			},
	// 			UserProfile: &armnginx.DeploymentUserProfile{
	// 				PreferredEmail: to.Ptr("nxqrabztuufzbdnmgqfg"),
	// 			},
	// 			NginxAppProtect: &armnginx.AppProtect{
	// 				WebApplicationFirewallSettings: &armnginx.WebApplicationFirewallSettings{
	// 					ActivationState: to.Ptr(armnginx.ActivationStateEnabled),
	// 				},
	// 				WebApplicationFirewallStatus: &armnginx.WebApplicationFirewallStatus{
	// 					WafRelease: to.Ptr("onmxvdxdnlzovetdqte"),
	// 					AttackSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("lpejes"),
	// 						RevisionDatetime: to.Ptr("rknwqymfap"),
	// 					},
	// 					BotSignaturesPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("lpejes"),
	// 						RevisionDatetime: to.Ptr("rknwqymfap"),
	// 					},
	// 					ThreatCampaignsPackage: &armnginx.WebApplicationFirewallPackage{
	// 						Version: to.Ptr("lpejes"),
	// 						RevisionDatetime: to.Ptr("rknwqymfap"),
	// 					},
	// 					ComponentVersions: &armnginx.WebApplicationFirewallComponentVersions{
	// 						WafEngineVersion: to.Ptr("obyyywbsvealqqnyrywe"),
	// 						WafNginxVersion: to.Ptr("ulptzjmifyyxdobni"),
	// 					},
	// 				},
	// 			},
	// 			DataplaneAPIEndpoint: to.Ptr("dlrtbdswoorqtkakjslfcuhgsva"),
	// 		},
	// 		Identity: &armnginx.ManagedServiceIdentity{
	// 			PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			TenantID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 			Type: to.Ptr(armnginx.ManagedServiceIdentityTypeNone),
	// 			UserAssignedIdentities: map[string]*armnginx.UserAssignedIdentity{
	// 				"key480": &armnginx.UserAssignedIdentity{
	// 					PrincipalID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 					ClientID: to.Ptr("32ae2eb4-67c5-408e-90b6-6cfe1ca82657"),
	// 				},
	// 			},
	// 		},
	// 		SKU: &armnginx.SKU{
	// 			Name: to.Ptr("piebonukrltsa"),
	// 			Tier: to.Ptr(armnginx.SKUTierFree),
	// 			Size: to.Ptr("sfhkuwcnxnactqtclqfwt"),
	// 			Family: to.Ptr("gfcpwwvwri"),
	// 			Capacity: to.Ptr[int32](27),
	// 		},
	// 		Tags: map[string]*string{
	// 			"key6788": to.Ptr("ocbflwfgetcdxdhnwe"),
	// 		},
	// 		Location: to.Ptr("dmy"),
	// 		ID: to.Ptr("/subscriptions/333F7B80-063D-40E5-975B-6E3C3CAC8296/resourceGroups/rgopenapi/providers/NGINX.NGINXPLUS/nginxDeployments/myDeployment"),
	// 		Name: to.Ptr("zpngfjhytajcvheoayopelklmzzpk"),
	// 		Type: to.Ptr("cxgktqvbtlxwjzc"),
	// 		SystemData: &armnginx.SystemData{
	// 			CreatedBy: to.Ptr("qokpyvbgqgcdpafqbhyfiftwgu"),
	// 			CreatedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			CreatedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.647Z"); return t}()),
	// 			LastModifiedBy: to.Ptr("vvkvcyipmssjflaauflxmvqnox"),
	// 			LastModifiedByType: to.Ptr(armnginx.CreatedByTypeUser),
	// 			LastModifiedAt: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2025-05-28T20:01:03.648Z"); return t}()),
	// 		},
	// 	},
	// }
}
