// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armoracledatabase

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime/datetime"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type ActivationLinks.
func (a ActivationLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "existingCloudAccountActivationLink", a.ExistingCloudAccountActivationLink)
	populate(objectMap, "newCloudAccountActivationLink", a.NewCloudAccountActivationLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivationLinks.
func (a *ActivationLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "existingCloudAccountActivationLink":
			err = unpopulate(val, "ExistingCloudAccountActivationLink", &a.ExistingCloudAccountActivationLink)
			delete(rawMsg, key)
		case "newCloudAccountActivationLink":
			err = unpopulate(val, "NewCloudAccountActivationLink", &a.NewCloudAccountActivationLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddRemoveDbNode.
func (a AddRemoveDbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbServers", a.DbServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddRemoveDbNode.
func (a *AddRemoveDbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbServers":
			err = unpopulate(val, "DbServers", &a.DbServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AllConnectionStringType.
func (a AllConnectionStringType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "high", a.High)
	populate(objectMap, "low", a.Low)
	populate(objectMap, "medium", a.Medium)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AllConnectionStringType.
func (a *AllConnectionStringType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "high":
			err = unpopulate(val, "High", &a.High)
			delete(rawMsg, key)
		case "low":
			err = unpopulate(val, "Low", &a.Low)
			delete(rawMsg, key)
		case "medium":
			err = unpopulate(val, "Medium", &a.Medium)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApexDetailsType.
func (a ApexDetailsType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apexVersion", a.ApexVersion)
	populate(objectMap, "ordsVersion", a.OrdsVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApexDetailsType.
func (a *ApexDetailsType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apexVersion":
			err = unpopulate(val, "ApexVersion", &a.ApexVersion)
			delete(rawMsg, key)
		case "ordsVersion":
			err = unpopulate(val, "OrdsVersion", &a.OrdsVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabase.
func (a AutonomousDatabase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabase.
func (a *AutonomousDatabase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAutonomousDatabaseBasePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackup.
func (a AutonomousDatabaseBackup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackup.
func (a *AutonomousDatabaseBackup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupListResult.
func (a AutonomousDatabaseBackupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupListResult.
func (a *AutonomousDatabaseBackupListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupProperties.
func (a AutonomousDatabaseBackupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autonomousDatabaseOcid", a.AutonomousDatabaseOcid)
	populate(objectMap, "backupType", a.BackupType)
	populate(objectMap, "databaseSizeInTbs", a.DatabaseSizeInTbs)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isAutomatic", a.IsAutomatic)
	populate(objectMap, "isRestorable", a.IsRestorable)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "retentionPeriodInDays", a.RetentionPeriodInDays)
	populate(objectMap, "sizeInTbs", a.SizeInTbs)
	populateTime[datetime.RFC3339](objectMap, "timeAvailableTil", a.TimeAvailableTil)
	populate(objectMap, "timeEnded", a.TimeEnded)
	populate(objectMap, "timeStarted", a.TimeStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupProperties.
func (a *AutonomousDatabaseBackupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autonomousDatabaseOcid":
			err = unpopulate(val, "AutonomousDatabaseOcid", &a.AutonomousDatabaseOcid)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, "BackupType", &a.BackupType)
			delete(rawMsg, key)
		case "databaseSizeInTbs":
			err = unpopulate(val, "DatabaseSizeInTbs", &a.DatabaseSizeInTbs)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isAutomatic":
			err = unpopulate(val, "IsAutomatic", &a.IsAutomatic)
			delete(rawMsg, key)
		case "isRestorable":
			err = unpopulate(val, "IsRestorable", &a.IsRestorable)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &a.RetentionPeriodInDays)
			delete(rawMsg, key)
		case "sizeInTbs":
			err = unpopulate(val, "SizeInTbs", &a.SizeInTbs)
			delete(rawMsg, key)
		case "timeAvailableTil":
			err = unpopulateTime[datetime.RFC3339](val, "TimeAvailableTil", &a.TimeAvailableTil)
			delete(rawMsg, key)
		case "timeEnded":
			err = unpopulate(val, "TimeEnded", &a.TimeEnded)
			delete(rawMsg, key)
		case "timeStarted":
			err = unpopulate(val, "TimeStarted", &a.TimeStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupUpdate.
func (a AutonomousDatabaseBackupUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupUpdate.
func (a *AutonomousDatabaseBackupUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupUpdateProperties.
func (a AutonomousDatabaseBackupUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "retentionPeriodInDays", a.RetentionPeriodInDays)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupUpdateProperties.
func (a *AutonomousDatabaseBackupUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &a.RetentionPeriodInDays)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBaseProperties.
func (a AutonomousDatabaseBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	populate(objectMap, "dataBaseType", a.DataBaseType)
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateTime[datetime.RFC3339](objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "remoteDisasterRecoveryConfiguration", a.RemoteDisasterRecoveryConfiguration)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBaseProperties.
func (a *AutonomousDatabaseBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateTime[datetime.RFC3339](val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryConfiguration":
			err = unpopulate(val, "RemoteDisasterRecoveryConfiguration", &a.RemoteDisasterRecoveryConfiguration)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulateTime[datetime.RFC3339](val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSet.
func (a AutonomousDatabaseCharacterSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSet.
func (a *AutonomousDatabaseCharacterSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSetListResult.
func (a AutonomousDatabaseCharacterSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSetListResult.
func (a *AutonomousDatabaseCharacterSetListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSetProperties.
func (a AutonomousDatabaseCharacterSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "characterSet", a.CharacterSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSetProperties.
func (a *AutonomousDatabaseCharacterSetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCloneProperties.
func (a AutonomousDatabaseCloneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "cloneType", a.CloneType)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeClone
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isReconnectCloneEnabled", a.IsReconnectCloneEnabled)
	populate(objectMap, "isRefreshableClone", a.IsRefreshableClone)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateTime[datetime.RFC3339](objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "refreshableModel", a.RefreshableModel)
	populate(objectMap, "refreshableStatus", a.RefreshableStatus)
	populate(objectMap, "remoteDisasterRecoveryConfiguration", a.RemoteDisasterRecoveryConfiguration)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "source", a.Source)
	populate(objectMap, "sourceId", a.SourceID)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "timeUntilReconnectCloneEnabled", a.TimeUntilReconnectCloneEnabled)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCloneProperties.
func (a *AutonomousDatabaseCloneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "cloneType":
			err = unpopulate(val, "CloneType", &a.CloneType)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isReconnectCloneEnabled":
			err = unpopulate(val, "IsReconnectCloneEnabled", &a.IsReconnectCloneEnabled)
			delete(rawMsg, key)
		case "isRefreshableClone":
			err = unpopulate(val, "IsRefreshableClone", &a.IsRefreshableClone)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateTime[datetime.RFC3339](val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "refreshableModel":
			err = unpopulate(val, "RefreshableModel", &a.RefreshableModel)
			delete(rawMsg, key)
		case "refreshableStatus":
			err = unpopulate(val, "RefreshableStatus", &a.RefreshableStatus)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryConfiguration":
			err = unpopulate(val, "RemoteDisasterRecoveryConfiguration", &a.RemoteDisasterRecoveryConfiguration)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		case "sourceId":
			err = unpopulate(val, "SourceID", &a.SourceID)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulateTime[datetime.RFC3339](val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeUntilReconnectCloneEnabled":
			err = unpopulate(val, "TimeUntilReconnectCloneEnabled", &a.TimeUntilReconnectCloneEnabled)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCrossRegionDisasterRecoveryProperties.
func (a AutonomousDatabaseCrossRegionDisasterRecoveryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeCrossRegionDisasterRecovery
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "isReplicateAutomaticBackups", a.IsReplicateAutomaticBackups)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateTime[datetime.RFC3339](objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "remoteDisasterRecoveryConfiguration", a.RemoteDisasterRecoveryConfiguration)
	populate(objectMap, "remoteDisasterRecoveryType", a.RemoteDisasterRecoveryType)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	objectMap["source"] = SourceTypeCrossRegionDisasterRecovery
	populate(objectMap, "sourceId", a.SourceID)
	populate(objectMap, "sourceLocation", a.SourceLocation)
	populate(objectMap, "sourceOcid", a.SourceOcid)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCrossRegionDisasterRecoveryProperties.
func (a *AutonomousDatabaseCrossRegionDisasterRecoveryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "isReplicateAutomaticBackups":
			err = unpopulate(val, "IsReplicateAutomaticBackups", &a.IsReplicateAutomaticBackups)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateTime[datetime.RFC3339](val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryConfiguration":
			err = unpopulate(val, "RemoteDisasterRecoveryConfiguration", &a.RemoteDisasterRecoveryConfiguration)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryType":
			err = unpopulate(val, "RemoteDisasterRecoveryType", &a.RemoteDisasterRecoveryType)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		case "sourceId":
			err = unpopulate(val, "SourceID", &a.SourceID)
			delete(rawMsg, key)
		case "sourceLocation":
			err = unpopulate(val, "SourceLocation", &a.SourceLocation)
			delete(rawMsg, key)
		case "sourceOcid":
			err = unpopulate(val, "SourceOcid", &a.SourceOcid)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulateTime[datetime.RFC3339](val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseFromBackupTimestampProperties.
func (a AutonomousDatabaseFromBackupTimestampProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "cloneType", a.CloneType)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeCloneFromBackupTimestamp
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateTime[datetime.RFC3339](objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "remoteDisasterRecoveryConfiguration", a.RemoteDisasterRecoveryConfiguration)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	objectMap["source"] = SourceTypeBackupFromTimestamp
	populate(objectMap, "sourceId", a.SourceID)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timestamp", a.Timestamp)
	populate(objectMap, "useLatestAvailableBackupTimeStamp", a.UseLatestAvailableBackupTimeStamp)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseFromBackupTimestampProperties.
func (a *AutonomousDatabaseFromBackupTimestampProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "cloneType":
			err = unpopulate(val, "CloneType", &a.CloneType)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateTime[datetime.RFC3339](val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryConfiguration":
			err = unpopulate(val, "RemoteDisasterRecoveryConfiguration", &a.RemoteDisasterRecoveryConfiguration)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		case "sourceId":
			err = unpopulate(val, "SourceID", &a.SourceID)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulateTime[datetime.RFC3339](val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTime[datetime.RFC3339](val, "Timestamp", &a.Timestamp)
			delete(rawMsg, key)
		case "useLatestAvailableBackupTimeStamp":
			err = unpopulate(val, "UseLatestAvailableBackupTimeStamp", &a.UseLatestAvailableBackupTimeStamp)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseLifecycleAction.
func (a AutonomousDatabaseLifecycleAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", a.Action)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseLifecycleAction.
func (a *AutonomousDatabaseLifecycleAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &a.Action)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseListResult.
func (a AutonomousDatabaseListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseListResult.
func (a *AutonomousDatabaseListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSet.
func (a AutonomousDatabaseNationalCharacterSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSet.
func (a *AutonomousDatabaseNationalCharacterSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSetListResult.
func (a AutonomousDatabaseNationalCharacterSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSetListResult.
func (a *AutonomousDatabaseNationalCharacterSetListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSetProperties.
func (a AutonomousDatabaseNationalCharacterSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "characterSet", a.CharacterSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSetProperties.
func (a *AutonomousDatabaseNationalCharacterSetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseProperties.
func (a AutonomousDatabaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeRegular
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateTime[datetime.RFC3339](objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "remoteDisasterRecoveryConfiguration", a.RemoteDisasterRecoveryConfiguration)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populateTime[datetime.RFC3339](objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseProperties.
func (a *AutonomousDatabaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateTime[datetime.RFC3339](val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "remoteDisasterRecoveryConfiguration":
			err = unpopulate(val, "RemoteDisasterRecoveryConfiguration", &a.RemoteDisasterRecoveryConfiguration)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulateTime[datetime.RFC3339](val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseStandbySummary.
func (a AutonomousDatabaseStandbySummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lagTimeInSeconds", a.LagTimeInSeconds)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseStandbySummary.
func (a *AutonomousDatabaseStandbySummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lagTimeInSeconds":
			err = unpopulate(val, "LagTimeInSeconds", &a.LagTimeInSeconds)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulate(val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseUpdate.
func (a AutonomousDatabaseUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseUpdate.
func (a *AutonomousDatabaseUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseUpdateProperties.
func (a AutonomousDatabaseUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "scheduledOperationsList", a.ScheduledOperationsList)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseUpdateProperties.
func (a *AutonomousDatabaseUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "scheduledOperationsList":
			err = unpopulate(val, "ScheduledOperationsList", &a.ScheduledOperationsList)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseWalletFile.
func (a AutonomousDatabaseWalletFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "walletFiles", a.WalletFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseWalletFile.
func (a *AutonomousDatabaseWalletFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "walletFiles":
			err = unpopulate(val, "WalletFiles", &a.WalletFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersion.
func (a AutonomousDbVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersion.
func (a *AutonomousDbVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersionListResult.
func (a AutonomousDbVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersionListResult.
func (a *AutonomousDbVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersionProperties.
func (a AutonomousDbVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "isDefaultForFree", a.IsDefaultForFree)
	populate(objectMap, "isDefaultForPaid", a.IsDefaultForPaid)
	populate(objectMap, "isFreeTierEnabled", a.IsFreeTierEnabled)
	populate(objectMap, "isPaidEnabled", a.IsPaidEnabled)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersionProperties.
func (a *AutonomousDbVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "isDefaultForFree":
			err = unpopulate(val, "IsDefaultForFree", &a.IsDefaultForFree)
			delete(rawMsg, key)
		case "isDefaultForPaid":
			err = unpopulate(val, "IsDefaultForPaid", &a.IsDefaultForPaid)
			delete(rawMsg, key)
		case "isFreeTierEnabled":
			err = unpopulate(val, "IsFreeTierEnabled", &a.IsFreeTierEnabled)
			delete(rawMsg, key)
		case "isPaidEnabled":
			err = unpopulate(val, "IsPaidEnabled", &a.IsPaidEnabled)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureSubscriptions.
func (a AzureSubscriptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureSubscriptionIds", a.AzureSubscriptionIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSubscriptions.
func (a *AzureSubscriptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureSubscriptionIds":
			err = unpopulate(val, "AzureSubscriptionIDs", &a.AzureSubscriptionIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudAccountDetails.
func (c CloudAccountDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloudAccountHomeRegion", c.CloudAccountHomeRegion)
	populate(objectMap, "cloudAccountName", c.CloudAccountName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudAccountDetails.
func (c *CloudAccountDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudAccountHomeRegion":
			err = unpopulate(val, "CloudAccountHomeRegion", &c.CloudAccountHomeRegion)
			delete(rawMsg, key)
		case "cloudAccountName":
			err = unpopulate(val, "CloudAccountName", &c.CloudAccountName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructure.
func (c CloudExadataInfrastructure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructure.
func (c *CloudExadataInfrastructure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureListResult.
func (c CloudExadataInfrastructureListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureListResult.
func (c *CloudExadataInfrastructureListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureProperties.
func (c CloudExadataInfrastructureProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activatedStorageCount", c.ActivatedStorageCount)
	populate(objectMap, "additionalStorageCount", c.AdditionalStorageCount)
	populate(objectMap, "availableStorageSizeInGbs", c.AvailableStorageSizeInGbs)
	populate(objectMap, "cpuCount", c.CPUCount)
	populate(objectMap, "computeCount", c.ComputeCount)
	populate(objectMap, "computeModel", c.ComputeModel)
	populate(objectMap, "customerContacts", c.CustomerContacts)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "databaseServerType", c.DatabaseServerType)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerVersion", c.DbServerVersion)
	populate(objectMap, "definedFileSystemConfiguration", c.DefinedFileSystemConfiguration)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "estimatedPatchingTime", c.EstimatedPatchingTime)
	populate(objectMap, "exascaleConfig", c.ExascaleConfig)
	populate(objectMap, "lastMaintenanceRunId", c.LastMaintenanceRunID)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "lifecycleState", c.LifecycleState)
	populate(objectMap, "maintenanceWindow", c.MaintenanceWindow)
	populate(objectMap, "maxCpuCount", c.MaxCPUCount)
	populate(objectMap, "maxDataStorageInTbs", c.MaxDataStorageInTbs)
	populate(objectMap, "maxDbNodeStorageSizeInGbs", c.MaxDbNodeStorageSizeInGbs)
	populate(objectMap, "maxMemoryInGbs", c.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "monthlyDbServerVersion", c.MonthlyDbServerVersion)
	populate(objectMap, "monthlyStorageServerVersion", c.MonthlyStorageServerVersion)
	populate(objectMap, "nextMaintenanceRunId", c.NextMaintenanceRunID)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageCount", c.StorageCount)
	populate(objectMap, "storageServerType", c.StorageServerType)
	populate(objectMap, "storageServerVersion", c.StorageServerVersion)
	populate(objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "totalStorageSizeInGbs", c.TotalStorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureProperties.
func (c *CloudExadataInfrastructureProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activatedStorageCount":
			err = unpopulate(val, "ActivatedStorageCount", &c.ActivatedStorageCount)
			delete(rawMsg, key)
		case "additionalStorageCount":
			err = unpopulate(val, "AdditionalStorageCount", &c.AdditionalStorageCount)
			delete(rawMsg, key)
		case "availableStorageSizeInGbs":
			err = unpopulate(val, "AvailableStorageSizeInGbs", &c.AvailableStorageSizeInGbs)
			delete(rawMsg, key)
		case "cpuCount":
			err = unpopulate(val, "CPUCount", &c.CPUCount)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &c.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &c.ComputeModel)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &c.CustomerContacts)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseServerType":
			err = unpopulate(val, "DatabaseServerType", &c.DatabaseServerType)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerVersion":
			err = unpopulate(val, "DbServerVersion", &c.DbServerVersion)
			delete(rawMsg, key)
		case "definedFileSystemConfiguration":
			err = unpopulate(val, "DefinedFileSystemConfiguration", &c.DefinedFileSystemConfiguration)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "estimatedPatchingTime":
			err = unpopulate(val, "EstimatedPatchingTime", &c.EstimatedPatchingTime)
			delete(rawMsg, key)
		case "exascaleConfig":
			err = unpopulate(val, "ExascaleConfig", &c.ExascaleConfig)
			delete(rawMsg, key)
		case "lastMaintenanceRunId":
			err = unpopulate(val, "LastMaintenanceRunID", &c.LastMaintenanceRunID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &c.LifecycleState)
			delete(rawMsg, key)
		case "maintenanceWindow":
			err = unpopulate(val, "MaintenanceWindow", &c.MaintenanceWindow)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &c.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDataStorageInTbs":
			err = unpopulate(val, "MaxDataStorageInTbs", &c.MaxDataStorageInTbs)
			delete(rawMsg, key)
		case "maxDbNodeStorageSizeInGbs":
			err = unpopulate(val, "MaxDbNodeStorageSizeInGbs", &c.MaxDbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &c.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "monthlyDbServerVersion":
			err = unpopulate(val, "MonthlyDbServerVersion", &c.MonthlyDbServerVersion)
			delete(rawMsg, key)
		case "monthlyStorageServerVersion":
			err = unpopulate(val, "MonthlyStorageServerVersion", &c.MonthlyStorageServerVersion)
			delete(rawMsg, key)
		case "nextMaintenanceRunId":
			err = unpopulate(val, "NextMaintenanceRunID", &c.NextMaintenanceRunID)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageCount":
			err = unpopulate(val, "StorageCount", &c.StorageCount)
			delete(rawMsg, key)
		case "storageServerType":
			err = unpopulate(val, "StorageServerType", &c.StorageServerType)
			delete(rawMsg, key)
		case "storageServerVersion":
			err = unpopulate(val, "StorageServerVersion", &c.StorageServerVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulate(val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "totalStorageSizeInGbs":
			err = unpopulate(val, "TotalStorageSizeInGbs", &c.TotalStorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureUpdate.
func (c CloudExadataInfrastructureUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureUpdate.
func (c *CloudExadataInfrastructureUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureUpdateProperties.
func (c CloudExadataInfrastructureUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeCount", c.ComputeCount)
	populate(objectMap, "customerContacts", c.CustomerContacts)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "maintenanceWindow", c.MaintenanceWindow)
	populate(objectMap, "storageCount", c.StorageCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureUpdateProperties.
func (c *CloudExadataInfrastructureUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &c.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &c.CustomerContacts)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "maintenanceWindow":
			err = unpopulate(val, "MaintenanceWindow", &c.MaintenanceWindow)
			delete(rawMsg, key)
		case "storageCount":
			err = unpopulate(val, "StorageCount", &c.StorageCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMCluster.
func (c CloudVMCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMCluster.
func (c *CloudVMCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterListResult.
func (c CloudVMClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterListResult.
func (c *CloudVMClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterProperties.
func (c CloudVMClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupSubnetCidr", c.BackupSubnetCidr)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "cloudExadataInfrastructureId", c.CloudExadataInfrastructureID)
	populate(objectMap, "clusterName", c.ClusterName)
	populate(objectMap, "compartmentId", c.CompartmentID)
	populate(objectMap, "computeModel", c.ComputeModel)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStoragePercentage", c.DataStoragePercentage)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServers", c.DbServers)
	populate(objectMap, "diskRedundancy", c.DiskRedundancy)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "domain", c.Domain)
	populate(objectMap, "exascaleDbStorageVaultId", c.ExascaleDbStorageVaultID)
	populate(objectMap, "fileSystemConfigurationDetails", c.FileSystemConfigurationDetails)
	populate(objectMap, "giVersion", c.GiVersion)
	populate(objectMap, "hostname", c.Hostname)
	populate(objectMap, "iormConfigCache", c.IormConfigCache)
	populate(objectMap, "isLocalBackupEnabled", c.IsLocalBackupEnabled)
	populate(objectMap, "isSparseDiskgroupEnabled", c.IsSparseDiskgroupEnabled)
	populate(objectMap, "lastUpdateHistoryEntryId", c.LastUpdateHistoryEntryID)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "lifecycleState", c.LifecycleState)
	populate(objectMap, "listenerPort", c.ListenerPort)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "nodeCount", c.NodeCount)
	populate(objectMap, "nsgCidrs", c.NsgCidrs)
	populate(objectMap, "nsgUrl", c.NsgURL)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "scanDnsName", c.ScanDNSName)
	populate(objectMap, "scanDnsRecordId", c.ScanDNSRecordID)
	populate(objectMap, "scanIpIds", c.ScanIPIDs)
	populate(objectMap, "scanListenerPortTcp", c.ScanListenerPortTCP)
	populate(objectMap, "scanListenerPortTcpSsl", c.ScanListenerPortTCPSSL)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageManagementType", c.StorageManagementType)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	populate(objectMap, "subnetId", c.SubnetID)
	populate(objectMap, "subnetOcid", c.SubnetOcid)
	populate(objectMap, "systemVersion", c.SystemVersion)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "timeZone", c.TimeZone)
	populate(objectMap, "vipIds", c.VipIDs)
	populate(objectMap, "vnetId", c.VnetID)
	populate(objectMap, "zoneId", c.ZoneID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterProperties.
func (c *CloudVMClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupSubnetCidr":
			err = unpopulate(val, "BackupSubnetCidr", &c.BackupSubnetCidr)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "cloudExadataInfrastructureId":
			err = unpopulate(val, "CloudExadataInfrastructureID", &c.CloudExadataInfrastructureID)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &c.ClusterName)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &c.CompartmentID)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &c.ComputeModel)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStoragePercentage":
			err = unpopulate(val, "DataStoragePercentage", &c.DataStoragePercentage)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServers":
			err = unpopulate(val, "DbServers", &c.DbServers)
			delete(rawMsg, key)
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &c.DiskRedundancy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &c.Domain)
			delete(rawMsg, key)
		case "exascaleDbStorageVaultId":
			err = unpopulate(val, "ExascaleDbStorageVaultID", &c.ExascaleDbStorageVaultID)
			delete(rawMsg, key)
		case "fileSystemConfigurationDetails":
			err = unpopulate(val, "FileSystemConfigurationDetails", &c.FileSystemConfigurationDetails)
			delete(rawMsg, key)
		case "giVersion":
			err = unpopulate(val, "GiVersion", &c.GiVersion)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &c.Hostname)
			delete(rawMsg, key)
		case "iormConfigCache":
			err = unpopulate(val, "IormConfigCache", &c.IormConfigCache)
			delete(rawMsg, key)
		case "isLocalBackupEnabled":
			err = unpopulate(val, "IsLocalBackupEnabled", &c.IsLocalBackupEnabled)
			delete(rawMsg, key)
		case "isSparseDiskgroupEnabled":
			err = unpopulate(val, "IsSparseDiskgroupEnabled", &c.IsSparseDiskgroupEnabled)
			delete(rawMsg, key)
		case "lastUpdateHistoryEntryId":
			err = unpopulate(val, "LastUpdateHistoryEntryID", &c.LastUpdateHistoryEntryID)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &c.LifecycleState)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &c.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &c.NodeCount)
			delete(rawMsg, key)
		case "nsgCidrs":
			err = unpopulate(val, "NsgCidrs", &c.NsgCidrs)
			delete(rawMsg, key)
		case "nsgUrl":
			err = unpopulate(val, "NsgURL", &c.NsgURL)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &c.ScanDNSName)
			delete(rawMsg, key)
		case "scanDnsRecordId":
			err = unpopulate(val, "ScanDNSRecordID", &c.ScanDNSRecordID)
			delete(rawMsg, key)
		case "scanIpIds":
			err = unpopulate(val, "ScanIPIDs", &c.ScanIPIDs)
			delete(rawMsg, key)
		case "scanListenerPortTcp":
			err = unpopulate(val, "ScanListenerPortTCP", &c.ScanListenerPortTCP)
			delete(rawMsg, key)
		case "scanListenerPortTcpSsl":
			err = unpopulate(val, "ScanListenerPortTCPSSL", &c.ScanListenerPortTCPSSL)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageManagementType":
			err = unpopulate(val, "StorageManagementType", &c.StorageManagementType)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &c.SubnetID)
			delete(rawMsg, key)
		case "subnetOcid":
			err = unpopulate(val, "SubnetOcid", &c.SubnetOcid)
			delete(rawMsg, key)
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &c.SystemVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &c.TimeZone)
			delete(rawMsg, key)
		case "vipIds":
			err = unpopulate(val, "VipIDs", &c.VipIDs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &c.VnetID)
			delete(rawMsg, key)
		case "zoneId":
			err = unpopulate(val, "ZoneID", &c.ZoneID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdate.
func (c CloudVMClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdate.
func (c *CloudVMClusterUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdateProperties.
func (c CloudVMClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "fileSystemConfigurationDetails", c.FileSystemConfigurationDetails)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdateProperties.
func (c *CloudVMClusterUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "fileSystemConfigurationDetails":
			err = unpopulate(val, "FileSystemConfigurationDetails", &c.FileSystemConfigurationDetails)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfigureExascaleCloudExadataInfrastructureDetails.
func (c ConfigureExascaleCloudExadataInfrastructureDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "totalStorageInGbs", c.TotalStorageInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfigureExascaleCloudExadataInfrastructureDetails.
func (c *ConfigureExascaleCloudExadataInfrastructureDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "totalStorageInGbs":
			err = unpopulate(val, "TotalStorageInGbs", &c.TotalStorageInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionStringType.
func (c ConnectionStringType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allConnectionStrings", c.AllConnectionStrings)
	populate(objectMap, "dedicated", c.Dedicated)
	populate(objectMap, "high", c.High)
	populate(objectMap, "low", c.Low)
	populate(objectMap, "medium", c.Medium)
	populate(objectMap, "profiles", c.Profiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionStringType.
func (c *ConnectionStringType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allConnectionStrings":
			err = unpopulate(val, "AllConnectionStrings", &c.AllConnectionStrings)
			delete(rawMsg, key)
		case "dedicated":
			err = unpopulate(val, "Dedicated", &c.Dedicated)
			delete(rawMsg, key)
		case "high":
			err = unpopulate(val, "High", &c.High)
			delete(rawMsg, key)
		case "low":
			err = unpopulate(val, "Low", &c.Low)
			delete(rawMsg, key)
		case "medium":
			err = unpopulate(val, "Medium", &c.Medium)
			delete(rawMsg, key)
		case "profiles":
			err = unpopulate(val, "Profiles", &c.Profiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionURLType.
func (c ConnectionURLType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apexUrl", c.ApexURL)
	populate(objectMap, "databaseTransformsUrl", c.DatabaseTransformsURL)
	populate(objectMap, "graphStudioUrl", c.GraphStudioURL)
	populate(objectMap, "machineLearningNotebookUrl", c.MachineLearningNotebookURL)
	populate(objectMap, "mongoDbUrl", c.MongoDbURL)
	populate(objectMap, "ordsUrl", c.OrdsURL)
	populate(objectMap, "sqlDevWebUrl", c.SQLDevWebURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionURLType.
func (c *ConnectionURLType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apexUrl":
			err = unpopulate(val, "ApexURL", &c.ApexURL)
			delete(rawMsg, key)
		case "databaseTransformsUrl":
			err = unpopulate(val, "DatabaseTransformsURL", &c.DatabaseTransformsURL)
			delete(rawMsg, key)
		case "graphStudioUrl":
			err = unpopulate(val, "GraphStudioURL", &c.GraphStudioURL)
			delete(rawMsg, key)
		case "machineLearningNotebookUrl":
			err = unpopulate(val, "MachineLearningNotebookURL", &c.MachineLearningNotebookURL)
			delete(rawMsg, key)
		case "mongoDbUrl":
			err = unpopulate(val, "MongoDbURL", &c.MongoDbURL)
			delete(rawMsg, key)
		case "ordsUrl":
			err = unpopulate(val, "OrdsURL", &c.OrdsURL)
			delete(rawMsg, key)
		case "sqlDevWebUrl":
			err = unpopulate(val, "SQLDevWebURL", &c.SQLDevWebURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerContact.
func (c CustomerContact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "email", c.Email)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerContact.
func (c *CustomerContact) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "email":
			err = unpopulate(val, "Email", &c.Email)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSForwardingRule.
func (d DNSForwardingRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainNames", d.DomainNames)
	populate(objectMap, "forwardingIpAddress", d.ForwardingIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSForwardingRule.
func (d *DNSForwardingRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainNames":
			err = unpopulate(val, "DomainNames", &d.DomainNames)
			delete(rawMsg, key)
		case "forwardingIpAddress":
			err = unpopulate(val, "ForwardingIPAddress", &d.ForwardingIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateView.
func (d DNSPrivateView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateView.
func (d *DNSPrivateView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewListResult.
func (d DNSPrivateViewListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewListResult.
func (d *DNSPrivateViewListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewProperties.
func (d DNSPrivateViewProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", d.TimeCreated)
	populateTime[datetime.RFC3339](objectMap, "timeUpdated", d.TimeUpdated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewProperties.
func (d *DNSPrivateViewProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeUpdated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeUpdated", &d.TimeUpdated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZone.
func (d DNSPrivateZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZone.
func (d *DNSPrivateZone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneListResult.
func (d DNSPrivateZoneListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneListResult.
func (d *DNSPrivateZoneListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneProperties.
func (d DNSPrivateZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populate(objectMap, "serial", d.Serial)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "version", d.Version)
	populate(objectMap, "viewId", d.ViewID)
	populate(objectMap, "zoneType", d.ZoneType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneProperties.
func (d *DNSPrivateZoneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "serial":
			err = unpopulate(val, "Serial", &d.Serial)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		case "viewId":
			err = unpopulate(val, "ViewID", &d.ViewID)
			delete(rawMsg, key)
		case "zoneType":
			err = unpopulate(val, "ZoneType", &d.ZoneType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionOptions.
func (d DataCollectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDiagnosticsEventsEnabled", d.IsDiagnosticsEventsEnabled)
	populate(objectMap, "isHealthMonitoringEnabled", d.IsHealthMonitoringEnabled)
	populate(objectMap, "isIncidentLogsEnabled", d.IsIncidentLogsEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionOptions.
func (d *DataCollectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDiagnosticsEventsEnabled":
			err = unpopulate(val, "IsDiagnosticsEventsEnabled", &d.IsDiagnosticsEventsEnabled)
			delete(rawMsg, key)
		case "isHealthMonitoringEnabled":
			err = unpopulate(val, "IsHealthMonitoringEnabled", &d.IsHealthMonitoringEnabled)
			delete(rawMsg, key)
		case "isIncidentLogsEnabled":
			err = unpopulate(val, "IsIncidentLogsEnabled", &d.IsIncidentLogsEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DayOfWeek.
func (d DayOfWeek) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DayOfWeek.
func (d *DayOfWeek) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DayOfWeekUpdate.
func (d DayOfWeekUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DayOfWeekUpdate.
func (d *DayOfWeekUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbActionResponse.
func (d DbActionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbActionResponse.
func (d *DbActionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbIormConfig.
func (d DbIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbName", d.DbName)
	populate(objectMap, "flashCacheLimit", d.FlashCacheLimit)
	populate(objectMap, "share", d.Share)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbIormConfig.
func (d *DbIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbName":
			err = unpopulate(val, "DbName", &d.DbName)
			delete(rawMsg, key)
		case "flashCacheLimit":
			err = unpopulate(val, "FlashCacheLimit", &d.FlashCacheLimit)
			delete(rawMsg, key)
		case "share":
			err = unpopulate(val, "Share", &d.Share)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNode.
func (d DbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNode.
func (d *DbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeAction.
func (d DbNodeAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", d.Action)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeAction.
func (d *DbNodeAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &d.Action)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeDetails.
func (d DbNodeDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbNodeId", d.DbNodeID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeDetails.
func (d *DbNodeDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbNodeId":
			err = unpopulate(val, "DbNodeID", &d.DbNodeID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeListResult.
func (d DbNodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeListResult.
func (d *DbNodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeProperties.
func (d DbNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDetails", d.AdditionalDetails)
	populate(objectMap, "backupIpId", d.BackupIPID)
	populate(objectMap, "backupVnic2Id", d.BackupVnic2ID)
	populate(objectMap, "backupVnicId", d.BackupVnicID)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerId", d.DbServerID)
	populate(objectMap, "dbSystemId", d.DbSystemID)
	populate(objectMap, "faultDomain", d.FaultDomain)
	populate(objectMap, "hostIpId", d.HostIPID)
	populate(objectMap, "hostname", d.Hostname)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "maintenanceType", d.MaintenanceType)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "softwareStorageSizeInGb", d.SoftwareStorageSizeInGb)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", d.TimeCreated)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceWindowEnd", d.TimeMaintenanceWindowEnd)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceWindowStart", d.TimeMaintenanceWindowStart)
	populate(objectMap, "vnic2Id", d.Vnic2ID)
	populate(objectMap, "vnicId", d.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeProperties.
func (d *DbNodeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDetails":
			err = unpopulate(val, "AdditionalDetails", &d.AdditionalDetails)
			delete(rawMsg, key)
		case "backupIpId":
			err = unpopulate(val, "BackupIPID", &d.BackupIPID)
			delete(rawMsg, key)
		case "backupVnic2Id":
			err = unpopulate(val, "BackupVnic2ID", &d.BackupVnic2ID)
			delete(rawMsg, key)
		case "backupVnicId":
			err = unpopulate(val, "BackupVnicID", &d.BackupVnicID)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerId":
			err = unpopulate(val, "DbServerID", &d.DbServerID)
			delete(rawMsg, key)
		case "dbSystemId":
			err = unpopulate(val, "DbSystemID", &d.DbSystemID)
			delete(rawMsg, key)
		case "faultDomain":
			err = unpopulate(val, "FaultDomain", &d.FaultDomain)
			delete(rawMsg, key)
		case "hostIpId":
			err = unpopulate(val, "HostIPID", &d.HostIPID)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &d.Hostname)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "maintenanceType":
			err = unpopulate(val, "MaintenanceType", &d.MaintenanceType)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "softwareStorageSizeInGb":
			err = unpopulate(val, "SoftwareStorageSizeInGb", &d.SoftwareStorageSizeInGb)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeMaintenanceWindowEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceWindowEnd", &d.TimeMaintenanceWindowEnd)
			delete(rawMsg, key)
		case "timeMaintenanceWindowStart":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceWindowStart", &d.TimeMaintenanceWindowStart)
			delete(rawMsg, key)
		case "vnic2Id":
			err = unpopulate(val, "Vnic2ID", &d.Vnic2ID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &d.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServer.
func (d DbServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServer.
func (d *DbServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerListResult.
func (d DbServerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerListResult.
func (d *DbServerListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerPatchingDetails.
func (d DbServerPatchingDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedPatchDuration", d.EstimatedPatchDuration)
	populate(objectMap, "patchingStatus", d.PatchingStatus)
	populateTime[datetime.RFC3339](objectMap, "timePatchingEnded", d.TimePatchingEnded)
	populateTime[datetime.RFC3339](objectMap, "timePatchingStarted", d.TimePatchingStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerPatchingDetails.
func (d *DbServerPatchingDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedPatchDuration":
			err = unpopulate(val, "EstimatedPatchDuration", &d.EstimatedPatchDuration)
			delete(rawMsg, key)
		case "patchingStatus":
			err = unpopulate(val, "PatchingStatus", &d.PatchingStatus)
			delete(rawMsg, key)
		case "timePatchingEnded":
			err = unpopulateTime[datetime.RFC3339](val, "TimePatchingEnded", &d.TimePatchingEnded)
			delete(rawMsg, key)
		case "timePatchingStarted":
			err = unpopulateTime[datetime.RFC3339](val, "TimePatchingStarted", &d.TimePatchingStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerProperties.
func (d DbServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autonomousVmClusterIds", d.AutonomousVMClusterIDs)
	populate(objectMap, "autonomousVirtualMachineIds", d.AutonomousVirtualMachineIDs)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "compartmentId", d.CompartmentID)
	populate(objectMap, "computeModel", d.ComputeModel)
	populate(objectMap, "dbNodeIds", d.DbNodeIDs)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerPatchingDetails", d.DbServerPatchingDetails)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "exadataInfrastructureId", d.ExadataInfrastructureID)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "maxCpuCount", d.MaxCPUCount)
	populate(objectMap, "maxDbNodeStorageInGbs", d.MaxDbNodeStorageInGbs)
	populate(objectMap, "maxMemoryInGbs", d.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "shape", d.Shape)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "vmClusterIds", d.VMClusterIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerProperties.
func (d *DbServerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autonomousVmClusterIds":
			err = unpopulate(val, "AutonomousVMClusterIDs", &d.AutonomousVMClusterIDs)
			delete(rawMsg, key)
		case "autonomousVirtualMachineIds":
			err = unpopulate(val, "AutonomousVirtualMachineIDs", &d.AutonomousVirtualMachineIDs)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &d.CompartmentID)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &d.ComputeModel)
			delete(rawMsg, key)
		case "dbNodeIds":
			err = unpopulate(val, "DbNodeIDs", &d.DbNodeIDs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerPatchingDetails":
			err = unpopulate(val, "DbServerPatchingDetails", &d.DbServerPatchingDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "exadataInfrastructureId":
			err = unpopulate(val, "ExadataInfrastructureID", &d.ExadataInfrastructureID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &d.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDbNodeStorageInGbs":
			err = unpopulate(val, "MaxDbNodeStorageInGbs", &d.MaxDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &d.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &d.Shape)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "vmClusterIds":
			err = unpopulate(val, "VMClusterIDs", &d.VMClusterIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystem.
func (d DbSystem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	populate(objectMap, "zones", d.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystem.
func (d *DbSystem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &d.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &d.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &d.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemBaseProperties.
func (d DbSystemBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterName", d.ClusterName)
	populate(objectMap, "computeCount", d.ComputeCount)
	populate(objectMap, "computeModel", d.ComputeModel)
	populate(objectMap, "dataStorageSizeInGbs", d.DataStorageSizeInGbs)
	populate(objectMap, "dbSystemOptions", d.DbSystemOptions)
	populate(objectMap, "diskRedundancy", d.DiskRedundancy)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "domain", d.DomainV2)
	populate(objectMap, "gridImageOcid", d.GridImageOcid)
	populate(objectMap, "hostname", d.Hostname)
	populate(objectMap, "initialDataStorageSizeInGb", d.InitialDataStorageSizeInGb)
	populate(objectMap, "licenseModel", d.LicenseModelV2)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "listenerPort", d.ListenerPort)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "networkAnchorId", d.NetworkAnchorID)
	populate(objectMap, "nodeCount", d.NodeCount)
	populate(objectMap, "ociUrl", d.OciURL)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "resourceAnchorId", d.ResourceAnchorID)
	populate(objectMap, "sshPublicKeys", d.SSHPublicKeys)
	populate(objectMap, "scanDnsName", d.ScanDNSName)
	populate(objectMap, "scanIps", d.ScanIPs)
	populate(objectMap, "shape", d.Shape)
	populate(objectMap, "source", d.Source)
	populate(objectMap, "storageVolumePerformanceMode", d.StorageVolumePerformanceMode)
	populate(objectMap, "timeZone", d.TimeZone)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemBaseProperties.
func (d *DbSystemBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterName":
			err = unpopulate(val, "ClusterName", &d.ClusterName)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &d.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &d.ComputeModel)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &d.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbSystemOptions":
			err = unpopulate(val, "DbSystemOptions", &d.DbSystemOptions)
			delete(rawMsg, key)
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &d.DiskRedundancy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "DomainV2", &d.DomainV2)
			delete(rawMsg, key)
		case "gridImageOcid":
			err = unpopulate(val, "GridImageOcid", &d.GridImageOcid)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &d.Hostname)
			delete(rawMsg, key)
		case "initialDataStorageSizeInGb":
			err = unpopulate(val, "InitialDataStorageSizeInGb", &d.InitialDataStorageSizeInGb)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModelV2", &d.LicenseModelV2)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &d.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "networkAnchorId":
			err = unpopulate(val, "NetworkAnchorID", &d.NetworkAnchorID)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &d.NodeCount)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &d.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "resourceAnchorId":
			err = unpopulate(val, "ResourceAnchorID", &d.ResourceAnchorID)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &d.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &d.ScanDNSName)
			delete(rawMsg, key)
		case "scanIps":
			err = unpopulate(val, "ScanIPs", &d.ScanIPs)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &d.Shape)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &d.Source)
			delete(rawMsg, key)
		case "storageVolumePerformanceMode":
			err = unpopulate(val, "StorageVolumePerformanceMode", &d.StorageVolumePerformanceMode)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &d.TimeZone)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemListResult.
func (d DbSystemListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemListResult.
func (d *DbSystemListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemOptions.
func (d DbSystemOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storageManagement", d.StorageManagement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemOptions.
func (d *DbSystemOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storageManagement":
			err = unpopulate(val, "StorageManagement", &d.StorageManagement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemProperties.
func (d DbSystemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adminPassword", d.AdminPassword)
	populate(objectMap, "clusterName", d.ClusterName)
	populate(objectMap, "computeCount", d.ComputeCount)
	populate(objectMap, "computeModel", d.ComputeModel)
	populate(objectMap, "dataStorageSizeInGbs", d.DataStorageSizeInGbs)
	populate(objectMap, "databaseEdition", d.DatabaseEdition)
	populate(objectMap, "dbSystemOptions", d.DbSystemOptions)
	populate(objectMap, "dbVersion", d.DbVersion)
	populate(objectMap, "diskRedundancy", d.DiskRedundancy)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "domain", d.DomainV2)
	populate(objectMap, "gridImageOcid", d.GridImageOcid)
	populate(objectMap, "hostname", d.Hostname)
	populate(objectMap, "initialDataStorageSizeInGb", d.InitialDataStorageSizeInGb)
	populate(objectMap, "licenseModel", d.LicenseModelV2)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "listenerPort", d.ListenerPort)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "networkAnchorId", d.NetworkAnchorID)
	populate(objectMap, "nodeCount", d.NodeCount)
	populate(objectMap, "ociUrl", d.OciURL)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "pdbName", d.PdbName)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "resourceAnchorId", d.ResourceAnchorID)
	populate(objectMap, "sshPublicKeys", d.SSHPublicKeys)
	populate(objectMap, "scanDnsName", d.ScanDNSName)
	populate(objectMap, "scanIps", d.ScanIPs)
	populate(objectMap, "shape", d.Shape)
	objectMap["source"] = DbSystemSourceTypeNone
	populate(objectMap, "storageVolumePerformanceMode", d.StorageVolumePerformanceMode)
	populate(objectMap, "timeZone", d.TimeZone)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemProperties.
func (d *DbSystemProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &d.AdminPassword)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &d.ClusterName)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &d.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &d.ComputeModel)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &d.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &d.DatabaseEdition)
			delete(rawMsg, key)
		case "dbSystemOptions":
			err = unpopulate(val, "DbSystemOptions", &d.DbSystemOptions)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &d.DbVersion)
			delete(rawMsg, key)
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &d.DiskRedundancy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "DomainV2", &d.DomainV2)
			delete(rawMsg, key)
		case "gridImageOcid":
			err = unpopulate(val, "GridImageOcid", &d.GridImageOcid)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &d.Hostname)
			delete(rawMsg, key)
		case "initialDataStorageSizeInGb":
			err = unpopulate(val, "InitialDataStorageSizeInGb", &d.InitialDataStorageSizeInGb)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModelV2", &d.LicenseModelV2)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &d.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "networkAnchorId":
			err = unpopulate(val, "NetworkAnchorID", &d.NetworkAnchorID)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &d.NodeCount)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &d.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "pdbName":
			err = unpopulate(val, "PdbName", &d.PdbName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "resourceAnchorId":
			err = unpopulate(val, "ResourceAnchorID", &d.ResourceAnchorID)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &d.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &d.ScanDNSName)
			delete(rawMsg, key)
		case "scanIps":
			err = unpopulate(val, "ScanIPs", &d.ScanIPs)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &d.Shape)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &d.Source)
			delete(rawMsg, key)
		case "storageVolumePerformanceMode":
			err = unpopulate(val, "StorageVolumePerformanceMode", &d.StorageVolumePerformanceMode)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &d.TimeZone)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShape.
func (d DbSystemShape) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShape.
func (d *DbSystemShape) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeListResult.
func (d DbSystemShapeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeListResult.
func (d *DbSystemShapeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeProperties.
func (d DbSystemShapeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "areServerTypesSupported", d.AreServerTypesSupported)
	populate(objectMap, "availableCoreCount", d.AvailableCoreCount)
	populate(objectMap, "availableCoreCountPerNode", d.AvailableCoreCountPerNode)
	populate(objectMap, "availableDataStorageInTbs", d.AvailableDataStorageInTbs)
	populate(objectMap, "availableDataStoragePerServerInTbs", d.AvailableDataStoragePerServerInTbs)
	populate(objectMap, "availableDbNodePerNodeInGbs", d.AvailableDbNodePerNodeInGbs)
	populate(objectMap, "availableDbNodeStorageInGbs", d.AvailableDbNodeStorageInGbs)
	populate(objectMap, "availableMemoryInGbs", d.AvailableMemoryInGbs)
	populate(objectMap, "availableMemoryPerNodeInGbs", d.AvailableMemoryPerNodeInGbs)
	populate(objectMap, "computeModel", d.ComputeModel)
	populate(objectMap, "coreCountIncrement", d.CoreCountIncrement)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "maxStorageCount", d.MaxStorageCount)
	populate(objectMap, "maximumNodeCount", d.MaximumNodeCount)
	populate(objectMap, "minCoreCountPerNode", d.MinCoreCountPerNode)
	populate(objectMap, "minDataStorageInTbs", d.MinDataStorageInTbs)
	populate(objectMap, "minDbNodeStoragePerNodeInGbs", d.MinDbNodeStoragePerNodeInGbs)
	populate(objectMap, "minMemoryPerNodeInGbs", d.MinMemoryPerNodeInGbs)
	populate(objectMap, "minStorageCount", d.MinStorageCount)
	populate(objectMap, "minimumCoreCount", d.MinimumCoreCount)
	populate(objectMap, "minimumNodeCount", d.MinimumNodeCount)
	populate(objectMap, "runtimeMinimumCoreCount", d.RuntimeMinimumCoreCount)
	populate(objectMap, "shapeAttributes", d.ShapeAttributes)
	populate(objectMap, "shapeFamily", d.ShapeFamily)
	populate(objectMap, "shapeName", d.ShapeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeProperties.
func (d *DbSystemShapeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "areServerTypesSupported":
			err = unpopulate(val, "AreServerTypesSupported", &d.AreServerTypesSupported)
			delete(rawMsg, key)
		case "availableCoreCount":
			err = unpopulate(val, "AvailableCoreCount", &d.AvailableCoreCount)
			delete(rawMsg, key)
		case "availableCoreCountPerNode":
			err = unpopulate(val, "AvailableCoreCountPerNode", &d.AvailableCoreCountPerNode)
			delete(rawMsg, key)
		case "availableDataStorageInTbs":
			err = unpopulate(val, "AvailableDataStorageInTbs", &d.AvailableDataStorageInTbs)
			delete(rawMsg, key)
		case "availableDataStoragePerServerInTbs":
			err = unpopulate(val, "AvailableDataStoragePerServerInTbs", &d.AvailableDataStoragePerServerInTbs)
			delete(rawMsg, key)
		case "availableDbNodePerNodeInGbs":
			err = unpopulate(val, "AvailableDbNodePerNodeInGbs", &d.AvailableDbNodePerNodeInGbs)
			delete(rawMsg, key)
		case "availableDbNodeStorageInGbs":
			err = unpopulate(val, "AvailableDbNodeStorageInGbs", &d.AvailableDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "availableMemoryInGbs":
			err = unpopulate(val, "AvailableMemoryInGbs", &d.AvailableMemoryInGbs)
			delete(rawMsg, key)
		case "availableMemoryPerNodeInGbs":
			err = unpopulate(val, "AvailableMemoryPerNodeInGbs", &d.AvailableMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &d.ComputeModel)
			delete(rawMsg, key)
		case "coreCountIncrement":
			err = unpopulate(val, "CoreCountIncrement", &d.CoreCountIncrement)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "maxStorageCount":
			err = unpopulate(val, "MaxStorageCount", &d.MaxStorageCount)
			delete(rawMsg, key)
		case "maximumNodeCount":
			err = unpopulate(val, "MaximumNodeCount", &d.MaximumNodeCount)
			delete(rawMsg, key)
		case "minCoreCountPerNode":
			err = unpopulate(val, "MinCoreCountPerNode", &d.MinCoreCountPerNode)
			delete(rawMsg, key)
		case "minDataStorageInTbs":
			err = unpopulate(val, "MinDataStorageInTbs", &d.MinDataStorageInTbs)
			delete(rawMsg, key)
		case "minDbNodeStoragePerNodeInGbs":
			err = unpopulate(val, "MinDbNodeStoragePerNodeInGbs", &d.MinDbNodeStoragePerNodeInGbs)
			delete(rawMsg, key)
		case "minMemoryPerNodeInGbs":
			err = unpopulate(val, "MinMemoryPerNodeInGbs", &d.MinMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "minStorageCount":
			err = unpopulate(val, "MinStorageCount", &d.MinStorageCount)
			delete(rawMsg, key)
		case "minimumCoreCount":
			err = unpopulate(val, "MinimumCoreCount", &d.MinimumCoreCount)
			delete(rawMsg, key)
		case "minimumNodeCount":
			err = unpopulate(val, "MinimumNodeCount", &d.MinimumNodeCount)
			delete(rawMsg, key)
		case "runtimeMinimumCoreCount":
			err = unpopulate(val, "RuntimeMinimumCoreCount", &d.RuntimeMinimumCoreCount)
			delete(rawMsg, key)
		case "shapeAttributes":
			err = unpopulate(val, "ShapeAttributes", &d.ShapeAttributes)
			delete(rawMsg, key)
		case "shapeFamily":
			err = unpopulate(val, "ShapeFamily", &d.ShapeFamily)
			delete(rawMsg, key)
		case "shapeName":
			err = unpopulate(val, "ShapeName", &d.ShapeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemUpdate.
func (d DbSystemUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "zones", d.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemUpdate.
func (d *DbSystemUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &d.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &d.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemUpdateProperties.
func (d DbSystemUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	if d.Source != nil {
		objectMap["source"] = DbSystemSourceTypeNone
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemUpdateProperties.
func (d *DbSystemUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &d.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbVersion.
func (d DbVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbVersion.
func (d *DbVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbVersionListResult.
func (d DbVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbVersionListResult.
func (d *DbVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbVersionProperties.
func (d DbVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isLatestForMajorVersion", d.IsLatestForMajorVersion)
	populate(objectMap, "isPreviewDbVersion", d.IsPreviewDbVersion)
	populate(objectMap, "isUpgradeSupported", d.IsUpgradeSupported)
	populate(objectMap, "supportsPdb", d.SupportsPdb)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbVersionProperties.
func (d *DbVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isLatestForMajorVersion":
			err = unpopulate(val, "IsLatestForMajorVersion", &d.IsLatestForMajorVersion)
			delete(rawMsg, key)
		case "isPreviewDbVersion":
			err = unpopulate(val, "IsPreviewDbVersion", &d.IsPreviewDbVersion)
			delete(rawMsg, key)
		case "isUpgradeSupported":
			err = unpopulate(val, "IsUpgradeSupported", &d.IsUpgradeSupported)
			delete(rawMsg, key)
		case "supportsPdb":
			err = unpopulate(val, "SupportsPdb", &d.SupportsPdb)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefinedFileSystemConfiguration.
func (d DefinedFileSystemConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isBackupPartition", d.IsBackupPartition)
	populate(objectMap, "isResizable", d.IsResizable)
	populate(objectMap, "minSizeGb", d.MinSizeGb)
	populate(objectMap, "mountPoint", d.MountPoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefinedFileSystemConfiguration.
func (d *DefinedFileSystemConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isBackupPartition":
			err = unpopulate(val, "IsBackupPartition", &d.IsBackupPartition)
			delete(rawMsg, key)
		case "isResizable":
			err = unpopulate(val, "IsResizable", &d.IsResizable)
			delete(rawMsg, key)
		case "minSizeGb":
			err = unpopulate(val, "MinSizeGb", &d.MinSizeGb)
			delete(rawMsg, key)
		case "mountPoint":
			err = unpopulate(val, "MountPoint", &d.MountPoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DisasterRecoveryConfigurationDetails.
func (d DisasterRecoveryConfigurationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disasterRecoveryType", d.DisasterRecoveryType)
	populate(objectMap, "isReplicateAutomaticBackups", d.IsReplicateAutomaticBackups)
	populate(objectMap, "isSnapshotStandby", d.IsSnapshotStandby)
	populateTime[datetime.RFC3339](objectMap, "timeSnapshotStandbyEnabledTill", d.TimeSnapshotStandbyEnabledTill)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DisasterRecoveryConfigurationDetails.
func (d *DisasterRecoveryConfigurationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disasterRecoveryType":
			err = unpopulate(val, "DisasterRecoveryType", &d.DisasterRecoveryType)
			delete(rawMsg, key)
		case "isReplicateAutomaticBackups":
			err = unpopulate(val, "IsReplicateAutomaticBackups", &d.IsReplicateAutomaticBackups)
			delete(rawMsg, key)
		case "isSnapshotStandby":
			err = unpopulate(val, "IsSnapshotStandby", &d.IsSnapshotStandby)
			delete(rawMsg, key)
		case "timeSnapshotStandbyEnabledTill":
			err = unpopulateTime[datetime.RFC3339](val, "TimeSnapshotStandbyEnabledTill", &d.TimeSnapshotStandbyEnabledTill)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedPatchingTime.
func (e EstimatedPatchingTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedDbServerPatchingTime", e.EstimatedDbServerPatchingTime)
	populate(objectMap, "estimatedNetworkSwitchesPatchingTime", e.EstimatedNetworkSwitchesPatchingTime)
	populate(objectMap, "estimatedStorageServerPatchingTime", e.EstimatedStorageServerPatchingTime)
	populate(objectMap, "totalEstimatedPatchingTime", e.TotalEstimatedPatchingTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedPatchingTime.
func (e *EstimatedPatchingTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedDbServerPatchingTime":
			err = unpopulate(val, "EstimatedDbServerPatchingTime", &e.EstimatedDbServerPatchingTime)
			delete(rawMsg, key)
		case "estimatedNetworkSwitchesPatchingTime":
			err = unpopulate(val, "EstimatedNetworkSwitchesPatchingTime", &e.EstimatedNetworkSwitchesPatchingTime)
			delete(rawMsg, key)
		case "estimatedStorageServerPatchingTime":
			err = unpopulate(val, "EstimatedStorageServerPatchingTime", &e.EstimatedStorageServerPatchingTime)
			delete(rawMsg, key)
		case "totalEstimatedPatchingTime":
			err = unpopulate(val, "TotalEstimatedPatchingTime", &e.TotalEstimatedPatchingTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadataIormConfig.
func (e ExadataIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbPlans", e.DbPlans)
	populate(objectMap, "lifecycleDetails", e.LifecycleDetails)
	populate(objectMap, "lifecycleState", e.LifecycleState)
	populate(objectMap, "objective", e.Objective)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadataIormConfig.
func (e *ExadataIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbPlans":
			err = unpopulate(val, "DbPlans", &e.DbPlans)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &e.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &e.LifecycleState)
			delete(rawMsg, key)
		case "objective":
			err = unpopulate(val, "Objective", &e.Objective)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMCluster.
func (e ExadbVMCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	populate(objectMap, "zones", e.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMCluster.
func (e *ExadbVMCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &e.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMClusterListResult.
func (e ExadbVMClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMClusterListResult.
func (e *ExadbVMClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMClusterProperties.
func (e ExadbVMClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupSubnetCidr", e.BackupSubnetCidr)
	populate(objectMap, "backupSubnetOcid", e.BackupSubnetOcid)
	populate(objectMap, "clusterName", e.ClusterName)
	populate(objectMap, "dataCollectionOptions", e.DataCollectionOptions)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "domain", e.Domain)
	populate(objectMap, "enabledEcpuCount", e.EnabledEcpuCount)
	populate(objectMap, "exascaleDbStorageVaultId", e.ExascaleDbStorageVaultID)
	populate(objectMap, "giVersion", e.GiVersion)
	populate(objectMap, "gridImageOcid", e.GridImageOcid)
	populate(objectMap, "gridImageType", e.GridImageType)
	populate(objectMap, "hostname", e.Hostname)
	populate(objectMap, "iormConfigCache", e.IormConfigCache)
	populate(objectMap, "licenseModel", e.LicenseModel)
	populate(objectMap, "lifecycleDetails", e.LifecycleDetails)
	populate(objectMap, "lifecycleState", e.LifecycleState)
	populate(objectMap, "listenerPort", e.ListenerPort)
	populate(objectMap, "memorySizeInGbs", e.MemorySizeInGbs)
	populate(objectMap, "nodeCount", e.NodeCount)
	populate(objectMap, "nsgCidrs", e.NsgCidrs)
	populate(objectMap, "nsgUrl", e.NsgURL)
	populate(objectMap, "ociUrl", e.OciURL)
	populate(objectMap, "ocid", e.Ocid)
	populate(objectMap, "privateZoneOcid", e.PrivateZoneOcid)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "sshPublicKeys", e.SSHPublicKeys)
	populate(objectMap, "scanDnsName", e.ScanDNSName)
	populate(objectMap, "scanDnsRecordId", e.ScanDNSRecordID)
	populate(objectMap, "scanIpIds", e.ScanIPIDs)
	populate(objectMap, "scanListenerPortTcp", e.ScanListenerPortTCP)
	populate(objectMap, "scanListenerPortTcpSsl", e.ScanListenerPortTCPSSL)
	populate(objectMap, "shape", e.Shape)
	populate(objectMap, "shapeAttribute", e.ShapeAttribute)
	populate(objectMap, "snapshotFileSystemStorage", e.SnapshotFileSystemStorage)
	populate(objectMap, "subnetId", e.SubnetID)
	populate(objectMap, "subnetOcid", e.SubnetOcid)
	populate(objectMap, "systemVersion", e.SystemVersion)
	populate(objectMap, "timeZone", e.TimeZone)
	populate(objectMap, "totalEcpuCount", e.TotalEcpuCount)
	populate(objectMap, "totalFileSystemStorage", e.TotalFileSystemStorage)
	populate(objectMap, "vmFileSystemStorage", e.VMFileSystemStorage)
	populate(objectMap, "vipIds", e.VipIDs)
	populate(objectMap, "vnetId", e.VnetID)
	populate(objectMap, "zoneOcid", e.ZoneOcid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMClusterProperties.
func (e *ExadbVMClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupSubnetCidr":
			err = unpopulate(val, "BackupSubnetCidr", &e.BackupSubnetCidr)
			delete(rawMsg, key)
		case "backupSubnetOcid":
			err = unpopulate(val, "BackupSubnetOcid", &e.BackupSubnetOcid)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &e.ClusterName)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &e.DataCollectionOptions)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &e.Domain)
			delete(rawMsg, key)
		case "enabledEcpuCount":
			err = unpopulate(val, "EnabledEcpuCount", &e.EnabledEcpuCount)
			delete(rawMsg, key)
		case "exascaleDbStorageVaultId":
			err = unpopulate(val, "ExascaleDbStorageVaultID", &e.ExascaleDbStorageVaultID)
			delete(rawMsg, key)
		case "giVersion":
			err = unpopulate(val, "GiVersion", &e.GiVersion)
			delete(rawMsg, key)
		case "gridImageOcid":
			err = unpopulate(val, "GridImageOcid", &e.GridImageOcid)
			delete(rawMsg, key)
		case "gridImageType":
			err = unpopulate(val, "GridImageType", &e.GridImageType)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &e.Hostname)
			delete(rawMsg, key)
		case "iormConfigCache":
			err = unpopulate(val, "IormConfigCache", &e.IormConfigCache)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &e.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &e.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &e.LifecycleState)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &e.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &e.MemorySizeInGbs)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &e.NodeCount)
			delete(rawMsg, key)
		case "nsgCidrs":
			err = unpopulate(val, "NsgCidrs", &e.NsgCidrs)
			delete(rawMsg, key)
		case "nsgUrl":
			err = unpopulate(val, "NsgURL", &e.NsgURL)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &e.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &e.Ocid)
			delete(rawMsg, key)
		case "privateZoneOcid":
			err = unpopulate(val, "PrivateZoneOcid", &e.PrivateZoneOcid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &e.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &e.ScanDNSName)
			delete(rawMsg, key)
		case "scanDnsRecordId":
			err = unpopulate(val, "ScanDNSRecordID", &e.ScanDNSRecordID)
			delete(rawMsg, key)
		case "scanIpIds":
			err = unpopulate(val, "ScanIPIDs", &e.ScanIPIDs)
			delete(rawMsg, key)
		case "scanListenerPortTcp":
			err = unpopulate(val, "ScanListenerPortTCP", &e.ScanListenerPortTCP)
			delete(rawMsg, key)
		case "scanListenerPortTcpSsl":
			err = unpopulate(val, "ScanListenerPortTCPSSL", &e.ScanListenerPortTCPSSL)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &e.Shape)
			delete(rawMsg, key)
		case "shapeAttribute":
			err = unpopulate(val, "ShapeAttribute", &e.ShapeAttribute)
			delete(rawMsg, key)
		case "snapshotFileSystemStorage":
			err = unpopulate(val, "SnapshotFileSystemStorage", &e.SnapshotFileSystemStorage)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &e.SubnetID)
			delete(rawMsg, key)
		case "subnetOcid":
			err = unpopulate(val, "SubnetOcid", &e.SubnetOcid)
			delete(rawMsg, key)
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &e.SystemVersion)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &e.TimeZone)
			delete(rawMsg, key)
		case "totalEcpuCount":
			err = unpopulate(val, "TotalEcpuCount", &e.TotalEcpuCount)
			delete(rawMsg, key)
		case "totalFileSystemStorage":
			err = unpopulate(val, "TotalFileSystemStorage", &e.TotalFileSystemStorage)
			delete(rawMsg, key)
		case "vmFileSystemStorage":
			err = unpopulate(val, "VMFileSystemStorage", &e.VMFileSystemStorage)
			delete(rawMsg, key)
		case "vipIds":
			err = unpopulate(val, "VipIDs", &e.VipIDs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &e.VnetID)
			delete(rawMsg, key)
		case "zoneOcid":
			err = unpopulate(val, "ZoneOcid", &e.ZoneOcid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMClusterStorageDetails.
func (e ExadbVMClusterStorageDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "totalSizeInGbs", e.TotalSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMClusterStorageDetails.
func (e *ExadbVMClusterStorageDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "totalSizeInGbs":
			err = unpopulate(val, "TotalSizeInGbs", &e.TotalSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMClusterUpdate.
func (e ExadbVMClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "zones", e.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMClusterUpdate.
func (e *ExadbVMClusterUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &e.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadbVMClusterUpdateProperties.
func (e ExadbVMClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeCount", e.NodeCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadbVMClusterUpdateProperties.
func (e *ExadbVMClusterUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &e.NodeCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleConfigDetails.
func (e ExascaleConfigDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableStorageInGbs", e.AvailableStorageInGbs)
	populate(objectMap, "totalStorageInGbs", e.TotalStorageInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleConfigDetails.
func (e *ExascaleConfigDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableStorageInGbs":
			err = unpopulate(val, "AvailableStorageInGbs", &e.AvailableStorageInGbs)
			delete(rawMsg, key)
		case "totalStorageInGbs":
			err = unpopulate(val, "TotalStorageInGbs", &e.TotalStorageInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbNode.
func (e ExascaleDbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbNode.
func (e *ExascaleDbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbNodeListResult.
func (e ExascaleDbNodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbNodeListResult.
func (e *ExascaleDbNodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbNodeProperties.
func (e ExascaleDbNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDetails", e.AdditionalDetails)
	populate(objectMap, "cpuCoreCount", e.CPUCoreCount)
	populate(objectMap, "dbNodeStorageSizeInGbs", e.DbNodeStorageSizeInGbs)
	populate(objectMap, "faultDomain", e.FaultDomain)
	populate(objectMap, "hostname", e.Hostname)
	populate(objectMap, "lifecycleState", e.LifecycleState)
	populate(objectMap, "maintenanceType", e.MaintenanceType)
	populate(objectMap, "memorySizeInGbs", e.MemorySizeInGbs)
	populate(objectMap, "ocid", e.Ocid)
	populate(objectMap, "softwareStorageSizeInGb", e.SoftwareStorageSizeInGb)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceWindowEnd", e.TimeMaintenanceWindowEnd)
	populateTime[datetime.RFC3339](objectMap, "timeMaintenanceWindowStart", e.TimeMaintenanceWindowStart)
	populate(objectMap, "totalCpuCoreCount", e.TotalCPUCoreCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbNodeProperties.
func (e *ExascaleDbNodeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDetails":
			err = unpopulate(val, "AdditionalDetails", &e.AdditionalDetails)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &e.CPUCoreCount)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &e.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "faultDomain":
			err = unpopulate(val, "FaultDomain", &e.FaultDomain)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &e.Hostname)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &e.LifecycleState)
			delete(rawMsg, key)
		case "maintenanceType":
			err = unpopulate(val, "MaintenanceType", &e.MaintenanceType)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &e.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &e.Ocid)
			delete(rawMsg, key)
		case "softwareStorageSizeInGb":
			err = unpopulate(val, "SoftwareStorageSizeInGb", &e.SoftwareStorageSizeInGb)
			delete(rawMsg, key)
		case "timeMaintenanceWindowEnd":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceWindowEnd", &e.TimeMaintenanceWindowEnd)
			delete(rawMsg, key)
		case "timeMaintenanceWindowStart":
			err = unpopulateTime[datetime.RFC3339](val, "TimeMaintenanceWindowStart", &e.TimeMaintenanceWindowStart)
			delete(rawMsg, key)
		case "totalCpuCoreCount":
			err = unpopulate(val, "TotalCPUCoreCount", &e.TotalCPUCoreCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageDetails.
func (e ExascaleDbStorageDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableSizeInGbs", e.AvailableSizeInGbs)
	populate(objectMap, "totalSizeInGbs", e.TotalSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageDetails.
func (e *ExascaleDbStorageDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableSizeInGbs":
			err = unpopulate(val, "AvailableSizeInGbs", &e.AvailableSizeInGbs)
			delete(rawMsg, key)
		case "totalSizeInGbs":
			err = unpopulate(val, "TotalSizeInGbs", &e.TotalSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageInputDetails.
func (e ExascaleDbStorageInputDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "totalSizeInGbs", e.TotalSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageInputDetails.
func (e *ExascaleDbStorageInputDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "totalSizeInGbs":
			err = unpopulate(val, "TotalSizeInGbs", &e.TotalSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageVault.
func (e ExascaleDbStorageVault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	populate(objectMap, "zones", e.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageVault.
func (e *ExascaleDbStorageVault) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &e.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageVaultListResult.
func (e ExascaleDbStorageVaultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageVaultListResult.
func (e *ExascaleDbStorageVaultListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageVaultProperties.
func (e ExascaleDbStorageVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalFlashCacheInPercent", e.AdditionalFlashCacheInPercent)
	populate(objectMap, "attachedShapeAttributes", e.AttachedShapeAttributes)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "exadataInfrastructureId", e.ExadataInfrastructureID)
	populate(objectMap, "highCapacityDatabaseStorage", e.HighCapacityDatabaseStorage)
	populate(objectMap, "highCapacityDatabaseStorageInput", e.HighCapacityDatabaseStorageInput)
	populate(objectMap, "lifecycleDetails", e.LifecycleDetails)
	populate(objectMap, "lifecycleState", e.LifecycleState)
	populate(objectMap, "ociUrl", e.OciURL)
	populate(objectMap, "ocid", e.Ocid)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "timeZone", e.TimeZone)
	populate(objectMap, "vmClusterCount", e.VMClusterCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageVaultProperties.
func (e *ExascaleDbStorageVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalFlashCacheInPercent":
			err = unpopulate(val, "AdditionalFlashCacheInPercent", &e.AdditionalFlashCacheInPercent)
			delete(rawMsg, key)
		case "attachedShapeAttributes":
			err = unpopulate(val, "AttachedShapeAttributes", &e.AttachedShapeAttributes)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "exadataInfrastructureId":
			err = unpopulate(val, "ExadataInfrastructureID", &e.ExadataInfrastructureID)
			delete(rawMsg, key)
		case "highCapacityDatabaseStorage":
			err = unpopulate(val, "HighCapacityDatabaseStorage", &e.HighCapacityDatabaseStorage)
			delete(rawMsg, key)
		case "highCapacityDatabaseStorageInput":
			err = unpopulate(val, "HighCapacityDatabaseStorageInput", &e.HighCapacityDatabaseStorageInput)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &e.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &e.LifecycleState)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &e.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &e.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &e.TimeZone)
			delete(rawMsg, key)
		case "vmClusterCount":
			err = unpopulate(val, "VMClusterCount", &e.VMClusterCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExascaleDbStorageVaultTagsUpdate.
func (e ExascaleDbStorageVaultTagsUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExascaleDbStorageVaultTagsUpdate.
func (e *ExascaleDbStorageVaultTagsUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemConfigurationDetails.
func (f FileSystemConfigurationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fileSystemSizeGb", f.FileSystemSizeGb)
	populate(objectMap, "mountPoint", f.MountPoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemConfigurationDetails.
func (f *FileSystemConfigurationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileSystemSizeGb":
			err = unpopulate(val, "FileSystemSizeGb", &f.FileSystemSizeGb)
			delete(rawMsg, key)
		case "mountPoint":
			err = unpopulate(val, "MountPoint", &f.MountPoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlexComponent.
func (f FlexComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlexComponent.
func (f *FlexComponent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlexComponentListResult.
func (f FlexComponentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlexComponentListResult.
func (f *FlexComponentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FlexComponentProperties.
func (f FlexComponentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableCoreCount", f.AvailableCoreCount)
	populate(objectMap, "availableDbStorageInGbs", f.AvailableDbStorageInGbs)
	populate(objectMap, "availableLocalStorageInGbs", f.AvailableLocalStorageInGbs)
	populate(objectMap, "availableMemoryInGbs", f.AvailableMemoryInGbs)
	populate(objectMap, "computeModel", f.ComputeModel)
	populate(objectMap, "descriptionSummary", f.DescriptionSummary)
	populate(objectMap, "hardwareType", f.HardwareType)
	populate(objectMap, "minimumCoreCount", f.MinimumCoreCount)
	populate(objectMap, "runtimeMinimumCoreCount", f.RuntimeMinimumCoreCount)
	populate(objectMap, "shape", f.Shape)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FlexComponentProperties.
func (f *FlexComponentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableCoreCount":
			err = unpopulate(val, "AvailableCoreCount", &f.AvailableCoreCount)
			delete(rawMsg, key)
		case "availableDbStorageInGbs":
			err = unpopulate(val, "AvailableDbStorageInGbs", &f.AvailableDbStorageInGbs)
			delete(rawMsg, key)
		case "availableLocalStorageInGbs":
			err = unpopulate(val, "AvailableLocalStorageInGbs", &f.AvailableLocalStorageInGbs)
			delete(rawMsg, key)
		case "availableMemoryInGbs":
			err = unpopulate(val, "AvailableMemoryInGbs", &f.AvailableMemoryInGbs)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &f.ComputeModel)
			delete(rawMsg, key)
		case "descriptionSummary":
			err = unpopulate(val, "DescriptionSummary", &f.DescriptionSummary)
			delete(rawMsg, key)
		case "hardwareType":
			err = unpopulate(val, "HardwareType", &f.HardwareType)
			delete(rawMsg, key)
		case "minimumCoreCount":
			err = unpopulate(val, "MinimumCoreCount", &f.MinimumCoreCount)
			delete(rawMsg, key)
		case "runtimeMinimumCoreCount":
			err = unpopulate(val, "RuntimeMinimumCoreCount", &f.RuntimeMinimumCoreCount)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &f.Shape)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateAutonomousDatabaseWalletDetails.
func (g GenerateAutonomousDatabaseWalletDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generateType", g.GenerateType)
	populate(objectMap, "isRegional", g.IsRegional)
	populate(objectMap, "password", g.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateAutonomousDatabaseWalletDetails.
func (g *GenerateAutonomousDatabaseWalletDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generateType":
			err = unpopulate(val, "GenerateType", &g.GenerateType)
			delete(rawMsg, key)
		case "isRegional":
			err = unpopulate(val, "IsRegional", &g.IsRegional)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &g.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiMinorVersion.
func (g GiMinorVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiMinorVersion.
func (g *GiMinorVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiMinorVersionListResult.
func (g GiMinorVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiMinorVersionListResult.
func (g *GiMinorVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiMinorVersionProperties.
func (g GiMinorVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gridImageOcid", g.GridImageOcid)
	populate(objectMap, "version", g.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiMinorVersionProperties.
func (g *GiMinorVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gridImageOcid":
			err = unpopulate(val, "GridImageOcid", &g.GridImageOcid)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &g.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersion.
func (g GiVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersion.
func (g *GiVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionListResult.
func (g GiVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionListResult.
func (g *GiVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionProperties.
func (g GiVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "version", g.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionProperties.
func (g *GiVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "version":
			err = unpopulate(val, "Version", &g.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongTermBackUpScheduleDetails.
func (l LongTermBackUpScheduleDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDisabled", l.IsDisabled)
	populate(objectMap, "repeatCadence", l.RepeatCadence)
	populate(objectMap, "retentionPeriodInDays", l.RetentionPeriodInDays)
	populateTime[datetime.RFC3339](objectMap, "timeOfBackup", l.TimeOfBackup)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongTermBackUpScheduleDetails.
func (l *LongTermBackUpScheduleDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDisabled":
			err = unpopulate(val, "IsDisabled", &l.IsDisabled)
			delete(rawMsg, key)
		case "repeatCadence":
			err = unpopulate(val, "RepeatCadence", &l.RepeatCadence)
			delete(rawMsg, key)
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &l.RetentionPeriodInDays)
			delete(rawMsg, key)
		case "timeOfBackup":
			err = unpopulateTime[datetime.RFC3339](val, "TimeOfBackup", &l.TimeOfBackup)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindow.
func (m MaintenanceWindow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customActionTimeoutInMins", m.CustomActionTimeoutInMins)
	populate(objectMap, "daysOfWeek", m.DaysOfWeek)
	populate(objectMap, "hoursOfDay", m.HoursOfDay)
	populate(objectMap, "isCustomActionTimeoutEnabled", m.IsCustomActionTimeoutEnabled)
	populate(objectMap, "isMonthlyPatchingEnabled", m.IsMonthlyPatchingEnabled)
	populate(objectMap, "leadTimeInWeeks", m.LeadTimeInWeeks)
	populate(objectMap, "months", m.Months)
	populate(objectMap, "patchingMode", m.PatchingMode)
	populate(objectMap, "preference", m.Preference)
	populate(objectMap, "weeksOfMonth", m.WeeksOfMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceWindow.
func (m *MaintenanceWindow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customActionTimeoutInMins":
			err = unpopulate(val, "CustomActionTimeoutInMins", &m.CustomActionTimeoutInMins)
			delete(rawMsg, key)
		case "daysOfWeek":
			err = unpopulate(val, "DaysOfWeek", &m.DaysOfWeek)
			delete(rawMsg, key)
		case "hoursOfDay":
			err = unpopulate(val, "HoursOfDay", &m.HoursOfDay)
			delete(rawMsg, key)
		case "isCustomActionTimeoutEnabled":
			err = unpopulate(val, "IsCustomActionTimeoutEnabled", &m.IsCustomActionTimeoutEnabled)
			delete(rawMsg, key)
		case "isMonthlyPatchingEnabled":
			err = unpopulate(val, "IsMonthlyPatchingEnabled", &m.IsMonthlyPatchingEnabled)
			delete(rawMsg, key)
		case "leadTimeInWeeks":
			err = unpopulate(val, "LeadTimeInWeeks", &m.LeadTimeInWeeks)
			delete(rawMsg, key)
		case "months":
			err = unpopulate(val, "Months", &m.Months)
			delete(rawMsg, key)
		case "patchingMode":
			err = unpopulate(val, "PatchingMode", &m.PatchingMode)
			delete(rawMsg, key)
		case "preference":
			err = unpopulate(val, "Preference", &m.Preference)
			delete(rawMsg, key)
		case "weeksOfMonth":
			err = unpopulate(val, "WeeksOfMonth", &m.WeeksOfMonth)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Month.
func (m Month) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Month.
func (m *Month) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAnchor.
func (n NetworkAnchor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "location", n.Location)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	populate(objectMap, "zones", n.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAnchor.
func (n *NetworkAnchor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &n.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &n.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAnchorListResult.
func (n NetworkAnchorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAnchorListResult.
func (n *NetworkAnchorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAnchorProperties.
func (n NetworkAnchorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cidrBlock", n.CidrBlock)
	populate(objectMap, "dnsForwardingEndpointIpAddress", n.DNSForwardingEndpointIPAddress)
	populate(objectMap, "dnsForwardingEndpointNsgRulesUrl", n.DNSForwardingEndpointNsgRulesURL)
	populate(objectMap, "dnsForwardingRules", n.DNSForwardingRules)
	populate(objectMap, "dnsForwardingRulesUrl", n.DNSForwardingRulesURL)
	populate(objectMap, "dnsListeningEndpointAllowedCidrs", n.DNSListeningEndpointAllowedCidrs)
	populate(objectMap, "dnsListeningEndpointIpAddress", n.DNSListeningEndpointIPAddress)
	populate(objectMap, "dnsListeningEndpointNsgRulesUrl", n.DNSListeningEndpointNsgRulesURL)
	populate(objectMap, "isOracleDnsForwardingEndpointEnabled", n.IsOracleDNSForwardingEndpointEnabled)
	populate(objectMap, "isOracleDnsListeningEndpointEnabled", n.IsOracleDNSListeningEndpointEnabled)
	populate(objectMap, "isOracleToAzureDnsZoneSyncEnabled", n.IsOracleToAzureDNSZoneSyncEnabled)
	populate(objectMap, "ociBackupCidrBlock", n.OciBackupCidrBlock)
	populate(objectMap, "ociSubnetId", n.OciSubnetID)
	populate(objectMap, "ociVcnDnsLabel", n.OciVcnDNSLabel)
	populate(objectMap, "ociVcnId", n.OciVcnID)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "resourceAnchorId", n.ResourceAnchorID)
	populate(objectMap, "subnetId", n.SubnetID)
	populate(objectMap, "vnetId", n.VnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAnchorProperties.
func (n *NetworkAnchorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cidrBlock":
			err = unpopulate(val, "CidrBlock", &n.CidrBlock)
			delete(rawMsg, key)
		case "dnsForwardingEndpointIpAddress":
			err = unpopulate(val, "DNSForwardingEndpointIPAddress", &n.DNSForwardingEndpointIPAddress)
			delete(rawMsg, key)
		case "dnsForwardingEndpointNsgRulesUrl":
			err = unpopulate(val, "DNSForwardingEndpointNsgRulesURL", &n.DNSForwardingEndpointNsgRulesURL)
			delete(rawMsg, key)
		case "dnsForwardingRules":
			err = unpopulate(val, "DNSForwardingRules", &n.DNSForwardingRules)
			delete(rawMsg, key)
		case "dnsForwardingRulesUrl":
			err = unpopulate(val, "DNSForwardingRulesURL", &n.DNSForwardingRulesURL)
			delete(rawMsg, key)
		case "dnsListeningEndpointAllowedCidrs":
			err = unpopulate(val, "DNSListeningEndpointAllowedCidrs", &n.DNSListeningEndpointAllowedCidrs)
			delete(rawMsg, key)
		case "dnsListeningEndpointIpAddress":
			err = unpopulate(val, "DNSListeningEndpointIPAddress", &n.DNSListeningEndpointIPAddress)
			delete(rawMsg, key)
		case "dnsListeningEndpointNsgRulesUrl":
			err = unpopulate(val, "DNSListeningEndpointNsgRulesURL", &n.DNSListeningEndpointNsgRulesURL)
			delete(rawMsg, key)
		case "isOracleDnsForwardingEndpointEnabled":
			err = unpopulate(val, "IsOracleDNSForwardingEndpointEnabled", &n.IsOracleDNSForwardingEndpointEnabled)
			delete(rawMsg, key)
		case "isOracleDnsListeningEndpointEnabled":
			err = unpopulate(val, "IsOracleDNSListeningEndpointEnabled", &n.IsOracleDNSListeningEndpointEnabled)
			delete(rawMsg, key)
		case "isOracleToAzureDnsZoneSyncEnabled":
			err = unpopulate(val, "IsOracleToAzureDNSZoneSyncEnabled", &n.IsOracleToAzureDNSZoneSyncEnabled)
			delete(rawMsg, key)
		case "ociBackupCidrBlock":
			err = unpopulate(val, "OciBackupCidrBlock", &n.OciBackupCidrBlock)
			delete(rawMsg, key)
		case "ociSubnetId":
			err = unpopulate(val, "OciSubnetID", &n.OciSubnetID)
			delete(rawMsg, key)
		case "ociVcnDnsLabel":
			err = unpopulate(val, "OciVcnDNSLabel", &n.OciVcnDNSLabel)
			delete(rawMsg, key)
		case "ociVcnId":
			err = unpopulate(val, "OciVcnID", &n.OciVcnID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "resourceAnchorId":
			err = unpopulate(val, "ResourceAnchorID", &n.ResourceAnchorID)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &n.SubnetID)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &n.VnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAnchorUpdate.
func (n NetworkAnchorUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "zones", n.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAnchorUpdate.
func (n *NetworkAnchorUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &n.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAnchorUpdateProperties.
func (n NetworkAnchorUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isOracleDnsForwardingEndpointEnabled", n.IsOracleDNSForwardingEndpointEnabled)
	populate(objectMap, "isOracleDnsListeningEndpointEnabled", n.IsOracleDNSListeningEndpointEnabled)
	populate(objectMap, "isOracleToAzureDnsZoneSyncEnabled", n.IsOracleToAzureDNSZoneSyncEnabled)
	populate(objectMap, "ociBackupCidrBlock", n.OciBackupCidrBlock)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkAnchorUpdateProperties.
func (n *NetworkAnchorUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isOracleDnsForwardingEndpointEnabled":
			err = unpopulate(val, "IsOracleDNSForwardingEndpointEnabled", &n.IsOracleDNSForwardingEndpointEnabled)
			delete(rawMsg, key)
		case "isOracleDnsListeningEndpointEnabled":
			err = unpopulate(val, "IsOracleDNSListeningEndpointEnabled", &n.IsOracleDNSListeningEndpointEnabled)
			delete(rawMsg, key)
		case "isOracleToAzureDnsZoneSyncEnabled":
			err = unpopulate(val, "IsOracleToAzureDNSZoneSyncEnabled", &n.IsOracleToAzureDNSZoneSyncEnabled)
			delete(rawMsg, key)
		case "ociBackupCidrBlock":
			err = unpopulate(val, "OciBackupCidrBlock", &n.OciBackupCidrBlock)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NsgCidr.
func (n NsgCidr) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destinationPortRange", n.DestinationPortRange)
	populate(objectMap, "source", n.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NsgCidr.
func (n *NsgCidr) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destinationPortRange":
			err = unpopulate(val, "DestinationPortRange", &n.DestinationPortRange)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &n.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscription.
func (o OracleSubscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscription.
func (o *OracleSubscription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionListResult.
func (o OracleSubscriptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionListResult.
func (o *OracleSubscriptionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionProperties.
func (o OracleSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addSubscriptionOperationState", o.AddSubscriptionOperationState)
	populate(objectMap, "azureSubscriptionIds", o.AzureSubscriptionIDs)
	populate(objectMap, "cloudAccountId", o.CloudAccountID)
	populate(objectMap, "cloudAccountState", o.CloudAccountState)
	populate(objectMap, "intent", o.Intent)
	populate(objectMap, "lastOperationStatusDetail", o.LastOperationStatusDetail)
	populate(objectMap, "productCode", o.ProductCode)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "saasSubscriptionId", o.SaasSubscriptionID)
	populate(objectMap, "termUnit", o.TermUnit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionProperties.
func (o *OracleSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addSubscriptionOperationState":
			err = unpopulate(val, "AddSubscriptionOperationState", &o.AddSubscriptionOperationState)
			delete(rawMsg, key)
		case "azureSubscriptionIds":
			err = unpopulate(val, "AzureSubscriptionIDs", &o.AzureSubscriptionIDs)
			delete(rawMsg, key)
		case "cloudAccountId":
			err = unpopulate(val, "CloudAccountID", &o.CloudAccountID)
			delete(rawMsg, key)
		case "cloudAccountState":
			err = unpopulate(val, "CloudAccountState", &o.CloudAccountState)
			delete(rawMsg, key)
		case "intent":
			err = unpopulate(val, "Intent", &o.Intent)
			delete(rawMsg, key)
		case "lastOperationStatusDetail":
			err = unpopulate(val, "LastOperationStatusDetail", &o.LastOperationStatusDetail)
			delete(rawMsg, key)
		case "productCode":
			err = unpopulate(val, "ProductCode", &o.ProductCode)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &o.ProvisioningState)
			delete(rawMsg, key)
		case "saasSubscriptionId":
			err = unpopulate(val, "SaasSubscriptionID", &o.SaasSubscriptionID)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &o.TermUnit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdate.
func (o OracleSubscriptionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdate.
func (o *OracleSubscriptionUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdateProperties.
func (o OracleSubscriptionUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "intent", o.Intent)
	populate(objectMap, "productCode", o.ProductCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdateProperties.
func (o *OracleSubscriptionUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "intent":
			err = unpopulate(val, "Intent", &o.Intent)
			delete(rawMsg, key)
		case "productCode":
			err = unpopulate(val, "ProductCode", &o.ProductCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PeerDbDetails.
func (p PeerDbDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "peerDbId", p.PeerDbID)
	populate(objectMap, "peerDbLocation", p.PeerDbLocation)
	populate(objectMap, "peerDbOcid", p.PeerDbOcid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PeerDbDetails.
func (p *PeerDbDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &p.PeerDbID)
			delete(rawMsg, key)
		case "peerDbLocation":
			err = unpopulate(val, "PeerDbLocation", &p.PeerDbLocation)
			delete(rawMsg, key)
		case "peerDbOcid":
			err = unpopulate(val, "PeerDbOcid", &p.PeerDbOcid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Plan.
func (p Plan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "promotionCode", p.PromotionCode)
	populate(objectMap, "publisher", p.Publisher)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Plan.
func (p *Plan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &p.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlanUpdate.
func (p PlanUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "promotionCode", p.PromotionCode)
	populate(objectMap, "publisher", p.Publisher)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlanUpdate.
func (p *PlanUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &p.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PortRange.
func (p PortRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "max", p.Max)
	populate(objectMap, "min", p.Min)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PortRange.
func (p *PortRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "max":
			err = unpopulate(val, "Max", &p.Max)
			delete(rawMsg, key)
		case "min":
			err = unpopulate(val, "Min", &p.Min)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressProperties.
func (p PrivateIPAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "hostnameLabel", p.HostnameLabel)
	populate(objectMap, "ipAddress", p.IPAddress)
	populate(objectMap, "ocid", p.Ocid)
	populate(objectMap, "subnetId", p.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressProperties.
func (p *PrivateIPAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "hostnameLabel":
			err = unpopulate(val, "HostnameLabel", &p.HostnameLabel)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &p.IPAddress)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &p.Ocid)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressesFilter.
func (p PrivateIPAddressesFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "subnetId", p.SubnetID)
	populate(objectMap, "vnicId", p.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressesFilter.
func (p *PrivateIPAddressesFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &p.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProfileType.
func (p ProfileType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "consumerGroup", p.ConsumerGroup)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "hostFormat", p.HostFormat)
	populate(objectMap, "isRegional", p.IsRegional)
	populate(objectMap, "protocol", p.Protocol)
	populate(objectMap, "sessionMode", p.SessionMode)
	populate(objectMap, "syntaxFormat", p.SyntaxFormat)
	populate(objectMap, "tlsAuthentication", p.TLSAuthentication)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProfileType.
func (p *ProfileType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consumerGroup":
			err = unpopulate(val, "ConsumerGroup", &p.ConsumerGroup)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "hostFormat":
			err = unpopulate(val, "HostFormat", &p.HostFormat)
			delete(rawMsg, key)
		case "isRegional":
			err = unpopulate(val, "IsRegional", &p.IsRegional)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &p.Protocol)
			delete(rawMsg, key)
		case "sessionMode":
			err = unpopulate(val, "SessionMode", &p.SessionMode)
			delete(rawMsg, key)
		case "syntaxFormat":
			err = unpopulate(val, "SyntaxFormat", &p.SyntaxFormat)
			delete(rawMsg, key)
		case "tlsAuthentication":
			err = unpopulate(val, "TLSAuthentication", &p.TLSAuthentication)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoveVirtualMachineFromExadbVMClusterDetails.
func (r RemoveVirtualMachineFromExadbVMClusterDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbNodes", r.DbNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoveVirtualMachineFromExadbVMClusterDetails.
func (r *RemoveVirtualMachineFromExadbVMClusterDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbNodes":
			err = unpopulate(val, "DbNodes", &r.DbNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAnchor.
func (r ResourceAnchor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAnchor.
func (r *ResourceAnchor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &r.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAnchorListResult.
func (r ResourceAnchorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAnchorListResult.
func (r *ResourceAnchorListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAnchorProperties.
func (r ResourceAnchorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "linkedCompartmentId", r.LinkedCompartmentID)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAnchorProperties.
func (r *ResourceAnchorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedCompartmentId":
			err = unpopulate(val, "LinkedCompartmentID", &r.LinkedCompartmentID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAnchorUpdate.
func (r ResourceAnchorUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAnchorUpdate.
func (r *ResourceAnchorUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreAutonomousDatabaseDetails.
func (r RestoreAutonomousDatabaseDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "timestamp", r.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreAutonomousDatabaseDetails.
func (r *RestoreAutonomousDatabaseDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateTime[datetime.RFC3339](val, "Timestamp", &r.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SaasSubscriptionDetails.
func (s SaasSubscriptionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "isAutoRenew", s.IsAutoRenew)
	populate(objectMap, "isFreeTrial", s.IsFreeTrial)
	populate(objectMap, "offerId", s.OfferID)
	populate(objectMap, "planId", s.PlanID)
	populate(objectMap, "publisherId", s.PublisherID)
	populate(objectMap, "purchaserEmailId", s.PurchaserEmailID)
	populate(objectMap, "purchaserTenantId", s.PurchaserTenantID)
	populate(objectMap, "saasSubscriptionStatus", s.SaasSubscriptionStatus)
	populate(objectMap, "subscriptionName", s.SubscriptionName)
	populate(objectMap, "termUnit", s.TermUnit)
	populateTime[datetime.RFC3339](objectMap, "timeCreated", s.TimeCreated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SaasSubscriptionDetails.
func (s *SaasSubscriptionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "isAutoRenew":
			err = unpopulate(val, "IsAutoRenew", &s.IsAutoRenew)
			delete(rawMsg, key)
		case "isFreeTrial":
			err = unpopulate(val, "IsFreeTrial", &s.IsFreeTrial)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, "OfferID", &s.OfferID)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, "PlanID", &s.PlanID)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, "PublisherID", &s.PublisherID)
			delete(rawMsg, key)
		case "purchaserEmailId":
			err = unpopulate(val, "PurchaserEmailID", &s.PurchaserEmailID)
			delete(rawMsg, key)
		case "purchaserTenantId":
			err = unpopulate(val, "PurchaserTenantID", &s.PurchaserTenantID)
			delete(rawMsg, key)
		case "saasSubscriptionStatus":
			err = unpopulate(val, "SaasSubscriptionStatus", &s.SaasSubscriptionStatus)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, "SubscriptionName", &s.SubscriptionName)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &s.TermUnit)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTime[datetime.RFC3339](val, "TimeCreated", &s.TimeCreated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledOperationsType.
func (s ScheduledOperationsType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dayOfWeek", s.DayOfWeek)
	populate(objectMap, "scheduledStartTime", s.ScheduledStartTime)
	populate(objectMap, "scheduledStopTime", s.ScheduledStopTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledOperationsType.
func (s *ScheduledOperationsType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dayOfWeek":
			err = unpopulate(val, "DayOfWeek", &s.DayOfWeek)
			delete(rawMsg, key)
		case "scheduledStartTime":
			err = unpopulate(val, "ScheduledStartTime", &s.ScheduledStartTime)
			delete(rawMsg, key)
		case "scheduledStopTime":
			err = unpopulate(val, "ScheduledStopTime", &s.ScheduledStopTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledOperationsTypeUpdate.
func (s ScheduledOperationsTypeUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dayOfWeek", s.DayOfWeek)
	populate(objectMap, "scheduledStartTime", s.ScheduledStartTime)
	populate(objectMap, "scheduledStopTime", s.ScheduledStopTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledOperationsTypeUpdate.
func (s *ScheduledOperationsTypeUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dayOfWeek":
			err = unpopulate(val, "DayOfWeek", &s.DayOfWeek)
			delete(rawMsg, key)
		case "scheduledStartTime":
			err = unpopulate(val, "ScheduledStartTime", &s.ScheduledStartTime)
			delete(rawMsg, key)
		case "scheduledStopTime":
			err = unpopulate(val, "ScheduledStopTime", &s.ScheduledStopTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTime[datetime.RFC3339](objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTime[datetime.RFC3339](val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersion.
func (s SystemVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersion.
func (s *SystemVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersionListResult.
func (s SystemVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersionListResult.
func (s *SystemVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersionProperties.
func (s SystemVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "systemVersion", s.SystemVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersionProperties.
func (s *SystemVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &s.SystemVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddress.
func (v VirtualNetworkAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddress.
func (v *VirtualNetworkAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressListResult.
func (v VirtualNetworkAddressListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressListResult.
func (v *VirtualNetworkAddressListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressProperties.
func (v VirtualNetworkAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domain", v.Domain)
	populate(objectMap, "ipAddress", v.IPAddress)
	populate(objectMap, "lifecycleDetails", v.LifecycleDetails)
	populate(objectMap, "lifecycleState", v.LifecycleState)
	populate(objectMap, "ocid", v.Ocid)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populateTime[datetime.RFC3339](objectMap, "timeAssigned", v.TimeAssigned)
	populate(objectMap, "vmOcid", v.VMOcid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressProperties.
func (v *VirtualNetworkAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, "Domain", &v.Domain)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &v.IPAddress)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &v.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &v.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &v.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "timeAssigned":
			err = unpopulateTime[datetime.RFC3339](val, "TimeAssigned", &v.TimeAssigned)
			delete(rawMsg, key)
		case "vmOcid":
			err = unpopulate(val, "VMOcid", &v.VMOcid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateTime[T dateTimeConstraints](m map[string]any, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
	} else if !reflect.ValueOf(t).IsNil() {
		newTime := T(*t)
		m[k] = (*T)(&newTime)
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

func unpopulateTime[T dateTimeConstraints](data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	var aux T
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	newTime := time.Time(aux)
	*t = &newTime
	return nil
}

type dateTimeConstraints interface {
	datetime.PlainDate | datetime.PlainTime | datetime.RFC1123 | datetime.RFC3339 | datetime.Unix
}
