//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armoracledatabase

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ActivationLinks.
func (a ActivationLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "existingCloudAccountActivationLink", a.ExistingCloudAccountActivationLink)
	populate(objectMap, "newCloudAccountActivationLink", a.NewCloudAccountActivationLink)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivationLinks.
func (a *ActivationLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "existingCloudAccountActivationLink":
			err = unpopulate(val, "ExistingCloudAccountActivationLink", &a.ExistingCloudAccountActivationLink)
			delete(rawMsg, key)
		case "newCloudAccountActivationLink":
			err = unpopulate(val, "NewCloudAccountActivationLink", &a.NewCloudAccountActivationLink)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddRemoveDbNode.
func (a AddRemoveDbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbServers", a.DbServers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddRemoveDbNode.
func (a *AddRemoveDbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbServers":
			err = unpopulate(val, "DbServers", &a.DbServers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AllConnectionStringType.
func (a AllConnectionStringType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "high", a.High)
	populate(objectMap, "low", a.Low)
	populate(objectMap, "medium", a.Medium)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AllConnectionStringType.
func (a *AllConnectionStringType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "high":
			err = unpopulate(val, "High", &a.High)
			delete(rawMsg, key)
		case "low":
			err = unpopulate(val, "Low", &a.Low)
			delete(rawMsg, key)
		case "medium":
			err = unpopulate(val, "Medium", &a.Medium)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApexDetailsType.
func (a ApexDetailsType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apexVersion", a.ApexVersion)
	populate(objectMap, "ordsVersion", a.OrdsVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApexDetailsType.
func (a *ApexDetailsType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apexVersion":
			err = unpopulate(val, "ApexVersion", &a.ApexVersion)
			delete(rawMsg, key)
		case "ordsVersion":
			err = unpopulate(val, "OrdsVersion", &a.OrdsVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabase.
func (a AutonomousDatabase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabase.
func (a *AutonomousDatabase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAutonomousDatabaseBasePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackup.
func (a AutonomousDatabaseBackup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackup.
func (a *AutonomousDatabaseBackup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupListResult.
func (a AutonomousDatabaseBackupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupListResult.
func (a *AutonomousDatabaseBackupListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupProperties.
func (a AutonomousDatabaseBackupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autonomousDatabaseOcid", a.AutonomousDatabaseOcid)
	populate(objectMap, "backupType", a.BackupType)
	populate(objectMap, "databaseSizeInTbs", a.DatabaseSizeInTbs)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isAutomatic", a.IsAutomatic)
	populate(objectMap, "isRestorable", a.IsRestorable)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "retentionPeriodInDays", a.RetentionPeriodInDays)
	populate(objectMap, "sizeInTbs", a.SizeInTbs)
	populateDateTimeRFC3339(objectMap, "timeAvailableTil", a.TimeAvailableTil)
	populate(objectMap, "timeEnded", a.TimeEnded)
	populate(objectMap, "timeStarted", a.TimeStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupProperties.
func (a *AutonomousDatabaseBackupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autonomousDatabaseOcid":
			err = unpopulate(val, "AutonomousDatabaseOcid", &a.AutonomousDatabaseOcid)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, "BackupType", &a.BackupType)
			delete(rawMsg, key)
		case "databaseSizeInTbs":
			err = unpopulate(val, "DatabaseSizeInTbs", &a.DatabaseSizeInTbs)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isAutomatic":
			err = unpopulate(val, "IsAutomatic", &a.IsAutomatic)
			delete(rawMsg, key)
		case "isRestorable":
			err = unpopulate(val, "IsRestorable", &a.IsRestorable)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &a.RetentionPeriodInDays)
			delete(rawMsg, key)
		case "sizeInTbs":
			err = unpopulate(val, "SizeInTbs", &a.SizeInTbs)
			delete(rawMsg, key)
		case "timeAvailableTil":
			err = unpopulateDateTimeRFC3339(val, "TimeAvailableTil", &a.TimeAvailableTil)
			delete(rawMsg, key)
		case "timeEnded":
			err = unpopulate(val, "TimeEnded", &a.TimeEnded)
			delete(rawMsg, key)
		case "timeStarted":
			err = unpopulate(val, "TimeStarted", &a.TimeStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupUpdate.
func (a AutonomousDatabaseBackupUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupUpdate.
func (a *AutonomousDatabaseBackupUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBackupUpdateProperties.
func (a AutonomousDatabaseBackupUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "retentionPeriodInDays", a.RetentionPeriodInDays)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBackupUpdateProperties.
func (a *AutonomousDatabaseBackupUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &a.RetentionPeriodInDays)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseBaseProperties.
func (a AutonomousDatabaseBaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = a.DataBaseType
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateDateTimeRFC3339(objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperations", a.ScheduledOperations)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateDateTimeRFC3339(objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseBaseProperties.
func (a *AutonomousDatabaseBaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperations":
			err = unpopulate(val, "ScheduledOperations", &a.ScheduledOperations)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSet.
func (a AutonomousDatabaseCharacterSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSet.
func (a *AutonomousDatabaseCharacterSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSetListResult.
func (a AutonomousDatabaseCharacterSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSetListResult.
func (a *AutonomousDatabaseCharacterSetListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCharacterSetProperties.
func (a AutonomousDatabaseCharacterSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "characterSet", a.CharacterSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCharacterSetProperties.
func (a *AutonomousDatabaseCharacterSetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseCloneProperties.
func (a AutonomousDatabaseCloneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "cloneType", a.CloneType)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeClone
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isReconnectCloneEnabled", a.IsReconnectCloneEnabled)
	populate(objectMap, "isRefreshableClone", a.IsRefreshableClone)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateDateTimeRFC3339(objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "refreshableModel", a.RefreshableModel)
	populate(objectMap, "refreshableStatus", a.RefreshableStatus)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperations", a.ScheduledOperations)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "source", a.Source)
	populate(objectMap, "sourceId", a.SourceID)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateDateTimeRFC3339(objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "timeUntilReconnectCloneEnabled", a.TimeUntilReconnectCloneEnabled)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseCloneProperties.
func (a *AutonomousDatabaseCloneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "cloneType":
			err = unpopulate(val, "CloneType", &a.CloneType)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isReconnectCloneEnabled":
			err = unpopulate(val, "IsReconnectCloneEnabled", &a.IsReconnectCloneEnabled)
			delete(rawMsg, key)
		case "isRefreshableClone":
			err = unpopulate(val, "IsRefreshableClone", &a.IsRefreshableClone)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "refreshableModel":
			err = unpopulate(val, "RefreshableModel", &a.RefreshableModel)
			delete(rawMsg, key)
		case "refreshableStatus":
			err = unpopulate(val, "RefreshableStatus", &a.RefreshableStatus)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperations":
			err = unpopulate(val, "ScheduledOperations", &a.ScheduledOperations)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		case "sourceId":
			err = unpopulate(val, "SourceID", &a.SourceID)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeUntilReconnectCloneEnabled":
			err = unpopulate(val, "TimeUntilReconnectCloneEnabled", &a.TimeUntilReconnectCloneEnabled)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseListResult.
func (a AutonomousDatabaseListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseListResult.
func (a *AutonomousDatabaseListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSet.
func (a AutonomousDatabaseNationalCharacterSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSet.
func (a *AutonomousDatabaseNationalCharacterSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSetListResult.
func (a AutonomousDatabaseNationalCharacterSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSetListResult.
func (a *AutonomousDatabaseNationalCharacterSetListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseNationalCharacterSetProperties.
func (a AutonomousDatabaseNationalCharacterSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "characterSet", a.CharacterSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseNationalCharacterSetProperties.
func (a *AutonomousDatabaseNationalCharacterSetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseProperties.
func (a AutonomousDatabaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actualUsedDataStorageSizeInTbs", a.ActualUsedDataStorageSizeInTbs)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "allocatedStorageSizeInTbs", a.AllocatedStorageSizeInTbs)
	populate(objectMap, "apexDetails", a.ApexDetails)
	populate(objectMap, "autonomousDatabaseId", a.AutonomousDatabaseID)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "availableUpgradeVersions", a.AvailableUpgradeVersions)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "characterSet", a.CharacterSet)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "computeModel", a.ComputeModel)
	populate(objectMap, "connectionStrings", a.ConnectionStrings)
	populate(objectMap, "connectionUrls", a.ConnectionUrls)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	objectMap["dataBaseType"] = DataBaseTypeRegular
	populate(objectMap, "dataSafeStatus", a.DataSafeStatus)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "dbVersion", a.DbVersion)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "failedDataRecoveryInSeconds", a.FailedDataRecoveryInSeconds)
	populate(objectMap, "inMemoryAreaInGbs", a.InMemoryAreaInGbs)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "isPreview", a.IsPreview)
	populate(objectMap, "isPreviewVersionWithServiceTermsAccepted", a.IsPreviewVersionWithServiceTermsAccepted)
	populate(objectMap, "isRemoteDataGuardEnabled", a.IsRemoteDataGuardEnabled)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "localDisasterRecoveryType", a.LocalDisasterRecoveryType)
	populate(objectMap, "localStandbyDb", a.LocalStandbyDb)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "memoryPerOracleComputeUnitInGbs", a.MemoryPerOracleComputeUnitInGbs)
	populate(objectMap, "ncharacterSet", a.NcharacterSet)
	populateDateTimeRFC3339(objectMap, "nextLongTermBackupTimeStamp", a.NextLongTermBackupTimeStamp)
	populate(objectMap, "ociUrl", a.OciURL)
	populate(objectMap, "ocid", a.Ocid)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "operationsInsightsStatus", a.OperationsInsightsStatus)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "peerDbIds", a.PeerDbIDs)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "privateEndpoint", a.PrivateEndpoint)
	populate(objectMap, "privateEndpointIp", a.PrivateEndpointIP)
	populate(objectMap, "privateEndpointLabel", a.PrivateEndpointLabel)
	populate(objectMap, "provisionableCpus", a.ProvisionableCpus)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "sqlWebDeveloperUrl", a.SQLWebDeveloperURL)
	populate(objectMap, "scheduledOperations", a.ScheduledOperations)
	populate(objectMap, "serviceConsoleUrl", a.ServiceConsoleURL)
	populate(objectMap, "subnetId", a.SubnetID)
	populate(objectMap, "supportedRegionsToCloneTo", a.SupportedRegionsToCloneTo)
	populateDateTimeRFC3339(objectMap, "timeCreated", a.TimeCreated)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDeletionOfFreeAutonomousDatabase", a.TimeDeletionOfFreeAutonomousDatabase)
	populate(objectMap, "timeLocalDataGuardEnabled", a.TimeLocalDataGuardEnabled)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceBegin", a.TimeMaintenanceBegin)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceEnd", a.TimeMaintenanceEnd)
	populate(objectMap, "timeOfLastFailover", a.TimeOfLastFailover)
	populate(objectMap, "timeOfLastRefresh", a.TimeOfLastRefresh)
	populate(objectMap, "timeOfLastRefreshPoint", a.TimeOfLastRefreshPoint)
	populate(objectMap, "timeOfLastSwitchover", a.TimeOfLastSwitchover)
	populate(objectMap, "timeReclamationOfFreeAutonomousDatabase", a.TimeReclamationOfFreeAutonomousDatabase)
	populate(objectMap, "usedDataStorageSizeInGbs", a.UsedDataStorageSizeInGbs)
	populate(objectMap, "usedDataStorageSizeInTbs", a.UsedDataStorageSizeInTbs)
	populate(objectMap, "vnetId", a.VnetID)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseProperties.
func (a *AutonomousDatabaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actualUsedDataStorageSizeInTbs":
			err = unpopulate(val, "ActualUsedDataStorageSizeInTbs", &a.ActualUsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "allocatedStorageSizeInTbs":
			err = unpopulate(val, "AllocatedStorageSizeInTbs", &a.AllocatedStorageSizeInTbs)
			delete(rawMsg, key)
		case "apexDetails":
			err = unpopulate(val, "ApexDetails", &a.ApexDetails)
			delete(rawMsg, key)
		case "autonomousDatabaseId":
			err = unpopulate(val, "AutonomousDatabaseID", &a.AutonomousDatabaseID)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "availableUpgradeVersions":
			err = unpopulate(val, "AvailableUpgradeVersions", &a.AvailableUpgradeVersions)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "characterSet":
			err = unpopulate(val, "CharacterSet", &a.CharacterSet)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "computeModel":
			err = unpopulate(val, "ComputeModel", &a.ComputeModel)
			delete(rawMsg, key)
		case "connectionStrings":
			err = unpopulate(val, "ConnectionStrings", &a.ConnectionStrings)
			delete(rawMsg, key)
		case "connectionUrls":
			err = unpopulate(val, "ConnectionUrls", &a.ConnectionUrls)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataBaseType":
			err = unpopulate(val, "DataBaseType", &a.DataBaseType)
			delete(rawMsg, key)
		case "dataSafeStatus":
			err = unpopulate(val, "DataSafeStatus", &a.DataSafeStatus)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "dbVersion":
			err = unpopulate(val, "DbVersion", &a.DbVersion)
			delete(rawMsg, key)
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "failedDataRecoveryInSeconds":
			err = unpopulate(val, "FailedDataRecoveryInSeconds", &a.FailedDataRecoveryInSeconds)
			delete(rawMsg, key)
		case "inMemoryAreaInGbs":
			err = unpopulate(val, "InMemoryAreaInGbs", &a.InMemoryAreaInGbs)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "isPreview":
			err = unpopulate(val, "IsPreview", &a.IsPreview)
			delete(rawMsg, key)
		case "isPreviewVersionWithServiceTermsAccepted":
			err = unpopulate(val, "IsPreviewVersionWithServiceTermsAccepted", &a.IsPreviewVersionWithServiceTermsAccepted)
			delete(rawMsg, key)
		case "isRemoteDataGuardEnabled":
			err = unpopulate(val, "IsRemoteDataGuardEnabled", &a.IsRemoteDataGuardEnabled)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "localDisasterRecoveryType":
			err = unpopulate(val, "LocalDisasterRecoveryType", &a.LocalDisasterRecoveryType)
			delete(rawMsg, key)
		case "localStandbyDb":
			err = unpopulate(val, "LocalStandbyDb", &a.LocalStandbyDb)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "memoryPerOracleComputeUnitInGbs":
			err = unpopulate(val, "MemoryPerOracleComputeUnitInGbs", &a.MemoryPerOracleComputeUnitInGbs)
			delete(rawMsg, key)
		case "ncharacterSet":
			err = unpopulate(val, "NcharacterSet", &a.NcharacterSet)
			delete(rawMsg, key)
		case "nextLongTermBackupTimeStamp":
			err = unpopulateDateTimeRFC3339(val, "NextLongTermBackupTimeStamp", &a.NextLongTermBackupTimeStamp)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &a.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &a.Ocid)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "operationsInsightsStatus":
			err = unpopulate(val, "OperationsInsightsStatus", &a.OperationsInsightsStatus)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "peerDbIds":
			err = unpopulate(val, "PeerDbIDs", &a.PeerDbIDs)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &a.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateEndpointIp":
			err = unpopulate(val, "PrivateEndpointIP", &a.PrivateEndpointIP)
			delete(rawMsg, key)
		case "privateEndpointLabel":
			err = unpopulate(val, "PrivateEndpointLabel", &a.PrivateEndpointLabel)
			delete(rawMsg, key)
		case "provisionableCpus":
			err = unpopulate(val, "ProvisionableCpus", &a.ProvisionableCpus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "sqlWebDeveloperUrl":
			err = unpopulate(val, "SQLWebDeveloperURL", &a.SQLWebDeveloperURL)
			delete(rawMsg, key)
		case "scheduledOperations":
			err = unpopulate(val, "ScheduledOperations", &a.ScheduledOperations)
			delete(rawMsg, key)
		case "serviceConsoleUrl":
			err = unpopulate(val, "ServiceConsoleURL", &a.ServiceConsoleURL)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &a.SubnetID)
			delete(rawMsg, key)
		case "supportedRegionsToCloneTo":
			err = unpopulate(val, "SupportedRegionsToCloneTo", &a.SupportedRegionsToCloneTo)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &a.TimeCreated)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDeletionOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeDeletionOfFreeAutonomousDatabase", &a.TimeDeletionOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "timeLocalDataGuardEnabled":
			err = unpopulate(val, "TimeLocalDataGuardEnabled", &a.TimeLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "timeMaintenanceBegin":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceBegin", &a.TimeMaintenanceBegin)
			delete(rawMsg, key)
		case "timeMaintenanceEnd":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceEnd", &a.TimeMaintenanceEnd)
			delete(rawMsg, key)
		case "timeOfLastFailover":
			err = unpopulate(val, "TimeOfLastFailover", &a.TimeOfLastFailover)
			delete(rawMsg, key)
		case "timeOfLastRefresh":
			err = unpopulate(val, "TimeOfLastRefresh", &a.TimeOfLastRefresh)
			delete(rawMsg, key)
		case "timeOfLastRefreshPoint":
			err = unpopulate(val, "TimeOfLastRefreshPoint", &a.TimeOfLastRefreshPoint)
			delete(rawMsg, key)
		case "timeOfLastSwitchover":
			err = unpopulate(val, "TimeOfLastSwitchover", &a.TimeOfLastSwitchover)
			delete(rawMsg, key)
		case "timeReclamationOfFreeAutonomousDatabase":
			err = unpopulate(val, "TimeReclamationOfFreeAutonomousDatabase", &a.TimeReclamationOfFreeAutonomousDatabase)
			delete(rawMsg, key)
		case "usedDataStorageSizeInGbs":
			err = unpopulate(val, "UsedDataStorageSizeInGbs", &a.UsedDataStorageSizeInGbs)
			delete(rawMsg, key)
		case "usedDataStorageSizeInTbs":
			err = unpopulate(val, "UsedDataStorageSizeInTbs", &a.UsedDataStorageSizeInTbs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &a.VnetID)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseStandbySummary.
func (a AutonomousDatabaseStandbySummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lagTimeInSeconds", a.LagTimeInSeconds)
	populate(objectMap, "lifecycleDetails", a.LifecycleDetails)
	populate(objectMap, "lifecycleState", a.LifecycleState)
	populate(objectMap, "timeDataGuardRoleChanged", a.TimeDataGuardRoleChanged)
	populate(objectMap, "timeDisasterRecoveryRoleChanged", a.TimeDisasterRecoveryRoleChanged)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseStandbySummary.
func (a *AutonomousDatabaseStandbySummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lagTimeInSeconds":
			err = unpopulate(val, "LagTimeInSeconds", &a.LagTimeInSeconds)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &a.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &a.LifecycleState)
			delete(rawMsg, key)
		case "timeDataGuardRoleChanged":
			err = unpopulate(val, "TimeDataGuardRoleChanged", &a.TimeDataGuardRoleChanged)
			delete(rawMsg, key)
		case "timeDisasterRecoveryRoleChanged":
			err = unpopulate(val, "TimeDisasterRecoveryRoleChanged", &a.TimeDisasterRecoveryRoleChanged)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseUpdate.
func (a AutonomousDatabaseUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseUpdate.
func (a *AutonomousDatabaseUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseUpdateProperties.
func (a AutonomousDatabaseUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adminPassword", a.AdminPassword)
	populate(objectMap, "autonomousMaintenanceScheduleType", a.AutonomousMaintenanceScheduleType)
	populate(objectMap, "backupRetentionPeriodInDays", a.BackupRetentionPeriodInDays)
	populate(objectMap, "cpuCoreCount", a.CPUCoreCount)
	populate(objectMap, "computeCount", a.ComputeCount)
	populate(objectMap, "customerContacts", a.CustomerContacts)
	populate(objectMap, "dataStorageSizeInGbs", a.DataStorageSizeInGbs)
	populate(objectMap, "dataStorageSizeInTbs", a.DataStorageSizeInTbs)
	populate(objectMap, "databaseEdition", a.DatabaseEdition)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isAutoScalingEnabled", a.IsAutoScalingEnabled)
	populate(objectMap, "isAutoScalingForStorageEnabled", a.IsAutoScalingForStorageEnabled)
	populate(objectMap, "isLocalDataGuardEnabled", a.IsLocalDataGuardEnabled)
	populate(objectMap, "isMtlsConnectionRequired", a.IsMtlsConnectionRequired)
	populate(objectMap, "licenseModel", a.LicenseModel)
	populate(objectMap, "localAdgAutoFailoverMaxDataLossLimit", a.LocalAdgAutoFailoverMaxDataLossLimit)
	populate(objectMap, "longTermBackupSchedule", a.LongTermBackupSchedule)
	populate(objectMap, "openMode", a.OpenMode)
	populate(objectMap, "peerDbId", a.PeerDbID)
	populate(objectMap, "permissionLevel", a.PermissionLevel)
	populate(objectMap, "role", a.Role)
	populate(objectMap, "scheduledOperations", a.ScheduledOperations)
	populate(objectMap, "whitelistedIps", a.WhitelistedIPs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseUpdateProperties.
func (a *AutonomousDatabaseUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &a.AdminPassword)
			delete(rawMsg, key)
		case "autonomousMaintenanceScheduleType":
			err = unpopulate(val, "AutonomousMaintenanceScheduleType", &a.AutonomousMaintenanceScheduleType)
			delete(rawMsg, key)
		case "backupRetentionPeriodInDays":
			err = unpopulate(val, "BackupRetentionPeriodInDays", &a.BackupRetentionPeriodInDays)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &a.CPUCoreCount)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &a.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &a.CustomerContacts)
			delete(rawMsg, key)
		case "dataStorageSizeInGbs":
			err = unpopulate(val, "DataStorageSizeInGbs", &a.DataStorageSizeInGbs)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &a.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "databaseEdition":
			err = unpopulate(val, "DatabaseEdition", &a.DatabaseEdition)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isAutoScalingEnabled":
			err = unpopulate(val, "IsAutoScalingEnabled", &a.IsAutoScalingEnabled)
			delete(rawMsg, key)
		case "isAutoScalingForStorageEnabled":
			err = unpopulate(val, "IsAutoScalingForStorageEnabled", &a.IsAutoScalingForStorageEnabled)
			delete(rawMsg, key)
		case "isLocalDataGuardEnabled":
			err = unpopulate(val, "IsLocalDataGuardEnabled", &a.IsLocalDataGuardEnabled)
			delete(rawMsg, key)
		case "isMtlsConnectionRequired":
			err = unpopulate(val, "IsMtlsConnectionRequired", &a.IsMtlsConnectionRequired)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &a.LicenseModel)
			delete(rawMsg, key)
		case "localAdgAutoFailoverMaxDataLossLimit":
			err = unpopulate(val, "LocalAdgAutoFailoverMaxDataLossLimit", &a.LocalAdgAutoFailoverMaxDataLossLimit)
			delete(rawMsg, key)
		case "longTermBackupSchedule":
			err = unpopulate(val, "LongTermBackupSchedule", &a.LongTermBackupSchedule)
			delete(rawMsg, key)
		case "openMode":
			err = unpopulate(val, "OpenMode", &a.OpenMode)
			delete(rawMsg, key)
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &a.PeerDbID)
			delete(rawMsg, key)
		case "permissionLevel":
			err = unpopulate(val, "PermissionLevel", &a.PermissionLevel)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		case "scheduledOperations":
			err = unpopulate(val, "ScheduledOperations", &a.ScheduledOperations)
			delete(rawMsg, key)
		case "whitelistedIps":
			err = unpopulate(val, "WhitelistedIPs", &a.WhitelistedIPs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDatabaseWalletFile.
func (a AutonomousDatabaseWalletFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "walletFiles", a.WalletFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDatabaseWalletFile.
func (a *AutonomousDatabaseWalletFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "walletFiles":
			err = unpopulate(val, "WalletFiles", &a.WalletFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersion.
func (a AutonomousDbVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersion.
func (a *AutonomousDbVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersionListResult.
func (a AutonomousDbVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersionListResult.
func (a *AutonomousDbVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutonomousDbVersionProperties.
func (a AutonomousDbVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbWorkload", a.DbWorkload)
	populate(objectMap, "isDefaultForFree", a.IsDefaultForFree)
	populate(objectMap, "isDefaultForPaid", a.IsDefaultForPaid)
	populate(objectMap, "isFreeTierEnabled", a.IsFreeTierEnabled)
	populate(objectMap, "isPaidEnabled", a.IsPaidEnabled)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutonomousDbVersionProperties.
func (a *AutonomousDbVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbWorkload":
			err = unpopulate(val, "DbWorkload", &a.DbWorkload)
			delete(rawMsg, key)
		case "isDefaultForFree":
			err = unpopulate(val, "IsDefaultForFree", &a.IsDefaultForFree)
			delete(rawMsg, key)
		case "isDefaultForPaid":
			err = unpopulate(val, "IsDefaultForPaid", &a.IsDefaultForPaid)
			delete(rawMsg, key)
		case "isFreeTierEnabled":
			err = unpopulate(val, "IsFreeTierEnabled", &a.IsFreeTierEnabled)
			delete(rawMsg, key)
		case "isPaidEnabled":
			err = unpopulate(val, "IsPaidEnabled", &a.IsPaidEnabled)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudAccountDetails.
func (c CloudAccountDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloudAccountHomeRegion", c.CloudAccountHomeRegion)
	populate(objectMap, "cloudAccountName", c.CloudAccountName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudAccountDetails.
func (c *CloudAccountDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudAccountHomeRegion":
			err = unpopulate(val, "CloudAccountHomeRegion", &c.CloudAccountHomeRegion)
			delete(rawMsg, key)
		case "cloudAccountName":
			err = unpopulate(val, "CloudAccountName", &c.CloudAccountName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructure.
func (c CloudExadataInfrastructure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructure.
func (c *CloudExadataInfrastructure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureListResult.
func (c CloudExadataInfrastructureListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureListResult.
func (c *CloudExadataInfrastructureListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureProperties.
func (c CloudExadataInfrastructureProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activatedStorageCount", c.ActivatedStorageCount)
	populate(objectMap, "additionalStorageCount", c.AdditionalStorageCount)
	populate(objectMap, "availableStorageSizeInGbs", c.AvailableStorageSizeInGbs)
	populate(objectMap, "cpuCount", c.CPUCount)
	populate(objectMap, "computeCount", c.ComputeCount)
	populate(objectMap, "customerContacts", c.CustomerContacts)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerVersion", c.DbServerVersion)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "estimatedPatchingTime", c.EstimatedPatchingTime)
	populate(objectMap, "lastMaintenanceRunId", c.LastMaintenanceRunID)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "lifecycleState", c.LifecycleState)
	populate(objectMap, "maintenanceWindow", c.MaintenanceWindow)
	populate(objectMap, "maxCpuCount", c.MaxCPUCount)
	populate(objectMap, "maxDataStorageInTbs", c.MaxDataStorageInTbs)
	populate(objectMap, "maxDbNodeStorageSizeInGbs", c.MaxDbNodeStorageSizeInGbs)
	populate(objectMap, "maxMemoryInGbs", c.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "monthlyDbServerVersion", c.MonthlyDbServerVersion)
	populate(objectMap, "monthlyStorageServerVersion", c.MonthlyStorageServerVersion)
	populate(objectMap, "nextMaintenanceRunId", c.NextMaintenanceRunID)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageCount", c.StorageCount)
	populate(objectMap, "storageServerVersion", c.StorageServerVersion)
	populate(objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "totalStorageSizeInGbs", c.TotalStorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureProperties.
func (c *CloudExadataInfrastructureProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activatedStorageCount":
			err = unpopulate(val, "ActivatedStorageCount", &c.ActivatedStorageCount)
			delete(rawMsg, key)
		case "additionalStorageCount":
			err = unpopulate(val, "AdditionalStorageCount", &c.AdditionalStorageCount)
			delete(rawMsg, key)
		case "availableStorageSizeInGbs":
			err = unpopulate(val, "AvailableStorageSizeInGbs", &c.AvailableStorageSizeInGbs)
			delete(rawMsg, key)
		case "cpuCount":
			err = unpopulate(val, "CPUCount", &c.CPUCount)
			delete(rawMsg, key)
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &c.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &c.CustomerContacts)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerVersion":
			err = unpopulate(val, "DbServerVersion", &c.DbServerVersion)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "estimatedPatchingTime":
			err = unpopulate(val, "EstimatedPatchingTime", &c.EstimatedPatchingTime)
			delete(rawMsg, key)
		case "lastMaintenanceRunId":
			err = unpopulate(val, "LastMaintenanceRunID", &c.LastMaintenanceRunID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &c.LifecycleState)
			delete(rawMsg, key)
		case "maintenanceWindow":
			err = unpopulate(val, "MaintenanceWindow", &c.MaintenanceWindow)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &c.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDataStorageInTbs":
			err = unpopulate(val, "MaxDataStorageInTbs", &c.MaxDataStorageInTbs)
			delete(rawMsg, key)
		case "maxDbNodeStorageSizeInGbs":
			err = unpopulate(val, "MaxDbNodeStorageSizeInGbs", &c.MaxDbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &c.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "monthlyDbServerVersion":
			err = unpopulate(val, "MonthlyDbServerVersion", &c.MonthlyDbServerVersion)
			delete(rawMsg, key)
		case "monthlyStorageServerVersion":
			err = unpopulate(val, "MonthlyStorageServerVersion", &c.MonthlyStorageServerVersion)
			delete(rawMsg, key)
		case "nextMaintenanceRunId":
			err = unpopulate(val, "NextMaintenanceRunID", &c.NextMaintenanceRunID)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageCount":
			err = unpopulate(val, "StorageCount", &c.StorageCount)
			delete(rawMsg, key)
		case "storageServerVersion":
			err = unpopulate(val, "StorageServerVersion", &c.StorageServerVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulate(val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "totalStorageSizeInGbs":
			err = unpopulate(val, "TotalStorageSizeInGbs", &c.TotalStorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureUpdate.
func (c CloudExadataInfrastructureUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureUpdate.
func (c *CloudExadataInfrastructureUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudExadataInfrastructureUpdateProperties.
func (c CloudExadataInfrastructureUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "computeCount", c.ComputeCount)
	populate(objectMap, "customerContacts", c.CustomerContacts)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "maintenanceWindow", c.MaintenanceWindow)
	populate(objectMap, "storageCount", c.StorageCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudExadataInfrastructureUpdateProperties.
func (c *CloudExadataInfrastructureUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeCount":
			err = unpopulate(val, "ComputeCount", &c.ComputeCount)
			delete(rawMsg, key)
		case "customerContacts":
			err = unpopulate(val, "CustomerContacts", &c.CustomerContacts)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "maintenanceWindow":
			err = unpopulate(val, "MaintenanceWindow", &c.MaintenanceWindow)
			delete(rawMsg, key)
		case "storageCount":
			err = unpopulate(val, "StorageCount", &c.StorageCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMCluster.
func (c CloudVMCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMCluster.
func (c *CloudVMCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterListResult.
func (c CloudVMClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterListResult.
func (c *CloudVMClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterProperties.
func (c CloudVMClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupSubnetCidr", c.BackupSubnetCidr)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "cloudExadataInfrastructureId", c.CloudExadataInfrastructureID)
	populate(objectMap, "clusterName", c.ClusterName)
	populate(objectMap, "compartmentId", c.CompartmentID)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStoragePercentage", c.DataStoragePercentage)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServers", c.DbServers)
	populate(objectMap, "diskRedundancy", c.DiskRedundancy)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "domain", c.Domain)
	populate(objectMap, "giVersion", c.GiVersion)
	populate(objectMap, "hostname", c.Hostname)
	populate(objectMap, "iormConfigCache", c.IormConfigCache)
	populate(objectMap, "isLocalBackupEnabled", c.IsLocalBackupEnabled)
	populate(objectMap, "isSparseDiskgroupEnabled", c.IsSparseDiskgroupEnabled)
	populate(objectMap, "lastUpdateHistoryEntryId", c.LastUpdateHistoryEntryID)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "lifecycleDetails", c.LifecycleDetails)
	populate(objectMap, "lifecycleState", c.LifecycleState)
	populate(objectMap, "listenerPort", c.ListenerPort)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "nodeCount", c.NodeCount)
	populate(objectMap, "nsgCidrs", c.NsgCidrs)
	populate(objectMap, "nsgUrl", c.NsgURL)
	populate(objectMap, "ociUrl", c.OciURL)
	populate(objectMap, "ocid", c.Ocid)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "scanDnsName", c.ScanDNSName)
	populate(objectMap, "scanDnsRecordId", c.ScanDNSRecordID)
	populate(objectMap, "scanIpIds", c.ScanIPIDs)
	populate(objectMap, "scanListenerPortTcp", c.ScanListenerPortTCP)
	populate(objectMap, "scanListenerPortTcpSsl", c.ScanListenerPortTCPSSL)
	populate(objectMap, "shape", c.Shape)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	populate(objectMap, "subnetId", c.SubnetID)
	populate(objectMap, "subnetOcid", c.SubnetOcid)
	populate(objectMap, "systemVersion", c.SystemVersion)
	populateDateTimeRFC3339(objectMap, "timeCreated", c.TimeCreated)
	populate(objectMap, "timeZone", c.TimeZone)
	populate(objectMap, "vipIds", c.VipIDs)
	populate(objectMap, "vnetId", c.VnetID)
	populate(objectMap, "zoneId", c.ZoneID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterProperties.
func (c *CloudVMClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupSubnetCidr":
			err = unpopulate(val, "BackupSubnetCidr", &c.BackupSubnetCidr)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "cloudExadataInfrastructureId":
			err = unpopulate(val, "CloudExadataInfrastructureID", &c.CloudExadataInfrastructureID)
			delete(rawMsg, key)
		case "clusterName":
			err = unpopulate(val, "ClusterName", &c.ClusterName)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &c.CompartmentID)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStoragePercentage":
			err = unpopulate(val, "DataStoragePercentage", &c.DataStoragePercentage)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServers":
			err = unpopulate(val, "DbServers", &c.DbServers)
			delete(rawMsg, key)
		case "diskRedundancy":
			err = unpopulate(val, "DiskRedundancy", &c.DiskRedundancy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, "Domain", &c.Domain)
			delete(rawMsg, key)
		case "giVersion":
			err = unpopulate(val, "GiVersion", &c.GiVersion)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &c.Hostname)
			delete(rawMsg, key)
		case "iormConfigCache":
			err = unpopulate(val, "IormConfigCache", &c.IormConfigCache)
			delete(rawMsg, key)
		case "isLocalBackupEnabled":
			err = unpopulate(val, "IsLocalBackupEnabled", &c.IsLocalBackupEnabled)
			delete(rawMsg, key)
		case "isSparseDiskgroupEnabled":
			err = unpopulate(val, "IsSparseDiskgroupEnabled", &c.IsSparseDiskgroupEnabled)
			delete(rawMsg, key)
		case "lastUpdateHistoryEntryId":
			err = unpopulate(val, "LastUpdateHistoryEntryID", &c.LastUpdateHistoryEntryID)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &c.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &c.LifecycleState)
			delete(rawMsg, key)
		case "listenerPort":
			err = unpopulate(val, "ListenerPort", &c.ListenerPort)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, "NodeCount", &c.NodeCount)
			delete(rawMsg, key)
		case "nsgCidrs":
			err = unpopulate(val, "NsgCidrs", &c.NsgCidrs)
			delete(rawMsg, key)
		case "nsgUrl":
			err = unpopulate(val, "NsgURL", &c.NsgURL)
			delete(rawMsg, key)
		case "ociUrl":
			err = unpopulate(val, "OciURL", &c.OciURL)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &c.Ocid)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "scanDnsName":
			err = unpopulate(val, "ScanDNSName", &c.ScanDNSName)
			delete(rawMsg, key)
		case "scanDnsRecordId":
			err = unpopulate(val, "ScanDNSRecordID", &c.ScanDNSRecordID)
			delete(rawMsg, key)
		case "scanIpIds":
			err = unpopulate(val, "ScanIPIDs", &c.ScanIPIDs)
			delete(rawMsg, key)
		case "scanListenerPortTcp":
			err = unpopulate(val, "ScanListenerPortTCP", &c.ScanListenerPortTCP)
			delete(rawMsg, key)
		case "scanListenerPortTcpSsl":
			err = unpopulate(val, "ScanListenerPortTCPSSL", &c.ScanListenerPortTCPSSL)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &c.Shape)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &c.SubnetID)
			delete(rawMsg, key)
		case "subnetOcid":
			err = unpopulate(val, "SubnetOcid", &c.SubnetOcid)
			delete(rawMsg, key)
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &c.SystemVersion)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &c.TimeCreated)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &c.TimeZone)
			delete(rawMsg, key)
		case "vipIds":
			err = unpopulate(val, "VipIDs", &c.VipIDs)
			delete(rawMsg, key)
		case "vnetId":
			err = unpopulate(val, "VnetID", &c.VnetID)
			delete(rawMsg, key)
		case "zoneId":
			err = unpopulate(val, "ZoneID", &c.ZoneID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdate.
func (c CloudVMClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdate.
func (c *CloudVMClusterUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudVMClusterUpdateProperties.
func (c CloudVMClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cpuCoreCount", c.CPUCoreCount)
	populate(objectMap, "computeNodes", c.ComputeNodes)
	populate(objectMap, "dataCollectionOptions", c.DataCollectionOptions)
	populate(objectMap, "dataStorageSizeInTbs", c.DataStorageSizeInTbs)
	populate(objectMap, "dbNodeStorageSizeInGbs", c.DbNodeStorageSizeInGbs)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "licenseModel", c.LicenseModel)
	populate(objectMap, "memorySizeInGbs", c.MemorySizeInGbs)
	populate(objectMap, "ocpuCount", c.OcpuCount)
	populate(objectMap, "sshPublicKeys", c.SSHPublicKeys)
	populate(objectMap, "storageSizeInGbs", c.StorageSizeInGbs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudVMClusterUpdateProperties.
func (c *CloudVMClusterUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &c.CPUCoreCount)
			delete(rawMsg, key)
		case "computeNodes":
			err = unpopulate(val, "ComputeNodes", &c.ComputeNodes)
			delete(rawMsg, key)
		case "dataCollectionOptions":
			err = unpopulate(val, "DataCollectionOptions", &c.DataCollectionOptions)
			delete(rawMsg, key)
		case "dataStorageSizeInTbs":
			err = unpopulate(val, "DataStorageSizeInTbs", &c.DataStorageSizeInTbs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &c.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "licenseModel":
			err = unpopulate(val, "LicenseModel", &c.LicenseModel)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &c.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocpuCount":
			err = unpopulate(val, "OcpuCount", &c.OcpuCount)
			delete(rawMsg, key)
		case "sshPublicKeys":
			err = unpopulate(val, "SSHPublicKeys", &c.SSHPublicKeys)
			delete(rawMsg, key)
		case "storageSizeInGbs":
			err = unpopulate(val, "StorageSizeInGbs", &c.StorageSizeInGbs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionStringType.
func (c ConnectionStringType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allConnectionStrings", c.AllConnectionStrings)
	populate(objectMap, "dedicated", c.Dedicated)
	populate(objectMap, "high", c.High)
	populate(objectMap, "low", c.Low)
	populate(objectMap, "medium", c.Medium)
	populate(objectMap, "profiles", c.Profiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionStringType.
func (c *ConnectionStringType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allConnectionStrings":
			err = unpopulate(val, "AllConnectionStrings", &c.AllConnectionStrings)
			delete(rawMsg, key)
		case "dedicated":
			err = unpopulate(val, "Dedicated", &c.Dedicated)
			delete(rawMsg, key)
		case "high":
			err = unpopulate(val, "High", &c.High)
			delete(rawMsg, key)
		case "low":
			err = unpopulate(val, "Low", &c.Low)
			delete(rawMsg, key)
		case "medium":
			err = unpopulate(val, "Medium", &c.Medium)
			delete(rawMsg, key)
		case "profiles":
			err = unpopulate(val, "Profiles", &c.Profiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionURLType.
func (c ConnectionURLType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apexUrl", c.ApexURL)
	populate(objectMap, "databaseTransformsUrl", c.DatabaseTransformsURL)
	populate(objectMap, "graphStudioUrl", c.GraphStudioURL)
	populate(objectMap, "machineLearningNotebookUrl", c.MachineLearningNotebookURL)
	populate(objectMap, "mongoDbUrl", c.MongoDbURL)
	populate(objectMap, "ordsUrl", c.OrdsURL)
	populate(objectMap, "sqlDevWebUrl", c.SQLDevWebURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionURLType.
func (c *ConnectionURLType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apexUrl":
			err = unpopulate(val, "ApexURL", &c.ApexURL)
			delete(rawMsg, key)
		case "databaseTransformsUrl":
			err = unpopulate(val, "DatabaseTransformsURL", &c.DatabaseTransformsURL)
			delete(rawMsg, key)
		case "graphStudioUrl":
			err = unpopulate(val, "GraphStudioURL", &c.GraphStudioURL)
			delete(rawMsg, key)
		case "machineLearningNotebookUrl":
			err = unpopulate(val, "MachineLearningNotebookURL", &c.MachineLearningNotebookURL)
			delete(rawMsg, key)
		case "mongoDbUrl":
			err = unpopulate(val, "MongoDbURL", &c.MongoDbURL)
			delete(rawMsg, key)
		case "ordsUrl":
			err = unpopulate(val, "OrdsURL", &c.OrdsURL)
			delete(rawMsg, key)
		case "sqlDevWebUrl":
			err = unpopulate(val, "SQLDevWebURL", &c.SQLDevWebURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomerContact.
func (c CustomerContact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "email", c.Email)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomerContact.
func (c *CustomerContact) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "email":
			err = unpopulate(val, "Email", &c.Email)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateView.
func (d DNSPrivateView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateView.
func (d *DNSPrivateView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewListResult.
func (d DNSPrivateViewListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewListResult.
func (d *DNSPrivateViewListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateViewProperties.
func (d DNSPrivateViewProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populateDateTimeRFC3339(objectMap, "timeUpdated", d.TimeUpdated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateViewProperties.
func (d *DNSPrivateViewProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeUpdated":
			err = unpopulateDateTimeRFC3339(val, "TimeUpdated", &d.TimeUpdated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZone.
func (d DNSPrivateZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZone.
func (d *DNSPrivateZone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneListResult.
func (d DNSPrivateZoneListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneListResult.
func (d *DNSPrivateZoneListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSPrivateZoneProperties.
func (d DNSPrivateZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isProtected", d.IsProtected)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "self", d.Self)
	populate(objectMap, "serial", d.Serial)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "version", d.Version)
	populate(objectMap, "viewId", d.ViewID)
	populate(objectMap, "zoneType", d.ZoneType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSPrivateZoneProperties.
func (d *DNSPrivateZoneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isProtected":
			err = unpopulate(val, "IsProtected", &d.IsProtected)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "self":
			err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "serial":
			err = unpopulate(val, "Serial", &d.Serial)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &d.Version)
			delete(rawMsg, key)
		case "viewId":
			err = unpopulate(val, "ViewID", &d.ViewID)
			delete(rawMsg, key)
		case "zoneType":
			err = unpopulate(val, "ZoneType", &d.ZoneType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataCollectionOptions.
func (d DataCollectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDiagnosticsEventsEnabled", d.IsDiagnosticsEventsEnabled)
	populate(objectMap, "isHealthMonitoringEnabled", d.IsHealthMonitoringEnabled)
	populate(objectMap, "isIncidentLogsEnabled", d.IsIncidentLogsEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataCollectionOptions.
func (d *DataCollectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDiagnosticsEventsEnabled":
			err = unpopulate(val, "IsDiagnosticsEventsEnabled", &d.IsDiagnosticsEventsEnabled)
			delete(rawMsg, key)
		case "isHealthMonitoringEnabled":
			err = unpopulate(val, "IsHealthMonitoringEnabled", &d.IsHealthMonitoringEnabled)
			delete(rawMsg, key)
		case "isIncidentLogsEnabled":
			err = unpopulate(val, "IsIncidentLogsEnabled", &d.IsIncidentLogsEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DayOfWeek.
func (d DayOfWeek) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DayOfWeek.
func (d *DayOfWeek) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DayOfWeekUpdate.
func (d DayOfWeekUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DayOfWeekUpdate.
func (d *DayOfWeekUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbIormConfig.
func (d DbIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbName", d.DbName)
	populate(objectMap, "flashCacheLimit", d.FlashCacheLimit)
	populate(objectMap, "share", d.Share)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbIormConfig.
func (d *DbIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbName":
			err = unpopulate(val, "DbName", &d.DbName)
			delete(rawMsg, key)
		case "flashCacheLimit":
			err = unpopulate(val, "FlashCacheLimit", &d.FlashCacheLimit)
			delete(rawMsg, key)
		case "share":
			err = unpopulate(val, "Share", &d.Share)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNode.
func (d DbNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNode.
func (d *DbNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeAction.
func (d DbNodeAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "action", d.Action)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeAction.
func (d *DbNodeAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, "Action", &d.Action)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeListResult.
func (d DbNodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeListResult.
func (d *DbNodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbNodeProperties.
func (d DbNodeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDetails", d.AdditionalDetails)
	populate(objectMap, "backupIpId", d.BackupIPID)
	populate(objectMap, "backupVnic2Id", d.BackupVnic2ID)
	populate(objectMap, "backupVnicId", d.BackupVnicID)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerId", d.DbServerID)
	populate(objectMap, "dbSystemId", d.DbSystemID)
	populate(objectMap, "faultDomain", d.FaultDomain)
	populate(objectMap, "hostIpId", d.HostIPID)
	populate(objectMap, "hostname", d.Hostname)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "maintenanceType", d.MaintenanceType)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "softwareStorageSizeInGb", d.SoftwareStorageSizeInGb)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceWindowEnd", d.TimeMaintenanceWindowEnd)
	populateDateTimeRFC3339(objectMap, "timeMaintenanceWindowStart", d.TimeMaintenanceWindowStart)
	populate(objectMap, "vnic2Id", d.Vnic2ID)
	populate(objectMap, "vnicId", d.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbNodeProperties.
func (d *DbNodeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDetails":
			err = unpopulate(val, "AdditionalDetails", &d.AdditionalDetails)
			delete(rawMsg, key)
		case "backupIpId":
			err = unpopulate(val, "BackupIPID", &d.BackupIPID)
			delete(rawMsg, key)
		case "backupVnic2Id":
			err = unpopulate(val, "BackupVnic2ID", &d.BackupVnic2ID)
			delete(rawMsg, key)
		case "backupVnicId":
			err = unpopulate(val, "BackupVnicID", &d.BackupVnicID)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerId":
			err = unpopulate(val, "DbServerID", &d.DbServerID)
			delete(rawMsg, key)
		case "dbSystemId":
			err = unpopulate(val, "DbSystemID", &d.DbSystemID)
			delete(rawMsg, key)
		case "faultDomain":
			err = unpopulate(val, "FaultDomain", &d.FaultDomain)
			delete(rawMsg, key)
		case "hostIpId":
			err = unpopulate(val, "HostIPID", &d.HostIPID)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &d.Hostname)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "maintenanceType":
			err = unpopulate(val, "MaintenanceType", &d.MaintenanceType)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "softwareStorageSizeInGb":
			err = unpopulate(val, "SoftwareStorageSizeInGb", &d.SoftwareStorageSizeInGb)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "timeMaintenanceWindowEnd":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceWindowEnd", &d.TimeMaintenanceWindowEnd)
			delete(rawMsg, key)
		case "timeMaintenanceWindowStart":
			err = unpopulateDateTimeRFC3339(val, "TimeMaintenanceWindowStart", &d.TimeMaintenanceWindowStart)
			delete(rawMsg, key)
		case "vnic2Id":
			err = unpopulate(val, "Vnic2ID", &d.Vnic2ID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &d.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServer.
func (d DbServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServer.
func (d *DbServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerListResult.
func (d DbServerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerListResult.
func (d *DbServerListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerPatchingDetails.
func (d DbServerPatchingDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedPatchDuration", d.EstimatedPatchDuration)
	populate(objectMap, "patchingStatus", d.PatchingStatus)
	populateDateTimeRFC3339(objectMap, "timePatchingEnded", d.TimePatchingEnded)
	populateDateTimeRFC3339(objectMap, "timePatchingStarted", d.TimePatchingStarted)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerPatchingDetails.
func (d *DbServerPatchingDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedPatchDuration":
			err = unpopulate(val, "EstimatedPatchDuration", &d.EstimatedPatchDuration)
			delete(rawMsg, key)
		case "patchingStatus":
			err = unpopulate(val, "PatchingStatus", &d.PatchingStatus)
			delete(rawMsg, key)
		case "timePatchingEnded":
			err = unpopulateDateTimeRFC3339(val, "TimePatchingEnded", &d.TimePatchingEnded)
			delete(rawMsg, key)
		case "timePatchingStarted":
			err = unpopulateDateTimeRFC3339(val, "TimePatchingStarted", &d.TimePatchingStarted)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbServerProperties.
func (d DbServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autonomousVmClusterIds", d.AutonomousVMClusterIDs)
	populate(objectMap, "autonomousVirtualMachineIds", d.AutonomousVirtualMachineIDs)
	populate(objectMap, "cpuCoreCount", d.CPUCoreCount)
	populate(objectMap, "compartmentId", d.CompartmentID)
	populate(objectMap, "dbNodeIds", d.DbNodeIDs)
	populate(objectMap, "dbNodeStorageSizeInGbs", d.DbNodeStorageSizeInGbs)
	populate(objectMap, "dbServerPatchingDetails", d.DbServerPatchingDetails)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "exadataInfrastructureId", d.ExadataInfrastructureID)
	populate(objectMap, "lifecycleDetails", d.LifecycleDetails)
	populate(objectMap, "lifecycleState", d.LifecycleState)
	populate(objectMap, "maxCpuCount", d.MaxCPUCount)
	populate(objectMap, "maxDbNodeStorageInGbs", d.MaxDbNodeStorageInGbs)
	populate(objectMap, "maxMemoryInGbs", d.MaxMemoryInGbs)
	populate(objectMap, "memorySizeInGbs", d.MemorySizeInGbs)
	populate(objectMap, "ocid", d.Ocid)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "shape", d.Shape)
	populateDateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "vmClusterIds", d.VMClusterIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbServerProperties.
func (d *DbServerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autonomousVmClusterIds":
			err = unpopulate(val, "AutonomousVMClusterIDs", &d.AutonomousVMClusterIDs)
			delete(rawMsg, key)
		case "autonomousVirtualMachineIds":
			err = unpopulate(val, "AutonomousVirtualMachineIDs", &d.AutonomousVirtualMachineIDs)
			delete(rawMsg, key)
		case "cpuCoreCount":
			err = unpopulate(val, "CPUCoreCount", &d.CPUCoreCount)
			delete(rawMsg, key)
		case "compartmentId":
			err = unpopulate(val, "CompartmentID", &d.CompartmentID)
			delete(rawMsg, key)
		case "dbNodeIds":
			err = unpopulate(val, "DbNodeIDs", &d.DbNodeIDs)
			delete(rawMsg, key)
		case "dbNodeStorageSizeInGbs":
			err = unpopulate(val, "DbNodeStorageSizeInGbs", &d.DbNodeStorageSizeInGbs)
			delete(rawMsg, key)
		case "dbServerPatchingDetails":
			err = unpopulate(val, "DbServerPatchingDetails", &d.DbServerPatchingDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "exadataInfrastructureId":
			err = unpopulate(val, "ExadataInfrastructureID", &d.ExadataInfrastructureID)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &d.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &d.LifecycleState)
			delete(rawMsg, key)
		case "maxCpuCount":
			err = unpopulate(val, "MaxCPUCount", &d.MaxCPUCount)
			delete(rawMsg, key)
		case "maxDbNodeStorageInGbs":
			err = unpopulate(val, "MaxDbNodeStorageInGbs", &d.MaxDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "maxMemoryInGbs":
			err = unpopulate(val, "MaxMemoryInGbs", &d.MaxMemoryInGbs)
			delete(rawMsg, key)
		case "memorySizeInGbs":
			err = unpopulate(val, "MemorySizeInGbs", &d.MemorySizeInGbs)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &d.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "shape":
			err = unpopulate(val, "Shape", &d.Shape)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &d.TimeCreated)
			delete(rawMsg, key)
		case "vmClusterIds":
			err = unpopulate(val, "VMClusterIDs", &d.VMClusterIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShape.
func (d DbSystemShape) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShape.
func (d *DbSystemShape) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeListResult.
func (d DbSystemShapeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeListResult.
func (d *DbSystemShapeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DbSystemShapeProperties.
func (d DbSystemShapeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableCoreCount", d.AvailableCoreCount)
	populate(objectMap, "availableCoreCountPerNode", d.AvailableCoreCountPerNode)
	populate(objectMap, "availableDataStorageInTbs", d.AvailableDataStorageInTbs)
	populate(objectMap, "availableDataStoragePerServerInTbs", d.AvailableDataStoragePerServerInTbs)
	populate(objectMap, "availableDbNodePerNodeInGbs", d.AvailableDbNodePerNodeInGbs)
	populate(objectMap, "availableDbNodeStorageInGbs", d.AvailableDbNodeStorageInGbs)
	populate(objectMap, "availableMemoryInGbs", d.AvailableMemoryInGbs)
	populate(objectMap, "availableMemoryPerNodeInGbs", d.AvailableMemoryPerNodeInGbs)
	populate(objectMap, "coreCountIncrement", d.CoreCountIncrement)
	populate(objectMap, "maxStorageCount", d.MaxStorageCount)
	populate(objectMap, "maximumNodeCount", d.MaximumNodeCount)
	populate(objectMap, "minCoreCountPerNode", d.MinCoreCountPerNode)
	populate(objectMap, "minDataStorageInTbs", d.MinDataStorageInTbs)
	populate(objectMap, "minDbNodeStoragePerNodeInGbs", d.MinDbNodeStoragePerNodeInGbs)
	populate(objectMap, "minMemoryPerNodeInGbs", d.MinMemoryPerNodeInGbs)
	populate(objectMap, "minStorageCount", d.MinStorageCount)
	populate(objectMap, "minimumCoreCount", d.MinimumCoreCount)
	populate(objectMap, "minimumNodeCount", d.MinimumNodeCount)
	populate(objectMap, "runtimeMinimumCoreCount", d.RuntimeMinimumCoreCount)
	populate(objectMap, "shapeFamily", d.ShapeFamily)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DbSystemShapeProperties.
func (d *DbSystemShapeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableCoreCount":
			err = unpopulate(val, "AvailableCoreCount", &d.AvailableCoreCount)
			delete(rawMsg, key)
		case "availableCoreCountPerNode":
			err = unpopulate(val, "AvailableCoreCountPerNode", &d.AvailableCoreCountPerNode)
			delete(rawMsg, key)
		case "availableDataStorageInTbs":
			err = unpopulate(val, "AvailableDataStorageInTbs", &d.AvailableDataStorageInTbs)
			delete(rawMsg, key)
		case "availableDataStoragePerServerInTbs":
			err = unpopulate(val, "AvailableDataStoragePerServerInTbs", &d.AvailableDataStoragePerServerInTbs)
			delete(rawMsg, key)
		case "availableDbNodePerNodeInGbs":
			err = unpopulate(val, "AvailableDbNodePerNodeInGbs", &d.AvailableDbNodePerNodeInGbs)
			delete(rawMsg, key)
		case "availableDbNodeStorageInGbs":
			err = unpopulate(val, "AvailableDbNodeStorageInGbs", &d.AvailableDbNodeStorageInGbs)
			delete(rawMsg, key)
		case "availableMemoryInGbs":
			err = unpopulate(val, "AvailableMemoryInGbs", &d.AvailableMemoryInGbs)
			delete(rawMsg, key)
		case "availableMemoryPerNodeInGbs":
			err = unpopulate(val, "AvailableMemoryPerNodeInGbs", &d.AvailableMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "coreCountIncrement":
			err = unpopulate(val, "CoreCountIncrement", &d.CoreCountIncrement)
			delete(rawMsg, key)
		case "maxStorageCount":
			err = unpopulate(val, "MaxStorageCount", &d.MaxStorageCount)
			delete(rawMsg, key)
		case "maximumNodeCount":
			err = unpopulate(val, "MaximumNodeCount", &d.MaximumNodeCount)
			delete(rawMsg, key)
		case "minCoreCountPerNode":
			err = unpopulate(val, "MinCoreCountPerNode", &d.MinCoreCountPerNode)
			delete(rawMsg, key)
		case "minDataStorageInTbs":
			err = unpopulate(val, "MinDataStorageInTbs", &d.MinDataStorageInTbs)
			delete(rawMsg, key)
		case "minDbNodeStoragePerNodeInGbs":
			err = unpopulate(val, "MinDbNodeStoragePerNodeInGbs", &d.MinDbNodeStoragePerNodeInGbs)
			delete(rawMsg, key)
		case "minMemoryPerNodeInGbs":
			err = unpopulate(val, "MinMemoryPerNodeInGbs", &d.MinMemoryPerNodeInGbs)
			delete(rawMsg, key)
		case "minStorageCount":
			err = unpopulate(val, "MinStorageCount", &d.MinStorageCount)
			delete(rawMsg, key)
		case "minimumCoreCount":
			err = unpopulate(val, "MinimumCoreCount", &d.MinimumCoreCount)
			delete(rawMsg, key)
		case "minimumNodeCount":
			err = unpopulate(val, "MinimumNodeCount", &d.MinimumNodeCount)
			delete(rawMsg, key)
		case "runtimeMinimumCoreCount":
			err = unpopulate(val, "RuntimeMinimumCoreCount", &d.RuntimeMinimumCoreCount)
			delete(rawMsg, key)
		case "shapeFamily":
			err = unpopulate(val, "ShapeFamily", &d.ShapeFamily)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EstimatedPatchingTime.
func (e EstimatedPatchingTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedDbServerPatchingTime", e.EstimatedDbServerPatchingTime)
	populate(objectMap, "estimatedNetworkSwitchesPatchingTime", e.EstimatedNetworkSwitchesPatchingTime)
	populate(objectMap, "estimatedStorageServerPatchingTime", e.EstimatedStorageServerPatchingTime)
	populate(objectMap, "totalEstimatedPatchingTime", e.TotalEstimatedPatchingTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EstimatedPatchingTime.
func (e *EstimatedPatchingTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedDbServerPatchingTime":
			err = unpopulate(val, "EstimatedDbServerPatchingTime", &e.EstimatedDbServerPatchingTime)
			delete(rawMsg, key)
		case "estimatedNetworkSwitchesPatchingTime":
			err = unpopulate(val, "EstimatedNetworkSwitchesPatchingTime", &e.EstimatedNetworkSwitchesPatchingTime)
			delete(rawMsg, key)
		case "estimatedStorageServerPatchingTime":
			err = unpopulate(val, "EstimatedStorageServerPatchingTime", &e.EstimatedStorageServerPatchingTime)
			delete(rawMsg, key)
		case "totalEstimatedPatchingTime":
			err = unpopulate(val, "TotalEstimatedPatchingTime", &e.TotalEstimatedPatchingTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExadataIormConfig.
func (e ExadataIormConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dbPlans", e.DbPlans)
	populate(objectMap, "lifecycleDetails", e.LifecycleDetails)
	populate(objectMap, "lifecycleState", e.LifecycleState)
	populate(objectMap, "objective", e.Objective)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExadataIormConfig.
func (e *ExadataIormConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dbPlans":
			err = unpopulate(val, "DbPlans", &e.DbPlans)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &e.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &e.LifecycleState)
			delete(rawMsg, key)
		case "objective":
			err = unpopulate(val, "Objective", &e.Objective)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GenerateAutonomousDatabaseWalletDetails.
func (g GenerateAutonomousDatabaseWalletDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generateType", g.GenerateType)
	populate(objectMap, "isRegional", g.IsRegional)
	populate(objectMap, "password", g.Password)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenerateAutonomousDatabaseWalletDetails.
func (g *GenerateAutonomousDatabaseWalletDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generateType":
			err = unpopulate(val, "GenerateType", &g.GenerateType)
			delete(rawMsg, key)
		case "isRegional":
			err = unpopulate(val, "IsRegional", &g.IsRegional)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &g.Password)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersion.
func (g GiVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersion.
func (g *GiVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionListResult.
func (g GiVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionListResult.
func (g *GiVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GiVersionProperties.
func (g GiVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "version", g.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GiVersionProperties.
func (g *GiVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "version":
			err = unpopulate(val, "Version", &g.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongTermBackUpScheduleDetails.
func (l LongTermBackUpScheduleDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDisabled", l.IsDisabled)
	populate(objectMap, "repeatCadence", l.RepeatCadence)
	populate(objectMap, "retentionPeriodInDays", l.RetentionPeriodInDays)
	populateDateTimeRFC3339(objectMap, "timeOfBackup", l.TimeOfBackup)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongTermBackUpScheduleDetails.
func (l *LongTermBackUpScheduleDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDisabled":
			err = unpopulate(val, "IsDisabled", &l.IsDisabled)
			delete(rawMsg, key)
		case "repeatCadence":
			err = unpopulate(val, "RepeatCadence", &l.RepeatCadence)
			delete(rawMsg, key)
		case "retentionPeriodInDays":
			err = unpopulate(val, "RetentionPeriodInDays", &l.RetentionPeriodInDays)
			delete(rawMsg, key)
		case "timeOfBackup":
			err = unpopulateDateTimeRFC3339(val, "TimeOfBackup", &l.TimeOfBackup)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindow.
func (m MaintenanceWindow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customActionTimeoutInMins", m.CustomActionTimeoutInMins)
	populate(objectMap, "daysOfWeek", m.DaysOfWeek)
	populate(objectMap, "hoursOfDay", m.HoursOfDay)
	populate(objectMap, "isCustomActionTimeoutEnabled", m.IsCustomActionTimeoutEnabled)
	populate(objectMap, "isMonthlyPatchingEnabled", m.IsMonthlyPatchingEnabled)
	populate(objectMap, "leadTimeInWeeks", m.LeadTimeInWeeks)
	populate(objectMap, "months", m.Months)
	populate(objectMap, "patchingMode", m.PatchingMode)
	populate(objectMap, "preference", m.Preference)
	populate(objectMap, "weeksOfMonth", m.WeeksOfMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceWindow.
func (m *MaintenanceWindow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customActionTimeoutInMins":
			err = unpopulate(val, "CustomActionTimeoutInMins", &m.CustomActionTimeoutInMins)
			delete(rawMsg, key)
		case "daysOfWeek":
			err = unpopulate(val, "DaysOfWeek", &m.DaysOfWeek)
			delete(rawMsg, key)
		case "hoursOfDay":
			err = unpopulate(val, "HoursOfDay", &m.HoursOfDay)
			delete(rawMsg, key)
		case "isCustomActionTimeoutEnabled":
			err = unpopulate(val, "IsCustomActionTimeoutEnabled", &m.IsCustomActionTimeoutEnabled)
			delete(rawMsg, key)
		case "isMonthlyPatchingEnabled":
			err = unpopulate(val, "IsMonthlyPatchingEnabled", &m.IsMonthlyPatchingEnabled)
			delete(rawMsg, key)
		case "leadTimeInWeeks":
			err = unpopulate(val, "LeadTimeInWeeks", &m.LeadTimeInWeeks)
			delete(rawMsg, key)
		case "months":
			err = unpopulate(val, "Months", &m.Months)
			delete(rawMsg, key)
		case "patchingMode":
			err = unpopulate(val, "PatchingMode", &m.PatchingMode)
			delete(rawMsg, key)
		case "preference":
			err = unpopulate(val, "Preference", &m.Preference)
			delete(rawMsg, key)
		case "weeksOfMonth":
			err = unpopulate(val, "WeeksOfMonth", &m.WeeksOfMonth)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Month.
func (m Month) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Month.
func (m *Month) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NsgCidr.
func (n NsgCidr) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destinationPortRange", n.DestinationPortRange)
	populate(objectMap, "source", n.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NsgCidr.
func (n *NsgCidr) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destinationPortRange":
			err = unpopulate(val, "DestinationPortRange", &n.DestinationPortRange)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &n.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscription.
func (o OracleSubscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscription.
func (o *OracleSubscription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionListResult.
func (o OracleSubscriptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionListResult.
func (o *OracleSubscriptionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionProperties.
func (o OracleSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloudAccountId", o.CloudAccountID)
	populate(objectMap, "cloudAccountState", o.CloudAccountState)
	populate(objectMap, "intent", o.Intent)
	populate(objectMap, "productCode", o.ProductCode)
	populate(objectMap, "provisioningState", o.ProvisioningState)
	populate(objectMap, "saasSubscriptionId", o.SaasSubscriptionID)
	populate(objectMap, "termUnit", o.TermUnit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionProperties.
func (o *OracleSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudAccountId":
			err = unpopulate(val, "CloudAccountID", &o.CloudAccountID)
			delete(rawMsg, key)
		case "cloudAccountState":
			err = unpopulate(val, "CloudAccountState", &o.CloudAccountState)
			delete(rawMsg, key)
		case "intent":
			err = unpopulate(val, "Intent", &o.Intent)
			delete(rawMsg, key)
		case "productCode":
			err = unpopulate(val, "ProductCode", &o.ProductCode)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &o.ProvisioningState)
			delete(rawMsg, key)
		case "saasSubscriptionId":
			err = unpopulate(val, "SaasSubscriptionID", &o.SaasSubscriptionID)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &o.TermUnit)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdate.
func (o OracleSubscriptionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "plan", o.Plan)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdate.
func (o *OracleSubscriptionUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "plan":
			err = unpopulate(val, "Plan", &o.Plan)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OracleSubscriptionUpdateProperties.
func (o OracleSubscriptionUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "intent", o.Intent)
	populate(objectMap, "productCode", o.ProductCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSubscriptionUpdateProperties.
func (o *OracleSubscriptionUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "intent":
			err = unpopulate(val, "Intent", &o.Intent)
			delete(rawMsg, key)
		case "productCode":
			err = unpopulate(val, "ProductCode", &o.ProductCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PeerDbDetails.
func (p PeerDbDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "peerDbId", p.PeerDbID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PeerDbDetails.
func (p *PeerDbDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "peerDbId":
			err = unpopulate(val, "PeerDbID", &p.PeerDbID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Plan.
func (p Plan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "promotionCode", p.PromotionCode)
	populate(objectMap, "publisher", p.Publisher)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Plan.
func (p *Plan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &p.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlanUpdate.
func (p PlanUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "promotionCode", p.PromotionCode)
	populate(objectMap, "publisher", p.Publisher)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlanUpdate.
func (p *PlanUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &p.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PortRange.
func (p PortRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "max", p.Max)
	populate(objectMap, "min", p.Min)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PortRange.
func (p *PortRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "max":
			err = unpopulate(val, "Max", &p.Max)
			delete(rawMsg, key)
		case "min":
			err = unpopulate(val, "Min", &p.Min)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressProperties.
func (p PrivateIPAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "hostnameLabel", p.HostnameLabel)
	populate(objectMap, "ipAddress", p.IPAddress)
	populate(objectMap, "ocid", p.Ocid)
	populate(objectMap, "subnetId", p.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressProperties.
func (p *PrivateIPAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "hostnameLabel":
			err = unpopulate(val, "HostnameLabel", &p.HostnameLabel)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &p.IPAddress)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &p.Ocid)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateIPAddressesFilter.
func (p PrivateIPAddressesFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "subnetId", p.SubnetID)
	populate(objectMap, "vnicId", p.VnicID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateIPAddressesFilter.
func (p *PrivateIPAddressesFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "subnetId":
			err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		case "vnicId":
			err = unpopulate(val, "VnicID", &p.VnicID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProfileType.
func (p ProfileType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "consumerGroup", p.ConsumerGroup)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "hostFormat", p.HostFormat)
	populate(objectMap, "isRegional", p.IsRegional)
	populate(objectMap, "protocol", p.Protocol)
	populate(objectMap, "sessionMode", p.SessionMode)
	populate(objectMap, "syntaxFormat", p.SyntaxFormat)
	populate(objectMap, "tlsAuthentication", p.TLSAuthentication)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProfileType.
func (p *ProfileType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consumerGroup":
			err = unpopulate(val, "ConsumerGroup", &p.ConsumerGroup)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "hostFormat":
			err = unpopulate(val, "HostFormat", &p.HostFormat)
			delete(rawMsg, key)
		case "isRegional":
			err = unpopulate(val, "IsRegional", &p.IsRegional)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &p.Protocol)
			delete(rawMsg, key)
		case "sessionMode":
			err = unpopulate(val, "SessionMode", &p.SessionMode)
			delete(rawMsg, key)
		case "syntaxFormat":
			err = unpopulate(val, "SyntaxFormat", &p.SyntaxFormat)
			delete(rawMsg, key)
		case "tlsAuthentication":
			err = unpopulate(val, "TLSAuthentication", &p.TLSAuthentication)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreAutonomousDatabaseDetails.
func (r RestoreAutonomousDatabaseDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "timestamp", r.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreAutonomousDatabaseDetails.
func (r *RestoreAutonomousDatabaseDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateDateTimeRFC3339(val, "Timestamp", &r.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SaasSubscriptionDetails.
func (s SaasSubscriptionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "isAutoRenew", s.IsAutoRenew)
	populate(objectMap, "isFreeTrial", s.IsFreeTrial)
	populate(objectMap, "offerId", s.OfferID)
	populate(objectMap, "planId", s.PlanID)
	populate(objectMap, "publisherId", s.PublisherID)
	populate(objectMap, "purchaserEmailId", s.PurchaserEmailID)
	populate(objectMap, "purchaserTenantId", s.PurchaserTenantID)
	populate(objectMap, "saasSubscriptionStatus", s.SaasSubscriptionStatus)
	populate(objectMap, "subscriptionName", s.SubscriptionName)
	populate(objectMap, "termUnit", s.TermUnit)
	populateDateTimeRFC3339(objectMap, "timeCreated", s.TimeCreated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SaasSubscriptionDetails.
func (s *SaasSubscriptionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "isAutoRenew":
			err = unpopulate(val, "IsAutoRenew", &s.IsAutoRenew)
			delete(rawMsg, key)
		case "isFreeTrial":
			err = unpopulate(val, "IsFreeTrial", &s.IsFreeTrial)
			delete(rawMsg, key)
		case "offerId":
			err = unpopulate(val, "OfferID", &s.OfferID)
			delete(rawMsg, key)
		case "planId":
			err = unpopulate(val, "PlanID", &s.PlanID)
			delete(rawMsg, key)
		case "publisherId":
			err = unpopulate(val, "PublisherID", &s.PublisherID)
			delete(rawMsg, key)
		case "purchaserEmailId":
			err = unpopulate(val, "PurchaserEmailID", &s.PurchaserEmailID)
			delete(rawMsg, key)
		case "purchaserTenantId":
			err = unpopulate(val, "PurchaserTenantID", &s.PurchaserTenantID)
			delete(rawMsg, key)
		case "saasSubscriptionStatus":
			err = unpopulate(val, "SaasSubscriptionStatus", &s.SaasSubscriptionStatus)
			delete(rawMsg, key)
		case "subscriptionName":
			err = unpopulate(val, "SubscriptionName", &s.SubscriptionName)
			delete(rawMsg, key)
		case "termUnit":
			err = unpopulate(val, "TermUnit", &s.TermUnit)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateDateTimeRFC3339(val, "TimeCreated", &s.TimeCreated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledOperationsType.
func (s ScheduledOperationsType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dayOfWeek", s.DayOfWeek)
	populate(objectMap, "scheduledStartTime", s.ScheduledStartTime)
	populate(objectMap, "scheduledStopTime", s.ScheduledStopTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledOperationsType.
func (s *ScheduledOperationsType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dayOfWeek":
			err = unpopulate(val, "DayOfWeek", &s.DayOfWeek)
			delete(rawMsg, key)
		case "scheduledStartTime":
			err = unpopulate(val, "ScheduledStartTime", &s.ScheduledStartTime)
			delete(rawMsg, key)
		case "scheduledStopTime":
			err = unpopulate(val, "ScheduledStopTime", &s.ScheduledStopTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledOperationsTypeUpdate.
func (s ScheduledOperationsTypeUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dayOfWeek", s.DayOfWeek)
	populate(objectMap, "scheduledStartTime", s.ScheduledStartTime)
	populate(objectMap, "scheduledStopTime", s.ScheduledStopTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledOperationsTypeUpdate.
func (s *ScheduledOperationsTypeUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dayOfWeek":
			err = unpopulate(val, "DayOfWeek", &s.DayOfWeek)
			delete(rawMsg, key)
		case "scheduledStartTime":
			err = unpopulate(val, "ScheduledStartTime", &s.ScheduledStartTime)
			delete(rawMsg, key)
		case "scheduledStopTime":
			err = unpopulate(val, "ScheduledStopTime", &s.ScheduledStopTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersion.
func (s SystemVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersion.
func (s *SystemVersion) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersionListResult.
func (s SystemVersionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersionListResult.
func (s *SystemVersionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemVersionProperties.
func (s SystemVersionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "systemVersion", s.SystemVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemVersionProperties.
func (s *SystemVersionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "systemVersion":
			err = unpopulate(val, "SystemVersion", &s.SystemVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddress.
func (v VirtualNetworkAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddress.
func (v *VirtualNetworkAddress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressListResult.
func (v VirtualNetworkAddressListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressListResult.
func (v *VirtualNetworkAddressListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAddressProperties.
func (v VirtualNetworkAddressProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domain", v.Domain)
	populate(objectMap, "ipAddress", v.IPAddress)
	populate(objectMap, "lifecycleDetails", v.LifecycleDetails)
	populate(objectMap, "lifecycleState", v.LifecycleState)
	populate(objectMap, "ocid", v.Ocid)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populateDateTimeRFC3339(objectMap, "timeAssigned", v.TimeAssigned)
	populate(objectMap, "vmOcid", v.VMOcid)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAddressProperties.
func (v *VirtualNetworkAddressProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			err = unpopulate(val, "Domain", &v.Domain)
			delete(rawMsg, key)
		case "ipAddress":
			err = unpopulate(val, "IPAddress", &v.IPAddress)
			delete(rawMsg, key)
		case "lifecycleDetails":
			err = unpopulate(val, "LifecycleDetails", &v.LifecycleDetails)
			delete(rawMsg, key)
		case "lifecycleState":
			err = unpopulate(val, "LifecycleState", &v.LifecycleState)
			delete(rawMsg, key)
		case "ocid":
			err = unpopulate(val, "Ocid", &v.Ocid)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "timeAssigned":
			err = unpopulateDateTimeRFC3339(val, "TimeAssigned", &v.TimeAssigned)
			delete(rawMsg, key)
		case "vmOcid":
			err = unpopulate(val, "VMOcid", &v.VMOcid)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
