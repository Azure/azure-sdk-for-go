//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AttestationsClientListForResourceGroupPager provides operations for iterating over paged responses.
type AttestationsClientListForResourceGroupPager struct {
	client    *AttestationsClient
	current   AttestationsClientListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AttestationsClientListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AttestationsClientListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AttestationsClientListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AttestationListResult.NextLink == nil || len(*p.current.AttestationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AttestationsClientListForResourceGroupResponse page.
func (p *AttestationsClientListForResourceGroupPager) PageResponse() AttestationsClientListForResourceGroupResponse {
	return p.current
}

// AttestationsClientListForResourcePager provides operations for iterating over paged responses.
type AttestationsClientListForResourcePager struct {
	client    *AttestationsClient
	current   AttestationsClientListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AttestationsClientListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AttestationsClientListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AttestationsClientListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AttestationListResult.NextLink == nil || len(*p.current.AttestationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AttestationsClientListForResourceResponse page.
func (p *AttestationsClientListForResourcePager) PageResponse() AttestationsClientListForResourceResponse {
	return p.current
}

// AttestationsClientListForSubscriptionPager provides operations for iterating over paged responses.
type AttestationsClientListForSubscriptionPager struct {
	client    *AttestationsClient
	current   AttestationsClientListForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AttestationsClientListForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AttestationsClientListForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AttestationsClientListForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AttestationListResult.NextLink == nil || len(*p.current.AttestationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AttestationsClientListForSubscriptionResponse page.
func (p *AttestationsClientListForSubscriptionPager) PageResponse() AttestationsClientListForSubscriptionResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForManagementGroupPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForManagementGroupPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForManagementGroupResponse page.
func (p *PolicyEventsClientListQueryResultsForManagementGroupPager) PageResponse() PolicyEventsClientListQueryResultsForManagementGroupResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForPolicyDefinitionPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForPolicyDefinitionPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForPolicyDefinitionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForPolicyDefinitionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForPolicyDefinitionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForPolicyDefinitionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForPolicyDefinitionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForPolicyDefinitionResponse page.
func (p *PolicyEventsClientListQueryResultsForPolicyDefinitionPager) PageResponse() PolicyEventsClientListQueryResultsForPolicyDefinitionResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForPolicySetDefinitionPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForPolicySetDefinitionPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForPolicySetDefinitionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForPolicySetDefinitionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForPolicySetDefinitionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse page.
func (p *PolicyEventsClientListQueryResultsForPolicySetDefinitionPager) PageResponse() PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse page.
func (p *PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) PageResponse() PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForResourceGroupPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForResourceGroupPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForResourceGroupResponse page.
func (p *PolicyEventsClientListQueryResultsForResourceGroupPager) PageResponse() PolicyEventsClientListQueryResultsForResourceGroupResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForResourcePager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForResourcePager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForResourceResponse page.
func (p *PolicyEventsClientListQueryResultsForResourcePager) PageResponse() PolicyEventsClientListQueryResultsForResourceResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse page.
func (p *PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) PageResponse() PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse {
	return p.current
}

// PolicyEventsClientListQueryResultsForSubscriptionPager provides operations for iterating over paged responses.
type PolicyEventsClientListQueryResultsForSubscriptionPager struct {
	client    *PolicyEventsClient
	current   PolicyEventsClientListQueryResultsForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyEventsClientListQueryResultsForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyEventsClientListQueryResultsForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyEventsClientListQueryResultsForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyEventsQueryResults.ODataNextLink == nil || len(*p.current.PolicyEventsQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyEventsClientListQueryResultsForSubscriptionResponse page.
func (p *PolicyEventsClientListQueryResultsForSubscriptionPager) PageResponse() PolicyEventsClientListQueryResultsForSubscriptionResponse {
	return p.current
}

// PolicyMetadataClientListPager provides operations for iterating over paged responses.
type PolicyMetadataClientListPager struct {
	client    *PolicyMetadataClient
	current   PolicyMetadataClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyMetadataClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyMetadataClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyMetadataClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyMetadataCollection.NextLink == nil || len(*p.current.PolicyMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyMetadataClientListResponse page.
func (p *PolicyMetadataClientListPager) PageResponse() PolicyMetadataClientListResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForManagementGroupPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForManagementGroupPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForManagementGroupResponse page.
func (p *PolicyStatesClientListQueryResultsForManagementGroupPager) PageResponse() PolicyStatesClientListQueryResultsForManagementGroupResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForPolicyDefinitionPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForPolicyDefinitionPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForPolicyDefinitionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForPolicyDefinitionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForPolicyDefinitionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForPolicyDefinitionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForPolicyDefinitionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForPolicyDefinitionResponse page.
func (p *PolicyStatesClientListQueryResultsForPolicyDefinitionPager) PageResponse() PolicyStatesClientListQueryResultsForPolicyDefinitionResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForPolicySetDefinitionPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForPolicySetDefinitionPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForPolicySetDefinitionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForPolicySetDefinitionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForPolicySetDefinitionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse page.
func (p *PolicyStatesClientListQueryResultsForPolicySetDefinitionPager) PageResponse() PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse page.
func (p *PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager) PageResponse() PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForResourceGroupPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForResourceGroupPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForResourceGroupResponse page.
func (p *PolicyStatesClientListQueryResultsForResourceGroupPager) PageResponse() PolicyStatesClientListQueryResultsForResourceGroupResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForResourcePager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForResourcePager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForResourceResponse page.
func (p *PolicyStatesClientListQueryResultsForResourcePager) PageResponse() PolicyStatesClientListQueryResultsForResourceResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse page.
func (p *PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager) PageResponse() PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse {
	return p.current
}

// PolicyStatesClientListQueryResultsForSubscriptionPager provides operations for iterating over paged responses.
type PolicyStatesClientListQueryResultsForSubscriptionPager struct {
	client    *PolicyStatesClient
	current   PolicyStatesClientListQueryResultsForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyStatesClientListQueryResultsForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyStatesClientListQueryResultsForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyStatesClientListQueryResultsForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyStatesQueryResults.ODataNextLink == nil || len(*p.current.PolicyStatesQueryResults.ODataNextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyStatesClientListQueryResultsForSubscriptionResponse page.
func (p *PolicyStatesClientListQueryResultsForSubscriptionPager) PageResponse() PolicyStatesClientListQueryResultsForSubscriptionResponse {
	return p.current
}

// PolicyTrackedResourcesClientListQueryResultsForManagementGroupPager provides operations for iterating over paged responses.
type PolicyTrackedResourcesClientListQueryResultsForManagementGroupPager struct {
	client    *PolicyTrackedResourcesClient
	current   PolicyTrackedResourcesClientListQueryResultsForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyTrackedResourcesClientListQueryResultsForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyTrackedResourcesClientListQueryResultsForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyTrackedResourcesClientListQueryResultsForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyTrackedResourcesQueryResults.NextLink == nil || len(*p.current.PolicyTrackedResourcesQueryResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyTrackedResourcesClientListQueryResultsForManagementGroupResponse page.
func (p *PolicyTrackedResourcesClientListQueryResultsForManagementGroupPager) PageResponse() PolicyTrackedResourcesClientListQueryResultsForManagementGroupResponse {
	return p.current
}

// PolicyTrackedResourcesClientListQueryResultsForResourceGroupPager provides operations for iterating over paged responses.
type PolicyTrackedResourcesClientListQueryResultsForResourceGroupPager struct {
	client    *PolicyTrackedResourcesClient
	current   PolicyTrackedResourcesClientListQueryResultsForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyTrackedResourcesClientListQueryResultsForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyTrackedResourcesQueryResults.NextLink == nil || len(*p.current.PolicyTrackedResourcesQueryResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyTrackedResourcesClientListQueryResultsForResourceGroupResponse page.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourceGroupPager) PageResponse() PolicyTrackedResourcesClientListQueryResultsForResourceGroupResponse {
	return p.current
}

// PolicyTrackedResourcesClientListQueryResultsForResourcePager provides operations for iterating over paged responses.
type PolicyTrackedResourcesClientListQueryResultsForResourcePager struct {
	client    *PolicyTrackedResourcesClient
	current   PolicyTrackedResourcesClientListQueryResultsForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyTrackedResourcesClientListQueryResultsForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyTrackedResourcesQueryResults.NextLink == nil || len(*p.current.PolicyTrackedResourcesQueryResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyTrackedResourcesClientListQueryResultsForResourceResponse page.
func (p *PolicyTrackedResourcesClientListQueryResultsForResourcePager) PageResponse() PolicyTrackedResourcesClientListQueryResultsForResourceResponse {
	return p.current
}

// PolicyTrackedResourcesClientListQueryResultsForSubscriptionPager provides operations for iterating over paged responses.
type PolicyTrackedResourcesClientListQueryResultsForSubscriptionPager struct {
	client    *PolicyTrackedResourcesClient
	current   PolicyTrackedResourcesClientListQueryResultsForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PolicyTrackedResourcesClientListQueryResultsForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PolicyTrackedResourcesClientListQueryResultsForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PolicyTrackedResourcesClientListQueryResultsForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyTrackedResourcesQueryResults.NextLink == nil || len(*p.current.PolicyTrackedResourcesQueryResults.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listQueryResultsForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PolicyTrackedResourcesClientListQueryResultsForSubscriptionResponse page.
func (p *PolicyTrackedResourcesClientListQueryResultsForSubscriptionPager) PageResponse() PolicyTrackedResourcesClientListQueryResultsForSubscriptionResponse {
	return p.current
}

// RemediationsClientListDeploymentsAtManagementGroupPager provides operations for iterating over paged responses.
type RemediationsClientListDeploymentsAtManagementGroupPager struct {
	client    *RemediationsClient
	current   RemediationsClientListDeploymentsAtManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListDeploymentsAtManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListDeploymentsAtManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListDeploymentsAtManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationDeploymentsListResult.NextLink == nil || len(*p.current.RemediationDeploymentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsAtManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListDeploymentsAtManagementGroupResponse page.
func (p *RemediationsClientListDeploymentsAtManagementGroupPager) PageResponse() RemediationsClientListDeploymentsAtManagementGroupResponse {
	return p.current
}

// RemediationsClientListDeploymentsAtResourceGroupPager provides operations for iterating over paged responses.
type RemediationsClientListDeploymentsAtResourceGroupPager struct {
	client    *RemediationsClient
	current   RemediationsClientListDeploymentsAtResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListDeploymentsAtResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListDeploymentsAtResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListDeploymentsAtResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationDeploymentsListResult.NextLink == nil || len(*p.current.RemediationDeploymentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsAtResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListDeploymentsAtResourceGroupResponse page.
func (p *RemediationsClientListDeploymentsAtResourceGroupPager) PageResponse() RemediationsClientListDeploymentsAtResourceGroupResponse {
	return p.current
}

// RemediationsClientListDeploymentsAtResourcePager provides operations for iterating over paged responses.
type RemediationsClientListDeploymentsAtResourcePager struct {
	client    *RemediationsClient
	current   RemediationsClientListDeploymentsAtResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListDeploymentsAtResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListDeploymentsAtResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListDeploymentsAtResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationDeploymentsListResult.NextLink == nil || len(*p.current.RemediationDeploymentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsAtResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListDeploymentsAtResourceResponse page.
func (p *RemediationsClientListDeploymentsAtResourcePager) PageResponse() RemediationsClientListDeploymentsAtResourceResponse {
	return p.current
}

// RemediationsClientListDeploymentsAtSubscriptionPager provides operations for iterating over paged responses.
type RemediationsClientListDeploymentsAtSubscriptionPager struct {
	client    *RemediationsClient
	current   RemediationsClientListDeploymentsAtSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListDeploymentsAtSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListDeploymentsAtSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListDeploymentsAtSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationDeploymentsListResult.NextLink == nil || len(*p.current.RemediationDeploymentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listDeploymentsAtSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListDeploymentsAtSubscriptionResponse page.
func (p *RemediationsClientListDeploymentsAtSubscriptionPager) PageResponse() RemediationsClientListDeploymentsAtSubscriptionResponse {
	return p.current
}

// RemediationsClientListForManagementGroupPager provides operations for iterating over paged responses.
type RemediationsClientListForManagementGroupPager struct {
	client    *RemediationsClient
	current   RemediationsClientListForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationListResult.NextLink == nil || len(*p.current.RemediationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListForManagementGroupResponse page.
func (p *RemediationsClientListForManagementGroupPager) PageResponse() RemediationsClientListForManagementGroupResponse {
	return p.current
}

// RemediationsClientListForResourceGroupPager provides operations for iterating over paged responses.
type RemediationsClientListForResourceGroupPager struct {
	client    *RemediationsClient
	current   RemediationsClientListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationListResult.NextLink == nil || len(*p.current.RemediationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListForResourceGroupResponse page.
func (p *RemediationsClientListForResourceGroupPager) PageResponse() RemediationsClientListForResourceGroupResponse {
	return p.current
}

// RemediationsClientListForResourcePager provides operations for iterating over paged responses.
type RemediationsClientListForResourcePager struct {
	client    *RemediationsClient
	current   RemediationsClientListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationListResult.NextLink == nil || len(*p.current.RemediationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListForResourceResponse page.
func (p *RemediationsClientListForResourcePager) PageResponse() RemediationsClientListForResourceResponse {
	return p.current
}

// RemediationsClientListForSubscriptionPager provides operations for iterating over paged responses.
type RemediationsClientListForSubscriptionPager struct {
	client    *RemediationsClient
	current   RemediationsClientListForSubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RemediationsClientListForSubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RemediationsClientListForSubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RemediationsClientListForSubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RemediationListResult.NextLink == nil || len(*p.current.RemediationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForSubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RemediationsClientListForSubscriptionResponse page.
func (p *RemediationsClientListForSubscriptionPager) PageResponse() RemediationsClientListForSubscriptionResponse {
	return p.current
}
