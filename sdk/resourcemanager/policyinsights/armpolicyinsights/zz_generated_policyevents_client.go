//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PolicyEventsClient contains the methods for the PolicyEvents group.
// Don't use this type directly, use NewPolicyEventsClient() instead.
type PolicyEventsClient struct {
	host string
	pl   runtime.Pipeline
}

// NewPolicyEventsClient creates a new instance of PolicyEventsClient with the specified values.
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewPolicyEventsClient(credential azcore.TokenCredential, options *arm.ClientOptions) *PolicyEventsClient {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := options.Endpoint
	if len(ep) == 0 {
		ep = arm.AzurePublicCloud
	}
	client := &PolicyEventsClient{
		host: string(ep),
		pl:   armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options),
	}
	return client
}

// ListQueryResultsForManagementGroup - Queries policy events for the resources under the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// managementGroupName - Management group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForManagementGroup(policyEventsResource PolicyEventsResourceType, managementGroupName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForManagementGroupPager {
	return &PolicyEventsClientListQueryResultsForManagementGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForManagementGroupCreateRequest(ctx, policyEventsResource, managementGroupName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForManagementGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForManagementGroupCreateRequest creates the ListQueryResultsForManagementGroup request.
func (client *PolicyEventsClient) listQueryResultsForManagementGroupCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, managementGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupName == "" {
		return nil, errors.New("parameter managementGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupName}", url.PathEscape(managementGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForManagementGroupHandleResponse handles the ListQueryResultsForManagementGroup response.
func (client *PolicyEventsClient) listQueryResultsForManagementGroupHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForManagementGroupResponse, error) {
	result := PolicyEventsClientListQueryResultsForManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForManagementGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicyDefinition - Queries policy events for the subscription level policy definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// policyDefinitionName - Policy definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForPolicyDefinition(policyEventsResource PolicyEventsResourceType, subscriptionID string, policyDefinitionName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForPolicyDefinitionPager {
	return &PolicyEventsClientListQueryResultsForPolicyDefinitionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForPolicyDefinitionCreateRequest(ctx, policyEventsResource, subscriptionID, policyDefinitionName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForPolicyDefinitionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForPolicyDefinitionCreateRequest creates the ListQueryResultsForPolicyDefinition request.
func (client *PolicyEventsClient) listQueryResultsForPolicyDefinitionCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, policyDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape("Microsoft.Authorization"))
	if policyDefinitionName == "" {
		return nil, errors.New("parameter policyDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyDefinitionName}", url.PathEscape(policyDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicyDefinitionHandleResponse handles the ListQueryResultsForPolicyDefinition response.
func (client *PolicyEventsClient) listQueryResultsForPolicyDefinitionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForPolicyDefinitionResponse, error) {
	result := PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicySetDefinition - Queries policy events for the subscription level policy set definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// policySetDefinitionName - Policy set definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForPolicySetDefinition(policyEventsResource PolicyEventsResourceType, subscriptionID string, policySetDefinitionName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForPolicySetDefinitionPager {
	return &PolicyEventsClientListQueryResultsForPolicySetDefinitionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForPolicySetDefinitionCreateRequest(ctx, policyEventsResource, subscriptionID, policySetDefinitionName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForPolicySetDefinitionCreateRequest creates the ListQueryResultsForPolicySetDefinition request.
func (client *PolicyEventsClient) listQueryResultsForPolicySetDefinitionCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, policySetDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape("Microsoft.Authorization"))
	if policySetDefinitionName == "" {
		return nil, errors.New("parameter policySetDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policySetDefinitionName}", url.PathEscape(policySetDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicySetDefinitionHandleResponse handles the ListQueryResultsForPolicySetDefinition response.
func (client *PolicyEventsClient) listQueryResultsForPolicySetDefinitionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse, error) {
	result := PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResource - Queries policy events for the resource.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// resourceID - Resource ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResource(policyEventsResource PolicyEventsResourceType, resourceID string, options *QueryOptions) *PolicyEventsClientListQueryResultsForResourcePager {
	return &PolicyEventsClientListQueryResultsForResourcePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForResourceCreateRequest(ctx, policyEventsResource, resourceID, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForResourceResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForResourceCreateRequest creates the ListQueryResultsForResource request.
func (client *PolicyEventsClient) listQueryResultsForResourceCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, resourceID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceHandleResponse handles the ListQueryResultsForResource response.
func (client *PolicyEventsClient) listQueryResultsForResourceHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroup - Queries policy events for the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResourceGroup(policyEventsResource PolicyEventsResourceType, subscriptionID string, resourceGroupName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForResourceGroupPager {
	return &PolicyEventsClientListQueryResultsForResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForResourceGroupCreateRequest(ctx, policyEventsResource, subscriptionID, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForResourceGroupCreateRequest creates the ListQueryResultsForResourceGroup request.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, resourceGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupHandleResponse handles the ListQueryResultsForResourceGroup response.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceGroupResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroupLevelPolicyAssignment - Queries policy events for the resource group level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResourceGroupLevelPolicyAssignment(policyEventsResource PolicyEventsResourceType, subscriptionID string, resourceGroupName string, policyAssignmentName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager {
	return &PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx, policyEventsResource, subscriptionID, resourceGroupName, policyAssignmentName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForResourceGroupLevelPolicyAssignment request.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, resourceGroupName string, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape("Microsoft.Authorization"))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForResourceGroupLevelPolicyAssignment response.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscription - Queries policy events for the resources under the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForSubscription(policyEventsResource PolicyEventsResourceType, subscriptionID string, options *QueryOptions) *PolicyEventsClientListQueryResultsForSubscriptionPager {
	return &PolicyEventsClientListQueryResultsForSubscriptionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForSubscriptionCreateRequest(ctx, policyEventsResource, subscriptionID, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForSubscriptionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForSubscriptionCreateRequest creates the ListQueryResultsForSubscription request.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionHandleResponse handles the ListQueryResultsForSubscription response.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForSubscriptionResponse, error) {
	result := PolicyEventsClientListQueryResultsForSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForSubscriptionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscriptionLevelPolicyAssignment - Queries policy events for the subscription level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForSubscriptionLevelPolicyAssignment(policyEventsResource PolicyEventsResourceType, subscriptionID string, policyAssignmentName string, options *QueryOptions) *PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager {
	return &PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx, policyEventsResource, subscriptionID, policyAssignmentName, options)
		},
		advancer: func(ctx context.Context, resp PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PolicyEventsQueryResults.ODataNextLink)
		},
	}
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForSubscriptionLevelPolicyAssignment request.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx context.Context, policyEventsResource PolicyEventsResourceType, subscriptionID string, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape("Microsoft.Authorization"))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForSubscriptionLevelPolicyAssignment response.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse, error) {
	result := PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}
