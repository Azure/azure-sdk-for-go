//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/cloud"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// RemediationsClient contains the methods for the Remediations group.
// Don't use this type directly, use NewRemediationsClient() instead.
type RemediationsClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewRemediationsClient creates a new instance of RemediationsClient with the specified values.
// subscriptionID - Microsoft Azure subscription ID.
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewRemediationsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*RemediationsClient, error) {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := cloud.AzurePublicCloud.Services[cloud.ResourceManager].Endpoint
	if c, ok := options.Cloud.Services[cloud.ResourceManager]; ok {
		ep = c.Endpoint
	}
	pl, err := armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options)
	if err != nil {
		return nil, err
	}
	client := &RemediationsClient{
		subscriptionID: subscriptionID,
		host:           ep,
		pl:             pl,
	}
	return client, nil
}

// CancelAtManagementGroup - Cancels a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtManagementGroupOptions contains the optional parameters for the RemediationsClient.CancelAtManagementGroup
// method.
func (client *RemediationsClient) CancelAtManagementGroup(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientCancelAtManagementGroupOptions) (RemediationsClientCancelAtManagementGroupResponse, error) {
	req, err := client.cancelAtManagementGroupCreateRequest(ctx, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtManagementGroupHandleResponse(resp)
}

// cancelAtManagementGroupCreateRequest creates the CancelAtManagementGroup request.
func (client *RemediationsClient) cancelAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientCancelAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtManagementGroupHandleResponse handles the CancelAtManagementGroup response.
func (client *RemediationsClient) cancelAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientCancelAtManagementGroupResponse, error) {
	result := RemediationsClientCancelAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	return result, nil
}

// CancelAtResource - Cancel a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtResourceOptions contains the optional parameters for the RemediationsClient.CancelAtResource
// method.
func (client *RemediationsClient) CancelAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientCancelAtResourceOptions) (RemediationsClientCancelAtResourceResponse, error) {
	req, err := client.cancelAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtResourceHandleResponse(resp)
}

// cancelAtResourceCreateRequest creates the CancelAtResource request.
func (client *RemediationsClient) cancelAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientCancelAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtResourceHandleResponse handles the CancelAtResource response.
func (client *RemediationsClient) cancelAtResourceHandleResponse(resp *http.Response) (RemediationsClientCancelAtResourceResponse, error) {
	result := RemediationsClientCancelAtResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	return result, nil
}

// CancelAtResourceGroup - Cancels a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtResourceGroupOptions contains the optional parameters for the RemediationsClient.CancelAtResourceGroup
// method.
func (client *RemediationsClient) CancelAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientCancelAtResourceGroupOptions) (RemediationsClientCancelAtResourceGroupResponse, error) {
	req, err := client.cancelAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtResourceGroupHandleResponse(resp)
}

// cancelAtResourceGroupCreateRequest creates the CancelAtResourceGroup request.
func (client *RemediationsClient) cancelAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientCancelAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtResourceGroupHandleResponse handles the CancelAtResourceGroup response.
func (client *RemediationsClient) cancelAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientCancelAtResourceGroupResponse, error) {
	result := RemediationsClientCancelAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	return result, nil
}

// CancelAtSubscription - Cancels a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtSubscriptionOptions contains the optional parameters for the RemediationsClient.CancelAtSubscription
// method.
func (client *RemediationsClient) CancelAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientCancelAtSubscriptionOptions) (RemediationsClientCancelAtSubscriptionResponse, error) {
	req, err := client.cancelAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtSubscriptionHandleResponse(resp)
}

// cancelAtSubscriptionCreateRequest creates the CancelAtSubscription request.
func (client *RemediationsClient) cancelAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientCancelAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtSubscriptionHandleResponse handles the CancelAtSubscription response.
func (client *RemediationsClient) cancelAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientCancelAtSubscriptionResponse, error) {
	result := RemediationsClientCancelAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtManagementGroup - Creates or updates a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtManagementGroupOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtManagementGroup
// method.
func (client *RemediationsClient) CreateOrUpdateAtManagementGroup(ctx context.Context, managementGroupID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtManagementGroupOptions) (RemediationsClientCreateOrUpdateAtManagementGroupResponse, error) {
	req, err := client.createOrUpdateAtManagementGroupCreateRequest(ctx, managementGroupID, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtManagementGroupHandleResponse(resp)
}

// createOrUpdateAtManagementGroupCreateRequest creates the CreateOrUpdateAtManagementGroup request.
func (client *RemediationsClient) createOrUpdateAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtManagementGroupHandleResponse handles the CreateOrUpdateAtManagementGroup response.
func (client *RemediationsClient) createOrUpdateAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtManagementGroupResponse, error) {
	result := RemediationsClientCreateOrUpdateAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtResource - Creates or updates a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtResourceOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtResource
// method.
func (client *RemediationsClient) CreateOrUpdateAtResource(ctx context.Context, resourceID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceOptions) (RemediationsClientCreateOrUpdateAtResourceResponse, error) {
	req, err := client.createOrUpdateAtResourceCreateRequest(ctx, resourceID, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtResourceHandleResponse(resp)
}

// createOrUpdateAtResourceCreateRequest creates the CreateOrUpdateAtResource request.
func (client *RemediationsClient) createOrUpdateAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceHandleResponse handles the CreateOrUpdateAtResource response.
func (client *RemediationsClient) createOrUpdateAtResourceHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtResourceResponse, error) {
	result := RemediationsClientCreateOrUpdateAtResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtResourceGroup - Creates or updates a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtResourceGroupOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtResourceGroup
// method.
func (client *RemediationsClient) CreateOrUpdateAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceGroupOptions) (RemediationsClientCreateOrUpdateAtResourceGroupResponse, error) {
	req, err := client.createOrUpdateAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtResourceGroupHandleResponse(resp)
}

// createOrUpdateAtResourceGroupCreateRequest creates the CreateOrUpdateAtResourceGroup request.
func (client *RemediationsClient) createOrUpdateAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceGroupHandleResponse handles the CreateOrUpdateAtResourceGroup response.
func (client *RemediationsClient) createOrUpdateAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtResourceGroupResponse, error) {
	result := RemediationsClientCreateOrUpdateAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtSubscription - Creates or updates a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtSubscriptionOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtSubscription
// method.
func (client *RemediationsClient) CreateOrUpdateAtSubscription(ctx context.Context, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtSubscriptionOptions) (RemediationsClientCreateOrUpdateAtSubscriptionResponse, error) {
	req, err := client.createOrUpdateAtSubscriptionCreateRequest(ctx, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtSubscriptionHandleResponse(resp)
}

// createOrUpdateAtSubscriptionCreateRequest creates the CreateOrUpdateAtSubscription request.
func (client *RemediationsClient) createOrUpdateAtSubscriptionCreateRequest(ctx context.Context, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtSubscriptionHandleResponse handles the CreateOrUpdateAtSubscription response.
func (client *RemediationsClient) createOrUpdateAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtSubscriptionResponse, error) {
	result := RemediationsClientCreateOrUpdateAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	return result, nil
}

// DeleteAtManagementGroup - Deletes an existing remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtManagementGroupOptions contains the optional parameters for the RemediationsClient.DeleteAtManagementGroup
// method.
func (client *RemediationsClient) DeleteAtManagementGroup(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientDeleteAtManagementGroupOptions) (RemediationsClientDeleteAtManagementGroupResponse, error) {
	req, err := client.deleteAtManagementGroupCreateRequest(ctx, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtManagementGroupHandleResponse(resp)
}

// deleteAtManagementGroupCreateRequest creates the DeleteAtManagementGroup request.
func (client *RemediationsClient) deleteAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientDeleteAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtManagementGroupHandleResponse handles the DeleteAtManagementGroup response.
func (client *RemediationsClient) deleteAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientDeleteAtManagementGroupResponse, error) {
	result := RemediationsClientDeleteAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	return result, nil
}

// DeleteAtResource - Deletes an existing remediation at individual resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtResourceOptions contains the optional parameters for the RemediationsClient.DeleteAtResource
// method.
func (client *RemediationsClient) DeleteAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientDeleteAtResourceOptions) (RemediationsClientDeleteAtResourceResponse, error) {
	req, err := client.deleteAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtResourceHandleResponse(resp)
}

// deleteAtResourceCreateRequest creates the DeleteAtResource request.
func (client *RemediationsClient) deleteAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientDeleteAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceHandleResponse handles the DeleteAtResource response.
func (client *RemediationsClient) deleteAtResourceHandleResponse(resp *http.Response) (RemediationsClientDeleteAtResourceResponse, error) {
	result := RemediationsClientDeleteAtResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	return result, nil
}

// DeleteAtResourceGroup - Deletes an existing remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtResourceGroupOptions contains the optional parameters for the RemediationsClient.DeleteAtResourceGroup
// method.
func (client *RemediationsClient) DeleteAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientDeleteAtResourceGroupOptions) (RemediationsClientDeleteAtResourceGroupResponse, error) {
	req, err := client.deleteAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtResourceGroupHandleResponse(resp)
}

// deleteAtResourceGroupCreateRequest creates the DeleteAtResourceGroup request.
func (client *RemediationsClient) deleteAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientDeleteAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceGroupHandleResponse handles the DeleteAtResourceGroup response.
func (client *RemediationsClient) deleteAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientDeleteAtResourceGroupResponse, error) {
	result := RemediationsClientDeleteAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	return result, nil
}

// DeleteAtSubscription - Deletes an existing remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtSubscriptionOptions contains the optional parameters for the RemediationsClient.DeleteAtSubscription
// method.
func (client *RemediationsClient) DeleteAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientDeleteAtSubscriptionOptions) (RemediationsClientDeleteAtSubscriptionResponse, error) {
	req, err := client.deleteAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtSubscriptionHandleResponse(resp)
}

// deleteAtSubscriptionCreateRequest creates the DeleteAtSubscription request.
func (client *RemediationsClient) deleteAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientDeleteAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtSubscriptionHandleResponse handles the DeleteAtSubscription response.
func (client *RemediationsClient) deleteAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientDeleteAtSubscriptionResponse, error) {
	result := RemediationsClientDeleteAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	return result, nil
}

// GetAtManagementGroup - Gets an existing remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtManagementGroupOptions contains the optional parameters for the RemediationsClient.GetAtManagementGroup
// method.
func (client *RemediationsClient) GetAtManagementGroup(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientGetAtManagementGroupOptions) (RemediationsClientGetAtManagementGroupResponse, error) {
	req, err := client.getAtManagementGroupCreateRequest(ctx, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtManagementGroupHandleResponse(resp)
}

// getAtManagementGroupCreateRequest creates the GetAtManagementGroup request.
func (client *RemediationsClient) getAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, remediationName string, options *RemediationsClientGetAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtManagementGroupHandleResponse handles the GetAtManagementGroup response.
func (client *RemediationsClient) getAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientGetAtManagementGroupResponse, error) {
	result := RemediationsClientGetAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	return result, nil
}

// GetAtResource - Gets an existing remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtResourceOptions contains the optional parameters for the RemediationsClient.GetAtResource
// method.
func (client *RemediationsClient) GetAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientGetAtResourceOptions) (RemediationsClientGetAtResourceResponse, error) {
	req, err := client.getAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtResourceHandleResponse(resp)
}

// getAtResourceCreateRequest creates the GetAtResource request.
func (client *RemediationsClient) getAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientGetAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceHandleResponse handles the GetAtResource response.
func (client *RemediationsClient) getAtResourceHandleResponse(resp *http.Response) (RemediationsClientGetAtResourceResponse, error) {
	result := RemediationsClientGetAtResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	return result, nil
}

// GetAtResourceGroup - Gets an existing remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtResourceGroupOptions contains the optional parameters for the RemediationsClient.GetAtResourceGroup
// method.
func (client *RemediationsClient) GetAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientGetAtResourceGroupOptions) (RemediationsClientGetAtResourceGroupResponse, error) {
	req, err := client.getAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtResourceGroupHandleResponse(resp)
}

// getAtResourceGroupCreateRequest creates the GetAtResourceGroup request.
func (client *RemediationsClient) getAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientGetAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceGroupHandleResponse handles the GetAtResourceGroup response.
func (client *RemediationsClient) getAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientGetAtResourceGroupResponse, error) {
	result := RemediationsClientGetAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	return result, nil
}

// GetAtSubscription - Gets an existing remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtSubscriptionOptions contains the optional parameters for the RemediationsClient.GetAtSubscription
// method.
func (client *RemediationsClient) GetAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientGetAtSubscriptionOptions) (RemediationsClientGetAtSubscriptionResponse, error) {
	req, err := client.getAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtSubscriptionHandleResponse(resp)
}

// getAtSubscriptionCreateRequest creates the GetAtSubscription request.
func (client *RemediationsClient) getAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientGetAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtSubscriptionHandleResponse handles the GetAtSubscription response.
func (client *RemediationsClient) getAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientGetAtSubscriptionResponse, error) {
	result := RemediationsClientGetAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsAtManagementGroupPager - Gets all deployments for a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListDeploymentsAtManagementGroupOptions contains the optional parameters for the RemediationsClient.ListDeploymentsAtManagementGroup
// method.
func (client *RemediationsClient) NewListDeploymentsAtManagementGroupPager(managementGroupID string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtManagementGroupOptions) *runtime.Pager[RemediationsClientListDeploymentsAtManagementGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListDeploymentsAtManagementGroupResponse]{
		More: func(page RemediationsClientListDeploymentsAtManagementGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListDeploymentsAtManagementGroupResponse) (RemediationsClientListDeploymentsAtManagementGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsAtManagementGroupCreateRequest(ctx, managementGroupID, remediationName, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListDeploymentsAtManagementGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListDeploymentsAtManagementGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListDeploymentsAtManagementGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsAtManagementGroupHandleResponse(resp)
		},
	})
}

// listDeploymentsAtManagementGroupCreateRequest creates the ListDeploymentsAtManagementGroup request.
func (client *RemediationsClient) listDeploymentsAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtManagementGroupHandleResponse handles the ListDeploymentsAtManagementGroup response.
func (client *RemediationsClient) listDeploymentsAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtManagementGroupResponse, error) {
	result := RemediationsClientListDeploymentsAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtManagementGroupResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsAtResourcePager - Gets all deployments for a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListDeploymentsAtResourceOptions contains the optional parameters for the RemediationsClient.ListDeploymentsAtResource
// method.
func (client *RemediationsClient) NewListDeploymentsAtResourcePager(resourceID string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtResourceOptions) *runtime.Pager[RemediationsClientListDeploymentsAtResourceResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListDeploymentsAtResourceResponse]{
		More: func(page RemediationsClientListDeploymentsAtResourceResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListDeploymentsAtResourceResponse) (RemediationsClientListDeploymentsAtResourceResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsAtResourceCreateRequest(ctx, resourceID, remediationName, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListDeploymentsAtResourceResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListDeploymentsAtResourceResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListDeploymentsAtResourceResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsAtResourceHandleResponse(resp)
		},
	})
}

// listDeploymentsAtResourceCreateRequest creates the ListDeploymentsAtResource request.
func (client *RemediationsClient) listDeploymentsAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtResourceHandleResponse handles the ListDeploymentsAtResource response.
func (client *RemediationsClient) listDeploymentsAtResourceHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtResourceResponse, error) {
	result := RemediationsClientListDeploymentsAtResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtResourceResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsAtResourceGroupPager - Gets all deployments for a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListDeploymentsAtResourceGroupOptions contains the optional parameters for the RemediationsClient.ListDeploymentsAtResourceGroup
// method.
func (client *RemediationsClient) NewListDeploymentsAtResourceGroupPager(resourceGroupName string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtResourceGroupOptions) *runtime.Pager[RemediationsClientListDeploymentsAtResourceGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListDeploymentsAtResourceGroupResponse]{
		More: func(page RemediationsClientListDeploymentsAtResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListDeploymentsAtResourceGroupResponse) (RemediationsClientListDeploymentsAtResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListDeploymentsAtResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListDeploymentsAtResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListDeploymentsAtResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsAtResourceGroupHandleResponse(resp)
		},
	})
}

// listDeploymentsAtResourceGroupCreateRequest creates the ListDeploymentsAtResourceGroup request.
func (client *RemediationsClient) listDeploymentsAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtResourceGroupHandleResponse handles the ListDeploymentsAtResourceGroup response.
func (client *RemediationsClient) listDeploymentsAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtResourceGroupResponse, error) {
	result := RemediationsClientListDeploymentsAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListDeploymentsAtSubscriptionPager - Gets all deployments for a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListDeploymentsAtSubscriptionOptions contains the optional parameters for the RemediationsClient.ListDeploymentsAtSubscription
// method.
func (client *RemediationsClient) NewListDeploymentsAtSubscriptionPager(remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtSubscriptionOptions) *runtime.Pager[RemediationsClientListDeploymentsAtSubscriptionResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListDeploymentsAtSubscriptionResponse]{
		More: func(page RemediationsClientListDeploymentsAtSubscriptionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListDeploymentsAtSubscriptionResponse) (RemediationsClientListDeploymentsAtSubscriptionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listDeploymentsAtSubscriptionCreateRequest(ctx, remediationName, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListDeploymentsAtSubscriptionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListDeploymentsAtSubscriptionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListDeploymentsAtSubscriptionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listDeploymentsAtSubscriptionHandleResponse(resp)
		},
	})
}

// listDeploymentsAtSubscriptionCreateRequest creates the ListDeploymentsAtSubscription request.
func (client *RemediationsClient) listDeploymentsAtSubscriptionCreateRequest(ctx context.Context, remediationName string, queryOptions *QueryOptions, options *RemediationsClientListDeploymentsAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtSubscriptionHandleResponse handles the ListDeploymentsAtSubscription response.
func (client *RemediationsClient) listDeploymentsAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtSubscriptionResponse, error) {
	result := RemediationsClientListDeploymentsAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtSubscriptionResponse{}, err
	}
	return result, nil
}

// NewListForManagementGroupPager - Gets all remediations for the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupID - Management group ID.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListForManagementGroupOptions contains the optional parameters for the RemediationsClient.ListForManagementGroup
// method.
func (client *RemediationsClient) NewListForManagementGroupPager(managementGroupID string, queryOptions *QueryOptions, options *RemediationsClientListForManagementGroupOptions) *runtime.Pager[RemediationsClientListForManagementGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListForManagementGroupResponse]{
		More: func(page RemediationsClientListForManagementGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListForManagementGroupResponse) (RemediationsClientListForManagementGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listForManagementGroupCreateRequest(ctx, managementGroupID, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListForManagementGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListForManagementGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListForManagementGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listForManagementGroupHandleResponse(resp)
		},
	})
}

// listForManagementGroupCreateRequest creates the ListForManagementGroup request.
func (client *RemediationsClient) listForManagementGroupCreateRequest(ctx context.Context, managementGroupID string, queryOptions *QueryOptions, options *RemediationsClientListForManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations"
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape("Microsoft.Management"))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForManagementGroupHandleResponse handles the ListForManagementGroup response.
func (client *RemediationsClient) listForManagementGroupHandleResponse(resp *http.Response) (RemediationsClientListForManagementGroupResponse, error) {
	result := RemediationsClientListForManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForManagementGroupResponse{}, err
	}
	return result, nil
}

// NewListForResourcePager - Gets all remediations for a resource.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListForResourceOptions contains the optional parameters for the RemediationsClient.ListForResource
// method.
func (client *RemediationsClient) NewListForResourcePager(resourceID string, queryOptions *QueryOptions, options *RemediationsClientListForResourceOptions) *runtime.Pager[RemediationsClientListForResourceResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListForResourceResponse]{
		More: func(page RemediationsClientListForResourceResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListForResourceResponse) (RemediationsClientListForResourceResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listForResourceCreateRequest(ctx, resourceID, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListForResourceResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListForResourceResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListForResourceResponse{}, runtime.NewResponseError(resp)
			}
			return client.listForResourceHandleResponse(resp)
		},
	})
}

// listForResourceCreateRequest creates the ListForResource request.
func (client *RemediationsClient) listForResourceCreateRequest(ctx context.Context, resourceID string, queryOptions *QueryOptions, options *RemediationsClientListForResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForResourceHandleResponse handles the ListForResource response.
func (client *RemediationsClient) listForResourceHandleResponse(resp *http.Response) (RemediationsClientListForResourceResponse, error) {
	result := RemediationsClientListForResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForResourceResponse{}, err
	}
	return result, nil
}

// NewListForResourceGroupPager - Gets all remediations for the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListForResourceGroupOptions contains the optional parameters for the RemediationsClient.ListForResourceGroup
// method.
func (client *RemediationsClient) NewListForResourceGroupPager(resourceGroupName string, queryOptions *QueryOptions, options *RemediationsClientListForResourceGroupOptions) *runtime.Pager[RemediationsClientListForResourceGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListForResourceGroupResponse]{
		More: func(page RemediationsClientListForResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListForResourceGroupResponse) (RemediationsClientListForResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listForResourceGroupCreateRequest(ctx, resourceGroupName, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListForResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListForResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListForResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listForResourceGroupHandleResponse(resp)
		},
	})
}

// listForResourceGroupCreateRequest creates the ListForResourceGroup request.
func (client *RemediationsClient) listForResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, queryOptions *QueryOptions, options *RemediationsClientListForResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForResourceGroupHandleResponse handles the ListForResourceGroup response.
func (client *RemediationsClient) listForResourceGroupHandleResponse(resp *http.Response) (RemediationsClientListForResourceGroupResponse, error) {
	result := RemediationsClientListForResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListForSubscriptionPager - Gets all remediations for the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// QueryOptions - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
// options - RemediationsClientListForSubscriptionOptions contains the optional parameters for the RemediationsClient.ListForSubscription
// method.
func (client *RemediationsClient) NewListForSubscriptionPager(queryOptions *QueryOptions, options *RemediationsClientListForSubscriptionOptions) *runtime.Pager[RemediationsClientListForSubscriptionResponse] {
	return runtime.NewPager(runtime.PageProcessor[RemediationsClientListForSubscriptionResponse]{
		More: func(page RemediationsClientListForSubscriptionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *RemediationsClientListForSubscriptionResponse) (RemediationsClientListForSubscriptionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listForSubscriptionCreateRequest(ctx, queryOptions, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return RemediationsClientListForSubscriptionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return RemediationsClientListForSubscriptionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return RemediationsClientListForSubscriptionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listForSubscriptionHandleResponse(resp)
		},
	})
}

// listForSubscriptionCreateRequest creates the ListForSubscription request.
func (client *RemediationsClient) listForSubscriptionCreateRequest(ctx context.Context, queryOptions *QueryOptions, options *RemediationsClientListForSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForSubscriptionHandleResponse handles the ListForSubscription response.
func (client *RemediationsClient) listForSubscriptionHandleResponse(resp *http.Response) (RemediationsClientListForSubscriptionResponse, error) {
	result := RemediationsClientListForSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForSubscriptionResponse{}, err
	}
	return result, nil
}
