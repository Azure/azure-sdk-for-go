//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// RemediationsClient contains the methods for the Remediations group.
// Don't use this type directly, use NewRemediationsClient() instead.
type RemediationsClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewRemediationsClient creates a new instance of RemediationsClient with the specified values.
// subscriptionID - Microsoft Azure subscription ID.
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewRemediationsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *RemediationsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Endpoint) == 0 {
		cp.Endpoint = arm.AzurePublicCloud
	}
	client := &RemediationsClient{
		subscriptionID: subscriptionID,
		host:           string(cp.Endpoint),
		pl:             armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, &cp),
	}
	return client
}

// CancelAtManagementGroup - Cancels a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtManagementGroupOptions contains the optional parameters for the RemediationsClient.CancelAtManagementGroup
// method.
func (client *RemediationsClient) CancelAtManagementGroup(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientCancelAtManagementGroupOptions) (RemediationsClientCancelAtManagementGroupResponse, error) {
	req, err := client.cancelAtManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtManagementGroupHandleResponse(resp)
}

// cancelAtManagementGroupCreateRequest creates the CancelAtManagementGroup request.
func (client *RemediationsClient) cancelAtManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientCancelAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtManagementGroupHandleResponse handles the CancelAtManagementGroup response.
func (client *RemediationsClient) cancelAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientCancelAtManagementGroupResponse, error) {
	result := RemediationsClientCancelAtManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtManagementGroupResponse{}, err
	}
	return result, nil
}

// CancelAtResource - Cancel a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtResourceOptions contains the optional parameters for the RemediationsClient.CancelAtResource
// method.
func (client *RemediationsClient) CancelAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientCancelAtResourceOptions) (RemediationsClientCancelAtResourceResponse, error) {
	req, err := client.cancelAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtResourceHandleResponse(resp)
}

// cancelAtResourceCreateRequest creates the CancelAtResource request.
func (client *RemediationsClient) cancelAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientCancelAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtResourceHandleResponse handles the CancelAtResource response.
func (client *RemediationsClient) cancelAtResourceHandleResponse(resp *http.Response) (RemediationsClientCancelAtResourceResponse, error) {
	result := RemediationsClientCancelAtResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtResourceResponse{}, err
	}
	return result, nil
}

// CancelAtResourceGroup - Cancels a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtResourceGroupOptions contains the optional parameters for the RemediationsClient.CancelAtResourceGroup
// method.
func (client *RemediationsClient) CancelAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientCancelAtResourceGroupOptions) (RemediationsClientCancelAtResourceGroupResponse, error) {
	req, err := client.cancelAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtResourceGroupHandleResponse(resp)
}

// cancelAtResourceGroupCreateRequest creates the CancelAtResourceGroup request.
func (client *RemediationsClient) cancelAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientCancelAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtResourceGroupHandleResponse handles the CancelAtResourceGroup response.
func (client *RemediationsClient) cancelAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientCancelAtResourceGroupResponse, error) {
	result := RemediationsClientCancelAtResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtResourceGroupResponse{}, err
	}
	return result, nil
}

// CancelAtSubscription - Cancels a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientCancelAtSubscriptionOptions contains the optional parameters for the RemediationsClient.CancelAtSubscription
// method.
func (client *RemediationsClient) CancelAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientCancelAtSubscriptionOptions) (RemediationsClientCancelAtSubscriptionResponse, error) {
	req, err := client.cancelAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientCancelAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelAtSubscriptionHandleResponse(resp)
}

// cancelAtSubscriptionCreateRequest creates the CancelAtSubscription request.
func (client *RemediationsClient) cancelAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientCancelAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/cancel"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtSubscriptionHandleResponse handles the CancelAtSubscription response.
func (client *RemediationsClient) cancelAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientCancelAtSubscriptionResponse, error) {
	result := RemediationsClientCancelAtSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCancelAtSubscriptionResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtManagementGroup - Creates or updates a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtManagementGroupOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtManagementGroup
// method.
func (client *RemediationsClient) CreateOrUpdateAtManagementGroup(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtManagementGroupOptions) (RemediationsClientCreateOrUpdateAtManagementGroupResponse, error) {
	req, err := client.createOrUpdateAtManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtManagementGroupHandleResponse(resp)
}

// createOrUpdateAtManagementGroupCreateRequest creates the CreateOrUpdateAtManagementGroup request.
func (client *RemediationsClient) createOrUpdateAtManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtManagementGroupHandleResponse handles the CreateOrUpdateAtManagementGroup response.
func (client *RemediationsClient) createOrUpdateAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtManagementGroupResponse, error) {
	result := RemediationsClientCreateOrUpdateAtManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtManagementGroupResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtResource - Creates or updates a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtResourceOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtResource
// method.
func (client *RemediationsClient) CreateOrUpdateAtResource(ctx context.Context, resourceID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceOptions) (RemediationsClientCreateOrUpdateAtResourceResponse, error) {
	req, err := client.createOrUpdateAtResourceCreateRequest(ctx, resourceID, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtResourceHandleResponse(resp)
}

// createOrUpdateAtResourceCreateRequest creates the CreateOrUpdateAtResource request.
func (client *RemediationsClient) createOrUpdateAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceHandleResponse handles the CreateOrUpdateAtResource response.
func (client *RemediationsClient) createOrUpdateAtResourceHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtResourceResponse, error) {
	result := RemediationsClientCreateOrUpdateAtResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtResourceResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtResourceGroup - Creates or updates a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtResourceGroupOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtResourceGroup
// method.
func (client *RemediationsClient) CreateOrUpdateAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceGroupOptions) (RemediationsClientCreateOrUpdateAtResourceGroupResponse, error) {
	req, err := client.createOrUpdateAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtResourceGroupHandleResponse(resp)
}

// createOrUpdateAtResourceGroupCreateRequest creates the CreateOrUpdateAtResourceGroup request.
func (client *RemediationsClient) createOrUpdateAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceGroupHandleResponse handles the CreateOrUpdateAtResourceGroup response.
func (client *RemediationsClient) createOrUpdateAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtResourceGroupResponse, error) {
	result := RemediationsClientCreateOrUpdateAtResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtResourceGroupResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateAtSubscription - Creates or updates a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// parameters - The remediation parameters.
// options - RemediationsClientCreateOrUpdateAtSubscriptionOptions contains the optional parameters for the RemediationsClient.CreateOrUpdateAtSubscription
// method.
func (client *RemediationsClient) CreateOrUpdateAtSubscription(ctx context.Context, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtSubscriptionOptions) (RemediationsClientCreateOrUpdateAtSubscriptionResponse, error) {
	req, err := client.createOrUpdateAtSubscriptionCreateRequest(ctx, remediationName, parameters, options)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateAtSubscriptionHandleResponse(resp)
}

// createOrUpdateAtSubscriptionCreateRequest creates the CreateOrUpdateAtSubscription request.
func (client *RemediationsClient) createOrUpdateAtSubscriptionCreateRequest(ctx context.Context, remediationName string, parameters Remediation, options *RemediationsClientCreateOrUpdateAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtSubscriptionHandleResponse handles the CreateOrUpdateAtSubscription response.
func (client *RemediationsClient) createOrUpdateAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientCreateOrUpdateAtSubscriptionResponse, error) {
	result := RemediationsClientCreateOrUpdateAtSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientCreateOrUpdateAtSubscriptionResponse{}, err
	}
	return result, nil
}

// DeleteAtManagementGroup - Deletes an existing remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtManagementGroupOptions contains the optional parameters for the RemediationsClient.DeleteAtManagementGroup
// method.
func (client *RemediationsClient) DeleteAtManagementGroup(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientDeleteAtManagementGroupOptions) (RemediationsClientDeleteAtManagementGroupResponse, error) {
	req, err := client.deleteAtManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtManagementGroupHandleResponse(resp)
}

// deleteAtManagementGroupCreateRequest creates the DeleteAtManagementGroup request.
func (client *RemediationsClient) deleteAtManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientDeleteAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtManagementGroupHandleResponse handles the DeleteAtManagementGroup response.
func (client *RemediationsClient) deleteAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientDeleteAtManagementGroupResponse, error) {
	result := RemediationsClientDeleteAtManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtManagementGroupResponse{}, err
	}
	return result, nil
}

// DeleteAtResource - Deletes an existing remediation at individual resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtResourceOptions contains the optional parameters for the RemediationsClient.DeleteAtResource
// method.
func (client *RemediationsClient) DeleteAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientDeleteAtResourceOptions) (RemediationsClientDeleteAtResourceResponse, error) {
	req, err := client.deleteAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtResourceHandleResponse(resp)
}

// deleteAtResourceCreateRequest creates the DeleteAtResource request.
func (client *RemediationsClient) deleteAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientDeleteAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceHandleResponse handles the DeleteAtResource response.
func (client *RemediationsClient) deleteAtResourceHandleResponse(resp *http.Response) (RemediationsClientDeleteAtResourceResponse, error) {
	result := RemediationsClientDeleteAtResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtResourceResponse{}, err
	}
	return result, nil
}

// DeleteAtResourceGroup - Deletes an existing remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtResourceGroupOptions contains the optional parameters for the RemediationsClient.DeleteAtResourceGroup
// method.
func (client *RemediationsClient) DeleteAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientDeleteAtResourceGroupOptions) (RemediationsClientDeleteAtResourceGroupResponse, error) {
	req, err := client.deleteAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtResourceGroupHandleResponse(resp)
}

// deleteAtResourceGroupCreateRequest creates the DeleteAtResourceGroup request.
func (client *RemediationsClient) deleteAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientDeleteAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceGroupHandleResponse handles the DeleteAtResourceGroup response.
func (client *RemediationsClient) deleteAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientDeleteAtResourceGroupResponse, error) {
	result := RemediationsClientDeleteAtResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtResourceGroupResponse{}, err
	}
	return result, nil
}

// DeleteAtSubscription - Deletes an existing remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientDeleteAtSubscriptionOptions contains the optional parameters for the RemediationsClient.DeleteAtSubscription
// method.
func (client *RemediationsClient) DeleteAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientDeleteAtSubscriptionOptions) (RemediationsClientDeleteAtSubscriptionResponse, error) {
	req, err := client.deleteAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return RemediationsClientDeleteAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteAtSubscriptionHandleResponse(resp)
}

// deleteAtSubscriptionCreateRequest creates the DeleteAtSubscription request.
func (client *RemediationsClient) deleteAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientDeleteAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtSubscriptionHandleResponse handles the DeleteAtSubscription response.
func (client *RemediationsClient) deleteAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientDeleteAtSubscriptionResponse, error) {
	result := RemediationsClientDeleteAtSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientDeleteAtSubscriptionResponse{}, err
	}
	return result, nil
}

// GetAtManagementGroup - Gets an existing remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtManagementGroupOptions contains the optional parameters for the RemediationsClient.GetAtManagementGroup
// method.
func (client *RemediationsClient) GetAtManagementGroup(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientGetAtManagementGroupOptions) (RemediationsClientGetAtManagementGroupResponse, error) {
	req, err := client.getAtManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtManagementGroupHandleResponse(resp)
}

// getAtManagementGroupCreateRequest creates the GetAtManagementGroup request.
func (client *RemediationsClient) getAtManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *RemediationsClientGetAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtManagementGroupHandleResponse handles the GetAtManagementGroup response.
func (client *RemediationsClient) getAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientGetAtManagementGroupResponse, error) {
	result := RemediationsClientGetAtManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtManagementGroupResponse{}, err
	}
	return result, nil
}

// GetAtResource - Gets an existing remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtResourceOptions contains the optional parameters for the RemediationsClient.GetAtResource
// method.
func (client *RemediationsClient) GetAtResource(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientGetAtResourceOptions) (RemediationsClientGetAtResourceResponse, error) {
	req, err := client.getAtResourceCreateRequest(ctx, resourceID, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtResourceHandleResponse(resp)
}

// getAtResourceCreateRequest creates the GetAtResource request.
func (client *RemediationsClient) getAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *RemediationsClientGetAtResourceOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceHandleResponse handles the GetAtResource response.
func (client *RemediationsClient) getAtResourceHandleResponse(resp *http.Response) (RemediationsClientGetAtResourceResponse, error) {
	result := RemediationsClientGetAtResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtResourceResponse{}, err
	}
	return result, nil
}

// GetAtResourceGroup - Gets an existing remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtResourceGroupOptions contains the optional parameters for the RemediationsClient.GetAtResourceGroup
// method.
func (client *RemediationsClient) GetAtResourceGroup(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientGetAtResourceGroupOptions) (RemediationsClientGetAtResourceGroupResponse, error) {
	req, err := client.getAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtResourceGroupHandleResponse(resp)
}

// getAtResourceGroupCreateRequest creates the GetAtResourceGroup request.
func (client *RemediationsClient) getAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *RemediationsClientGetAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceGroupHandleResponse handles the GetAtResourceGroup response.
func (client *RemediationsClient) getAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientGetAtResourceGroupResponse, error) {
	result := RemediationsClientGetAtResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtResourceGroupResponse{}, err
	}
	return result, nil
}

// GetAtSubscription - Gets an existing remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - RemediationsClientGetAtSubscriptionOptions contains the optional parameters for the RemediationsClient.GetAtSubscription
// method.
func (client *RemediationsClient) GetAtSubscription(ctx context.Context, remediationName string, options *RemediationsClientGetAtSubscriptionOptions) (RemediationsClientGetAtSubscriptionResponse, error) {
	req, err := client.getAtSubscriptionCreateRequest(ctx, remediationName, options)
	if err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RemediationsClientGetAtSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAtSubscriptionHandleResponse(resp)
}

// getAtSubscriptionCreateRequest creates the GetAtSubscription request.
func (client *RemediationsClient) getAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *RemediationsClientGetAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtSubscriptionHandleResponse handles the GetAtSubscription response.
func (client *RemediationsClient) getAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientGetAtSubscriptionResponse, error) {
	result := RemediationsClientGetAtSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Remediation); err != nil {
		return RemediationsClientGetAtSubscriptionResponse{}, err
	}
	return result, nil
}

// ListDeploymentsAtManagementGroup - Gets all deployments for a remediation at management group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// remediationName - The name of the remediation.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListDeploymentsAtManagementGroup(managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *QueryOptions) *RemediationsClientListDeploymentsAtManagementGroupPager {
	return &RemediationsClientListDeploymentsAtManagementGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsAtManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, remediationName, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListDeploymentsAtManagementGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationDeploymentsListResult.NextLink)
		},
	}
}

// listDeploymentsAtManagementGroupCreateRequest creates the ListDeploymentsAtManagementGroup request.
func (client *RemediationsClient) listDeploymentsAtManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, remediationName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtManagementGroupHandleResponse handles the ListDeploymentsAtManagementGroup response.
func (client *RemediationsClient) listDeploymentsAtManagementGroupHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtManagementGroupResponse, error) {
	result := RemediationsClientListDeploymentsAtManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtManagementGroupResponse{}, err
	}
	return result, nil
}

// ListDeploymentsAtResource - Gets all deployments for a remediation at resource scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// remediationName - The name of the remediation.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListDeploymentsAtResource(resourceID string, remediationName string, options *QueryOptions) *RemediationsClientListDeploymentsAtResourcePager {
	return &RemediationsClientListDeploymentsAtResourcePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsAtResourceCreateRequest(ctx, resourceID, remediationName, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListDeploymentsAtResourceResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationDeploymentsListResult.NextLink)
		},
	}
}

// listDeploymentsAtResourceCreateRequest creates the ListDeploymentsAtResource request.
func (client *RemediationsClient) listDeploymentsAtResourceCreateRequest(ctx context.Context, resourceID string, remediationName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtResourceHandleResponse handles the ListDeploymentsAtResource response.
func (client *RemediationsClient) listDeploymentsAtResourceHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtResourceResponse, error) {
	result := RemediationsClientListDeploymentsAtResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtResourceResponse{}, err
	}
	return result, nil
}

// ListDeploymentsAtResourceGroup - Gets all deployments for a remediation at resource group scope.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// remediationName - The name of the remediation.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListDeploymentsAtResourceGroup(resourceGroupName string, remediationName string, options *QueryOptions) *RemediationsClientListDeploymentsAtResourceGroupPager {
	return &RemediationsClientListDeploymentsAtResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsAtResourceGroupCreateRequest(ctx, resourceGroupName, remediationName, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListDeploymentsAtResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationDeploymentsListResult.NextLink)
		},
	}
}

// listDeploymentsAtResourceGroupCreateRequest creates the ListDeploymentsAtResourceGroup request.
func (client *RemediationsClient) listDeploymentsAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, remediationName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtResourceGroupHandleResponse handles the ListDeploymentsAtResourceGroup response.
func (client *RemediationsClient) listDeploymentsAtResourceGroupHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtResourceGroupResponse, error) {
	result := RemediationsClientListDeploymentsAtResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtResourceGroupResponse{}, err
	}
	return result, nil
}

// ListDeploymentsAtSubscription - Gets all deployments for a remediation at subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
// remediationName - The name of the remediation.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListDeploymentsAtSubscription(remediationName string, options *QueryOptions) *RemediationsClientListDeploymentsAtSubscriptionPager {
	return &RemediationsClientListDeploymentsAtSubscriptionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsAtSubscriptionCreateRequest(ctx, remediationName, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListDeploymentsAtSubscriptionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationDeploymentsListResult.NextLink)
		},
	}
}

// listDeploymentsAtSubscriptionCreateRequest creates the ListDeploymentsAtSubscription request.
func (client *RemediationsClient) listDeploymentsAtSubscriptionCreateRequest(ctx context.Context, remediationName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations/{remediationName}/listDeployments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if remediationName == "" {
		return nil, errors.New("parameter remediationName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{remediationName}", url.PathEscape(remediationName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsAtSubscriptionHandleResponse handles the ListDeploymentsAtSubscription response.
func (client *RemediationsClient) listDeploymentsAtSubscriptionHandleResponse(resp *http.Response) (RemediationsClientListDeploymentsAtSubscriptionResponse, error) {
	result := RemediationsClientListDeploymentsAtSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationDeploymentsListResult); err != nil {
		return RemediationsClientListDeploymentsAtSubscriptionResponse{}, err
	}
	return result, nil
}

// ListForManagementGroup - Gets all remediations for the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupID - Management group ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListForManagementGroup(managementGroupsNamespace Enum0, managementGroupID string, options *QueryOptions) *RemediationsClientListForManagementGroupPager {
	return &RemediationsClientListForManagementGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listForManagementGroupCreateRequest(ctx, managementGroupsNamespace, managementGroupID, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListForManagementGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationListResult.NextLink)
		},
	}
}

// listForManagementGroupCreateRequest creates the ListForManagementGroup request.
func (client *RemediationsClient) listForManagementGroupCreateRequest(ctx context.Context, managementGroupsNamespace Enum0, managementGroupID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupId}/providers/Microsoft.PolicyInsights/remediations"
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForManagementGroupHandleResponse handles the ListForManagementGroup response.
func (client *RemediationsClient) listForManagementGroupHandleResponse(resp *http.Response) (RemediationsClientListForManagementGroupResponse, error) {
	result := RemediationsClientListForManagementGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForManagementGroupResponse{}, err
	}
	return result, nil
}

// ListForResource - Gets all remediations for a resource.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceID - Resource ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListForResource(resourceID string, options *QueryOptions) *RemediationsClientListForResourcePager {
	return &RemediationsClientListForResourcePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listForResourceCreateRequest(ctx, resourceID, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListForResourceResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationListResult.NextLink)
		},
	}
}

// listForResourceCreateRequest creates the ListForResource request.
func (client *RemediationsClient) listForResourceCreateRequest(ctx context.Context, resourceID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/remediations"
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForResourceHandleResponse handles the ListForResource response.
func (client *RemediationsClient) listForResourceHandleResponse(resp *http.Response) (RemediationsClientListForResourceResponse, error) {
	result := RemediationsClientListForResourceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForResourceResponse{}, err
	}
	return result, nil
}

// ListForResourceGroup - Gets all remediations for the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - Resource group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListForResourceGroup(resourceGroupName string, options *QueryOptions) *RemediationsClientListForResourceGroupPager {
	return &RemediationsClientListForResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listForResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListForResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationListResult.NextLink)
		},
	}
}

// listForResourceGroupCreateRequest creates the ListForResourceGroup request.
func (client *RemediationsClient) listForResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/remediations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForResourceGroupHandleResponse handles the ListForResourceGroup response.
func (client *RemediationsClient) listForResourceGroupHandleResponse(resp *http.Response) (RemediationsClientListForResourceGroupResponse, error) {
	result := RemediationsClientListForResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForResourceGroupResponse{}, err
	}
	return result, nil
}

// ListForSubscription - Gets all remediations for the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *RemediationsClient) ListForSubscription(options *QueryOptions) *RemediationsClientListForSubscriptionPager {
	return &RemediationsClientListForSubscriptionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listForSubscriptionCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp RemediationsClientListForSubscriptionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RemediationListResult.NextLink)
		},
	}
}

// listForSubscriptionCreateRequest creates the ListForSubscription request.
func (client *RemediationsClient) listForSubscriptionCreateRequest(ctx context.Context, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/remediations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2021-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listForSubscriptionHandleResponse handles the ListForSubscription response.
func (client *RemediationsClient) listForSubscriptionHandleResponse(resp *http.Response) (RemediationsClientListForSubscriptionResponse, error) {
	result := RemediationsClientListForSubscriptionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemediationListResult); err != nil {
		return RemediationsClientListForSubscriptionResponse{}, err
	}
	return result, nil
}
