//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpostgresqlhsc

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ConfigurationsGetResponse contains the response from method Configurations.Get.
type ConfigurationsGetResponse struct {
	ConfigurationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsGetResult contains the result from method Configurations.Get.
type ConfigurationsGetResult struct {
	ServerGroupConfiguration
}

// ConfigurationsListByServerGroupResponse contains the response from method Configurations.ListByServerGroup.
type ConfigurationsListByServerGroupResponse struct {
	ConfigurationsListByServerGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsListByServerGroupResult contains the result from method Configurations.ListByServerGroup.
type ConfigurationsListByServerGroupResult struct {
	ServerGroupConfigurationListResult
}

// ConfigurationsListByServerResponse contains the response from method Configurations.ListByServer.
type ConfigurationsListByServerResponse struct {
	ConfigurationsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsListByServerResult contains the result from method Configurations.ListByServer.
type ConfigurationsListByServerResult struct {
	ServerConfigurationListResult
}

// ConfigurationsUpdatePollerResponse contains the response from method Configurations.Update.
type ConfigurationsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConfigurationsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConfigurationsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConfigurationsUpdateResponse, error) {
	respType := ConfigurationsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerGroupConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConfigurationsUpdatePollerResponse from the provided client and resume token.
func (l *ConfigurationsUpdatePollerResponse) Resume(ctx context.Context, client *ConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConfigurationsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ConfigurationsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConfigurationsUpdateResponse contains the response from method Configurations.Update.
type ConfigurationsUpdateResponse struct {
	ConfigurationsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConfigurationsUpdateResult contains the result from method Configurations.Update.
type ConfigurationsUpdateResult struct {
	ServerGroupConfiguration
}

// FirewallRulesCreateOrUpdatePollerResponse contains the response from method FirewallRules.CreateOrUpdate.
type FirewallRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallRulesCreateOrUpdateResponse, error) {
	respType := FirewallRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallRulesCreateOrUpdateResponse contains the response from method FirewallRules.CreateOrUpdate.
type FirewallRulesCreateOrUpdateResponse struct {
	FirewallRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesCreateOrUpdateResult contains the result from method FirewallRules.CreateOrUpdate.
type FirewallRulesCreateOrUpdateResult struct {
	FirewallRule
}

// FirewallRulesDeletePollerResponse contains the response from method FirewallRules.Delete.
type FirewallRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallRulesDeleteResponse, error) {
	respType := FirewallRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallRulesDeletePollerResponse from the provided client and resume token.
func (l *FirewallRulesDeletePollerResponse) Resume(ctx context.Context, client *FirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FirewallRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallRulesDeleteResponse contains the response from method FirewallRules.Delete.
type FirewallRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesGetResponse contains the response from method FirewallRules.Get.
type FirewallRulesGetResponse struct {
	FirewallRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesGetResult contains the result from method FirewallRules.Get.
type FirewallRulesGetResult struct {
	FirewallRule
}

// FirewallRulesListByServerGroupResponse contains the response from method FirewallRules.ListByServerGroup.
type FirewallRulesListByServerGroupResponse struct {
	FirewallRulesListByServerGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesListByServerGroupResult contains the result from method FirewallRules.ListByServerGroup.
type FirewallRulesListByServerGroupResult struct {
	FirewallRuleListResult
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// RolesCreatePollerResponse contains the response from method Roles.Create.
type RolesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesCreateResponse, error) {
	respType := RolesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Role)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesCreatePollerResponse from the provided client and resume token.
func (l *RolesCreatePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &RolesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesCreateResponse contains the response from method Roles.Create.
type RolesCreateResponse struct {
	RolesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesCreateResult contains the result from method Roles.Create.
type RolesCreateResult struct {
	Role
}

// RolesDeletePollerResponse contains the response from method Roles.Delete.
type RolesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RolesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RolesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RolesDeleteResponse, error) {
	respType := RolesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RolesDeletePollerResponse from the provided client and resume token.
func (l *RolesDeletePollerResponse) Resume(ctx context.Context, client *RolesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RolesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RolesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RolesDeleteResponse contains the response from method Roles.Delete.
type RolesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesListByServerGroupResponse contains the response from method Roles.ListByServerGroup.
type RolesListByServerGroupResponse struct {
	RolesListByServerGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RolesListByServerGroupResult contains the result from method Roles.ListByServerGroup.
type RolesListByServerGroupResult struct {
	RoleListResult
}

// ServerGroupsCheckNameAvailabilityResponse contains the response from method ServerGroups.CheckNameAvailability.
type ServerGroupsCheckNameAvailabilityResponse struct {
	ServerGroupsCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsCheckNameAvailabilityResult contains the result from method ServerGroups.CheckNameAvailability.
type ServerGroupsCheckNameAvailabilityResult struct {
	NameAvailability
}

// ServerGroupsCreateOrUpdatePollerResponse contains the response from method ServerGroups.CreateOrUpdate.
type ServerGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsCreateOrUpdateResponse, error) {
	respType := ServerGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsCreateOrUpdateResponse contains the response from method ServerGroups.CreateOrUpdate.
type ServerGroupsCreateOrUpdateResponse struct {
	ServerGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsCreateOrUpdateResult contains the result from method ServerGroups.CreateOrUpdate.
type ServerGroupsCreateOrUpdateResult struct {
	ServerGroup
}

// ServerGroupsDeletePollerResponse contains the response from method ServerGroups.Delete.
type ServerGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsDeleteResponse, error) {
	respType := ServerGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsDeletePollerResponse from the provided client and resume token.
func (l *ServerGroupsDeletePollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsDeleteResponse contains the response from method ServerGroups.Delete.
type ServerGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsGetResponse contains the response from method ServerGroups.Get.
type ServerGroupsGetResponse struct {
	ServerGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsGetResult contains the result from method ServerGroups.Get.
type ServerGroupsGetResult struct {
	ServerGroup
}

// ServerGroupsListByResourceGroupResponse contains the response from method ServerGroups.ListByResourceGroup.
type ServerGroupsListByResourceGroupResponse struct {
	ServerGroupsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsListByResourceGroupResult contains the result from method ServerGroups.ListByResourceGroup.
type ServerGroupsListByResourceGroupResult struct {
	ServerGroupListResult
}

// ServerGroupsListResponse contains the response from method ServerGroups.List.
type ServerGroupsListResponse struct {
	ServerGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsListResult contains the result from method ServerGroups.List.
type ServerGroupsListResult struct {
	ServerGroupListResult
}

// ServerGroupsRestartPollerResponse contains the response from method ServerGroups.Restart.
type ServerGroupsRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsRestartResponse, error) {
	respType := ServerGroupsRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsRestartPollerResponse from the provided client and resume token.
func (l *ServerGroupsRestartPollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.Restart", token, client.pl, client.restartHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsRestartResponse contains the response from method ServerGroups.Restart.
type ServerGroupsRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsStartPollerResponse contains the response from method ServerGroups.Start.
type ServerGroupsStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsStartResponse, error) {
	respType := ServerGroupsStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsStartPollerResponse from the provided client and resume token.
func (l *ServerGroupsStartPollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.Start", token, client.pl, client.startHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsStartResponse contains the response from method ServerGroups.Start.
type ServerGroupsStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsStopPollerResponse contains the response from method ServerGroups.Stop.
type ServerGroupsStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsStopResponse, error) {
	respType := ServerGroupsStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsStopPollerResponse from the provided client and resume token.
func (l *ServerGroupsStopPollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.Stop", token, client.pl, client.stopHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsStopResponse contains the response from method ServerGroups.Stop.
type ServerGroupsStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsUpdatePollerResponse contains the response from method ServerGroups.Update.
type ServerGroupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerGroupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerGroupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerGroupsUpdateResponse, error) {
	respType := ServerGroupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerGroupsUpdatePollerResponse from the provided client and resume token.
func (l *ServerGroupsUpdatePollerResponse) Resume(ctx context.Context, client *ServerGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerGroupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerGroupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerGroupsUpdateResponse contains the response from method ServerGroups.Update.
type ServerGroupsUpdateResponse struct {
	ServerGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerGroupsUpdateResult contains the result from method ServerGroups.Update.
type ServerGroupsUpdateResult struct {
	ServerGroup
}

// ServersGetResponse contains the response from method Servers.Get.
type ServersGetResponse struct {
	ServersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersGetResult contains the result from method Servers.Get.
type ServersGetResult struct {
	ServerGroupServer
}

// ServersListByServerGroupResponse contains the response from method Servers.ListByServerGroup.
type ServersListByServerGroupResponse struct {
	ServersListByServerGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersListByServerGroupResult contains the result from method Servers.ListByServerGroup.
type ServersListByServerGroupResult struct {
	ServerGroupServerListResult
}
