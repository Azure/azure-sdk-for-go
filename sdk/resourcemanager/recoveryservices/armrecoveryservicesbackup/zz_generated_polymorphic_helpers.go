//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicesbackup

import "encoding/json"

func unmarshalAzureIaaSVMProtectedItemClassification(rawMsg json.RawMessage) (AzureIaaSVMProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureIaaSVMProtectedItemClassification
	switch m["protectedItemType"] {
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMProtectedItem{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMProtectedItem{}
	default:
		b = &AzureIaaSVMProtectedItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureIaaSVMProtectedItemClassificationArray(rawMsg json.RawMessage) ([]AzureIaaSVMProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureIaaSVMProtectedItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureIaaSVMProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureIaaSVMProtectedItemClassificationMap(rawMsg json.RawMessage) (map[string]AzureIaaSVMProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureIaaSVMProtectedItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureIaaSVMProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureRecoveryServiceVaultProtectionIntentClassification(rawMsg json.RawMessage) (AzureRecoveryServiceVaultProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureRecoveryServiceVaultProtectionIntentClassification
	switch m["protectionIntentItemType"] {
	case "AzureWorkloadAutoProtectionIntent":
		b = &AzureWorkloadAutoProtectionIntent{}
	case "AzureWorkloadSQLAutoProtectionIntent":
		b = &AzureWorkloadSQLAutoProtectionIntent{}
	default:
		b = &AzureRecoveryServiceVaultProtectionIntent{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureRecoveryServiceVaultProtectionIntentClassificationArray(rawMsg json.RawMessage) ([]AzureRecoveryServiceVaultProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureRecoveryServiceVaultProtectionIntentClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureRecoveryServiceVaultProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureRecoveryServiceVaultProtectionIntentClassificationMap(rawMsg json.RawMessage) (map[string]AzureRecoveryServiceVaultProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureRecoveryServiceVaultProtectionIntentClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureRecoveryServiceVaultProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureVMWorkloadItemClassification(rawMsg json.RawMessage) (AzureVMWorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureVMWorkloadItemClassification
	switch m["workloadItemType"] {
	case "SAPAseDatabase":
		b = &AzureVMWorkloadSAPAseDatabaseWorkloadItem{}
	case "SAPAseSystem":
		b = &AzureVMWorkloadSAPAseSystemWorkloadItem{}
	case "SAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseWorkloadItem{}
	case "SAPHanaSystem":
		b = &AzureVMWorkloadSAPHanaSystemWorkloadItem{}
	case "SQLDataBase":
		b = &AzureVMWorkloadSQLDatabaseWorkloadItem{}
	case "SQLInstance":
		b = &AzureVMWorkloadSQLInstanceWorkloadItem{}
	default:
		b = &AzureVMWorkloadItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureVMWorkloadItemClassificationArray(rawMsg json.RawMessage) ([]AzureVMWorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureVMWorkloadItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureVMWorkloadItemClassificationMap(rawMsg json.RawMessage) (map[string]AzureVMWorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureVMWorkloadItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureVMWorkloadProtectableItemClassification(rawMsg json.RawMessage) (AzureVMWorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureVMWorkloadProtectableItemClassification
	switch m["protectableItemType"] {
	case "SAPAseSystem":
		b = &AzureVMWorkloadSAPAseSystemProtectableItem{}
	case "SAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseProtectableItem{}
	case "SAPHanaSystem":
		b = &AzureVMWorkloadSAPHanaSystemProtectableItem{}
	case "SQLAvailabilityGroupContainer":
		b = &AzureVMWorkloadSQLAvailabilityGroupProtectableItem{}
	case "SQLDataBase":
		b = &AzureVMWorkloadSQLDatabaseProtectableItem{}
	case "SQLInstance":
		b = &AzureVMWorkloadSQLInstanceProtectableItem{}
	default:
		b = &AzureVMWorkloadProtectableItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureVMWorkloadProtectableItemClassificationArray(rawMsg json.RawMessage) ([]AzureVMWorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureVMWorkloadProtectableItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureVMWorkloadProtectableItemClassificationMap(rawMsg json.RawMessage) (map[string]AzureVMWorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureVMWorkloadProtectableItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureVMWorkloadProtectedItemClassification(rawMsg json.RawMessage) (AzureVMWorkloadProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureVMWorkloadProtectedItemClassification
	switch m["protectedItemType"] {
	case "AzureVmWorkloadSAPAseDatabase":
		b = &AzureVMWorkloadSAPAseDatabaseProtectedItem{}
	case "AzureVmWorkloadSAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseProtectedItem{}
	case "AzureVmWorkloadSQLDatabase":
		b = &AzureVMWorkloadSQLDatabaseProtectedItem{}
	default:
		b = &AzureVMWorkloadProtectedItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureVMWorkloadProtectedItemClassificationArray(rawMsg json.RawMessage) ([]AzureVMWorkloadProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureVMWorkloadProtectedItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureVMWorkloadProtectedItemClassificationMap(rawMsg json.RawMessage) (map[string]AzureVMWorkloadProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureVMWorkloadProtectedItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureVMWorkloadProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadAutoProtectionIntentClassification(rawMsg json.RawMessage) (AzureWorkloadAutoProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadAutoProtectionIntentClassification
	switch m["protectionIntentItemType"] {
	case "AzureWorkloadSQLAutoProtectionIntent":
		b = &AzureWorkloadSQLAutoProtectionIntent{}
	default:
		b = &AzureWorkloadAutoProtectionIntent{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadAutoProtectionIntentClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadAutoProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadAutoProtectionIntentClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadAutoProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadAutoProtectionIntentClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadAutoProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadAutoProtectionIntentClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadAutoProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadContainerClassification(rawMsg json.RawMessage) (AzureWorkloadContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadContainerClassification
	switch m["containerType"] {
	case string(ContainerTypeSQLAGWorkLoadContainer):
		b = &AzureSQLAGWorkloadContainerProtectionContainer{}
	case string(ContainerTypeVMAppContainer):
		b = &AzureVMAppContainerProtectionContainer{}
	default:
		b = &AzureWorkloadContainer{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadContainerClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadContainerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadContainerClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadContainerClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadPointInTimeRecoveryPointClassification(rawMsg json.RawMessage) (AzureWorkloadPointInTimeRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadPointInTimeRecoveryPointClassification
	switch m["objectType"] {
	case "AzureWorkloadSAPHanaPointInTimeRecoveryPoint":
		b = &AzureWorkloadSAPHanaPointInTimeRecoveryPoint{}
	default:
		b = &AzureWorkloadPointInTimeRecoveryPoint{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadPointInTimeRecoveryPointClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadPointInTimeRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadPointInTimeRecoveryPointClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadPointInTimeRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadPointInTimeRecoveryPointClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadPointInTimeRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadPointInTimeRecoveryPointClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadPointInTimeRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadRecoveryPointClassification(rawMsg json.RawMessage) (AzureWorkloadRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadRecoveryPointClassification
	switch m["objectType"] {
	case "AzureWorkloadPointInTimeRecoveryPoint":
		b = &AzureWorkloadPointInTimeRecoveryPoint{}
	case "AzureWorkloadSAPHanaPointInTimeRecoveryPoint":
		b = &AzureWorkloadSAPHanaPointInTimeRecoveryPoint{}
	case "AzureWorkloadSAPHanaRecoveryPoint":
		b = &AzureWorkloadSAPHanaRecoveryPoint{}
	case "AzureWorkloadSQLPointInTimeRecoveryPoint":
		b = &AzureWorkloadSQLPointInTimeRecoveryPoint{}
	case "AzureWorkloadSQLRecoveryPoint":
		b = &AzureWorkloadSQLRecoveryPoint{}
	default:
		b = &AzureWorkloadRecoveryPoint{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadRecoveryPointClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadRecoveryPointClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadRecoveryPointClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadRecoveryPointClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadRestoreRequestClassification(rawMsg json.RawMessage) (AzureWorkloadRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadRestoreRequestClassification
	switch m["objectType"] {
	case "AzureWorkloadPointInTimeRestoreRequest":
		b = &AzureWorkloadPointInTimeRestoreRequest{}
	case "AzureWorkloadSAPHanaPointInTimeRestoreRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreRequest{}
	case "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSAPHanaRestoreRequest":
		b = &AzureWorkloadSAPHanaRestoreRequest{}
	case "AzureWorkloadSAPHanaRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaRestoreWithRehydrateRequest{}
	case "AzureWorkloadSQLPointInTimeRestoreRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreRequest{}
	case "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSQLRestoreRequest":
		b = &AzureWorkloadSQLRestoreRequest{}
	case "AzureWorkloadSQLRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLRestoreWithRehydrateRequest{}
	default:
		b = &AzureWorkloadRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadSAPHanaPointInTimeRestoreRequestClassification(rawMsg json.RawMessage) (AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification
	switch m["objectType"] {
	case "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest{}
	default:
		b = &AzureWorkloadSAPHanaPointInTimeRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadSAPHanaPointInTimeRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSAPHanaPointInTimeRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadSAPHanaPointInTimeRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadSAPHanaPointInTimeRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSAPHanaPointInTimeRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadSAPHanaRestoreRequestClassification(rawMsg json.RawMessage) (AzureWorkloadSAPHanaRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadSAPHanaRestoreRequestClassification
	switch m["objectType"] {
	case "AzureWorkloadSAPHanaPointInTimeRestoreRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreRequest{}
	case "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSAPHanaRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaRestoreWithRehydrateRequest{}
	default:
		b = &AzureWorkloadSAPHanaRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadSAPHanaRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadSAPHanaRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadSAPHanaRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSAPHanaRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadSAPHanaRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadSAPHanaRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadSAPHanaRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSAPHanaRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadSQLPointInTimeRestoreRequestClassification(rawMsg json.RawMessage) (AzureWorkloadSQLPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadSQLPointInTimeRestoreRequestClassification
	switch m["objectType"] {
	case "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest{}
	default:
		b = &AzureWorkloadSQLPointInTimeRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadSQLPointInTimeRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadSQLPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadSQLPointInTimeRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLPointInTimeRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadSQLPointInTimeRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadSQLPointInTimeRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadSQLPointInTimeRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLPointInTimeRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadSQLRecoveryPointClassification(rawMsg json.RawMessage) (AzureWorkloadSQLRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadSQLRecoveryPointClassification
	switch m["objectType"] {
	case "AzureWorkloadSQLPointInTimeRecoveryPoint":
		b = &AzureWorkloadSQLPointInTimeRecoveryPoint{}
	default:
		b = &AzureWorkloadSQLRecoveryPoint{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadSQLRecoveryPointClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadSQLRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadSQLRecoveryPointClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadSQLRecoveryPointClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadSQLRecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadSQLRecoveryPointClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAzureWorkloadSQLRestoreRequestClassification(rawMsg json.RawMessage) (AzureWorkloadSQLRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AzureWorkloadSQLRestoreRequestClassification
	switch m["objectType"] {
	case "AzureWorkloadSQLPointInTimeRestoreRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreRequest{}
	case "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSQLRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLRestoreWithRehydrateRequest{}
	default:
		b = &AzureWorkloadSQLRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAzureWorkloadSQLRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]AzureWorkloadSQLRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AzureWorkloadSQLRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAzureWorkloadSQLRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]AzureWorkloadSQLRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AzureWorkloadSQLRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAzureWorkloadSQLRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalBackupEngineBaseClassification(rawMsg json.RawMessage) (BackupEngineBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b BackupEngineBaseClassification
	switch m["backupEngineType"] {
	case string(BackupEngineTypeAzureBackupServerEngine):
		b = &AzureBackupServerEngine{}
	case string(BackupEngineTypeDpmBackupEngine):
		b = &DpmBackupEngine{}
	default:
		b = &BackupEngineBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalBackupEngineBaseClassificationArray(rawMsg json.RawMessage) ([]BackupEngineBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]BackupEngineBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalBackupEngineBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalBackupEngineBaseClassificationMap(rawMsg json.RawMessage) (map[string]BackupEngineBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]BackupEngineBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalBackupEngineBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalBackupRequestClassification(rawMsg json.RawMessage) (BackupRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b BackupRequestClassification
	switch m["objectType"] {
	case "AzureFileShareBackupRequest":
		b = &AzureFileShareBackupRequest{}
	case "AzureWorkloadBackupRequest":
		b = &AzureWorkloadBackupRequest{}
	case "IaasVMBackupRequest":
		b = &IaasVMBackupRequest{}
	default:
		b = &BackupRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalBackupRequestClassificationArray(rawMsg json.RawMessage) ([]BackupRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]BackupRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalBackupRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalBackupRequestClassificationMap(rawMsg json.RawMessage) (map[string]BackupRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]BackupRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalBackupRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalDpmContainerClassification(rawMsg json.RawMessage) (DpmContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DpmContainerClassification
	switch m["containerType"] {
	case string(ContainerTypeAzureBackupServerContainer):
		b = &AzureBackupServerContainer{}
	default:
		b = &DpmContainer{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalDpmContainerClassificationArray(rawMsg json.RawMessage) ([]DpmContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DpmContainerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDpmContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalDpmContainerClassificationMap(rawMsg json.RawMessage) (map[string]DpmContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]DpmContainerClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalDpmContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalFeatureSupportRequestClassification(rawMsg json.RawMessage) (FeatureSupportRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b FeatureSupportRequestClassification
	switch m["featureType"] {
	case "AzureBackupGoals":
		b = &AzureBackupGoalFeatureSupportRequest{}
	case "AzureVMResourceBackup":
		b = &AzureVMResourceFeatureSupportRequest{}
	default:
		b = &FeatureSupportRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalFeatureSupportRequestClassificationArray(rawMsg json.RawMessage) ([]FeatureSupportRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]FeatureSupportRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalFeatureSupportRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalFeatureSupportRequestClassificationMap(rawMsg json.RawMessage) (map[string]FeatureSupportRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]FeatureSupportRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalFeatureSupportRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalILRRequestClassification(rawMsg json.RawMessage) (ILRRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ILRRequestClassification
	switch m["objectType"] {
	case "AzureFileShareProvisionILRRequest":
		b = &AzureFileShareProvisionILRRequest{}
	case "IaasVMILRRegistrationRequest":
		b = &IaasVMILRRegistrationRequest{}
	default:
		b = &ILRRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalILRRequestClassificationArray(rawMsg json.RawMessage) ([]ILRRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ILRRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalILRRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalILRRequestClassificationMap(rawMsg json.RawMessage) (map[string]ILRRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ILRRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalILRRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalIaaSVMContainerClassification(rawMsg json.RawMessage) (IaaSVMContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b IaaSVMContainerClassification
	switch m["containerType"] {
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMContainer{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMContainer{}
	default:
		b = &IaaSVMContainer{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalIaaSVMContainerClassificationArray(rawMsg json.RawMessage) ([]IaaSVMContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]IaaSVMContainerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalIaaSVMContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalIaaSVMContainerClassificationMap(rawMsg json.RawMessage) (map[string]IaaSVMContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]IaaSVMContainerClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalIaaSVMContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalIaaSVMProtectableItemClassification(rawMsg json.RawMessage) (IaaSVMProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b IaaSVMProtectableItemClassification
	switch m["protectableItemType"] {
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMProtectableItem{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMProtectableItem{}
	default:
		b = &IaaSVMProtectableItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalIaaSVMProtectableItemClassificationArray(rawMsg json.RawMessage) ([]IaaSVMProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]IaaSVMProtectableItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalIaaSVMProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalIaaSVMProtectableItemClassificationMap(rawMsg json.RawMessage) (map[string]IaaSVMProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]IaaSVMProtectableItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalIaaSVMProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalIaasVMRestoreRequestClassification(rawMsg json.RawMessage) (IaasVMRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b IaasVMRestoreRequestClassification
	switch m["objectType"] {
	case "IaasVMRestoreWithRehydrationRequest":
		b = &IaasVMRestoreWithRehydrationRequest{}
	default:
		b = &IaasVMRestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalIaasVMRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]IaasVMRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]IaasVMRestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalIaasVMRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalIaasVMRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]IaasVMRestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]IaasVMRestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalIaasVMRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalJobClassification(rawMsg json.RawMessage) (JobClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b JobClassification
	switch m["jobType"] {
	case "AzureIaaSVMJob":
		b = &AzureIaaSVMJob{}
	case "AzureStorageJob":
		b = &AzureStorageJob{}
	case "AzureWorkloadJob":
		b = &AzureWorkloadJob{}
	case "DpmJob":
		b = &DpmJob{}
	case "MabJob":
		b = &MabJob{}
	case "VaultJob":
		b = &VaultJob{}
	default:
		b = &Job{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalJobClassificationArray(rawMsg json.RawMessage) ([]JobClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]JobClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalJobClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalJobClassificationMap(rawMsg json.RawMessage) (map[string]JobClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]JobClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalJobClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalOperationResultInfoBaseClassification(rawMsg json.RawMessage) (OperationResultInfoBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b OperationResultInfoBaseClassification
	switch m["objectType"] {
	case "ExportJobsOperationResultInfo":
		b = &ExportJobsOperationResultInfo{}
	case "OperationResultInfo":
		b = &OperationResultInfo{}
	default:
		b = &OperationResultInfoBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalOperationResultInfoBaseClassificationArray(rawMsg json.RawMessage) ([]OperationResultInfoBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]OperationResultInfoBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalOperationResultInfoBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalOperationResultInfoBaseClassificationMap(rawMsg json.RawMessage) (map[string]OperationResultInfoBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]OperationResultInfoBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalOperationResultInfoBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalOperationStatusExtendedInfoClassification(rawMsg json.RawMessage) (OperationStatusExtendedInfoClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b OperationStatusExtendedInfoClassification
	switch m["objectType"] {
	case "OperationStatusJobExtendedInfo":
		b = &OperationStatusJobExtendedInfo{}
	case "OperationStatusJobsExtendedInfo":
		b = &OperationStatusJobsExtendedInfo{}
	case "OperationStatusProvisionILRExtendedInfo":
		b = &OperationStatusProvisionILRExtendedInfo{}
	default:
		b = &OperationStatusExtendedInfo{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalOperationStatusExtendedInfoClassificationArray(rawMsg json.RawMessage) ([]OperationStatusExtendedInfoClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]OperationStatusExtendedInfoClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalOperationStatusExtendedInfoClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalOperationStatusExtendedInfoClassificationMap(rawMsg json.RawMessage) (map[string]OperationStatusExtendedInfoClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]OperationStatusExtendedInfoClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalOperationStatusExtendedInfoClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProtectableContainerClassification(rawMsg json.RawMessage) (ProtectableContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProtectableContainerClassification
	switch m["protectableContainerType"] {
	case string(ContainerTypeStorageContainer):
		b = &AzureStorageProtectableContainer{}
	case string(ContainerTypeVMAppContainer):
		b = &AzureVMAppContainerProtectableContainer{}
	default:
		b = &ProtectableContainer{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProtectableContainerClassificationArray(rawMsg json.RawMessage) ([]ProtectableContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProtectableContainerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProtectableContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProtectableContainerClassificationMap(rawMsg json.RawMessage) (map[string]ProtectableContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProtectableContainerClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProtectableContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProtectedItemClassification(rawMsg json.RawMessage) (ProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProtectedItemClassification
	switch m["protectedItemType"] {
	case "AzureFileShareProtectedItem":
		b = &AzureFileshareProtectedItem{}
	case "AzureIaaSVMProtectedItem":
		b = &AzureIaaSVMProtectedItem{}
	case "AzureVmWorkloadProtectedItem":
		b = &AzureVMWorkloadProtectedItem{}
	case "AzureVmWorkloadSAPAseDatabase":
		b = &AzureVMWorkloadSAPAseDatabaseProtectedItem{}
	case "AzureVmWorkloadSAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseProtectedItem{}
	case "AzureVmWorkloadSQLDatabase":
		b = &AzureVMWorkloadSQLDatabaseProtectedItem{}
	case "DPMProtectedItem":
		b = &DPMProtectedItem{}
	case "GenericProtectedItem":
		b = &GenericProtectedItem{}
	case "MabFileFolderProtectedItem":
		b = &MabFileFolderProtectedItem{}
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMProtectedItem{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMProtectedItem{}
	case "Microsoft.Sql/servers/databases":
		b = &AzureSQLProtectedItem{}
	default:
		b = &ProtectedItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProtectedItemClassificationArray(rawMsg json.RawMessage) ([]ProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProtectedItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProtectedItemClassificationMap(rawMsg json.RawMessage) (map[string]ProtectedItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProtectedItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProtectedItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProtectionContainerClassification(rawMsg json.RawMessage) (ProtectionContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProtectionContainerClassification
	switch m["containerType"] {
	case string(ContainerTypeAzureBackupServerContainer):
		b = &AzureBackupServerContainer{}
	case string(ContainerTypeAzureSQLContainer):
		b = &AzureSQLContainer{}
	case "AzureWorkloadContainer":
		b = &AzureWorkloadContainer{}
	case string(ContainerTypeDPMContainer):
		b = &DpmContainer{}
	case string(ContainerTypeGenericContainer):
		b = &GenericContainer{}
	case "IaaSVMContainer":
		b = &IaaSVMContainer{}
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMContainer{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMContainer{}
	case string(ContainerTypeSQLAGWorkLoadContainer):
		b = &AzureSQLAGWorkloadContainerProtectionContainer{}
	case string(ContainerTypeStorageContainer):
		b = &AzureStorageContainer{}
	case string(ContainerTypeVMAppContainer):
		b = &AzureVMAppContainerProtectionContainer{}
	case string(ContainerTypeWindows):
		b = &MabContainer{}
	default:
		b = &ProtectionContainer{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProtectionContainerClassificationArray(rawMsg json.RawMessage) ([]ProtectionContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProtectionContainerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProtectionContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProtectionContainerClassificationMap(rawMsg json.RawMessage) (map[string]ProtectionContainerClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProtectionContainerClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProtectionContainerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProtectionIntentClassification(rawMsg json.RawMessage) (ProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProtectionIntentClassification
	switch m["protectionIntentItemType"] {
	case "AzureResourceItem":
		b = &AzureResourceProtectionIntent{}
	case "AzureWorkloadAutoProtectionIntent":
		b = &AzureWorkloadAutoProtectionIntent{}
	case "AzureWorkloadSQLAutoProtectionIntent":
		b = &AzureWorkloadSQLAutoProtectionIntent{}
	case "RecoveryServiceVaultItem":
		b = &AzureRecoveryServiceVaultProtectionIntent{}
	default:
		b = &ProtectionIntent{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProtectionIntentClassificationArray(rawMsg json.RawMessage) ([]ProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProtectionIntentClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProtectionIntentClassificationMap(rawMsg json.RawMessage) (map[string]ProtectionIntentClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProtectionIntentClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProtectionIntentClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProtectionPolicyClassification(rawMsg json.RawMessage) (ProtectionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProtectionPolicyClassification
	switch m["backupManagementType"] {
	case "AzureIaasVM":
		b = &AzureIaaSVMProtectionPolicy{}
	case "AzureSql":
		b = &AzureSQLProtectionPolicy{}
	case "AzureStorage":
		b = &AzureFileShareProtectionPolicy{}
	case "AzureWorkload":
		b = &AzureVMWorkloadProtectionPolicy{}
	case "GenericProtectionPolicy":
		b = &GenericProtectionPolicy{}
	case "MAB":
		b = &MabProtectionPolicy{}
	default:
		b = &ProtectionPolicy{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProtectionPolicyClassificationArray(rawMsg json.RawMessage) ([]ProtectionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProtectionPolicyClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProtectionPolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProtectionPolicyClassificationMap(rawMsg json.RawMessage) (map[string]ProtectionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProtectionPolicyClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProtectionPolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalRecoveryPointClassification(rawMsg json.RawMessage) (RecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RecoveryPointClassification
	switch m["objectType"] {
	case "AzureFileShareRecoveryPoint":
		b = &AzureFileShareRecoveryPoint{}
	case "AzureWorkloadPointInTimeRecoveryPoint":
		b = &AzureWorkloadPointInTimeRecoveryPoint{}
	case "AzureWorkloadRecoveryPoint":
		b = &AzureWorkloadRecoveryPoint{}
	case "AzureWorkloadSAPHanaPointInTimeRecoveryPoint":
		b = &AzureWorkloadSAPHanaPointInTimeRecoveryPoint{}
	case "AzureWorkloadSAPHanaRecoveryPoint":
		b = &AzureWorkloadSAPHanaRecoveryPoint{}
	case "AzureWorkloadSQLPointInTimeRecoveryPoint":
		b = &AzureWorkloadSQLPointInTimeRecoveryPoint{}
	case "AzureWorkloadSQLRecoveryPoint":
		b = &AzureWorkloadSQLRecoveryPoint{}
	case "GenericRecoveryPoint":
		b = &GenericRecoveryPoint{}
	case "IaasVMRecoveryPoint":
		b = &IaasVMRecoveryPoint{}
	default:
		b = &RecoveryPoint{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalRecoveryPointClassificationArray(rawMsg json.RawMessage) ([]RecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RecoveryPointClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRecoveryPointClassificationMap(rawMsg json.RawMessage) (map[string]RecoveryPointClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]RecoveryPointClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalRecoveryPointClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalRestoreRequestClassification(rawMsg json.RawMessage) (RestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RestoreRequestClassification
	switch m["objectType"] {
	case "AzureFileShareRestoreRequest":
		b = &AzureFileShareRestoreRequest{}
	case "AzureWorkloadPointInTimeRestoreRequest":
		b = &AzureWorkloadPointInTimeRestoreRequest{}
	case "AzureWorkloadRestoreRequest":
		b = &AzureWorkloadRestoreRequest{}
	case "AzureWorkloadSAPHanaPointInTimeRestoreRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreRequest{}
	case "AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSAPHanaRestoreRequest":
		b = &AzureWorkloadSAPHanaRestoreRequest{}
	case "AzureWorkloadSAPHanaRestoreWithRehydrateRequest":
		b = &AzureWorkloadSAPHanaRestoreWithRehydrateRequest{}
	case "AzureWorkloadSQLPointInTimeRestoreRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreRequest{}
	case "AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLPointInTimeRestoreWithRehydrateRequest{}
	case "AzureWorkloadSQLRestoreRequest":
		b = &AzureWorkloadSQLRestoreRequest{}
	case "AzureWorkloadSQLRestoreWithRehydrateRequest":
		b = &AzureWorkloadSQLRestoreWithRehydrateRequest{}
	case "IaasVMRestoreRequest":
		b = &IaasVMRestoreRequest{}
	case "IaasVMRestoreWithRehydrationRequest":
		b = &IaasVMRestoreWithRehydrationRequest{}
	default:
		b = &RestoreRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalRestoreRequestClassificationArray(rawMsg json.RawMessage) ([]RestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RestoreRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRestoreRequestClassificationMap(rawMsg json.RawMessage) (map[string]RestoreRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]RestoreRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalRestoreRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalRetentionPolicyClassification(rawMsg json.RawMessage) (RetentionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b RetentionPolicyClassification
	switch m["retentionPolicyType"] {
	case "LongTermRetentionPolicy":
		b = &LongTermRetentionPolicy{}
	case "SimpleRetentionPolicy":
		b = &SimpleRetentionPolicy{}
	default:
		b = &RetentionPolicy{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalRetentionPolicyClassificationArray(rawMsg json.RawMessage) ([]RetentionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]RetentionPolicyClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalRetentionPolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalRetentionPolicyClassificationMap(rawMsg json.RawMessage) (map[string]RetentionPolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]RetentionPolicyClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalRetentionPolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalSchedulePolicyClassification(rawMsg json.RawMessage) (SchedulePolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SchedulePolicyClassification
	switch m["schedulePolicyType"] {
	case "LogSchedulePolicy":
		b = &LogSchedulePolicy{}
	case "LongTermSchedulePolicy":
		b = &LongTermSchedulePolicy{}
	case "SimpleSchedulePolicy":
		b = &SimpleSchedulePolicy{}
	default:
		b = &SchedulePolicy{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalSchedulePolicyClassificationArray(rawMsg json.RawMessage) ([]SchedulePolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SchedulePolicyClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSchedulePolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSchedulePolicyClassificationMap(rawMsg json.RawMessage) (map[string]SchedulePolicyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]SchedulePolicyClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalSchedulePolicyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalValidateOperationRequestClassification(rawMsg json.RawMessage) (ValidateOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ValidateOperationRequestClassification
	switch m["objectType"] {
	case "ValidateIaasVMRestoreOperationRequest":
		b = &ValidateIaasVMRestoreOperationRequest{}
	case "ValidateRestoreOperationRequest":
		b = &ValidateRestoreOperationRequest{}
	default:
		b = &ValidateOperationRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalValidateOperationRequestClassificationArray(rawMsg json.RawMessage) ([]ValidateOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ValidateOperationRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalValidateOperationRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalValidateOperationRequestClassificationMap(rawMsg json.RawMessage) (map[string]ValidateOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ValidateOperationRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalValidateOperationRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalValidateRestoreOperationRequestClassification(rawMsg json.RawMessage) (ValidateRestoreOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ValidateRestoreOperationRequestClassification
	switch m["objectType"] {
	case "ValidateIaasVMRestoreOperationRequest":
		b = &ValidateIaasVMRestoreOperationRequest{}
	default:
		b = &ValidateRestoreOperationRequest{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalValidateRestoreOperationRequestClassificationArray(rawMsg json.RawMessage) ([]ValidateRestoreOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ValidateRestoreOperationRequestClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalValidateRestoreOperationRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalValidateRestoreOperationRequestClassificationMap(rawMsg json.RawMessage) (map[string]ValidateRestoreOperationRequestClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ValidateRestoreOperationRequestClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalValidateRestoreOperationRequestClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalVaultStorageConfigOperationResultResponseClassification(rawMsg json.RawMessage) (VaultStorageConfigOperationResultResponseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b VaultStorageConfigOperationResultResponseClassification
	switch m["objectType"] {
	case "PrepareDataMoveResponse":
		b = &PrepareDataMoveResponse{}
	default:
		b = &VaultStorageConfigOperationResultResponse{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalVaultStorageConfigOperationResultResponseClassificationArray(rawMsg json.RawMessage) ([]VaultStorageConfigOperationResultResponseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]VaultStorageConfigOperationResultResponseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalVaultStorageConfigOperationResultResponseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalVaultStorageConfigOperationResultResponseClassificationMap(rawMsg json.RawMessage) (map[string]VaultStorageConfigOperationResultResponseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]VaultStorageConfigOperationResultResponseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalVaultStorageConfigOperationResultResponseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalWorkloadItemClassification(rawMsg json.RawMessage) (WorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b WorkloadItemClassification
	switch m["workloadItemType"] {
	case "AzureVmWorkloadItem":
		b = &AzureVMWorkloadItem{}
	case "SAPAseDatabase":
		b = &AzureVMWorkloadSAPAseDatabaseWorkloadItem{}
	case "SAPAseSystem":
		b = &AzureVMWorkloadSAPAseSystemWorkloadItem{}
	case "SAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseWorkloadItem{}
	case "SAPHanaSystem":
		b = &AzureVMWorkloadSAPHanaSystemWorkloadItem{}
	case "SQLDataBase":
		b = &AzureVMWorkloadSQLDatabaseWorkloadItem{}
	case "SQLInstance":
		b = &AzureVMWorkloadSQLInstanceWorkloadItem{}
	default:
		b = &WorkloadItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalWorkloadItemClassificationArray(rawMsg json.RawMessage) ([]WorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]WorkloadItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalWorkloadItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalWorkloadItemClassificationMap(rawMsg json.RawMessage) (map[string]WorkloadItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]WorkloadItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalWorkloadItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalWorkloadProtectableItemClassification(rawMsg json.RawMessage) (WorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b WorkloadProtectableItemClassification
	switch m["protectableItemType"] {
	case "AzureFileShare":
		b = &AzureFileShareProtectableItem{}
	case "AzureVmWorkloadProtectableItem":
		b = &AzureVMWorkloadProtectableItem{}
	case "IaaSVMProtectableItem":
		b = &IaaSVMProtectableItem{}
	case "Microsoft.ClassicCompute/virtualMachines":
		b = &AzureIaaSClassicComputeVMProtectableItem{}
	case "Microsoft.Compute/virtualMachines":
		b = &AzureIaaSComputeVMProtectableItem{}
	case "SAPAseSystem":
		b = &AzureVMWorkloadSAPAseSystemProtectableItem{}
	case "SAPHanaDatabase":
		b = &AzureVMWorkloadSAPHanaDatabaseProtectableItem{}
	case "SAPHanaSystem":
		b = &AzureVMWorkloadSAPHanaSystemProtectableItem{}
	case "SQLAvailabilityGroupContainer":
		b = &AzureVMWorkloadSQLAvailabilityGroupProtectableItem{}
	case "SQLDataBase":
		b = &AzureVMWorkloadSQLDatabaseProtectableItem{}
	case "SQLInstance":
		b = &AzureVMWorkloadSQLInstanceProtectableItem{}
	default:
		b = &WorkloadProtectableItem{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalWorkloadProtectableItemClassificationArray(rawMsg json.RawMessage) ([]WorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]WorkloadProtectableItemClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalWorkloadProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalWorkloadProtectableItemClassificationMap(rawMsg json.RawMessage) (map[string]WorkloadProtectableItemClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]WorkloadProtectableItemClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalWorkloadProtectableItemClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}
