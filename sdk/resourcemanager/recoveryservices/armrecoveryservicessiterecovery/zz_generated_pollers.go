//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicessiterecovery

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// ReplicationFabricsCheckConsistencyPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsCheckConsistencyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsCheckConsistencyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsCheckConsistencyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsCheckConsistencyResponse will be returned.
func (p *ReplicationFabricsCheckConsistencyPoller) FinalResponse(ctx context.Context) (ReplicationFabricsCheckConsistencyResponse, error) {
	respType := ReplicationFabricsCheckConsistencyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Fabric)
	if err != nil {
		return ReplicationFabricsCheckConsistencyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsCheckConsistencyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsCreateResponse will be returned.
func (p *ReplicationFabricsCreatePoller) FinalResponse(ctx context.Context) (ReplicationFabricsCreateResponse, error) {
	respType := ReplicationFabricsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Fabric)
	if err != nil {
		return ReplicationFabricsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsDeleteResponse will be returned.
func (p *ReplicationFabricsDeletePoller) FinalResponse(ctx context.Context) (ReplicationFabricsDeleteResponse, error) {
	respType := ReplicationFabricsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationFabricsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsMigrateToAADPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsMigrateToAADPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsMigrateToAADPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsMigrateToAADPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsMigrateToAADResponse will be returned.
func (p *ReplicationFabricsMigrateToAADPoller) FinalResponse(ctx context.Context) (ReplicationFabricsMigrateToAADResponse, error) {
	respType := ReplicationFabricsMigrateToAADResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationFabricsMigrateToAADResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsMigrateToAADPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsPurgePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsPurgePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsPurgePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsPurgePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsPurgeResponse will be returned.
func (p *ReplicationFabricsPurgePoller) FinalResponse(ctx context.Context) (ReplicationFabricsPurgeResponse, error) {
	respType := ReplicationFabricsPurgeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationFabricsPurgeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsPurgePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsReassociateGatewayPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsReassociateGatewayPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsReassociateGatewayPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsReassociateGatewayPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsReassociateGatewayResponse will be returned.
func (p *ReplicationFabricsReassociateGatewayPoller) FinalResponse(ctx context.Context) (ReplicationFabricsReassociateGatewayResponse, error) {
	respType := ReplicationFabricsReassociateGatewayResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Fabric)
	if err != nil {
		return ReplicationFabricsReassociateGatewayResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsReassociateGatewayPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationFabricsRenewCertificatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationFabricsRenewCertificatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationFabricsRenewCertificatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationFabricsRenewCertificatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationFabricsRenewCertificateResponse will be returned.
func (p *ReplicationFabricsRenewCertificatePoller) FinalResponse(ctx context.Context) (ReplicationFabricsRenewCertificateResponse, error) {
	respType := ReplicationFabricsRenewCertificateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Fabric)
	if err != nil {
		return ReplicationFabricsRenewCertificateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationFabricsRenewCertificatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationJobsCancelPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationJobsCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationJobsCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationJobsCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationJobsCancelResponse will be returned.
func (p *ReplicationJobsCancelPoller) FinalResponse(ctx context.Context) (ReplicationJobsCancelResponse, error) {
	respType := ReplicationJobsCancelResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Job)
	if err != nil {
		return ReplicationJobsCancelResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationJobsCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationJobsExportPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationJobsExportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationJobsExportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationJobsExportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationJobsExportResponse will be returned.
func (p *ReplicationJobsExportPoller) FinalResponse(ctx context.Context) (ReplicationJobsExportResponse, error) {
	respType := ReplicationJobsExportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Job)
	if err != nil {
		return ReplicationJobsExportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationJobsExportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationJobsRestartPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationJobsRestartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationJobsRestartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationJobsRestartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationJobsRestartResponse will be returned.
func (p *ReplicationJobsRestartPoller) FinalResponse(ctx context.Context) (ReplicationJobsRestartResponse, error) {
	respType := ReplicationJobsRestartResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Job)
	if err != nil {
		return ReplicationJobsRestartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationJobsRestartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationJobsResumePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationJobsResumePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationJobsResumePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationJobsResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationJobsResumeResponse will be returned.
func (p *ReplicationJobsResumePoller) FinalResponse(ctx context.Context) (ReplicationJobsResumeResponse, error) {
	respType := ReplicationJobsResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Job)
	if err != nil {
		return ReplicationJobsResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationJobsResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsCreateResponse will be returned.
func (p *ReplicationMigrationItemsCreatePoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsCreateResponse, error) {
	respType := ReplicationMigrationItemsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsDeleteResponse will be returned.
func (p *ReplicationMigrationItemsDeletePoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsDeleteResponse, error) {
	respType := ReplicationMigrationItemsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationMigrationItemsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsMigratePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsMigratePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsMigratePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsMigratePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsMigrateResponse will be returned.
func (p *ReplicationMigrationItemsMigratePoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsMigrateResponse, error) {
	respType := ReplicationMigrationItemsMigrateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsMigrateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsMigratePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsResyncPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsResyncPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsResyncPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsResyncPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsResyncResponse will be returned.
func (p *ReplicationMigrationItemsResyncPoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsResyncResponse, error) {
	respType := ReplicationMigrationItemsResyncResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsResyncResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsResyncPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsTestMigrateCleanupPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsTestMigrateCleanupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsTestMigrateCleanupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsTestMigrateCleanupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsTestMigrateCleanupResponse will be returned.
func (p *ReplicationMigrationItemsTestMigrateCleanupPoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsTestMigrateCleanupResponse, error) {
	respType := ReplicationMigrationItemsTestMigrateCleanupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsTestMigrateCleanupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsTestMigrateCleanupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsTestMigratePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsTestMigratePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsTestMigratePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsTestMigratePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsTestMigrateResponse will be returned.
func (p *ReplicationMigrationItemsTestMigratePoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsTestMigrateResponse, error) {
	respType := ReplicationMigrationItemsTestMigrateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsTestMigrateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsTestMigratePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationMigrationItemsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationMigrationItemsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationMigrationItemsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationMigrationItemsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationMigrationItemsUpdateResponse will be returned.
func (p *ReplicationMigrationItemsUpdatePoller) FinalResponse(ctx context.Context) (ReplicationMigrationItemsUpdateResponse, error) {
	respType := ReplicationMigrationItemsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MigrationItem)
	if err != nil {
		return ReplicationMigrationItemsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationMigrationItemsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationNetworkMappingsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationNetworkMappingsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationNetworkMappingsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationNetworkMappingsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationNetworkMappingsCreateResponse will be returned.
func (p *ReplicationNetworkMappingsCreatePoller) FinalResponse(ctx context.Context) (ReplicationNetworkMappingsCreateResponse, error) {
	respType := ReplicationNetworkMappingsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkMapping)
	if err != nil {
		return ReplicationNetworkMappingsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationNetworkMappingsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationNetworkMappingsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationNetworkMappingsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationNetworkMappingsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationNetworkMappingsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationNetworkMappingsDeleteResponse will be returned.
func (p *ReplicationNetworkMappingsDeletePoller) FinalResponse(ctx context.Context) (ReplicationNetworkMappingsDeleteResponse, error) {
	respType := ReplicationNetworkMappingsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationNetworkMappingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationNetworkMappingsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationNetworkMappingsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationNetworkMappingsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationNetworkMappingsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationNetworkMappingsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationNetworkMappingsUpdateResponse will be returned.
func (p *ReplicationNetworkMappingsUpdatePoller) FinalResponse(ctx context.Context) (ReplicationNetworkMappingsUpdateResponse, error) {
	respType := ReplicationNetworkMappingsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkMapping)
	if err != nil {
		return ReplicationNetworkMappingsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationNetworkMappingsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationPoliciesCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationPoliciesCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationPoliciesCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationPoliciesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationPoliciesCreateResponse will be returned.
func (p *ReplicationPoliciesCreatePoller) FinalResponse(ctx context.Context) (ReplicationPoliciesCreateResponse, error) {
	respType := ReplicationPoliciesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Policy)
	if err != nil {
		return ReplicationPoliciesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationPoliciesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationPoliciesDeleteResponse will be returned.
func (p *ReplicationPoliciesDeletePoller) FinalResponse(ctx context.Context) (ReplicationPoliciesDeleteResponse, error) {
	respType := ReplicationPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationPoliciesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationPoliciesUpdateResponse will be returned.
func (p *ReplicationPoliciesUpdatePoller) FinalResponse(ctx context.Context) (ReplicationPoliciesUpdateResponse, error) {
	respType := ReplicationPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Policy)
	if err != nil {
		return ReplicationPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsAddDisksPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsAddDisksPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsAddDisksPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsAddDisksPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsAddDisksResponse will be returned.
func (p *ReplicationProtectedItemsAddDisksPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsAddDisksResponse, error) {
	respType := ReplicationProtectedItemsAddDisksResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsAddDisksResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsAddDisksPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsApplyRecoveryPointPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsApplyRecoveryPointPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsApplyRecoveryPointPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsApplyRecoveryPointPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsApplyRecoveryPointResponse will be returned.
func (p *ReplicationProtectedItemsApplyRecoveryPointPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsApplyRecoveryPointResponse, error) {
	respType := ReplicationProtectedItemsApplyRecoveryPointResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsApplyRecoveryPointResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsApplyRecoveryPointPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsCreateResponse will be returned.
func (p *ReplicationProtectedItemsCreatePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsCreateResponse, error) {
	respType := ReplicationProtectedItemsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsDeleteResponse will be returned.
func (p *ReplicationProtectedItemsDeletePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsDeleteResponse, error) {
	respType := ReplicationProtectedItemsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationProtectedItemsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsFailoverCancelPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsFailoverCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsFailoverCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsFailoverCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsFailoverCancelResponse will be returned.
func (p *ReplicationProtectedItemsFailoverCancelPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsFailoverCancelResponse, error) {
	respType := ReplicationProtectedItemsFailoverCancelResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsFailoverCancelResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsFailoverCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsFailoverCommitPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsFailoverCommitPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsFailoverCommitPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsFailoverCommitPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsFailoverCommitResponse will be returned.
func (p *ReplicationProtectedItemsFailoverCommitPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsFailoverCommitResponse, error) {
	respType := ReplicationProtectedItemsFailoverCommitResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsFailoverCommitResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsFailoverCommitPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsPlannedFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsPlannedFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsPlannedFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsPlannedFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsPlannedFailoverResponse will be returned.
func (p *ReplicationProtectedItemsPlannedFailoverPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsPlannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsPlannedFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsPlannedFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsPlannedFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsPurgePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsPurgePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsPurgePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsPurgePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsPurgeResponse will be returned.
func (p *ReplicationProtectedItemsPurgePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsPurgeResponse, error) {
	respType := ReplicationProtectedItemsPurgeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationProtectedItemsPurgeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsPurgePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsRemoveDisksPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsRemoveDisksPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsRemoveDisksPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsRemoveDisksPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsRemoveDisksResponse will be returned.
func (p *ReplicationProtectedItemsRemoveDisksPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsRemoveDisksResponse, error) {
	respType := ReplicationProtectedItemsRemoveDisksResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsRemoveDisksResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsRemoveDisksPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsRepairReplicationPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsRepairReplicationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsRepairReplicationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsRepairReplicationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsRepairReplicationResponse will be returned.
func (p *ReplicationProtectedItemsRepairReplicationPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsRepairReplicationResponse, error) {
	respType := ReplicationProtectedItemsRepairReplicationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsRepairReplicationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsRepairReplicationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsReprotectPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsReprotectPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsReprotectPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsReprotectPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsReprotectResponse will be returned.
func (p *ReplicationProtectedItemsReprotectPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsReprotectResponse, error) {
	respType := ReplicationProtectedItemsReprotectResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsReprotectResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsReprotectPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsResolveHealthErrorsPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsResolveHealthErrorsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsResolveHealthErrorsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsResolveHealthErrorsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsResolveHealthErrorsResponse will be returned.
func (p *ReplicationProtectedItemsResolveHealthErrorsPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsResolveHealthErrorsResponse, error) {
	respType := ReplicationProtectedItemsResolveHealthErrorsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsResolveHealthErrorsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsResolveHealthErrorsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsTestFailoverCleanupPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsTestFailoverCleanupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsTestFailoverCleanupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsTestFailoverCleanupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsTestFailoverCleanupResponse will be returned.
func (p *ReplicationProtectedItemsTestFailoverCleanupPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsTestFailoverCleanupResponse, error) {
	respType := ReplicationProtectedItemsTestFailoverCleanupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsTestFailoverCleanupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsTestFailoverCleanupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsTestFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsTestFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsTestFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsTestFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsTestFailoverResponse will be returned.
func (p *ReplicationProtectedItemsTestFailoverPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsTestFailoverResponse, error) {
	respType := ReplicationProtectedItemsTestFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsTestFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsTestFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsUnplannedFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsUnplannedFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsUnplannedFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsUnplannedFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsUnplannedFailoverResponse will be returned.
func (p *ReplicationProtectedItemsUnplannedFailoverPoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsUnplannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsUnplannedFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsUnplannedFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsUnplannedFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsUpdateAppliancePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsUpdateAppliancePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsUpdateAppliancePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsUpdateAppliancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsUpdateApplianceResponse will be returned.
func (p *ReplicationProtectedItemsUpdateAppliancePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsUpdateApplianceResponse, error) {
	respType := ReplicationProtectedItemsUpdateApplianceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsUpdateApplianceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsUpdateAppliancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsUpdateMobilityServicePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsUpdateMobilityServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsUpdateMobilityServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsUpdateMobilityServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsUpdateMobilityServiceResponse will be returned.
func (p *ReplicationProtectedItemsUpdateMobilityServicePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsUpdateMobilityServiceResponse, error) {
	respType := ReplicationProtectedItemsUpdateMobilityServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsUpdateMobilityServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsUpdateMobilityServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectedItemsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectedItemsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectedItemsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectedItemsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectedItemsUpdateResponse will be returned.
func (p *ReplicationProtectedItemsUpdatePoller) FinalResponse(ctx context.Context) (ReplicationProtectedItemsUpdateResponse, error) {
	respType := ReplicationProtectedItemsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplicationProtectedItem)
	if err != nil {
		return ReplicationProtectedItemsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectedItemsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainerMappingsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainerMappingsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainerMappingsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainerMappingsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainerMappingsCreateResponse will be returned.
func (p *ReplicationProtectionContainerMappingsCreatePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainerMappingsCreateResponse, error) {
	respType := ReplicationProtectionContainerMappingsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProtectionContainerMapping)
	if err != nil {
		return ReplicationProtectionContainerMappingsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainerMappingsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainerMappingsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainerMappingsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainerMappingsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainerMappingsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainerMappingsDeleteResponse will be returned.
func (p *ReplicationProtectionContainerMappingsDeletePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainerMappingsDeleteResponse, error) {
	respType := ReplicationProtectionContainerMappingsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationProtectionContainerMappingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainerMappingsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainerMappingsPurgePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainerMappingsPurgePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainerMappingsPurgePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainerMappingsPurgePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainerMappingsPurgeResponse will be returned.
func (p *ReplicationProtectionContainerMappingsPurgePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainerMappingsPurgeResponse, error) {
	respType := ReplicationProtectionContainerMappingsPurgeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationProtectionContainerMappingsPurgeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainerMappingsPurgePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainerMappingsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainerMappingsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainerMappingsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainerMappingsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainerMappingsUpdateResponse will be returned.
func (p *ReplicationProtectionContainerMappingsUpdatePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainerMappingsUpdateResponse, error) {
	respType := ReplicationProtectionContainerMappingsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProtectionContainerMapping)
	if err != nil {
		return ReplicationProtectionContainerMappingsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainerMappingsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainersCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainersCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainersCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainersCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainersCreateResponse will be returned.
func (p *ReplicationProtectionContainersCreatePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainersCreateResponse, error) {
	respType := ReplicationProtectionContainersCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProtectionContainer)
	if err != nil {
		return ReplicationProtectionContainersCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainersCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainersDeleteResponse will be returned.
func (p *ReplicationProtectionContainersDeletePoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainersDeleteResponse, error) {
	respType := ReplicationProtectionContainersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationProtectionContainersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainersDiscoverProtectableItemPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainersDiscoverProtectableItemPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainersDiscoverProtectableItemPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainersDiscoverProtectableItemPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainersDiscoverProtectableItemResponse will be returned.
func (p *ReplicationProtectionContainersDiscoverProtectableItemPoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainersDiscoverProtectableItemResponse, error) {
	respType := ReplicationProtectionContainersDiscoverProtectableItemResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProtectionContainer)
	if err != nil {
		return ReplicationProtectionContainersDiscoverProtectableItemResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainersDiscoverProtectableItemPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationProtectionContainersSwitchProtectionPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationProtectionContainersSwitchProtectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationProtectionContainersSwitchProtectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationProtectionContainersSwitchProtectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationProtectionContainersSwitchProtectionResponse will be returned.
func (p *ReplicationProtectionContainersSwitchProtectionPoller) FinalResponse(ctx context.Context) (ReplicationProtectionContainersSwitchProtectionResponse, error) {
	respType := ReplicationProtectionContainersSwitchProtectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ProtectionContainer)
	if err != nil {
		return ReplicationProtectionContainersSwitchProtectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationProtectionContainersSwitchProtectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansCreateResponse will be returned.
func (p *ReplicationRecoveryPlansCreatePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansCreateResponse, error) {
	respType := ReplicationRecoveryPlansCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansDeleteResponse will be returned.
func (p *ReplicationRecoveryPlansDeletePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansDeleteResponse, error) {
	respType := ReplicationRecoveryPlansDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationRecoveryPlansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansFailoverCancelPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansFailoverCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansFailoverCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansFailoverCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansFailoverCancelResponse will be returned.
func (p *ReplicationRecoveryPlansFailoverCancelPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansFailoverCancelResponse, error) {
	respType := ReplicationRecoveryPlansFailoverCancelResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansFailoverCancelResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansFailoverCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansFailoverCommitPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansFailoverCommitPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansFailoverCommitPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansFailoverCommitPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansFailoverCommitResponse will be returned.
func (p *ReplicationRecoveryPlansFailoverCommitPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansFailoverCommitResponse, error) {
	respType := ReplicationRecoveryPlansFailoverCommitResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansFailoverCommitResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansFailoverCommitPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansPlannedFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansPlannedFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansPlannedFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansPlannedFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansPlannedFailoverResponse will be returned.
func (p *ReplicationRecoveryPlansPlannedFailoverPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansPlannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansPlannedFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansPlannedFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansPlannedFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansReprotectPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansReprotectPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansReprotectPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansReprotectPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansReprotectResponse will be returned.
func (p *ReplicationRecoveryPlansReprotectPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansReprotectResponse, error) {
	respType := ReplicationRecoveryPlansReprotectResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansReprotectResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansReprotectPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansTestFailoverCleanupPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansTestFailoverCleanupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansTestFailoverCleanupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansTestFailoverCleanupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansTestFailoverCleanupResponse will be returned.
func (p *ReplicationRecoveryPlansTestFailoverCleanupPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansTestFailoverCleanupResponse, error) {
	respType := ReplicationRecoveryPlansTestFailoverCleanupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansTestFailoverCleanupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansTestFailoverCleanupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansTestFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansTestFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansTestFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansTestFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansTestFailoverResponse will be returned.
func (p *ReplicationRecoveryPlansTestFailoverPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansTestFailoverResponse, error) {
	respType := ReplicationRecoveryPlansTestFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansTestFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansTestFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansUnplannedFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansUnplannedFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansUnplannedFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansUnplannedFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansUnplannedFailoverResponse will be returned.
func (p *ReplicationRecoveryPlansUnplannedFailoverPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansUnplannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansUnplannedFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansUnplannedFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansUnplannedFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryPlansUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryPlansUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryPlansUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryPlansUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryPlansUpdateResponse will be returned.
func (p *ReplicationRecoveryPlansUpdatePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryPlansUpdateResponse, error) {
	respType := ReplicationRecoveryPlansUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryPlan)
	if err != nil {
		return ReplicationRecoveryPlansUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryPlansUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryServicesProvidersCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryServicesProvidersCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryServicesProvidersCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryServicesProvidersCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryServicesProvidersCreateResponse will be returned.
func (p *ReplicationRecoveryServicesProvidersCreatePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryServicesProvidersCreateResponse, error) {
	respType := ReplicationRecoveryServicesProvidersCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryServicesProvider)
	if err != nil {
		return ReplicationRecoveryServicesProvidersCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryServicesProvidersCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryServicesProvidersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryServicesProvidersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryServicesProvidersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryServicesProvidersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryServicesProvidersDeleteResponse will be returned.
func (p *ReplicationRecoveryServicesProvidersDeletePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryServicesProvidersDeleteResponse, error) {
	respType := ReplicationRecoveryServicesProvidersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationRecoveryServicesProvidersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryServicesProvidersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryServicesProvidersPurgePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryServicesProvidersPurgePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryServicesProvidersPurgePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryServicesProvidersPurgePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryServicesProvidersPurgeResponse will be returned.
func (p *ReplicationRecoveryServicesProvidersPurgePoller) FinalResponse(ctx context.Context) (ReplicationRecoveryServicesProvidersPurgeResponse, error) {
	respType := ReplicationRecoveryServicesProvidersPurgeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationRecoveryServicesProvidersPurgeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryServicesProvidersPurgePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationRecoveryServicesProvidersRefreshProviderPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationRecoveryServicesProvidersRefreshProviderPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationRecoveryServicesProvidersRefreshProviderPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationRecoveryServicesProvidersRefreshProviderPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationRecoveryServicesProvidersRefreshProviderResponse will be returned.
func (p *ReplicationRecoveryServicesProvidersRefreshProviderPoller) FinalResponse(ctx context.Context) (ReplicationRecoveryServicesProvidersRefreshProviderResponse, error) {
	respType := ReplicationRecoveryServicesProvidersRefreshProviderResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RecoveryServicesProvider)
	if err != nil {
		return ReplicationRecoveryServicesProvidersRefreshProviderResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationRecoveryServicesProvidersRefreshProviderPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationStorageClassificationMappingsCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationStorageClassificationMappingsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationStorageClassificationMappingsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationStorageClassificationMappingsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationStorageClassificationMappingsCreateResponse will be returned.
func (p *ReplicationStorageClassificationMappingsCreatePoller) FinalResponse(ctx context.Context) (ReplicationStorageClassificationMappingsCreateResponse, error) {
	respType := ReplicationStorageClassificationMappingsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.StorageClassificationMapping)
	if err != nil {
		return ReplicationStorageClassificationMappingsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationStorageClassificationMappingsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationStorageClassificationMappingsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationStorageClassificationMappingsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationStorageClassificationMappingsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationStorageClassificationMappingsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationStorageClassificationMappingsDeleteResponse will be returned.
func (p *ReplicationStorageClassificationMappingsDeletePoller) FinalResponse(ctx context.Context) (ReplicationStorageClassificationMappingsDeleteResponse, error) {
	respType := ReplicationStorageClassificationMappingsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationStorageClassificationMappingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationStorageClassificationMappingsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationVaultHealthRefreshPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationVaultHealthRefreshPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationVaultHealthRefreshPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationVaultHealthRefreshPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationVaultHealthRefreshResponse will be returned.
func (p *ReplicationVaultHealthRefreshPoller) FinalResponse(ctx context.Context) (ReplicationVaultHealthRefreshResponse, error) {
	respType := ReplicationVaultHealthRefreshResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VaultHealthDetails)
	if err != nil {
		return ReplicationVaultHealthRefreshResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationVaultHealthRefreshPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationVaultSettingCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationVaultSettingCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationVaultSettingCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationVaultSettingCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationVaultSettingCreateResponse will be returned.
func (p *ReplicationVaultSettingCreatePoller) FinalResponse(ctx context.Context) (ReplicationVaultSettingCreateResponse, error) {
	respType := ReplicationVaultSettingCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VaultSetting)
	if err != nil {
		return ReplicationVaultSettingCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationVaultSettingCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationvCentersCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationvCentersCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationvCentersCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationvCentersCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationvCentersCreateResponse will be returned.
func (p *ReplicationvCentersCreatePoller) FinalResponse(ctx context.Context) (ReplicationvCentersCreateResponse, error) {
	respType := ReplicationvCentersCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VCenter)
	if err != nil {
		return ReplicationvCentersCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationvCentersCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationvCentersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationvCentersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationvCentersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationvCentersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationvCentersDeleteResponse will be returned.
func (p *ReplicationvCentersDeletePoller) FinalResponse(ctx context.Context) (ReplicationvCentersDeleteResponse, error) {
	respType := ReplicationvCentersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationvCentersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationvCentersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationvCentersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationvCentersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationvCentersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationvCentersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationvCentersUpdateResponse will be returned.
func (p *ReplicationvCentersUpdatePoller) FinalResponse(ctx context.Context) (ReplicationvCentersUpdateResponse, error) {
	respType := ReplicationvCentersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VCenter)
	if err != nil {
		return ReplicationvCentersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationvCentersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
