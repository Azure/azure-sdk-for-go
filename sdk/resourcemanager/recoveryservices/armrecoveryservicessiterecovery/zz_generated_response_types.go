//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicessiterecovery

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// MigrationRecoveryPointsClientGetResponse contains the response from method MigrationRecoveryPointsClient.Get.
type MigrationRecoveryPointsClientGetResponse struct {
	MigrationRecoveryPointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MigrationRecoveryPointsClientGetResult contains the result from method MigrationRecoveryPointsClient.Get.
type MigrationRecoveryPointsClientGetResult struct {
	MigrationRecoveryPoint
}

// MigrationRecoveryPointsClientListByReplicationMigrationItemsResponse contains the response from method MigrationRecoveryPointsClient.ListByReplicationMigrationItems.
type MigrationRecoveryPointsClientListByReplicationMigrationItemsResponse struct {
	MigrationRecoveryPointsClientListByReplicationMigrationItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MigrationRecoveryPointsClientListByReplicationMigrationItemsResult contains the result from method MigrationRecoveryPointsClient.ListByReplicationMigrationItems.
type MigrationRecoveryPointsClientListByReplicationMigrationItemsResult struct {
	MigrationRecoveryPointCollection
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationsDiscoveryCollection
}

// RecoveryPointsClientGetResponse contains the response from method RecoveryPointsClient.Get.
type RecoveryPointsClientGetResponse struct {
	RecoveryPointsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoveryPointsClientGetResult contains the result from method RecoveryPointsClient.Get.
type RecoveryPointsClientGetResult struct {
	RecoveryPoint
}

// RecoveryPointsClientListByReplicationProtectedItemsResponse contains the response from method RecoveryPointsClient.ListByReplicationProtectedItems.
type RecoveryPointsClientListByReplicationProtectedItemsResponse struct {
	RecoveryPointsClientListByReplicationProtectedItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoveryPointsClientListByReplicationProtectedItemsResult contains the result from method RecoveryPointsClient.ListByReplicationProtectedItems.
type RecoveryPointsClientListByReplicationProtectedItemsResult struct {
	RecoveryPointCollection
}

// ReplicationAlertSettingsClientCreateResponse contains the response from method ReplicationAlertSettingsClient.Create.
type ReplicationAlertSettingsClientCreateResponse struct {
	ReplicationAlertSettingsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsClientCreateResult contains the result from method ReplicationAlertSettingsClient.Create.
type ReplicationAlertSettingsClientCreateResult struct {
	Alert
}

// ReplicationAlertSettingsClientGetResponse contains the response from method ReplicationAlertSettingsClient.Get.
type ReplicationAlertSettingsClientGetResponse struct {
	ReplicationAlertSettingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsClientGetResult contains the result from method ReplicationAlertSettingsClient.Get.
type ReplicationAlertSettingsClientGetResult struct {
	Alert
}

// ReplicationAlertSettingsClientListResponse contains the response from method ReplicationAlertSettingsClient.List.
type ReplicationAlertSettingsClientListResponse struct {
	ReplicationAlertSettingsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsClientListResult contains the result from method ReplicationAlertSettingsClient.List.
type ReplicationAlertSettingsClientListResult struct {
	AlertCollection
}

// ReplicationAppliancesClientListResponse contains the response from method ReplicationAppliancesClient.List.
type ReplicationAppliancesClientListResponse struct {
	ReplicationAppliancesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAppliancesClientListResult contains the result from method ReplicationAppliancesClient.List.
type ReplicationAppliancesClientListResult struct {
	ApplianceCollection
}

// ReplicationEligibilityResultsClientGetResponse contains the response from method ReplicationEligibilityResultsClient.Get.
type ReplicationEligibilityResultsClientGetResponse struct {
	ReplicationEligibilityResultsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEligibilityResultsClientGetResult contains the result from method ReplicationEligibilityResultsClient.Get.
type ReplicationEligibilityResultsClientGetResult struct {
	ReplicationEligibilityResults
}

// ReplicationEligibilityResultsClientListResponse contains the response from method ReplicationEligibilityResultsClient.List.
type ReplicationEligibilityResultsClientListResponse struct {
	ReplicationEligibilityResultsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEligibilityResultsClientListResult contains the result from method ReplicationEligibilityResultsClient.List.
type ReplicationEligibilityResultsClientListResult struct {
	ReplicationEligibilityResultsCollection
}

// ReplicationEventsClientGetResponse contains the response from method ReplicationEventsClient.Get.
type ReplicationEventsClientGetResponse struct {
	ReplicationEventsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEventsClientGetResult contains the result from method ReplicationEventsClient.Get.
type ReplicationEventsClientGetResult struct {
	Event
}

// ReplicationEventsClientListResponse contains the response from method ReplicationEventsClient.List.
type ReplicationEventsClientListResponse struct {
	ReplicationEventsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEventsClientListResult contains the result from method ReplicationEventsClient.List.
type ReplicationEventsClientListResult struct {
	EventCollection
}

// ReplicationFabricsClientCheckConsistencyPollerResponse contains the response from method ReplicationFabricsClient.CheckConsistency.
type ReplicationFabricsClientCheckConsistencyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientCheckConsistencyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientCheckConsistencyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientCheckConsistencyResponse, error) {
	respType := ReplicationFabricsClientCheckConsistencyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientCheckConsistencyPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientCheckConsistencyPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.CheckConsistency", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientCheckConsistencyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientCheckConsistencyResponse contains the response from method ReplicationFabricsClient.CheckConsistency.
type ReplicationFabricsClientCheckConsistencyResponse struct {
	ReplicationFabricsClientCheckConsistencyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientCheckConsistencyResult contains the result from method ReplicationFabricsClient.CheckConsistency.
type ReplicationFabricsClientCheckConsistencyResult struct {
	Fabric
}

// ReplicationFabricsClientCreatePollerResponse contains the response from method ReplicationFabricsClient.Create.
type ReplicationFabricsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientCreateResponse, error) {
	respType := ReplicationFabricsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientCreateResponse contains the response from method ReplicationFabricsClient.Create.
type ReplicationFabricsClientCreateResponse struct {
	ReplicationFabricsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientCreateResult contains the result from method ReplicationFabricsClient.Create.
type ReplicationFabricsClientCreateResult struct {
	Fabric
}

// ReplicationFabricsClientDeletePollerResponse contains the response from method ReplicationFabricsClient.Delete.
type ReplicationFabricsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientDeleteResponse, error) {
	respType := ReplicationFabricsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientDeleteResponse contains the response from method ReplicationFabricsClient.Delete.
type ReplicationFabricsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientGetResponse contains the response from method ReplicationFabricsClient.Get.
type ReplicationFabricsClientGetResponse struct {
	ReplicationFabricsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientGetResult contains the result from method ReplicationFabricsClient.Get.
type ReplicationFabricsClientGetResult struct {
	Fabric
}

// ReplicationFabricsClientListResponse contains the response from method ReplicationFabricsClient.List.
type ReplicationFabricsClientListResponse struct {
	ReplicationFabricsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientListResult contains the result from method ReplicationFabricsClient.List.
type ReplicationFabricsClientListResult struct {
	FabricCollection
}

// ReplicationFabricsClientMigrateToAADPollerResponse contains the response from method ReplicationFabricsClient.MigrateToAAD.
type ReplicationFabricsClientMigrateToAADPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientMigrateToAADPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientMigrateToAADPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientMigrateToAADResponse, error) {
	respType := ReplicationFabricsClientMigrateToAADResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientMigrateToAADPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientMigrateToAADPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.MigrateToAAD", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientMigrateToAADPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientMigrateToAADResponse contains the response from method ReplicationFabricsClient.MigrateToAAD.
type ReplicationFabricsClientMigrateToAADResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientPurgePollerResponse contains the response from method ReplicationFabricsClient.Purge.
type ReplicationFabricsClientPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientPurgeResponse, error) {
	respType := ReplicationFabricsClientPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientPurgePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientPurgePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Purge", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientPurgeResponse contains the response from method ReplicationFabricsClient.Purge.
type ReplicationFabricsClientPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientReassociateGatewayPollerResponse contains the response from method ReplicationFabricsClient.ReassociateGateway.
type ReplicationFabricsClientReassociateGatewayPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientReassociateGatewayPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientReassociateGatewayPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientReassociateGatewayResponse, error) {
	respType := ReplicationFabricsClientReassociateGatewayResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientReassociateGatewayPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientReassociateGatewayPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.ReassociateGateway", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientReassociateGatewayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientReassociateGatewayResponse contains the response from method ReplicationFabricsClient.ReassociateGateway.
type ReplicationFabricsClientReassociateGatewayResponse struct {
	ReplicationFabricsClientReassociateGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientReassociateGatewayResult contains the result from method ReplicationFabricsClient.ReassociateGateway.
type ReplicationFabricsClientReassociateGatewayResult struct {
	Fabric
}

// ReplicationFabricsClientRenewCertificatePollerResponse contains the response from method ReplicationFabricsClient.RenewCertificate.
type ReplicationFabricsClientRenewCertificatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsClientRenewCertificatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsClientRenewCertificatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsClientRenewCertificateResponse, error) {
	respType := ReplicationFabricsClientRenewCertificateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsClientRenewCertificatePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsClientRenewCertificatePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.RenewCertificate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsClientRenewCertificatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsClientRenewCertificateResponse contains the response from method ReplicationFabricsClient.RenewCertificate.
type ReplicationFabricsClientRenewCertificateResponse struct {
	ReplicationFabricsClientRenewCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsClientRenewCertificateResult contains the result from method ReplicationFabricsClient.RenewCertificate.
type ReplicationFabricsClientRenewCertificateResult struct {
	Fabric
}

// ReplicationJobsClientCancelPollerResponse contains the response from method ReplicationJobsClient.Cancel.
type ReplicationJobsClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsClientCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsClientCancelResponse, error) {
	respType := ReplicationJobsClientCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsClientCancelPollerResponse from the provided client and resume token.
func (l *ReplicationJobsClientCancelPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsClientCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsClientCancelResponse contains the response from method ReplicationJobsClient.Cancel.
type ReplicationJobsClientCancelResponse struct {
	ReplicationJobsClientCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientCancelResult contains the result from method ReplicationJobsClient.Cancel.
type ReplicationJobsClientCancelResult struct {
	Job
}

// ReplicationJobsClientExportPollerResponse contains the response from method ReplicationJobsClient.Export.
type ReplicationJobsClientExportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsClientExportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsClientExportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsClientExportResponse, error) {
	respType := ReplicationJobsClientExportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsClientExportPollerResponse from the provided client and resume token.
func (l *ReplicationJobsClientExportPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Export", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsClientExportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsClientExportResponse contains the response from method ReplicationJobsClient.Export.
type ReplicationJobsClientExportResponse struct {
	ReplicationJobsClientExportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientExportResult contains the result from method ReplicationJobsClient.Export.
type ReplicationJobsClientExportResult struct {
	Job
}

// ReplicationJobsClientGetResponse contains the response from method ReplicationJobsClient.Get.
type ReplicationJobsClientGetResponse struct {
	ReplicationJobsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientGetResult contains the result from method ReplicationJobsClient.Get.
type ReplicationJobsClientGetResult struct {
	Job
}

// ReplicationJobsClientListResponse contains the response from method ReplicationJobsClient.List.
type ReplicationJobsClientListResponse struct {
	ReplicationJobsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientListResult contains the result from method ReplicationJobsClient.List.
type ReplicationJobsClientListResult struct {
	JobCollection
}

// ReplicationJobsClientRestartPollerResponse contains the response from method ReplicationJobsClient.Restart.
type ReplicationJobsClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsClientRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsClientRestartResponse, error) {
	respType := ReplicationJobsClientRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsClientRestartPollerResponse from the provided client and resume token.
func (l *ReplicationJobsClientRestartPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsClientRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsClientRestartResponse contains the response from method ReplicationJobsClient.Restart.
type ReplicationJobsClientRestartResponse struct {
	ReplicationJobsClientRestartResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientRestartResult contains the result from method ReplicationJobsClient.Restart.
type ReplicationJobsClientRestartResult struct {
	Job
}

// ReplicationJobsClientResumePollerResponse contains the response from method ReplicationJobsClient.Resume.
type ReplicationJobsClientResumePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsClientResumePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsClientResumePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsClientResumeResponse, error) {
	respType := ReplicationJobsClientResumeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsClientResumePollerResponse from the provided client and resume token.
func (l *ReplicationJobsClientResumePollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Resume", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsClientResumePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsClientResumeResponse contains the response from method ReplicationJobsClient.Resume.
type ReplicationJobsClientResumeResponse struct {
	ReplicationJobsClientResumeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsClientResumeResult contains the result from method ReplicationJobsClient.Resume.
type ReplicationJobsClientResumeResult struct {
	Job
}

// ReplicationLogicalNetworksClientGetResponse contains the response from method ReplicationLogicalNetworksClient.Get.
type ReplicationLogicalNetworksClientGetResponse struct {
	ReplicationLogicalNetworksClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLogicalNetworksClientGetResult contains the result from method ReplicationLogicalNetworksClient.Get.
type ReplicationLogicalNetworksClientGetResult struct {
	LogicalNetwork
}

// ReplicationLogicalNetworksClientListByReplicationFabricsResponse contains the response from method ReplicationLogicalNetworksClient.ListByReplicationFabrics.
type ReplicationLogicalNetworksClientListByReplicationFabricsResponse struct {
	ReplicationLogicalNetworksClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLogicalNetworksClientListByReplicationFabricsResult contains the result from method ReplicationLogicalNetworksClient.ListByReplicationFabrics.
type ReplicationLogicalNetworksClientListByReplicationFabricsResult struct {
	LogicalNetworkCollection
}

// ReplicationMigrationItemsClientCreatePollerResponse contains the response from method ReplicationMigrationItemsClient.Create.
type ReplicationMigrationItemsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientCreateResponse, error) {
	respType := ReplicationMigrationItemsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientCreateResponse contains the response from method ReplicationMigrationItemsClient.Create.
type ReplicationMigrationItemsClientCreateResponse struct {
	ReplicationMigrationItemsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientCreateResult contains the result from method ReplicationMigrationItemsClient.Create.
type ReplicationMigrationItemsClientCreateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientDeletePollerResponse contains the response from method ReplicationMigrationItemsClient.Delete.
type ReplicationMigrationItemsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientDeleteResponse, error) {
	respType := ReplicationMigrationItemsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientDeleteResponse contains the response from method ReplicationMigrationItemsClient.Delete.
type ReplicationMigrationItemsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientGetResponse contains the response from method ReplicationMigrationItemsClient.Get.
type ReplicationMigrationItemsClientGetResponse struct {
	ReplicationMigrationItemsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientGetResult contains the result from method ReplicationMigrationItemsClient.Get.
type ReplicationMigrationItemsClientGetResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientListByReplicationProtectionContainersResponse contains the response from method ReplicationMigrationItemsClient.ListByReplicationProtectionContainers.
type ReplicationMigrationItemsClientListByReplicationProtectionContainersResponse struct {
	ReplicationMigrationItemsClientListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientListByReplicationProtectionContainersResult contains the result from method ReplicationMigrationItemsClient.ListByReplicationProtectionContainers.
type ReplicationMigrationItemsClientListByReplicationProtectionContainersResult struct {
	MigrationItemCollection
}

// ReplicationMigrationItemsClientListResponse contains the response from method ReplicationMigrationItemsClient.List.
type ReplicationMigrationItemsClientListResponse struct {
	ReplicationMigrationItemsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientListResult contains the result from method ReplicationMigrationItemsClient.List.
type ReplicationMigrationItemsClientListResult struct {
	MigrationItemCollection
}

// ReplicationMigrationItemsClientMigratePollerResponse contains the response from method ReplicationMigrationItemsClient.Migrate.
type ReplicationMigrationItemsClientMigratePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientMigratePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientMigratePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientMigrateResponse, error) {
	respType := ReplicationMigrationItemsClientMigrateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientMigratePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientMigratePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Migrate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientMigratePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientMigrateResponse contains the response from method ReplicationMigrationItemsClient.Migrate.
type ReplicationMigrationItemsClientMigrateResponse struct {
	ReplicationMigrationItemsClientMigrateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientMigrateResult contains the result from method ReplicationMigrationItemsClient.Migrate.
type ReplicationMigrationItemsClientMigrateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientResyncPollerResponse contains the response from method ReplicationMigrationItemsClient.Resync.
type ReplicationMigrationItemsClientResyncPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientResyncPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientResyncPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientResyncResponse, error) {
	respType := ReplicationMigrationItemsClientResyncResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientResyncPollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientResyncPollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Resync", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientResyncPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientResyncResponse contains the response from method ReplicationMigrationItemsClient.Resync.
type ReplicationMigrationItemsClientResyncResponse struct {
	ReplicationMigrationItemsClientResyncResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientResyncResult contains the result from method ReplicationMigrationItemsClient.Resync.
type ReplicationMigrationItemsClientResyncResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientTestMigrateCleanupPollerResponse contains the response from method ReplicationMigrationItemsClient.TestMigrateCleanup.
type ReplicationMigrationItemsClientTestMigrateCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientTestMigrateCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientTestMigrateCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientTestMigrateCleanupResponse, error) {
	respType := ReplicationMigrationItemsClientTestMigrateCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientTestMigrateCleanupPollerResponse from the provided client and resume
// token.
func (l *ReplicationMigrationItemsClientTestMigrateCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.TestMigrateCleanup", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientTestMigrateCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientTestMigrateCleanupResponse contains the response from method ReplicationMigrationItemsClient.TestMigrateCleanup.
type ReplicationMigrationItemsClientTestMigrateCleanupResponse struct {
	ReplicationMigrationItemsClientTestMigrateCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientTestMigrateCleanupResult contains the result from method ReplicationMigrationItemsClient.TestMigrateCleanup.
type ReplicationMigrationItemsClientTestMigrateCleanupResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientTestMigratePollerResponse contains the response from method ReplicationMigrationItemsClient.TestMigrate.
type ReplicationMigrationItemsClientTestMigratePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientTestMigratePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientTestMigratePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientTestMigrateResponse, error) {
	respType := ReplicationMigrationItemsClientTestMigrateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientTestMigratePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientTestMigratePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.TestMigrate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientTestMigratePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientTestMigrateResponse contains the response from method ReplicationMigrationItemsClient.TestMigrate.
type ReplicationMigrationItemsClientTestMigrateResponse struct {
	ReplicationMigrationItemsClientTestMigrateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientTestMigrateResult contains the result from method ReplicationMigrationItemsClient.TestMigrate.
type ReplicationMigrationItemsClientTestMigrateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsClientUpdatePollerResponse contains the response from method ReplicationMigrationItemsClient.Update.
type ReplicationMigrationItemsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsClientUpdateResponse, error) {
	respType := ReplicationMigrationItemsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsClientUpdateResponse contains the response from method ReplicationMigrationItemsClient.Update.
type ReplicationMigrationItemsClientUpdateResponse struct {
	ReplicationMigrationItemsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsClientUpdateResult contains the result from method ReplicationMigrationItemsClient.Update.
type ReplicationMigrationItemsClientUpdateResult struct {
	MigrationItem
}

// ReplicationNetworkMappingsClientCreatePollerResponse contains the response from method ReplicationNetworkMappingsClient.Create.
type ReplicationNetworkMappingsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsClientCreateResponse, error) {
	respType := ReplicationNetworkMappingsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsClientCreateResponse contains the response from method ReplicationNetworkMappingsClient.Create.
type ReplicationNetworkMappingsClientCreateResponse struct {
	ReplicationNetworkMappingsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientCreateResult contains the result from method ReplicationNetworkMappingsClient.Create.
type ReplicationNetworkMappingsClientCreateResult struct {
	NetworkMapping
}

// ReplicationNetworkMappingsClientDeletePollerResponse contains the response from method ReplicationNetworkMappingsClient.Delete.
type ReplicationNetworkMappingsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsClientDeleteResponse, error) {
	respType := ReplicationNetworkMappingsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsClientDeleteResponse contains the response from method ReplicationNetworkMappingsClient.Delete.
type ReplicationNetworkMappingsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientGetResponse contains the response from method ReplicationNetworkMappingsClient.Get.
type ReplicationNetworkMappingsClientGetResponse struct {
	ReplicationNetworkMappingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientGetResult contains the result from method ReplicationNetworkMappingsClient.Get.
type ReplicationNetworkMappingsClientGetResult struct {
	NetworkMapping
}

// ReplicationNetworkMappingsClientListByReplicationNetworksResponse contains the response from method ReplicationNetworkMappingsClient.ListByReplicationNetworks.
type ReplicationNetworkMappingsClientListByReplicationNetworksResponse struct {
	ReplicationNetworkMappingsClientListByReplicationNetworksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientListByReplicationNetworksResult contains the result from method ReplicationNetworkMappingsClient.ListByReplicationNetworks.
type ReplicationNetworkMappingsClientListByReplicationNetworksResult struct {
	NetworkMappingCollection
}

// ReplicationNetworkMappingsClientListResponse contains the response from method ReplicationNetworkMappingsClient.List.
type ReplicationNetworkMappingsClientListResponse struct {
	ReplicationNetworkMappingsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientListResult contains the result from method ReplicationNetworkMappingsClient.List.
type ReplicationNetworkMappingsClientListResult struct {
	NetworkMappingCollection
}

// ReplicationNetworkMappingsClientUpdatePollerResponse contains the response from method ReplicationNetworkMappingsClient.Update.
type ReplicationNetworkMappingsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsClientUpdateResponse, error) {
	respType := ReplicationNetworkMappingsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsClientUpdateResponse contains the response from method ReplicationNetworkMappingsClient.Update.
type ReplicationNetworkMappingsClientUpdateResponse struct {
	ReplicationNetworkMappingsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsClientUpdateResult contains the result from method ReplicationNetworkMappingsClient.Update.
type ReplicationNetworkMappingsClientUpdateResult struct {
	NetworkMapping
}

// ReplicationNetworksClientGetResponse contains the response from method ReplicationNetworksClient.Get.
type ReplicationNetworksClientGetResponse struct {
	ReplicationNetworksClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksClientGetResult contains the result from method ReplicationNetworksClient.Get.
type ReplicationNetworksClientGetResult struct {
	Network
}

// ReplicationNetworksClientListByReplicationFabricsResponse contains the response from method ReplicationNetworksClient.ListByReplicationFabrics.
type ReplicationNetworksClientListByReplicationFabricsResponse struct {
	ReplicationNetworksClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksClientListByReplicationFabricsResult contains the result from method ReplicationNetworksClient.ListByReplicationFabrics.
type ReplicationNetworksClientListByReplicationFabricsResult struct {
	NetworkCollection
}

// ReplicationNetworksClientListResponse contains the response from method ReplicationNetworksClient.List.
type ReplicationNetworksClientListResponse struct {
	ReplicationNetworksClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksClientListResult contains the result from method ReplicationNetworksClient.List.
type ReplicationNetworksClientListResult struct {
	NetworkCollection
}

// ReplicationPoliciesClientCreatePollerResponse contains the response from method ReplicationPoliciesClient.Create.
type ReplicationPoliciesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesClientCreateResponse, error) {
	respType := ReplicationPoliciesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Policy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesClientCreateResponse contains the response from method ReplicationPoliciesClient.Create.
type ReplicationPoliciesClientCreateResponse struct {
	ReplicationPoliciesClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesClientCreateResult contains the result from method ReplicationPoliciesClient.Create.
type ReplicationPoliciesClientCreateResult struct {
	Policy
}

// ReplicationPoliciesClientDeletePollerResponse contains the response from method ReplicationPoliciesClient.Delete.
type ReplicationPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesClientDeleteResponse, error) {
	respType := ReplicationPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesClientDeleteResponse contains the response from method ReplicationPoliciesClient.Delete.
type ReplicationPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesClientGetResponse contains the response from method ReplicationPoliciesClient.Get.
type ReplicationPoliciesClientGetResponse struct {
	ReplicationPoliciesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesClientGetResult contains the result from method ReplicationPoliciesClient.Get.
type ReplicationPoliciesClientGetResult struct {
	Policy
}

// ReplicationPoliciesClientListResponse contains the response from method ReplicationPoliciesClient.List.
type ReplicationPoliciesClientListResponse struct {
	ReplicationPoliciesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesClientListResult contains the result from method ReplicationPoliciesClient.List.
type ReplicationPoliciesClientListResult struct {
	PolicyCollection
}

// ReplicationPoliciesClientUpdatePollerResponse contains the response from method ReplicationPoliciesClient.Update.
type ReplicationPoliciesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesClientUpdateResponse, error) {
	respType := ReplicationPoliciesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Policy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesClientUpdateResponse contains the response from method ReplicationPoliciesClient.Update.
type ReplicationPoliciesClientUpdateResponse struct {
	ReplicationPoliciesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesClientUpdateResult contains the result from method ReplicationPoliciesClient.Update.
type ReplicationPoliciesClientUpdateResult struct {
	Policy
}

// ReplicationProtectableItemsClientGetResponse contains the response from method ReplicationProtectableItemsClient.Get.
type ReplicationProtectableItemsClientGetResponse struct {
	ReplicationProtectableItemsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectableItemsClientGetResult contains the result from method ReplicationProtectableItemsClient.Get.
type ReplicationProtectableItemsClientGetResult struct {
	ProtectableItem
}

// ReplicationProtectableItemsClientListByReplicationProtectionContainersResponse contains the response from method ReplicationProtectableItemsClient.ListByReplicationProtectionContainers.
type ReplicationProtectableItemsClientListByReplicationProtectionContainersResponse struct {
	ReplicationProtectableItemsClientListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectableItemsClientListByReplicationProtectionContainersResult contains the result from method ReplicationProtectableItemsClient.ListByReplicationProtectionContainers.
type ReplicationProtectableItemsClientListByReplicationProtectionContainersResult struct {
	ProtectableItemCollection
}

// ReplicationProtectedItemsClientAddDisksPollerResponse contains the response from method ReplicationProtectedItemsClient.AddDisks.
type ReplicationProtectedItemsClientAddDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientAddDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientAddDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientAddDisksResponse, error) {
	respType := ReplicationProtectedItemsClientAddDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientAddDisksPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientAddDisksPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.AddDisks", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientAddDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientAddDisksResponse contains the response from method ReplicationProtectedItemsClient.AddDisks.
type ReplicationProtectedItemsClientAddDisksResponse struct {
	ReplicationProtectedItemsClientAddDisksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientAddDisksResult contains the result from method ReplicationProtectedItemsClient.AddDisks.
type ReplicationProtectedItemsClientAddDisksResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientApplyRecoveryPointPollerResponse contains the response from method ReplicationProtectedItemsClient.ApplyRecoveryPoint.
type ReplicationProtectedItemsClientApplyRecoveryPointPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientApplyRecoveryPointPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientApplyRecoveryPointPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientApplyRecoveryPointResponse, error) {
	respType := ReplicationProtectedItemsClientApplyRecoveryPointResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientApplyRecoveryPointPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientApplyRecoveryPointPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.ApplyRecoveryPoint", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientApplyRecoveryPointPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientApplyRecoveryPointResponse contains the response from method ReplicationProtectedItemsClient.ApplyRecoveryPoint.
type ReplicationProtectedItemsClientApplyRecoveryPointResponse struct {
	ReplicationProtectedItemsClientApplyRecoveryPointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientApplyRecoveryPointResult contains the result from method ReplicationProtectedItemsClient.ApplyRecoveryPoint.
type ReplicationProtectedItemsClientApplyRecoveryPointResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientCreatePollerResponse contains the response from method ReplicationProtectedItemsClient.Create.
type ReplicationProtectedItemsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientCreateResponse, error) {
	respType := ReplicationProtectedItemsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientCreateResponse contains the response from method ReplicationProtectedItemsClient.Create.
type ReplicationProtectedItemsClientCreateResponse struct {
	ReplicationProtectedItemsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientCreateResult contains the result from method ReplicationProtectedItemsClient.Create.
type ReplicationProtectedItemsClientCreateResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientDeletePollerResponse contains the response from method ReplicationProtectedItemsClient.Delete.
type ReplicationProtectedItemsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientDeleteResponse, error) {
	respType := ReplicationProtectedItemsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientDeleteResponse contains the response from method ReplicationProtectedItemsClient.Delete.
type ReplicationProtectedItemsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientFailoverCancelPollerResponse contains the response from method ReplicationProtectedItemsClient.FailoverCancel.
type ReplicationProtectedItemsClientFailoverCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientFailoverCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientFailoverCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientFailoverCancelResponse, error) {
	respType := ReplicationProtectedItemsClientFailoverCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientFailoverCancelPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientFailoverCancelPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.FailoverCancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientFailoverCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientFailoverCancelResponse contains the response from method ReplicationProtectedItemsClient.FailoverCancel.
type ReplicationProtectedItemsClientFailoverCancelResponse struct {
	ReplicationProtectedItemsClientFailoverCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientFailoverCancelResult contains the result from method ReplicationProtectedItemsClient.FailoverCancel.
type ReplicationProtectedItemsClientFailoverCancelResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientFailoverCommitPollerResponse contains the response from method ReplicationProtectedItemsClient.FailoverCommit.
type ReplicationProtectedItemsClientFailoverCommitPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientFailoverCommitPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientFailoverCommitPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientFailoverCommitResponse, error) {
	respType := ReplicationProtectedItemsClientFailoverCommitResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientFailoverCommitPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientFailoverCommitPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.FailoverCommit", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientFailoverCommitPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientFailoverCommitResponse contains the response from method ReplicationProtectedItemsClient.FailoverCommit.
type ReplicationProtectedItemsClientFailoverCommitResponse struct {
	ReplicationProtectedItemsClientFailoverCommitResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientFailoverCommitResult contains the result from method ReplicationProtectedItemsClient.FailoverCommit.
type ReplicationProtectedItemsClientFailoverCommitResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientGetResponse contains the response from method ReplicationProtectedItemsClient.Get.
type ReplicationProtectedItemsClientGetResponse struct {
	ReplicationProtectedItemsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientGetResult contains the result from method ReplicationProtectedItemsClient.Get.
type ReplicationProtectedItemsClientGetResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientListByReplicationProtectionContainersResponse contains the response from method ReplicationProtectedItemsClient.ListByReplicationProtectionContainers.
type ReplicationProtectedItemsClientListByReplicationProtectionContainersResponse struct {
	ReplicationProtectedItemsClientListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientListByReplicationProtectionContainersResult contains the result from method ReplicationProtectedItemsClient.ListByReplicationProtectionContainers.
type ReplicationProtectedItemsClientListByReplicationProtectionContainersResult struct {
	ReplicationProtectedItemCollection
}

// ReplicationProtectedItemsClientListResponse contains the response from method ReplicationProtectedItemsClient.List.
type ReplicationProtectedItemsClientListResponse struct {
	ReplicationProtectedItemsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientListResult contains the result from method ReplicationProtectedItemsClient.List.
type ReplicationProtectedItemsClientListResult struct {
	ReplicationProtectedItemCollection
}

// ReplicationProtectedItemsClientPlannedFailoverPollerResponse contains the response from method ReplicationProtectedItemsClient.PlannedFailover.
type ReplicationProtectedItemsClientPlannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientPlannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientPlannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientPlannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsClientPlannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientPlannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientPlannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.PlannedFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientPlannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientPlannedFailoverResponse contains the response from method ReplicationProtectedItemsClient.PlannedFailover.
type ReplicationProtectedItemsClientPlannedFailoverResponse struct {
	ReplicationProtectedItemsClientPlannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientPlannedFailoverResult contains the result from method ReplicationProtectedItemsClient.PlannedFailover.
type ReplicationProtectedItemsClientPlannedFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientPurgePollerResponse contains the response from method ReplicationProtectedItemsClient.Purge.
type ReplicationProtectedItemsClientPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientPurgeResponse, error) {
	respType := ReplicationProtectedItemsClientPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientPurgePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientPurgePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Purge", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientPurgeResponse contains the response from method ReplicationProtectedItemsClient.Purge.
type ReplicationProtectedItemsClientPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientRemoveDisksPollerResponse contains the response from method ReplicationProtectedItemsClient.RemoveDisks.
type ReplicationProtectedItemsClientRemoveDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientRemoveDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientRemoveDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientRemoveDisksResponse, error) {
	respType := ReplicationProtectedItemsClientRemoveDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientRemoveDisksPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientRemoveDisksPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.RemoveDisks", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientRemoveDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientRemoveDisksResponse contains the response from method ReplicationProtectedItemsClient.RemoveDisks.
type ReplicationProtectedItemsClientRemoveDisksResponse struct {
	ReplicationProtectedItemsClientRemoveDisksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientRemoveDisksResult contains the result from method ReplicationProtectedItemsClient.RemoveDisks.
type ReplicationProtectedItemsClientRemoveDisksResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientRepairReplicationPollerResponse contains the response from method ReplicationProtectedItemsClient.RepairReplication.
type ReplicationProtectedItemsClientRepairReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientRepairReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientRepairReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientRepairReplicationResponse, error) {
	respType := ReplicationProtectedItemsClientRepairReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientRepairReplicationPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientRepairReplicationPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.RepairReplication", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientRepairReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientRepairReplicationResponse contains the response from method ReplicationProtectedItemsClient.RepairReplication.
type ReplicationProtectedItemsClientRepairReplicationResponse struct {
	ReplicationProtectedItemsClientRepairReplicationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientRepairReplicationResult contains the result from method ReplicationProtectedItemsClient.RepairReplication.
type ReplicationProtectedItemsClientRepairReplicationResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientReprotectPollerResponse contains the response from method ReplicationProtectedItemsClient.Reprotect.
type ReplicationProtectedItemsClientReprotectPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientReprotectPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientReprotectPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientReprotectResponse, error) {
	respType := ReplicationProtectedItemsClientReprotectResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientReprotectPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientReprotectPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Reprotect", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientReprotectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientReprotectResponse contains the response from method ReplicationProtectedItemsClient.Reprotect.
type ReplicationProtectedItemsClientReprotectResponse struct {
	ReplicationProtectedItemsClientReprotectResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientReprotectResult contains the result from method ReplicationProtectedItemsClient.Reprotect.
type ReplicationProtectedItemsClientReprotectResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientResolveHealthErrorsPollerResponse contains the response from method ReplicationProtectedItemsClient.ResolveHealthErrors.
type ReplicationProtectedItemsClientResolveHealthErrorsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientResolveHealthErrorsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientResolveHealthErrorsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientResolveHealthErrorsResponse, error) {
	respType := ReplicationProtectedItemsClientResolveHealthErrorsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientResolveHealthErrorsPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientResolveHealthErrorsPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.ResolveHealthErrors", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientResolveHealthErrorsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientResolveHealthErrorsResponse contains the response from method ReplicationProtectedItemsClient.ResolveHealthErrors.
type ReplicationProtectedItemsClientResolveHealthErrorsResponse struct {
	ReplicationProtectedItemsClientResolveHealthErrorsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientResolveHealthErrorsResult contains the result from method ReplicationProtectedItemsClient.ResolveHealthErrors.
type ReplicationProtectedItemsClientResolveHealthErrorsResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientSwitchProviderPollerResponse contains the response from method ReplicationProtectedItemsClient.SwitchProvider.
type ReplicationProtectedItemsClientSwitchProviderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientSwitchProviderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientSwitchProviderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientSwitchProviderResponse, error) {
	respType := ReplicationProtectedItemsClientSwitchProviderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientSwitchProviderPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientSwitchProviderPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.SwitchProvider", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientSwitchProviderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientSwitchProviderResponse contains the response from method ReplicationProtectedItemsClient.SwitchProvider.
type ReplicationProtectedItemsClientSwitchProviderResponse struct {
	ReplicationProtectedItemsClientSwitchProviderResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientSwitchProviderResult contains the result from method ReplicationProtectedItemsClient.SwitchProvider.
type ReplicationProtectedItemsClientSwitchProviderResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientTestFailoverCleanupPollerResponse contains the response from method ReplicationProtectedItemsClient.TestFailoverCleanup.
type ReplicationProtectedItemsClientTestFailoverCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientTestFailoverCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientTestFailoverCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientTestFailoverCleanupResponse, error) {
	respType := ReplicationProtectedItemsClientTestFailoverCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientTestFailoverCleanupPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientTestFailoverCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.TestFailoverCleanup", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientTestFailoverCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientTestFailoverCleanupResponse contains the response from method ReplicationProtectedItemsClient.TestFailoverCleanup.
type ReplicationProtectedItemsClientTestFailoverCleanupResponse struct {
	ReplicationProtectedItemsClientTestFailoverCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientTestFailoverCleanupResult contains the result from method ReplicationProtectedItemsClient.TestFailoverCleanup.
type ReplicationProtectedItemsClientTestFailoverCleanupResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientTestFailoverPollerResponse contains the response from method ReplicationProtectedItemsClient.TestFailover.
type ReplicationProtectedItemsClientTestFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientTestFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientTestFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientTestFailoverResponse, error) {
	respType := ReplicationProtectedItemsClientTestFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientTestFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientTestFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.TestFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientTestFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientTestFailoverResponse contains the response from method ReplicationProtectedItemsClient.TestFailover.
type ReplicationProtectedItemsClientTestFailoverResponse struct {
	ReplicationProtectedItemsClientTestFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientTestFailoverResult contains the result from method ReplicationProtectedItemsClient.TestFailover.
type ReplicationProtectedItemsClientTestFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientUnplannedFailoverPollerResponse contains the response from method ReplicationProtectedItemsClient.UnplannedFailover.
type ReplicationProtectedItemsClientUnplannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientUnplannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientUnplannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientUnplannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsClientUnplannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientUnplannedFailoverPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientUnplannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UnplannedFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientUnplannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientUnplannedFailoverResponse contains the response from method ReplicationProtectedItemsClient.UnplannedFailover.
type ReplicationProtectedItemsClientUnplannedFailoverResponse struct {
	ReplicationProtectedItemsClientUnplannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientUnplannedFailoverResult contains the result from method ReplicationProtectedItemsClient.UnplannedFailover.
type ReplicationProtectedItemsClientUnplannedFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientUpdateAppliancePollerResponse contains the response from method ReplicationProtectedItemsClient.UpdateAppliance.
type ReplicationProtectedItemsClientUpdateAppliancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientUpdateAppliancePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientUpdateAppliancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientUpdateApplianceResponse, error) {
	respType := ReplicationProtectedItemsClientUpdateApplianceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientUpdateAppliancePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientUpdateAppliancePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UpdateAppliance", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientUpdateAppliancePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientUpdateApplianceResponse contains the response from method ReplicationProtectedItemsClient.UpdateAppliance.
type ReplicationProtectedItemsClientUpdateApplianceResponse struct {
	ReplicationProtectedItemsClientUpdateApplianceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientUpdateApplianceResult contains the result from method ReplicationProtectedItemsClient.UpdateAppliance.
type ReplicationProtectedItemsClientUpdateApplianceResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientUpdateMobilityServicePollerResponse contains the response from method ReplicationProtectedItemsClient.UpdateMobilityService.
type ReplicationProtectedItemsClientUpdateMobilityServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientUpdateMobilityServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientUpdateMobilityServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientUpdateMobilityServiceResponse, error) {
	respType := ReplicationProtectedItemsClientUpdateMobilityServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientUpdateMobilityServicePollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectedItemsClientUpdateMobilityServicePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UpdateMobilityService", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientUpdateMobilityServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientUpdateMobilityServiceResponse contains the response from method ReplicationProtectedItemsClient.UpdateMobilityService.
type ReplicationProtectedItemsClientUpdateMobilityServiceResponse struct {
	ReplicationProtectedItemsClientUpdateMobilityServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientUpdateMobilityServiceResult contains the result from method ReplicationProtectedItemsClient.UpdateMobilityService.
type ReplicationProtectedItemsClientUpdateMobilityServiceResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsClientUpdatePollerResponse contains the response from method ReplicationProtectedItemsClient.Update.
type ReplicationProtectedItemsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsClientUpdateResponse, error) {
	respType := ReplicationProtectedItemsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsClientUpdateResponse contains the response from method ReplicationProtectedItemsClient.Update.
type ReplicationProtectedItemsClientUpdateResponse struct {
	ReplicationProtectedItemsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsClientUpdateResult contains the result from method ReplicationProtectedItemsClient.Update.
type ReplicationProtectedItemsClientUpdateResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectionContainerMappingsClientCreatePollerResponse contains the response from method ReplicationProtectionContainerMappingsClient.Create.
type ReplicationProtectionContainerMappingsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsClientCreateResponse, error) {
	respType := ReplicationProtectionContainerMappingsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainerMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsClientCreatePollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectionContainerMappingsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsClientCreateResponse contains the response from method ReplicationProtectionContainerMappingsClient.Create.
type ReplicationProtectionContainerMappingsClientCreateResponse struct {
	ReplicationProtectionContainerMappingsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientCreateResult contains the result from method ReplicationProtectionContainerMappingsClient.Create.
type ReplicationProtectionContainerMappingsClientCreateResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainerMappingsClientDeletePollerResponse contains the response from method ReplicationProtectionContainerMappingsClient.Delete.
type ReplicationProtectionContainerMappingsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsClientDeleteResponse, error) {
	respType := ReplicationProtectionContainerMappingsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsClientDeletePollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectionContainerMappingsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsClientDeleteResponse contains the response from method ReplicationProtectionContainerMappingsClient.Delete.
type ReplicationProtectionContainerMappingsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientGetResponse contains the response from method ReplicationProtectionContainerMappingsClient.Get.
type ReplicationProtectionContainerMappingsClientGetResponse struct {
	ReplicationProtectionContainerMappingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientGetResult contains the result from method ReplicationProtectionContainerMappingsClient.Get.
type ReplicationProtectionContainerMappingsClientGetResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainerMappingsClientListByReplicationProtectionContainersResponse contains the response from method
// ReplicationProtectionContainerMappingsClient.ListByReplicationProtectionContainers.
type ReplicationProtectionContainerMappingsClientListByReplicationProtectionContainersResponse struct {
	ReplicationProtectionContainerMappingsClientListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientListByReplicationProtectionContainersResult contains the result from method
// ReplicationProtectionContainerMappingsClient.ListByReplicationProtectionContainers.
type ReplicationProtectionContainerMappingsClientListByReplicationProtectionContainersResult struct {
	ProtectionContainerMappingCollection
}

// ReplicationProtectionContainerMappingsClientListResponse contains the response from method ReplicationProtectionContainerMappingsClient.List.
type ReplicationProtectionContainerMappingsClientListResponse struct {
	ReplicationProtectionContainerMappingsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientListResult contains the result from method ReplicationProtectionContainerMappingsClient.List.
type ReplicationProtectionContainerMappingsClientListResult struct {
	ProtectionContainerMappingCollection
}

// ReplicationProtectionContainerMappingsClientPurgePollerResponse contains the response from method ReplicationProtectionContainerMappingsClient.Purge.
type ReplicationProtectionContainerMappingsClientPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsClientPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsClientPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsClientPurgeResponse, error) {
	respType := ReplicationProtectionContainerMappingsClientPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsClientPurgePollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectionContainerMappingsClientPurgePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Purge", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsClientPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsClientPurgeResponse contains the response from method ReplicationProtectionContainerMappingsClient.Purge.
type ReplicationProtectionContainerMappingsClientPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientUpdatePollerResponse contains the response from method ReplicationProtectionContainerMappingsClient.Update.
type ReplicationProtectionContainerMappingsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsClientUpdateResponse, error) {
	respType := ReplicationProtectionContainerMappingsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainerMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsClientUpdatePollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectionContainerMappingsClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsClientUpdateResponse contains the response from method ReplicationProtectionContainerMappingsClient.Update.
type ReplicationProtectionContainerMappingsClientUpdateResponse struct {
	ReplicationProtectionContainerMappingsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsClientUpdateResult contains the result from method ReplicationProtectionContainerMappingsClient.Update.
type ReplicationProtectionContainerMappingsClientUpdateResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainersClientCreatePollerResponse contains the response from method ReplicationProtectionContainersClient.Create.
type ReplicationProtectionContainersClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersClientCreateResponse, error) {
	respType := ReplicationProtectionContainersClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersClientCreateResponse contains the response from method ReplicationProtectionContainersClient.Create.
type ReplicationProtectionContainersClientCreateResponse struct {
	ReplicationProtectionContainersClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientCreateResult contains the result from method ReplicationProtectionContainersClient.Create.
type ReplicationProtectionContainersClientCreateResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersClientDeletePollerResponse contains the response from method ReplicationProtectionContainersClient.Delete.
type ReplicationProtectionContainersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersClientDeleteResponse, error) {
	respType := ReplicationProtectionContainersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersClientDeleteResponse contains the response from method ReplicationProtectionContainersClient.Delete.
type ReplicationProtectionContainersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientDiscoverProtectableItemPollerResponse contains the response from method ReplicationProtectionContainersClient.DiscoverProtectableItem.
type ReplicationProtectionContainersClientDiscoverProtectableItemPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersClientDiscoverProtectableItemPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersClientDiscoverProtectableItemPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersClientDiscoverProtectableItemResponse, error) {
	respType := ReplicationProtectionContainersClientDiscoverProtectableItemResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersClientDiscoverProtectableItemPollerResponse from the provided client
// and resume token.
func (l *ReplicationProtectionContainersClientDiscoverProtectableItemPollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.DiscoverProtectableItem", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersClientDiscoverProtectableItemPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersClientDiscoverProtectableItemResponse contains the response from method ReplicationProtectionContainersClient.DiscoverProtectableItem.
type ReplicationProtectionContainersClientDiscoverProtectableItemResponse struct {
	ReplicationProtectionContainersClientDiscoverProtectableItemResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientDiscoverProtectableItemResult contains the result from method ReplicationProtectionContainersClient.DiscoverProtectableItem.
type ReplicationProtectionContainersClientDiscoverProtectableItemResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersClientGetResponse contains the response from method ReplicationProtectionContainersClient.Get.
type ReplicationProtectionContainersClientGetResponse struct {
	ReplicationProtectionContainersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientGetResult contains the result from method ReplicationProtectionContainersClient.Get.
type ReplicationProtectionContainersClientGetResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersClientListByReplicationFabricsResponse contains the response from method ReplicationProtectionContainersClient.ListByReplicationFabrics.
type ReplicationProtectionContainersClientListByReplicationFabricsResponse struct {
	ReplicationProtectionContainersClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientListByReplicationFabricsResult contains the result from method ReplicationProtectionContainersClient.ListByReplicationFabrics.
type ReplicationProtectionContainersClientListByReplicationFabricsResult struct {
	ProtectionContainerCollection
}

// ReplicationProtectionContainersClientListResponse contains the response from method ReplicationProtectionContainersClient.List.
type ReplicationProtectionContainersClientListResponse struct {
	ReplicationProtectionContainersClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientListResult contains the result from method ReplicationProtectionContainersClient.List.
type ReplicationProtectionContainersClientListResult struct {
	ProtectionContainerCollection
}

// ReplicationProtectionContainersClientSwitchProtectionPollerResponse contains the response from method ReplicationProtectionContainersClient.SwitchProtection.
type ReplicationProtectionContainersClientSwitchProtectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersClientSwitchProtectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersClientSwitchProtectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersClientSwitchProtectionResponse, error) {
	respType := ReplicationProtectionContainersClientSwitchProtectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersClientSwitchProtectionPollerResponse from the provided client and resume
// token.
func (l *ReplicationProtectionContainersClientSwitchProtectionPollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.SwitchProtection", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersClientSwitchProtectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersClientSwitchProtectionResponse contains the response from method ReplicationProtectionContainersClient.SwitchProtection.
type ReplicationProtectionContainersClientSwitchProtectionResponse struct {
	ReplicationProtectionContainersClientSwitchProtectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersClientSwitchProtectionResult contains the result from method ReplicationProtectionContainersClient.SwitchProtection.
type ReplicationProtectionContainersClientSwitchProtectionResult struct {
	ProtectionContainer
}

// ReplicationProtectionIntentsClientCreateResponse contains the response from method ReplicationProtectionIntentsClient.Create.
type ReplicationProtectionIntentsClientCreateResponse struct {
	ReplicationProtectionIntentsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsClientCreateResult contains the result from method ReplicationProtectionIntentsClient.Create.
type ReplicationProtectionIntentsClientCreateResult struct {
	ReplicationProtectionIntent
}

// ReplicationProtectionIntentsClientGetResponse contains the response from method ReplicationProtectionIntentsClient.Get.
type ReplicationProtectionIntentsClientGetResponse struct {
	ReplicationProtectionIntentsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsClientGetResult contains the result from method ReplicationProtectionIntentsClient.Get.
type ReplicationProtectionIntentsClientGetResult struct {
	ReplicationProtectionIntent
}

// ReplicationProtectionIntentsClientListResponse contains the response from method ReplicationProtectionIntentsClient.List.
type ReplicationProtectionIntentsClientListResponse struct {
	ReplicationProtectionIntentsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsClientListResult contains the result from method ReplicationProtectionIntentsClient.List.
type ReplicationProtectionIntentsClientListResult struct {
	ReplicationProtectionIntentCollection
}

// ReplicationRecoveryPlansClientCreatePollerResponse contains the response from method ReplicationRecoveryPlansClient.Create.
type ReplicationRecoveryPlansClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientCreateResponse, error) {
	respType := ReplicationRecoveryPlansClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientCreateResponse contains the response from method ReplicationRecoveryPlansClient.Create.
type ReplicationRecoveryPlansClientCreateResponse struct {
	ReplicationRecoveryPlansClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientCreateResult contains the result from method ReplicationRecoveryPlansClient.Create.
type ReplicationRecoveryPlansClientCreateResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientDeletePollerResponse contains the response from method ReplicationRecoveryPlansClient.Delete.
type ReplicationRecoveryPlansClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientDeleteResponse, error) {
	respType := ReplicationRecoveryPlansClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientDeleteResponse contains the response from method ReplicationRecoveryPlansClient.Delete.
type ReplicationRecoveryPlansClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientFailoverCancelPollerResponse contains the response from method ReplicationRecoveryPlansClient.FailoverCancel.
type ReplicationRecoveryPlansClientFailoverCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientFailoverCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientFailoverCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientFailoverCancelResponse, error) {
	respType := ReplicationRecoveryPlansClientFailoverCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientFailoverCancelPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientFailoverCancelPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.FailoverCancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientFailoverCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientFailoverCancelResponse contains the response from method ReplicationRecoveryPlansClient.FailoverCancel.
type ReplicationRecoveryPlansClientFailoverCancelResponse struct {
	ReplicationRecoveryPlansClientFailoverCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientFailoverCancelResult contains the result from method ReplicationRecoveryPlansClient.FailoverCancel.
type ReplicationRecoveryPlansClientFailoverCancelResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientFailoverCommitPollerResponse contains the response from method ReplicationRecoveryPlansClient.FailoverCommit.
type ReplicationRecoveryPlansClientFailoverCommitPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientFailoverCommitPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientFailoverCommitPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientFailoverCommitResponse, error) {
	respType := ReplicationRecoveryPlansClientFailoverCommitResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientFailoverCommitPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientFailoverCommitPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.FailoverCommit", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientFailoverCommitPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientFailoverCommitResponse contains the response from method ReplicationRecoveryPlansClient.FailoverCommit.
type ReplicationRecoveryPlansClientFailoverCommitResponse struct {
	ReplicationRecoveryPlansClientFailoverCommitResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientFailoverCommitResult contains the result from method ReplicationRecoveryPlansClient.FailoverCommit.
type ReplicationRecoveryPlansClientFailoverCommitResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientGetResponse contains the response from method ReplicationRecoveryPlansClient.Get.
type ReplicationRecoveryPlansClientGetResponse struct {
	ReplicationRecoveryPlansClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientGetResult contains the result from method ReplicationRecoveryPlansClient.Get.
type ReplicationRecoveryPlansClientGetResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientListResponse contains the response from method ReplicationRecoveryPlansClient.List.
type ReplicationRecoveryPlansClientListResponse struct {
	ReplicationRecoveryPlansClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientListResult contains the result from method ReplicationRecoveryPlansClient.List.
type ReplicationRecoveryPlansClientListResult struct {
	RecoveryPlanCollection
}

// ReplicationRecoveryPlansClientPlannedFailoverPollerResponse contains the response from method ReplicationRecoveryPlansClient.PlannedFailover.
type ReplicationRecoveryPlansClientPlannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientPlannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientPlannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientPlannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansClientPlannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientPlannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientPlannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.PlannedFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientPlannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientPlannedFailoverResponse contains the response from method ReplicationRecoveryPlansClient.PlannedFailover.
type ReplicationRecoveryPlansClientPlannedFailoverResponse struct {
	ReplicationRecoveryPlansClientPlannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientPlannedFailoverResult contains the result from method ReplicationRecoveryPlansClient.PlannedFailover.
type ReplicationRecoveryPlansClientPlannedFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientReprotectPollerResponse contains the response from method ReplicationRecoveryPlansClient.Reprotect.
type ReplicationRecoveryPlansClientReprotectPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientReprotectPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientReprotectPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientReprotectResponse, error) {
	respType := ReplicationRecoveryPlansClientReprotectResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientReprotectPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientReprotectPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Reprotect", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientReprotectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientReprotectResponse contains the response from method ReplicationRecoveryPlansClient.Reprotect.
type ReplicationRecoveryPlansClientReprotectResponse struct {
	ReplicationRecoveryPlansClientReprotectResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientReprotectResult contains the result from method ReplicationRecoveryPlansClient.Reprotect.
type ReplicationRecoveryPlansClientReprotectResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientTestFailoverCleanupPollerResponse contains the response from method ReplicationRecoveryPlansClient.TestFailoverCleanup.
type ReplicationRecoveryPlansClientTestFailoverCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientTestFailoverCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientTestFailoverCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientTestFailoverCleanupResponse, error) {
	respType := ReplicationRecoveryPlansClientTestFailoverCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientTestFailoverCleanupPollerResponse from the provided client and resume
// token.
func (l *ReplicationRecoveryPlansClientTestFailoverCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.TestFailoverCleanup", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientTestFailoverCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientTestFailoverCleanupResponse contains the response from method ReplicationRecoveryPlansClient.TestFailoverCleanup.
type ReplicationRecoveryPlansClientTestFailoverCleanupResponse struct {
	ReplicationRecoveryPlansClientTestFailoverCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientTestFailoverCleanupResult contains the result from method ReplicationRecoveryPlansClient.TestFailoverCleanup.
type ReplicationRecoveryPlansClientTestFailoverCleanupResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientTestFailoverPollerResponse contains the response from method ReplicationRecoveryPlansClient.TestFailover.
type ReplicationRecoveryPlansClientTestFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientTestFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientTestFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientTestFailoverResponse, error) {
	respType := ReplicationRecoveryPlansClientTestFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientTestFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientTestFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.TestFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientTestFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientTestFailoverResponse contains the response from method ReplicationRecoveryPlansClient.TestFailover.
type ReplicationRecoveryPlansClientTestFailoverResponse struct {
	ReplicationRecoveryPlansClientTestFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientTestFailoverResult contains the result from method ReplicationRecoveryPlansClient.TestFailover.
type ReplicationRecoveryPlansClientTestFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientUnplannedFailoverPollerResponse contains the response from method ReplicationRecoveryPlansClient.UnplannedFailover.
type ReplicationRecoveryPlansClientUnplannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientUnplannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientUnplannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientUnplannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansClientUnplannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientUnplannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientUnplannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.UnplannedFailover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientUnplannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientUnplannedFailoverResponse contains the response from method ReplicationRecoveryPlansClient.UnplannedFailover.
type ReplicationRecoveryPlansClientUnplannedFailoverResponse struct {
	ReplicationRecoveryPlansClientUnplannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientUnplannedFailoverResult contains the result from method ReplicationRecoveryPlansClient.UnplannedFailover.
type ReplicationRecoveryPlansClientUnplannedFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansClientUpdatePollerResponse contains the response from method ReplicationRecoveryPlansClient.Update.
type ReplicationRecoveryPlansClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansClientUpdateResponse, error) {
	respType := ReplicationRecoveryPlansClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansClientUpdateResponse contains the response from method ReplicationRecoveryPlansClient.Update.
type ReplicationRecoveryPlansClientUpdateResponse struct {
	ReplicationRecoveryPlansClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansClientUpdateResult contains the result from method ReplicationRecoveryPlansClient.Update.
type ReplicationRecoveryPlansClientUpdateResult struct {
	RecoveryPlan
}

// ReplicationRecoveryServicesProvidersClientCreatePollerResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Create.
type ReplicationRecoveryServicesProvidersClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersClientCreateResponse, error) {
	respType := ReplicationRecoveryServicesProvidersClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryServicesProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersClientCreatePollerResponse from the provided client and resume
// token.
func (l *ReplicationRecoveryServicesProvidersClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersClientCreateResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Create.
type ReplicationRecoveryServicesProvidersClientCreateResponse struct {
	ReplicationRecoveryServicesProvidersClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientCreateResult contains the result from method ReplicationRecoveryServicesProvidersClient.Create.
type ReplicationRecoveryServicesProvidersClientCreateResult struct {
	RecoveryServicesProvider
}

// ReplicationRecoveryServicesProvidersClientDeletePollerResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Delete.
type ReplicationRecoveryServicesProvidersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersClientDeleteResponse, error) {
	respType := ReplicationRecoveryServicesProvidersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersClientDeletePollerResponse from the provided client and resume
// token.
func (l *ReplicationRecoveryServicesProvidersClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersClientDeleteResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Delete.
type ReplicationRecoveryServicesProvidersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientGetResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Get.
type ReplicationRecoveryServicesProvidersClientGetResponse struct {
	ReplicationRecoveryServicesProvidersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientGetResult contains the result from method ReplicationRecoveryServicesProvidersClient.Get.
type ReplicationRecoveryServicesProvidersClientGetResult struct {
	RecoveryServicesProvider
}

// ReplicationRecoveryServicesProvidersClientListByReplicationFabricsResponse contains the response from method ReplicationRecoveryServicesProvidersClient.ListByReplicationFabrics.
type ReplicationRecoveryServicesProvidersClientListByReplicationFabricsResponse struct {
	ReplicationRecoveryServicesProvidersClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientListByReplicationFabricsResult contains the result from method ReplicationRecoveryServicesProvidersClient.ListByReplicationFabrics.
type ReplicationRecoveryServicesProvidersClientListByReplicationFabricsResult struct {
	RecoveryServicesProviderCollection
}

// ReplicationRecoveryServicesProvidersClientListResponse contains the response from method ReplicationRecoveryServicesProvidersClient.List.
type ReplicationRecoveryServicesProvidersClientListResponse struct {
	ReplicationRecoveryServicesProvidersClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientListResult contains the result from method ReplicationRecoveryServicesProvidersClient.List.
type ReplicationRecoveryServicesProvidersClientListResult struct {
	RecoveryServicesProviderCollection
}

// ReplicationRecoveryServicesProvidersClientPurgePollerResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Purge.
type ReplicationRecoveryServicesProvidersClientPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersClientPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersClientPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersClientPurgeResponse, error) {
	respType := ReplicationRecoveryServicesProvidersClientPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersClientPurgePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryServicesProvidersClientPurgePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Purge", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersClientPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersClientPurgeResponse contains the response from method ReplicationRecoveryServicesProvidersClient.Purge.
type ReplicationRecoveryServicesProvidersClientPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientRefreshProviderPollerResponse contains the response from method ReplicationRecoveryServicesProvidersClient.RefreshProvider.
type ReplicationRecoveryServicesProvidersClientRefreshProviderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersClientRefreshProviderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersClientRefreshProviderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersClientRefreshProviderResponse, error) {
	respType := ReplicationRecoveryServicesProvidersClientRefreshProviderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryServicesProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersClientRefreshProviderPollerResponse from the provided client and
// resume token.
func (l *ReplicationRecoveryServicesProvidersClientRefreshProviderPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.RefreshProvider", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersClientRefreshProviderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersClientRefreshProviderResponse contains the response from method ReplicationRecoveryServicesProvidersClient.RefreshProvider.
type ReplicationRecoveryServicesProvidersClientRefreshProviderResponse struct {
	ReplicationRecoveryServicesProvidersClientRefreshProviderResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersClientRefreshProviderResult contains the result from method ReplicationRecoveryServicesProvidersClient.RefreshProvider.
type ReplicationRecoveryServicesProvidersClientRefreshProviderResult struct {
	RecoveryServicesProvider
}

// ReplicationStorageClassificationMappingsClientCreatePollerResponse contains the response from method ReplicationStorageClassificationMappingsClient.Create.
type ReplicationStorageClassificationMappingsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationStorageClassificationMappingsClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationStorageClassificationMappingsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationStorageClassificationMappingsClientCreateResponse, error) {
	respType := ReplicationStorageClassificationMappingsClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageClassificationMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationStorageClassificationMappingsClientCreatePollerResponse from the provided client and resume
// token.
func (l *ReplicationStorageClassificationMappingsClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationStorageClassificationMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationStorageClassificationMappingsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationStorageClassificationMappingsClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationStorageClassificationMappingsClientCreateResponse contains the response from method ReplicationStorageClassificationMappingsClient.Create.
type ReplicationStorageClassificationMappingsClientCreateResponse struct {
	ReplicationStorageClassificationMappingsClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsClientCreateResult contains the result from method ReplicationStorageClassificationMappingsClient.Create.
type ReplicationStorageClassificationMappingsClientCreateResult struct {
	StorageClassificationMapping
}

// ReplicationStorageClassificationMappingsClientDeletePollerResponse contains the response from method ReplicationStorageClassificationMappingsClient.Delete.
type ReplicationStorageClassificationMappingsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationStorageClassificationMappingsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationStorageClassificationMappingsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationStorageClassificationMappingsClientDeleteResponse, error) {
	respType := ReplicationStorageClassificationMappingsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationStorageClassificationMappingsClientDeletePollerResponse from the provided client and resume
// token.
func (l *ReplicationStorageClassificationMappingsClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationStorageClassificationMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationStorageClassificationMappingsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationStorageClassificationMappingsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationStorageClassificationMappingsClientDeleteResponse contains the response from method ReplicationStorageClassificationMappingsClient.Delete.
type ReplicationStorageClassificationMappingsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsClientGetResponse contains the response from method ReplicationStorageClassificationMappingsClient.Get.
type ReplicationStorageClassificationMappingsClientGetResponse struct {
	ReplicationStorageClassificationMappingsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsClientGetResult contains the result from method ReplicationStorageClassificationMappingsClient.Get.
type ReplicationStorageClassificationMappingsClientGetResult struct {
	StorageClassificationMapping
}

// ReplicationStorageClassificationMappingsClientListByReplicationStorageClassificationsResponse contains the response from
// method ReplicationStorageClassificationMappingsClient.ListByReplicationStorageClassifications.
type ReplicationStorageClassificationMappingsClientListByReplicationStorageClassificationsResponse struct {
	ReplicationStorageClassificationMappingsClientListByReplicationStorageClassificationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsClientListByReplicationStorageClassificationsResult contains the result from method
// ReplicationStorageClassificationMappingsClient.ListByReplicationStorageClassifications.
type ReplicationStorageClassificationMappingsClientListByReplicationStorageClassificationsResult struct {
	StorageClassificationMappingCollection
}

// ReplicationStorageClassificationMappingsClientListResponse contains the response from method ReplicationStorageClassificationMappingsClient.List.
type ReplicationStorageClassificationMappingsClientListResponse struct {
	ReplicationStorageClassificationMappingsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsClientListResult contains the result from method ReplicationStorageClassificationMappingsClient.List.
type ReplicationStorageClassificationMappingsClientListResult struct {
	StorageClassificationMappingCollection
}

// ReplicationStorageClassificationsClientGetResponse contains the response from method ReplicationStorageClassificationsClient.Get.
type ReplicationStorageClassificationsClientGetResponse struct {
	ReplicationStorageClassificationsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsClientGetResult contains the result from method ReplicationStorageClassificationsClient.Get.
type ReplicationStorageClassificationsClientGetResult struct {
	StorageClassification
}

// ReplicationStorageClassificationsClientListByReplicationFabricsResponse contains the response from method ReplicationStorageClassificationsClient.ListByReplicationFabrics.
type ReplicationStorageClassificationsClientListByReplicationFabricsResponse struct {
	ReplicationStorageClassificationsClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsClientListByReplicationFabricsResult contains the result from method ReplicationStorageClassificationsClient.ListByReplicationFabrics.
type ReplicationStorageClassificationsClientListByReplicationFabricsResult struct {
	StorageClassificationCollection
}

// ReplicationStorageClassificationsClientListResponse contains the response from method ReplicationStorageClassificationsClient.List.
type ReplicationStorageClassificationsClientListResponse struct {
	ReplicationStorageClassificationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsClientListResult contains the result from method ReplicationStorageClassificationsClient.List.
type ReplicationStorageClassificationsClientListResult struct {
	StorageClassificationCollection
}

// ReplicationVaultHealthClientGetResponse contains the response from method ReplicationVaultHealthClient.Get.
type ReplicationVaultHealthClientGetResponse struct {
	ReplicationVaultHealthClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultHealthClientGetResult contains the result from method ReplicationVaultHealthClient.Get.
type ReplicationVaultHealthClientGetResult struct {
	VaultHealthDetails
}

// ReplicationVaultHealthClientRefreshPollerResponse contains the response from method ReplicationVaultHealthClient.Refresh.
type ReplicationVaultHealthClientRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationVaultHealthClientRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationVaultHealthClientRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationVaultHealthClientRefreshResponse, error) {
	respType := ReplicationVaultHealthClientRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VaultHealthDetails)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationVaultHealthClientRefreshPollerResponse from the provided client and resume token.
func (l *ReplicationVaultHealthClientRefreshPollerResponse) Resume(ctx context.Context, client *ReplicationVaultHealthClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationVaultHealthClient.Refresh", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationVaultHealthClientRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationVaultHealthClientRefreshResponse contains the response from method ReplicationVaultHealthClient.Refresh.
type ReplicationVaultHealthClientRefreshResponse struct {
	ReplicationVaultHealthClientRefreshResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultHealthClientRefreshResult contains the result from method ReplicationVaultHealthClient.Refresh.
type ReplicationVaultHealthClientRefreshResult struct {
	VaultHealthDetails
}

// ReplicationVaultSettingClientCreatePollerResponse contains the response from method ReplicationVaultSettingClient.Create.
type ReplicationVaultSettingClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationVaultSettingClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationVaultSettingClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationVaultSettingClientCreateResponse, error) {
	respType := ReplicationVaultSettingClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VaultSetting)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationVaultSettingClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationVaultSettingClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationVaultSettingClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationVaultSettingClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationVaultSettingClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationVaultSettingClientCreateResponse contains the response from method ReplicationVaultSettingClient.Create.
type ReplicationVaultSettingClientCreateResponse struct {
	ReplicationVaultSettingClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingClientCreateResult contains the result from method ReplicationVaultSettingClient.Create.
type ReplicationVaultSettingClientCreateResult struct {
	VaultSetting
}

// ReplicationVaultSettingClientGetResponse contains the response from method ReplicationVaultSettingClient.Get.
type ReplicationVaultSettingClientGetResponse struct {
	ReplicationVaultSettingClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingClientGetResult contains the result from method ReplicationVaultSettingClient.Get.
type ReplicationVaultSettingClientGetResult struct {
	VaultSetting
}

// ReplicationVaultSettingClientListResponse contains the response from method ReplicationVaultSettingClient.List.
type ReplicationVaultSettingClientListResponse struct {
	ReplicationVaultSettingClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingClientListResult contains the result from method ReplicationVaultSettingClient.List.
type ReplicationVaultSettingClientListResult struct {
	VaultSettingCollection
}

// ReplicationvCentersClientCreatePollerResponse contains the response from method ReplicationvCentersClient.Create.
type ReplicationvCentersClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersClientCreateResponse, error) {
	respType := ReplicationvCentersClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VCenter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersClientCreatePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersClientCreatePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersClientCreateResponse contains the response from method ReplicationvCentersClient.Create.
type ReplicationvCentersClientCreateResponse struct {
	ReplicationvCentersClientCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientCreateResult contains the result from method ReplicationvCentersClient.Create.
type ReplicationvCentersClientCreateResult struct {
	VCenter
}

// ReplicationvCentersClientDeletePollerResponse contains the response from method ReplicationvCentersClient.Delete.
type ReplicationvCentersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersClientDeleteResponse, error) {
	respType := ReplicationvCentersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersClientDeletePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersClientDeletePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersClientDeleteResponse contains the response from method ReplicationvCentersClient.Delete.
type ReplicationvCentersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientGetResponse contains the response from method ReplicationvCentersClient.Get.
type ReplicationvCentersClientGetResponse struct {
	ReplicationvCentersClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientGetResult contains the result from method ReplicationvCentersClient.Get.
type ReplicationvCentersClientGetResult struct {
	VCenter
}

// ReplicationvCentersClientListByReplicationFabricsResponse contains the response from method ReplicationvCentersClient.ListByReplicationFabrics.
type ReplicationvCentersClientListByReplicationFabricsResponse struct {
	ReplicationvCentersClientListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientListByReplicationFabricsResult contains the result from method ReplicationvCentersClient.ListByReplicationFabrics.
type ReplicationvCentersClientListByReplicationFabricsResult struct {
	VCenterCollection
}

// ReplicationvCentersClientListResponse contains the response from method ReplicationvCentersClient.List.
type ReplicationvCentersClientListResponse struct {
	ReplicationvCentersClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientListResult contains the result from method ReplicationvCentersClient.List.
type ReplicationvCentersClientListResult struct {
	VCenterCollection
}

// ReplicationvCentersClientUpdatePollerResponse contains the response from method ReplicationvCentersClient.Update.
type ReplicationvCentersClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersClientUpdateResponse, error) {
	respType := ReplicationvCentersClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VCenter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersClientUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersClientUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersClientUpdateResponse contains the response from method ReplicationvCentersClient.Update.
type ReplicationvCentersClientUpdateResponse struct {
	ReplicationvCentersClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersClientUpdateResult contains the result from method ReplicationvCentersClient.Update.
type ReplicationvCentersClientUpdateResult struct {
	VCenter
}

// SupportedOperatingSystemsClientGetResponse contains the response from method SupportedOperatingSystemsClient.Get.
type SupportedOperatingSystemsClientGetResponse struct {
	SupportedOperatingSystemsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SupportedOperatingSystemsClientGetResult contains the result from method SupportedOperatingSystemsClient.Get.
type SupportedOperatingSystemsClientGetResult struct {
	SupportedOperatingSystems
}

// TargetComputeSizesClientListByReplicationProtectedItemsResponse contains the response from method TargetComputeSizesClient.ListByReplicationProtectedItems.
type TargetComputeSizesClientListByReplicationProtectedItemsResponse struct {
	TargetComputeSizesClientListByReplicationProtectedItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TargetComputeSizesClientListByReplicationProtectedItemsResult contains the result from method TargetComputeSizesClient.ListByReplicationProtectedItems.
type TargetComputeSizesClientListByReplicationProtectedItemsResult struct {
	TargetComputeSizeCollection
}
