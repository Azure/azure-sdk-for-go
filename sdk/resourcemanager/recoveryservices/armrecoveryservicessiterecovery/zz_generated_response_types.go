//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicessiterecovery

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// MigrationRecoveryPointsGetResponse contains the response from method MigrationRecoveryPoints.Get.
type MigrationRecoveryPointsGetResponse struct {
	MigrationRecoveryPointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MigrationRecoveryPointsGetResult contains the result from method MigrationRecoveryPoints.Get.
type MigrationRecoveryPointsGetResult struct {
	MigrationRecoveryPoint
}

// MigrationRecoveryPointsListByReplicationMigrationItemsResponse contains the response from method MigrationRecoveryPoints.ListByReplicationMigrationItems.
type MigrationRecoveryPointsListByReplicationMigrationItemsResponse struct {
	MigrationRecoveryPointsListByReplicationMigrationItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MigrationRecoveryPointsListByReplicationMigrationItemsResult contains the result from method MigrationRecoveryPoints.ListByReplicationMigrationItems.
type MigrationRecoveryPointsListByReplicationMigrationItemsResult struct {
	MigrationRecoveryPointCollection
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationsDiscoveryCollection
}

// RecoveryPointsGetResponse contains the response from method RecoveryPoints.Get.
type RecoveryPointsGetResponse struct {
	RecoveryPointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoveryPointsGetResult contains the result from method RecoveryPoints.Get.
type RecoveryPointsGetResult struct {
	RecoveryPoint
}

// RecoveryPointsListByReplicationProtectedItemsResponse contains the response from method RecoveryPoints.ListByReplicationProtectedItems.
type RecoveryPointsListByReplicationProtectedItemsResponse struct {
	RecoveryPointsListByReplicationProtectedItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoveryPointsListByReplicationProtectedItemsResult contains the result from method RecoveryPoints.ListByReplicationProtectedItems.
type RecoveryPointsListByReplicationProtectedItemsResult struct {
	RecoveryPointCollection
}

// ReplicationAlertSettingsCreateResponse contains the response from method ReplicationAlertSettings.Create.
type ReplicationAlertSettingsCreateResponse struct {
	ReplicationAlertSettingsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsCreateResult contains the result from method ReplicationAlertSettings.Create.
type ReplicationAlertSettingsCreateResult struct {
	Alert
}

// ReplicationAlertSettingsGetResponse contains the response from method ReplicationAlertSettings.Get.
type ReplicationAlertSettingsGetResponse struct {
	ReplicationAlertSettingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsGetResult contains the result from method ReplicationAlertSettings.Get.
type ReplicationAlertSettingsGetResult struct {
	Alert
}

// ReplicationAlertSettingsListResponse contains the response from method ReplicationAlertSettings.List.
type ReplicationAlertSettingsListResponse struct {
	ReplicationAlertSettingsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationAlertSettingsListResult contains the result from method ReplicationAlertSettings.List.
type ReplicationAlertSettingsListResult struct {
	AlertCollection
}

// ReplicationEligibilityResultsGetResponse contains the response from method ReplicationEligibilityResults.Get.
type ReplicationEligibilityResultsGetResponse struct {
	ReplicationEligibilityResultsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEligibilityResultsGetResult contains the result from method ReplicationEligibilityResults.Get.
type ReplicationEligibilityResultsGetResult struct {
	ReplicationEligibilityResults
}

// ReplicationEligibilityResultsListResponse contains the response from method ReplicationEligibilityResults.List.
type ReplicationEligibilityResultsListResponse struct {
	ReplicationEligibilityResultsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEligibilityResultsListResult contains the result from method ReplicationEligibilityResults.List.
type ReplicationEligibilityResultsListResult struct {
	ReplicationEligibilityResultsCollection
}

// ReplicationEventsGetResponse contains the response from method ReplicationEvents.Get.
type ReplicationEventsGetResponse struct {
	ReplicationEventsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEventsGetResult contains the result from method ReplicationEvents.Get.
type ReplicationEventsGetResult struct {
	Event
}

// ReplicationEventsListResponse contains the response from method ReplicationEvents.List.
type ReplicationEventsListResponse struct {
	ReplicationEventsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationEventsListResult contains the result from method ReplicationEvents.List.
type ReplicationEventsListResult struct {
	EventCollection
}

// ReplicationFabricsCheckConsistencyPollerResponse contains the response from method ReplicationFabrics.CheckConsistency.
type ReplicationFabricsCheckConsistencyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsCheckConsistencyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsCheckConsistencyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsCheckConsistencyResponse, error) {
	respType := ReplicationFabricsCheckConsistencyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsCheckConsistencyPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsCheckConsistencyPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.CheckConsistency", token, client.pl, client.checkConsistencyHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsCheckConsistencyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsCheckConsistencyResponse contains the response from method ReplicationFabrics.CheckConsistency.
type ReplicationFabricsCheckConsistencyResponse struct {
	ReplicationFabricsCheckConsistencyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsCheckConsistencyResult contains the result from method ReplicationFabrics.CheckConsistency.
type ReplicationFabricsCheckConsistencyResult struct {
	Fabric
}

// ReplicationFabricsCreatePollerResponse contains the response from method ReplicationFabrics.Create.
type ReplicationFabricsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsCreateResponse, error) {
	respType := ReplicationFabricsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsCreateResponse contains the response from method ReplicationFabrics.Create.
type ReplicationFabricsCreateResponse struct {
	ReplicationFabricsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsCreateResult contains the result from method ReplicationFabrics.Create.
type ReplicationFabricsCreateResult struct {
	Fabric
}

// ReplicationFabricsDeletePollerResponse contains the response from method ReplicationFabrics.Delete.
type ReplicationFabricsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsDeleteResponse, error) {
	respType := ReplicationFabricsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsDeleteResponse contains the response from method ReplicationFabrics.Delete.
type ReplicationFabricsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsGetResponse contains the response from method ReplicationFabrics.Get.
type ReplicationFabricsGetResponse struct {
	ReplicationFabricsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsGetResult contains the result from method ReplicationFabrics.Get.
type ReplicationFabricsGetResult struct {
	Fabric
}

// ReplicationFabricsListResponse contains the response from method ReplicationFabrics.List.
type ReplicationFabricsListResponse struct {
	ReplicationFabricsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsListResult contains the result from method ReplicationFabrics.List.
type ReplicationFabricsListResult struct {
	FabricCollection
}

// ReplicationFabricsMigrateToAADPollerResponse contains the response from method ReplicationFabrics.MigrateToAAD.
type ReplicationFabricsMigrateToAADPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsMigrateToAADPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsMigrateToAADPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsMigrateToAADResponse, error) {
	respType := ReplicationFabricsMigrateToAADResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsMigrateToAADPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsMigrateToAADPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.MigrateToAAD", token, client.pl, client.migrateToAADHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsMigrateToAADPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsMigrateToAADResponse contains the response from method ReplicationFabrics.MigrateToAAD.
type ReplicationFabricsMigrateToAADResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsPurgePollerResponse contains the response from method ReplicationFabrics.Purge.
type ReplicationFabricsPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsPurgeResponse, error) {
	respType := ReplicationFabricsPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsPurgePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsPurgePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.Purge", token, client.pl, client.purgeHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsPurgeResponse contains the response from method ReplicationFabrics.Purge.
type ReplicationFabricsPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsReassociateGatewayPollerResponse contains the response from method ReplicationFabrics.ReassociateGateway.
type ReplicationFabricsReassociateGatewayPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsReassociateGatewayPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsReassociateGatewayPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsReassociateGatewayResponse, error) {
	respType := ReplicationFabricsReassociateGatewayResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsReassociateGatewayPollerResponse from the provided client and resume token.
func (l *ReplicationFabricsReassociateGatewayPollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.ReassociateGateway", token, client.pl, client.reassociateGatewayHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsReassociateGatewayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsReassociateGatewayResponse contains the response from method ReplicationFabrics.ReassociateGateway.
type ReplicationFabricsReassociateGatewayResponse struct {
	ReplicationFabricsReassociateGatewayResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsReassociateGatewayResult contains the result from method ReplicationFabrics.ReassociateGateway.
type ReplicationFabricsReassociateGatewayResult struct {
	Fabric
}

// ReplicationFabricsRenewCertificatePollerResponse contains the response from method ReplicationFabrics.RenewCertificate.
type ReplicationFabricsRenewCertificatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationFabricsRenewCertificatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationFabricsRenewCertificatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationFabricsRenewCertificateResponse, error) {
	respType := ReplicationFabricsRenewCertificateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Fabric)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationFabricsRenewCertificatePollerResponse from the provided client and resume token.
func (l *ReplicationFabricsRenewCertificatePollerResponse) Resume(ctx context.Context, client *ReplicationFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationFabricsClient.RenewCertificate", token, client.pl, client.renewCertificateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationFabricsRenewCertificatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationFabricsRenewCertificateResponse contains the response from method ReplicationFabrics.RenewCertificate.
type ReplicationFabricsRenewCertificateResponse struct {
	ReplicationFabricsRenewCertificateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationFabricsRenewCertificateResult contains the result from method ReplicationFabrics.RenewCertificate.
type ReplicationFabricsRenewCertificateResult struct {
	Fabric
}

// ReplicationJobsCancelPollerResponse contains the response from method ReplicationJobs.Cancel.
type ReplicationJobsCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsCancelResponse, error) {
	respType := ReplicationJobsCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsCancelPollerResponse from the provided client and resume token.
func (l *ReplicationJobsCancelPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Cancel", token, client.pl, client.cancelHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsCancelResponse contains the response from method ReplicationJobs.Cancel.
type ReplicationJobsCancelResponse struct {
	ReplicationJobsCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsCancelResult contains the result from method ReplicationJobs.Cancel.
type ReplicationJobsCancelResult struct {
	Job
}

// ReplicationJobsExportPollerResponse contains the response from method ReplicationJobs.Export.
type ReplicationJobsExportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsExportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsExportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsExportResponse, error) {
	respType := ReplicationJobsExportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsExportPollerResponse from the provided client and resume token.
func (l *ReplicationJobsExportPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Export", token, client.pl, client.exportHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsExportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsExportResponse contains the response from method ReplicationJobs.Export.
type ReplicationJobsExportResponse struct {
	ReplicationJobsExportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsExportResult contains the result from method ReplicationJobs.Export.
type ReplicationJobsExportResult struct {
	Job
}

// ReplicationJobsGetResponse contains the response from method ReplicationJobs.Get.
type ReplicationJobsGetResponse struct {
	ReplicationJobsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsGetResult contains the result from method ReplicationJobs.Get.
type ReplicationJobsGetResult struct {
	Job
}

// ReplicationJobsListResponse contains the response from method ReplicationJobs.List.
type ReplicationJobsListResponse struct {
	ReplicationJobsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsListResult contains the result from method ReplicationJobs.List.
type ReplicationJobsListResult struct {
	JobCollection
}

// ReplicationJobsRestartPollerResponse contains the response from method ReplicationJobs.Restart.
type ReplicationJobsRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsRestartResponse, error) {
	respType := ReplicationJobsRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsRestartPollerResponse from the provided client and resume token.
func (l *ReplicationJobsRestartPollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Restart", token, client.pl, client.restartHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsRestartResponse contains the response from method ReplicationJobs.Restart.
type ReplicationJobsRestartResponse struct {
	ReplicationJobsRestartResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsRestartResult contains the result from method ReplicationJobs.Restart.
type ReplicationJobsRestartResult struct {
	Job
}

// ReplicationJobsResumePollerResponse contains the response from method ReplicationJobs.Resume.
type ReplicationJobsResumePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationJobsResumePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationJobsResumePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationJobsResumeResponse, error) {
	respType := ReplicationJobsResumeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Job)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationJobsResumePollerResponse from the provided client and resume token.
func (l *ReplicationJobsResumePollerResponse) Resume(ctx context.Context, client *ReplicationJobsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationJobsClient.Resume", token, client.pl, client.resumeHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationJobsResumePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationJobsResumeResponse contains the response from method ReplicationJobs.Resume.
type ReplicationJobsResumeResponse struct {
	ReplicationJobsResumeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationJobsResumeResult contains the result from method ReplicationJobs.Resume.
type ReplicationJobsResumeResult struct {
	Job
}

// ReplicationLogicalNetworksGetResponse contains the response from method ReplicationLogicalNetworks.Get.
type ReplicationLogicalNetworksGetResponse struct {
	ReplicationLogicalNetworksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLogicalNetworksGetResult contains the result from method ReplicationLogicalNetworks.Get.
type ReplicationLogicalNetworksGetResult struct {
	LogicalNetwork
}

// ReplicationLogicalNetworksListByReplicationFabricsResponse contains the response from method ReplicationLogicalNetworks.ListByReplicationFabrics.
type ReplicationLogicalNetworksListByReplicationFabricsResponse struct {
	ReplicationLogicalNetworksListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLogicalNetworksListByReplicationFabricsResult contains the result from method ReplicationLogicalNetworks.ListByReplicationFabrics.
type ReplicationLogicalNetworksListByReplicationFabricsResult struct {
	LogicalNetworkCollection
}

// ReplicationMigrationItemsCreatePollerResponse contains the response from method ReplicationMigrationItems.Create.
type ReplicationMigrationItemsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsCreateResponse, error) {
	respType := ReplicationMigrationItemsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsCreateResponse contains the response from method ReplicationMigrationItems.Create.
type ReplicationMigrationItemsCreateResponse struct {
	ReplicationMigrationItemsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsCreateResult contains the result from method ReplicationMigrationItems.Create.
type ReplicationMigrationItemsCreateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsDeletePollerResponse contains the response from method ReplicationMigrationItems.Delete.
type ReplicationMigrationItemsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsDeleteResponse, error) {
	respType := ReplicationMigrationItemsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsDeleteResponse contains the response from method ReplicationMigrationItems.Delete.
type ReplicationMigrationItemsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsGetResponse contains the response from method ReplicationMigrationItems.Get.
type ReplicationMigrationItemsGetResponse struct {
	ReplicationMigrationItemsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsGetResult contains the result from method ReplicationMigrationItems.Get.
type ReplicationMigrationItemsGetResult struct {
	MigrationItem
}

// ReplicationMigrationItemsListByReplicationProtectionContainersResponse contains the response from method ReplicationMigrationItems.ListByReplicationProtectionContainers.
type ReplicationMigrationItemsListByReplicationProtectionContainersResponse struct {
	ReplicationMigrationItemsListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsListByReplicationProtectionContainersResult contains the result from method ReplicationMigrationItems.ListByReplicationProtectionContainers.
type ReplicationMigrationItemsListByReplicationProtectionContainersResult struct {
	MigrationItemCollection
}

// ReplicationMigrationItemsListResponse contains the response from method ReplicationMigrationItems.List.
type ReplicationMigrationItemsListResponse struct {
	ReplicationMigrationItemsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsListResult contains the result from method ReplicationMigrationItems.List.
type ReplicationMigrationItemsListResult struct {
	MigrationItemCollection
}

// ReplicationMigrationItemsMigratePollerResponse contains the response from method ReplicationMigrationItems.Migrate.
type ReplicationMigrationItemsMigratePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsMigratePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsMigratePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsMigrateResponse, error) {
	respType := ReplicationMigrationItemsMigrateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsMigratePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsMigratePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Migrate", token, client.pl, client.migrateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsMigratePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsMigrateResponse contains the response from method ReplicationMigrationItems.Migrate.
type ReplicationMigrationItemsMigrateResponse struct {
	ReplicationMigrationItemsMigrateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsMigrateResult contains the result from method ReplicationMigrationItems.Migrate.
type ReplicationMigrationItemsMigrateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsResyncPollerResponse contains the response from method ReplicationMigrationItems.Resync.
type ReplicationMigrationItemsResyncPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsResyncPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsResyncPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsResyncResponse, error) {
	respType := ReplicationMigrationItemsResyncResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsResyncPollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsResyncPollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Resync", token, client.pl, client.resyncHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsResyncPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsResyncResponse contains the response from method ReplicationMigrationItems.Resync.
type ReplicationMigrationItemsResyncResponse struct {
	ReplicationMigrationItemsResyncResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsResyncResult contains the result from method ReplicationMigrationItems.Resync.
type ReplicationMigrationItemsResyncResult struct {
	MigrationItem
}

// ReplicationMigrationItemsTestMigrateCleanupPollerResponse contains the response from method ReplicationMigrationItems.TestMigrateCleanup.
type ReplicationMigrationItemsTestMigrateCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsTestMigrateCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsTestMigrateCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsTestMigrateCleanupResponse, error) {
	respType := ReplicationMigrationItemsTestMigrateCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsTestMigrateCleanupPollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsTestMigrateCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.TestMigrateCleanup", token, client.pl, client.testMigrateCleanupHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsTestMigrateCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsTestMigrateCleanupResponse contains the response from method ReplicationMigrationItems.TestMigrateCleanup.
type ReplicationMigrationItemsTestMigrateCleanupResponse struct {
	ReplicationMigrationItemsTestMigrateCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsTestMigrateCleanupResult contains the result from method ReplicationMigrationItems.TestMigrateCleanup.
type ReplicationMigrationItemsTestMigrateCleanupResult struct {
	MigrationItem
}

// ReplicationMigrationItemsTestMigratePollerResponse contains the response from method ReplicationMigrationItems.TestMigrate.
type ReplicationMigrationItemsTestMigratePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsTestMigratePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsTestMigratePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsTestMigrateResponse, error) {
	respType := ReplicationMigrationItemsTestMigrateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsTestMigratePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsTestMigratePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.TestMigrate", token, client.pl, client.testMigrateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsTestMigratePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsTestMigrateResponse contains the response from method ReplicationMigrationItems.TestMigrate.
type ReplicationMigrationItemsTestMigrateResponse struct {
	ReplicationMigrationItemsTestMigrateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsTestMigrateResult contains the result from method ReplicationMigrationItems.TestMigrate.
type ReplicationMigrationItemsTestMigrateResult struct {
	MigrationItem
}

// ReplicationMigrationItemsUpdatePollerResponse contains the response from method ReplicationMigrationItems.Update.
type ReplicationMigrationItemsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationMigrationItemsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationMigrationItemsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationMigrationItemsUpdateResponse, error) {
	respType := ReplicationMigrationItemsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MigrationItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationMigrationItemsUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationMigrationItemsUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationMigrationItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationMigrationItemsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationMigrationItemsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationMigrationItemsUpdateResponse contains the response from method ReplicationMigrationItems.Update.
type ReplicationMigrationItemsUpdateResponse struct {
	ReplicationMigrationItemsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationMigrationItemsUpdateResult contains the result from method ReplicationMigrationItems.Update.
type ReplicationMigrationItemsUpdateResult struct {
	MigrationItem
}

// ReplicationNetworkMappingsCreatePollerResponse contains the response from method ReplicationNetworkMappings.Create.
type ReplicationNetworkMappingsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsCreateResponse, error) {
	respType := ReplicationNetworkMappingsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsCreateResponse contains the response from method ReplicationNetworkMappings.Create.
type ReplicationNetworkMappingsCreateResponse struct {
	ReplicationNetworkMappingsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsCreateResult contains the result from method ReplicationNetworkMappings.Create.
type ReplicationNetworkMappingsCreateResult struct {
	NetworkMapping
}

// ReplicationNetworkMappingsDeletePollerResponse contains the response from method ReplicationNetworkMappings.Delete.
type ReplicationNetworkMappingsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsDeleteResponse, error) {
	respType := ReplicationNetworkMappingsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsDeleteResponse contains the response from method ReplicationNetworkMappings.Delete.
type ReplicationNetworkMappingsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsGetResponse contains the response from method ReplicationNetworkMappings.Get.
type ReplicationNetworkMappingsGetResponse struct {
	ReplicationNetworkMappingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsGetResult contains the result from method ReplicationNetworkMappings.Get.
type ReplicationNetworkMappingsGetResult struct {
	NetworkMapping
}

// ReplicationNetworkMappingsListByReplicationNetworksResponse contains the response from method ReplicationNetworkMappings.ListByReplicationNetworks.
type ReplicationNetworkMappingsListByReplicationNetworksResponse struct {
	ReplicationNetworkMappingsListByReplicationNetworksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsListByReplicationNetworksResult contains the result from method ReplicationNetworkMappings.ListByReplicationNetworks.
type ReplicationNetworkMappingsListByReplicationNetworksResult struct {
	NetworkMappingCollection
}

// ReplicationNetworkMappingsListResponse contains the response from method ReplicationNetworkMappings.List.
type ReplicationNetworkMappingsListResponse struct {
	ReplicationNetworkMappingsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsListResult contains the result from method ReplicationNetworkMappings.List.
type ReplicationNetworkMappingsListResult struct {
	NetworkMappingCollection
}

// ReplicationNetworkMappingsUpdatePollerResponse contains the response from method ReplicationNetworkMappings.Update.
type ReplicationNetworkMappingsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationNetworkMappingsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationNetworkMappingsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationNetworkMappingsUpdateResponse, error) {
	respType := ReplicationNetworkMappingsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationNetworkMappingsUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationNetworkMappingsUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationNetworkMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationNetworkMappingsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationNetworkMappingsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationNetworkMappingsUpdateResponse contains the response from method ReplicationNetworkMappings.Update.
type ReplicationNetworkMappingsUpdateResponse struct {
	ReplicationNetworkMappingsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworkMappingsUpdateResult contains the result from method ReplicationNetworkMappings.Update.
type ReplicationNetworkMappingsUpdateResult struct {
	NetworkMapping
}

// ReplicationNetworksGetResponse contains the response from method ReplicationNetworks.Get.
type ReplicationNetworksGetResponse struct {
	ReplicationNetworksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksGetResult contains the result from method ReplicationNetworks.Get.
type ReplicationNetworksGetResult struct {
	Network
}

// ReplicationNetworksListByReplicationFabricsResponse contains the response from method ReplicationNetworks.ListByReplicationFabrics.
type ReplicationNetworksListByReplicationFabricsResponse struct {
	ReplicationNetworksListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksListByReplicationFabricsResult contains the result from method ReplicationNetworks.ListByReplicationFabrics.
type ReplicationNetworksListByReplicationFabricsResult struct {
	NetworkCollection
}

// ReplicationNetworksListResponse contains the response from method ReplicationNetworks.List.
type ReplicationNetworksListResponse struct {
	ReplicationNetworksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationNetworksListResult contains the result from method ReplicationNetworks.List.
type ReplicationNetworksListResult struct {
	NetworkCollection
}

// ReplicationPoliciesCreatePollerResponse contains the response from method ReplicationPolicies.Create.
type ReplicationPoliciesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesCreateResponse, error) {
	respType := ReplicationPoliciesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Policy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesCreatePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesCreatePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesCreateResponse contains the response from method ReplicationPolicies.Create.
type ReplicationPoliciesCreateResponse struct {
	ReplicationPoliciesCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesCreateResult contains the result from method ReplicationPolicies.Create.
type ReplicationPoliciesCreateResult struct {
	Policy
}

// ReplicationPoliciesDeletePollerResponse contains the response from method ReplicationPolicies.Delete.
type ReplicationPoliciesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesDeleteResponse, error) {
	respType := ReplicationPoliciesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesDeletePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesDeletePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesDeleteResponse contains the response from method ReplicationPolicies.Delete.
type ReplicationPoliciesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesGetResponse contains the response from method ReplicationPolicies.Get.
type ReplicationPoliciesGetResponse struct {
	ReplicationPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesGetResult contains the result from method ReplicationPolicies.Get.
type ReplicationPoliciesGetResult struct {
	Policy
}

// ReplicationPoliciesListResponse contains the response from method ReplicationPolicies.List.
type ReplicationPoliciesListResponse struct {
	ReplicationPoliciesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesListResult contains the result from method ReplicationPolicies.List.
type ReplicationPoliciesListResult struct {
	PolicyCollection
}

// ReplicationPoliciesUpdatePollerResponse contains the response from method ReplicationPolicies.Update.
type ReplicationPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationPoliciesUpdateResponse, error) {
	respType := ReplicationPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Policy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationPoliciesUpdateResponse contains the response from method ReplicationPolicies.Update.
type ReplicationPoliciesUpdateResponse struct {
	ReplicationPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationPoliciesUpdateResult contains the result from method ReplicationPolicies.Update.
type ReplicationPoliciesUpdateResult struct {
	Policy
}

// ReplicationProtectableItemsGetResponse contains the response from method ReplicationProtectableItems.Get.
type ReplicationProtectableItemsGetResponse struct {
	ReplicationProtectableItemsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectableItemsGetResult contains the result from method ReplicationProtectableItems.Get.
type ReplicationProtectableItemsGetResult struct {
	ProtectableItem
}

// ReplicationProtectableItemsListByReplicationProtectionContainersResponse contains the response from method ReplicationProtectableItems.ListByReplicationProtectionContainers.
type ReplicationProtectableItemsListByReplicationProtectionContainersResponse struct {
	ReplicationProtectableItemsListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectableItemsListByReplicationProtectionContainersResult contains the result from method ReplicationProtectableItems.ListByReplicationProtectionContainers.
type ReplicationProtectableItemsListByReplicationProtectionContainersResult struct {
	ProtectableItemCollection
}

// ReplicationProtectedItemsAddDisksPollerResponse contains the response from method ReplicationProtectedItems.AddDisks.
type ReplicationProtectedItemsAddDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsAddDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsAddDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsAddDisksResponse, error) {
	respType := ReplicationProtectedItemsAddDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsAddDisksPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsAddDisksPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.AddDisks", token, client.pl, client.addDisksHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsAddDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsAddDisksResponse contains the response from method ReplicationProtectedItems.AddDisks.
type ReplicationProtectedItemsAddDisksResponse struct {
	ReplicationProtectedItemsAddDisksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsAddDisksResult contains the result from method ReplicationProtectedItems.AddDisks.
type ReplicationProtectedItemsAddDisksResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsApplyRecoveryPointPollerResponse contains the response from method ReplicationProtectedItems.ApplyRecoveryPoint.
type ReplicationProtectedItemsApplyRecoveryPointPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsApplyRecoveryPointPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsApplyRecoveryPointPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsApplyRecoveryPointResponse, error) {
	respType := ReplicationProtectedItemsApplyRecoveryPointResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsApplyRecoveryPointPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsApplyRecoveryPointPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.ApplyRecoveryPoint", token, client.pl, client.applyRecoveryPointHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsApplyRecoveryPointPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsApplyRecoveryPointResponse contains the response from method ReplicationProtectedItems.ApplyRecoveryPoint.
type ReplicationProtectedItemsApplyRecoveryPointResponse struct {
	ReplicationProtectedItemsApplyRecoveryPointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsApplyRecoveryPointResult contains the result from method ReplicationProtectedItems.ApplyRecoveryPoint.
type ReplicationProtectedItemsApplyRecoveryPointResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsCreatePollerResponse contains the response from method ReplicationProtectedItems.Create.
type ReplicationProtectedItemsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsCreateResponse, error) {
	respType := ReplicationProtectedItemsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsCreateResponse contains the response from method ReplicationProtectedItems.Create.
type ReplicationProtectedItemsCreateResponse struct {
	ReplicationProtectedItemsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsCreateResult contains the result from method ReplicationProtectedItems.Create.
type ReplicationProtectedItemsCreateResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsDeletePollerResponse contains the response from method ReplicationProtectedItems.Delete.
type ReplicationProtectedItemsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsDeleteResponse, error) {
	respType := ReplicationProtectedItemsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsDeleteResponse contains the response from method ReplicationProtectedItems.Delete.
type ReplicationProtectedItemsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsFailoverCancelPollerResponse contains the response from method ReplicationProtectedItems.FailoverCancel.
type ReplicationProtectedItemsFailoverCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsFailoverCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsFailoverCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsFailoverCancelResponse, error) {
	respType := ReplicationProtectedItemsFailoverCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsFailoverCancelPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsFailoverCancelPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.FailoverCancel", token, client.pl, client.failoverCancelHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsFailoverCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsFailoverCancelResponse contains the response from method ReplicationProtectedItems.FailoverCancel.
type ReplicationProtectedItemsFailoverCancelResponse struct {
	ReplicationProtectedItemsFailoverCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsFailoverCancelResult contains the result from method ReplicationProtectedItems.FailoverCancel.
type ReplicationProtectedItemsFailoverCancelResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsFailoverCommitPollerResponse contains the response from method ReplicationProtectedItems.FailoverCommit.
type ReplicationProtectedItemsFailoverCommitPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsFailoverCommitPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsFailoverCommitPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsFailoverCommitResponse, error) {
	respType := ReplicationProtectedItemsFailoverCommitResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsFailoverCommitPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsFailoverCommitPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.FailoverCommit", token, client.pl, client.failoverCommitHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsFailoverCommitPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsFailoverCommitResponse contains the response from method ReplicationProtectedItems.FailoverCommit.
type ReplicationProtectedItemsFailoverCommitResponse struct {
	ReplicationProtectedItemsFailoverCommitResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsFailoverCommitResult contains the result from method ReplicationProtectedItems.FailoverCommit.
type ReplicationProtectedItemsFailoverCommitResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsGetResponse contains the response from method ReplicationProtectedItems.Get.
type ReplicationProtectedItemsGetResponse struct {
	ReplicationProtectedItemsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsGetResult contains the result from method ReplicationProtectedItems.Get.
type ReplicationProtectedItemsGetResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsListByReplicationProtectionContainersResponse contains the response from method ReplicationProtectedItems.ListByReplicationProtectionContainers.
type ReplicationProtectedItemsListByReplicationProtectionContainersResponse struct {
	ReplicationProtectedItemsListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsListByReplicationProtectionContainersResult contains the result from method ReplicationProtectedItems.ListByReplicationProtectionContainers.
type ReplicationProtectedItemsListByReplicationProtectionContainersResult struct {
	ReplicationProtectedItemCollection
}

// ReplicationProtectedItemsListResponse contains the response from method ReplicationProtectedItems.List.
type ReplicationProtectedItemsListResponse struct {
	ReplicationProtectedItemsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsListResult contains the result from method ReplicationProtectedItems.List.
type ReplicationProtectedItemsListResult struct {
	ReplicationProtectedItemCollection
}

// ReplicationProtectedItemsPlannedFailoverPollerResponse contains the response from method ReplicationProtectedItems.PlannedFailover.
type ReplicationProtectedItemsPlannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsPlannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsPlannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsPlannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsPlannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsPlannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsPlannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.PlannedFailover", token, client.pl, client.plannedFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsPlannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsPlannedFailoverResponse contains the response from method ReplicationProtectedItems.PlannedFailover.
type ReplicationProtectedItemsPlannedFailoverResponse struct {
	ReplicationProtectedItemsPlannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsPlannedFailoverResult contains the result from method ReplicationProtectedItems.PlannedFailover.
type ReplicationProtectedItemsPlannedFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsPurgePollerResponse contains the response from method ReplicationProtectedItems.Purge.
type ReplicationProtectedItemsPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsPurgeResponse, error) {
	respType := ReplicationProtectedItemsPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsPurgePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsPurgePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Purge", token, client.pl, client.purgeHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsPurgeResponse contains the response from method ReplicationProtectedItems.Purge.
type ReplicationProtectedItemsPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsRemoveDisksPollerResponse contains the response from method ReplicationProtectedItems.RemoveDisks.
type ReplicationProtectedItemsRemoveDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsRemoveDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsRemoveDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsRemoveDisksResponse, error) {
	respType := ReplicationProtectedItemsRemoveDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsRemoveDisksPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsRemoveDisksPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.RemoveDisks", token, client.pl, client.removeDisksHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsRemoveDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsRemoveDisksResponse contains the response from method ReplicationProtectedItems.RemoveDisks.
type ReplicationProtectedItemsRemoveDisksResponse struct {
	ReplicationProtectedItemsRemoveDisksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsRemoveDisksResult contains the result from method ReplicationProtectedItems.RemoveDisks.
type ReplicationProtectedItemsRemoveDisksResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsRepairReplicationPollerResponse contains the response from method ReplicationProtectedItems.RepairReplication.
type ReplicationProtectedItemsRepairReplicationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsRepairReplicationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsRepairReplicationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsRepairReplicationResponse, error) {
	respType := ReplicationProtectedItemsRepairReplicationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsRepairReplicationPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsRepairReplicationPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.RepairReplication", token, client.pl, client.repairReplicationHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsRepairReplicationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsRepairReplicationResponse contains the response from method ReplicationProtectedItems.RepairReplication.
type ReplicationProtectedItemsRepairReplicationResponse struct {
	ReplicationProtectedItemsRepairReplicationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsRepairReplicationResult contains the result from method ReplicationProtectedItems.RepairReplication.
type ReplicationProtectedItemsRepairReplicationResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsReprotectPollerResponse contains the response from method ReplicationProtectedItems.Reprotect.
type ReplicationProtectedItemsReprotectPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsReprotectPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsReprotectPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsReprotectResponse, error) {
	respType := ReplicationProtectedItemsReprotectResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsReprotectPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsReprotectPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Reprotect", token, client.pl, client.reprotectHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsReprotectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsReprotectResponse contains the response from method ReplicationProtectedItems.Reprotect.
type ReplicationProtectedItemsReprotectResponse struct {
	ReplicationProtectedItemsReprotectResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsReprotectResult contains the result from method ReplicationProtectedItems.Reprotect.
type ReplicationProtectedItemsReprotectResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsResolveHealthErrorsPollerResponse contains the response from method ReplicationProtectedItems.ResolveHealthErrors.
type ReplicationProtectedItemsResolveHealthErrorsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsResolveHealthErrorsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsResolveHealthErrorsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsResolveHealthErrorsResponse, error) {
	respType := ReplicationProtectedItemsResolveHealthErrorsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsResolveHealthErrorsPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsResolveHealthErrorsPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.ResolveHealthErrors", token, client.pl, client.resolveHealthErrorsHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsResolveHealthErrorsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsResolveHealthErrorsResponse contains the response from method ReplicationProtectedItems.ResolveHealthErrors.
type ReplicationProtectedItemsResolveHealthErrorsResponse struct {
	ReplicationProtectedItemsResolveHealthErrorsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsResolveHealthErrorsResult contains the result from method ReplicationProtectedItems.ResolveHealthErrors.
type ReplicationProtectedItemsResolveHealthErrorsResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsTestFailoverCleanupPollerResponse contains the response from method ReplicationProtectedItems.TestFailoverCleanup.
type ReplicationProtectedItemsTestFailoverCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsTestFailoverCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsTestFailoverCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsTestFailoverCleanupResponse, error) {
	respType := ReplicationProtectedItemsTestFailoverCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsTestFailoverCleanupPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsTestFailoverCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.TestFailoverCleanup", token, client.pl, client.testFailoverCleanupHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsTestFailoverCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsTestFailoverCleanupResponse contains the response from method ReplicationProtectedItems.TestFailoverCleanup.
type ReplicationProtectedItemsTestFailoverCleanupResponse struct {
	ReplicationProtectedItemsTestFailoverCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsTestFailoverCleanupResult contains the result from method ReplicationProtectedItems.TestFailoverCleanup.
type ReplicationProtectedItemsTestFailoverCleanupResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsTestFailoverPollerResponse contains the response from method ReplicationProtectedItems.TestFailover.
type ReplicationProtectedItemsTestFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsTestFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsTestFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsTestFailoverResponse, error) {
	respType := ReplicationProtectedItemsTestFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsTestFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsTestFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.TestFailover", token, client.pl, client.testFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsTestFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsTestFailoverResponse contains the response from method ReplicationProtectedItems.TestFailover.
type ReplicationProtectedItemsTestFailoverResponse struct {
	ReplicationProtectedItemsTestFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsTestFailoverResult contains the result from method ReplicationProtectedItems.TestFailover.
type ReplicationProtectedItemsTestFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsUnplannedFailoverPollerResponse contains the response from method ReplicationProtectedItems.UnplannedFailover.
type ReplicationProtectedItemsUnplannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsUnplannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsUnplannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsUnplannedFailoverResponse, error) {
	respType := ReplicationProtectedItemsUnplannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsUnplannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsUnplannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UnplannedFailover", token, client.pl, client.unplannedFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsUnplannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsUnplannedFailoverResponse contains the response from method ReplicationProtectedItems.UnplannedFailover.
type ReplicationProtectedItemsUnplannedFailoverResponse struct {
	ReplicationProtectedItemsUnplannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsUnplannedFailoverResult contains the result from method ReplicationProtectedItems.UnplannedFailover.
type ReplicationProtectedItemsUnplannedFailoverResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsUpdateAppliancePollerResponse contains the response from method ReplicationProtectedItems.UpdateAppliance.
type ReplicationProtectedItemsUpdateAppliancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsUpdateAppliancePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsUpdateAppliancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsUpdateApplianceResponse, error) {
	respType := ReplicationProtectedItemsUpdateApplianceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsUpdateAppliancePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsUpdateAppliancePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UpdateAppliance", token, client.pl, client.updateApplianceHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsUpdateAppliancePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsUpdateApplianceResponse contains the response from method ReplicationProtectedItems.UpdateAppliance.
type ReplicationProtectedItemsUpdateApplianceResponse struct {
	ReplicationProtectedItemsUpdateApplianceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsUpdateApplianceResult contains the result from method ReplicationProtectedItems.UpdateAppliance.
type ReplicationProtectedItemsUpdateApplianceResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsUpdateMobilityServicePollerResponse contains the response from method ReplicationProtectedItems.UpdateMobilityService.
type ReplicationProtectedItemsUpdateMobilityServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsUpdateMobilityServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsUpdateMobilityServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsUpdateMobilityServiceResponse, error) {
	respType := ReplicationProtectedItemsUpdateMobilityServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsUpdateMobilityServicePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsUpdateMobilityServicePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.UpdateMobilityService", token, client.pl, client.updateMobilityServiceHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsUpdateMobilityServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsUpdateMobilityServiceResponse contains the response from method ReplicationProtectedItems.UpdateMobilityService.
type ReplicationProtectedItemsUpdateMobilityServiceResponse struct {
	ReplicationProtectedItemsUpdateMobilityServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsUpdateMobilityServiceResult contains the result from method ReplicationProtectedItems.UpdateMobilityService.
type ReplicationProtectedItemsUpdateMobilityServiceResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectedItemsUpdatePollerResponse contains the response from method ReplicationProtectedItems.Update.
type ReplicationProtectedItemsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectedItemsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectedItemsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectedItemsUpdateResponse, error) {
	respType := ReplicationProtectedItemsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ReplicationProtectedItem)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectedItemsUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectedItemsUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectedItemsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectedItemsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectedItemsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectedItemsUpdateResponse contains the response from method ReplicationProtectedItems.Update.
type ReplicationProtectedItemsUpdateResponse struct {
	ReplicationProtectedItemsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectedItemsUpdateResult contains the result from method ReplicationProtectedItems.Update.
type ReplicationProtectedItemsUpdateResult struct {
	ReplicationProtectedItem
}

// ReplicationProtectionContainerMappingsCreatePollerResponse contains the response from method ReplicationProtectionContainerMappings.Create.
type ReplicationProtectionContainerMappingsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsCreateResponse, error) {
	respType := ReplicationProtectionContainerMappingsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainerMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainerMappingsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsCreateResponse contains the response from method ReplicationProtectionContainerMappings.Create.
type ReplicationProtectionContainerMappingsCreateResponse struct {
	ReplicationProtectionContainerMappingsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsCreateResult contains the result from method ReplicationProtectionContainerMappings.Create.
type ReplicationProtectionContainerMappingsCreateResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainerMappingsDeletePollerResponse contains the response from method ReplicationProtectionContainerMappings.Delete.
type ReplicationProtectionContainerMappingsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsDeleteResponse, error) {
	respType := ReplicationProtectionContainerMappingsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainerMappingsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsDeleteResponse contains the response from method ReplicationProtectionContainerMappings.Delete.
type ReplicationProtectionContainerMappingsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsGetResponse contains the response from method ReplicationProtectionContainerMappings.Get.
type ReplicationProtectionContainerMappingsGetResponse struct {
	ReplicationProtectionContainerMappingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsGetResult contains the result from method ReplicationProtectionContainerMappings.Get.
type ReplicationProtectionContainerMappingsGetResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainerMappingsListByReplicationProtectionContainersResponse contains the response from method ReplicationProtectionContainerMappings.ListByReplicationProtectionContainers.
type ReplicationProtectionContainerMappingsListByReplicationProtectionContainersResponse struct {
	ReplicationProtectionContainerMappingsListByReplicationProtectionContainersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsListByReplicationProtectionContainersResult contains the result from method ReplicationProtectionContainerMappings.ListByReplicationProtectionContainers.
type ReplicationProtectionContainerMappingsListByReplicationProtectionContainersResult struct {
	ProtectionContainerMappingCollection
}

// ReplicationProtectionContainerMappingsListResponse contains the response from method ReplicationProtectionContainerMappings.List.
type ReplicationProtectionContainerMappingsListResponse struct {
	ReplicationProtectionContainerMappingsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsListResult contains the result from method ReplicationProtectionContainerMappings.List.
type ReplicationProtectionContainerMappingsListResult struct {
	ProtectionContainerMappingCollection
}

// ReplicationProtectionContainerMappingsPurgePollerResponse contains the response from method ReplicationProtectionContainerMappings.Purge.
type ReplicationProtectionContainerMappingsPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsPurgeResponse, error) {
	respType := ReplicationProtectionContainerMappingsPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsPurgePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainerMappingsPurgePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Purge", token, client.pl, client.purgeHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsPurgeResponse contains the response from method ReplicationProtectionContainerMappings.Purge.
type ReplicationProtectionContainerMappingsPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsUpdatePollerResponse contains the response from method ReplicationProtectionContainerMappings.Update.
type ReplicationProtectionContainerMappingsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainerMappingsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainerMappingsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainerMappingsUpdateResponse, error) {
	respType := ReplicationProtectionContainerMappingsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainerMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainerMappingsUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainerMappingsUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainerMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainerMappingsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainerMappingsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainerMappingsUpdateResponse contains the response from method ReplicationProtectionContainerMappings.Update.
type ReplicationProtectionContainerMappingsUpdateResponse struct {
	ReplicationProtectionContainerMappingsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainerMappingsUpdateResult contains the result from method ReplicationProtectionContainerMappings.Update.
type ReplicationProtectionContainerMappingsUpdateResult struct {
	ProtectionContainerMapping
}

// ReplicationProtectionContainersCreatePollerResponse contains the response from method ReplicationProtectionContainers.Create.
type ReplicationProtectionContainersCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersCreateResponse, error) {
	respType := ReplicationProtectionContainersCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersCreatePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersCreatePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersCreateResponse contains the response from method ReplicationProtectionContainers.Create.
type ReplicationProtectionContainersCreateResponse struct {
	ReplicationProtectionContainersCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersCreateResult contains the result from method ReplicationProtectionContainers.Create.
type ReplicationProtectionContainersCreateResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersDeletePollerResponse contains the response from method ReplicationProtectionContainers.Delete.
type ReplicationProtectionContainersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersDeleteResponse, error) {
	respType := ReplicationProtectionContainersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersDeletePollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersDeletePollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersDeleteResponse contains the response from method ReplicationProtectionContainers.Delete.
type ReplicationProtectionContainersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersDiscoverProtectableItemPollerResponse contains the response from method ReplicationProtectionContainers.DiscoverProtectableItem.
type ReplicationProtectionContainersDiscoverProtectableItemPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersDiscoverProtectableItemPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersDiscoverProtectableItemPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersDiscoverProtectableItemResponse, error) {
	respType := ReplicationProtectionContainersDiscoverProtectableItemResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersDiscoverProtectableItemPollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersDiscoverProtectableItemPollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.DiscoverProtectableItem", token, client.pl, client.discoverProtectableItemHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersDiscoverProtectableItemPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersDiscoverProtectableItemResponse contains the response from method ReplicationProtectionContainers.DiscoverProtectableItem.
type ReplicationProtectionContainersDiscoverProtectableItemResponse struct {
	ReplicationProtectionContainersDiscoverProtectableItemResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersDiscoverProtectableItemResult contains the result from method ReplicationProtectionContainers.DiscoverProtectableItem.
type ReplicationProtectionContainersDiscoverProtectableItemResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersGetResponse contains the response from method ReplicationProtectionContainers.Get.
type ReplicationProtectionContainersGetResponse struct {
	ReplicationProtectionContainersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersGetResult contains the result from method ReplicationProtectionContainers.Get.
type ReplicationProtectionContainersGetResult struct {
	ProtectionContainer
}

// ReplicationProtectionContainersListByReplicationFabricsResponse contains the response from method ReplicationProtectionContainers.ListByReplicationFabrics.
type ReplicationProtectionContainersListByReplicationFabricsResponse struct {
	ReplicationProtectionContainersListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersListByReplicationFabricsResult contains the result from method ReplicationProtectionContainers.ListByReplicationFabrics.
type ReplicationProtectionContainersListByReplicationFabricsResult struct {
	ProtectionContainerCollection
}

// ReplicationProtectionContainersListResponse contains the response from method ReplicationProtectionContainers.List.
type ReplicationProtectionContainersListResponse struct {
	ReplicationProtectionContainersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersListResult contains the result from method ReplicationProtectionContainers.List.
type ReplicationProtectionContainersListResult struct {
	ProtectionContainerCollection
}

// ReplicationProtectionContainersSwitchProtectionPollerResponse contains the response from method ReplicationProtectionContainers.SwitchProtection.
type ReplicationProtectionContainersSwitchProtectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationProtectionContainersSwitchProtectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationProtectionContainersSwitchProtectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationProtectionContainersSwitchProtectionResponse, error) {
	respType := ReplicationProtectionContainersSwitchProtectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ProtectionContainer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationProtectionContainersSwitchProtectionPollerResponse from the provided client and resume token.
func (l *ReplicationProtectionContainersSwitchProtectionPollerResponse) Resume(ctx context.Context, client *ReplicationProtectionContainersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationProtectionContainersClient.SwitchProtection", token, client.pl, client.switchProtectionHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationProtectionContainersSwitchProtectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationProtectionContainersSwitchProtectionResponse contains the response from method ReplicationProtectionContainers.SwitchProtection.
type ReplicationProtectionContainersSwitchProtectionResponse struct {
	ReplicationProtectionContainersSwitchProtectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionContainersSwitchProtectionResult contains the result from method ReplicationProtectionContainers.SwitchProtection.
type ReplicationProtectionContainersSwitchProtectionResult struct {
	ProtectionContainer
}

// ReplicationProtectionIntentsCreateResponse contains the response from method ReplicationProtectionIntents.Create.
type ReplicationProtectionIntentsCreateResponse struct {
	ReplicationProtectionIntentsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsCreateResult contains the result from method ReplicationProtectionIntents.Create.
type ReplicationProtectionIntentsCreateResult struct {
	ReplicationProtectionIntent
}

// ReplicationProtectionIntentsGetResponse contains the response from method ReplicationProtectionIntents.Get.
type ReplicationProtectionIntentsGetResponse struct {
	ReplicationProtectionIntentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsGetResult contains the result from method ReplicationProtectionIntents.Get.
type ReplicationProtectionIntentsGetResult struct {
	ReplicationProtectionIntent
}

// ReplicationProtectionIntentsListResponse contains the response from method ReplicationProtectionIntents.List.
type ReplicationProtectionIntentsListResponse struct {
	ReplicationProtectionIntentsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationProtectionIntentsListResult contains the result from method ReplicationProtectionIntents.List.
type ReplicationProtectionIntentsListResult struct {
	ReplicationProtectionIntentCollection
}

// ReplicationRecoveryPlansCreatePollerResponse contains the response from method ReplicationRecoveryPlans.Create.
type ReplicationRecoveryPlansCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansCreateResponse, error) {
	respType := ReplicationRecoveryPlansCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansCreatePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansCreatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansCreateResponse contains the response from method ReplicationRecoveryPlans.Create.
type ReplicationRecoveryPlansCreateResponse struct {
	ReplicationRecoveryPlansCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansCreateResult contains the result from method ReplicationRecoveryPlans.Create.
type ReplicationRecoveryPlansCreateResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansDeletePollerResponse contains the response from method ReplicationRecoveryPlans.Delete.
type ReplicationRecoveryPlansDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansDeleteResponse, error) {
	respType := ReplicationRecoveryPlansDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansDeletePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansDeletePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansDeleteResponse contains the response from method ReplicationRecoveryPlans.Delete.
type ReplicationRecoveryPlansDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansFailoverCancelPollerResponse contains the response from method ReplicationRecoveryPlans.FailoverCancel.
type ReplicationRecoveryPlansFailoverCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansFailoverCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansFailoverCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansFailoverCancelResponse, error) {
	respType := ReplicationRecoveryPlansFailoverCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansFailoverCancelPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansFailoverCancelPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.FailoverCancel", token, client.pl, client.failoverCancelHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansFailoverCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansFailoverCancelResponse contains the response from method ReplicationRecoveryPlans.FailoverCancel.
type ReplicationRecoveryPlansFailoverCancelResponse struct {
	ReplicationRecoveryPlansFailoverCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansFailoverCancelResult contains the result from method ReplicationRecoveryPlans.FailoverCancel.
type ReplicationRecoveryPlansFailoverCancelResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansFailoverCommitPollerResponse contains the response from method ReplicationRecoveryPlans.FailoverCommit.
type ReplicationRecoveryPlansFailoverCommitPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansFailoverCommitPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansFailoverCommitPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansFailoverCommitResponse, error) {
	respType := ReplicationRecoveryPlansFailoverCommitResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansFailoverCommitPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansFailoverCommitPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.FailoverCommit", token, client.pl, client.failoverCommitHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansFailoverCommitPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansFailoverCommitResponse contains the response from method ReplicationRecoveryPlans.FailoverCommit.
type ReplicationRecoveryPlansFailoverCommitResponse struct {
	ReplicationRecoveryPlansFailoverCommitResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansFailoverCommitResult contains the result from method ReplicationRecoveryPlans.FailoverCommit.
type ReplicationRecoveryPlansFailoverCommitResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansGetResponse contains the response from method ReplicationRecoveryPlans.Get.
type ReplicationRecoveryPlansGetResponse struct {
	ReplicationRecoveryPlansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansGetResult contains the result from method ReplicationRecoveryPlans.Get.
type ReplicationRecoveryPlansGetResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansListResponse contains the response from method ReplicationRecoveryPlans.List.
type ReplicationRecoveryPlansListResponse struct {
	ReplicationRecoveryPlansListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansListResult contains the result from method ReplicationRecoveryPlans.List.
type ReplicationRecoveryPlansListResult struct {
	RecoveryPlanCollection
}

// ReplicationRecoveryPlansPlannedFailoverPollerResponse contains the response from method ReplicationRecoveryPlans.PlannedFailover.
type ReplicationRecoveryPlansPlannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansPlannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansPlannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansPlannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansPlannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansPlannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansPlannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.PlannedFailover", token, client.pl, client.plannedFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansPlannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansPlannedFailoverResponse contains the response from method ReplicationRecoveryPlans.PlannedFailover.
type ReplicationRecoveryPlansPlannedFailoverResponse struct {
	ReplicationRecoveryPlansPlannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansPlannedFailoverResult contains the result from method ReplicationRecoveryPlans.PlannedFailover.
type ReplicationRecoveryPlansPlannedFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansReprotectPollerResponse contains the response from method ReplicationRecoveryPlans.Reprotect.
type ReplicationRecoveryPlansReprotectPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansReprotectPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansReprotectPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansReprotectResponse, error) {
	respType := ReplicationRecoveryPlansReprotectResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansReprotectPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansReprotectPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Reprotect", token, client.pl, client.reprotectHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansReprotectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansReprotectResponse contains the response from method ReplicationRecoveryPlans.Reprotect.
type ReplicationRecoveryPlansReprotectResponse struct {
	ReplicationRecoveryPlansReprotectResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansReprotectResult contains the result from method ReplicationRecoveryPlans.Reprotect.
type ReplicationRecoveryPlansReprotectResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansTestFailoverCleanupPollerResponse contains the response from method ReplicationRecoveryPlans.TestFailoverCleanup.
type ReplicationRecoveryPlansTestFailoverCleanupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansTestFailoverCleanupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansTestFailoverCleanupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansTestFailoverCleanupResponse, error) {
	respType := ReplicationRecoveryPlansTestFailoverCleanupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansTestFailoverCleanupPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansTestFailoverCleanupPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.TestFailoverCleanup", token, client.pl, client.testFailoverCleanupHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansTestFailoverCleanupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansTestFailoverCleanupResponse contains the response from method ReplicationRecoveryPlans.TestFailoverCleanup.
type ReplicationRecoveryPlansTestFailoverCleanupResponse struct {
	ReplicationRecoveryPlansTestFailoverCleanupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansTestFailoverCleanupResult contains the result from method ReplicationRecoveryPlans.TestFailoverCleanup.
type ReplicationRecoveryPlansTestFailoverCleanupResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansTestFailoverPollerResponse contains the response from method ReplicationRecoveryPlans.TestFailover.
type ReplicationRecoveryPlansTestFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansTestFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansTestFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansTestFailoverResponse, error) {
	respType := ReplicationRecoveryPlansTestFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansTestFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansTestFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.TestFailover", token, client.pl, client.testFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansTestFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansTestFailoverResponse contains the response from method ReplicationRecoveryPlans.TestFailover.
type ReplicationRecoveryPlansTestFailoverResponse struct {
	ReplicationRecoveryPlansTestFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansTestFailoverResult contains the result from method ReplicationRecoveryPlans.TestFailover.
type ReplicationRecoveryPlansTestFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansUnplannedFailoverPollerResponse contains the response from method ReplicationRecoveryPlans.UnplannedFailover.
type ReplicationRecoveryPlansUnplannedFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansUnplannedFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansUnplannedFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansUnplannedFailoverResponse, error) {
	respType := ReplicationRecoveryPlansUnplannedFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansUnplannedFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansUnplannedFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.UnplannedFailover", token, client.pl, client.unplannedFailoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansUnplannedFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansUnplannedFailoverResponse contains the response from method ReplicationRecoveryPlans.UnplannedFailover.
type ReplicationRecoveryPlansUnplannedFailoverResponse struct {
	ReplicationRecoveryPlansUnplannedFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansUnplannedFailoverResult contains the result from method ReplicationRecoveryPlans.UnplannedFailover.
type ReplicationRecoveryPlansUnplannedFailoverResult struct {
	RecoveryPlan
}

// ReplicationRecoveryPlansUpdatePollerResponse contains the response from method ReplicationRecoveryPlans.Update.
type ReplicationRecoveryPlansUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryPlansUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryPlansUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryPlansUpdateResponse, error) {
	respType := ReplicationRecoveryPlansUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryPlansUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryPlansUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryPlansClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryPlansUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryPlansUpdateResponse contains the response from method ReplicationRecoveryPlans.Update.
type ReplicationRecoveryPlansUpdateResponse struct {
	ReplicationRecoveryPlansUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryPlansUpdateResult contains the result from method ReplicationRecoveryPlans.Update.
type ReplicationRecoveryPlansUpdateResult struct {
	RecoveryPlan
}

// ReplicationRecoveryServicesProvidersCreatePollerResponse contains the response from method ReplicationRecoveryServicesProviders.Create.
type ReplicationRecoveryServicesProvidersCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersCreateResponse, error) {
	respType := ReplicationRecoveryServicesProvidersCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryServicesProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersCreatePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryServicesProvidersCreatePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersCreateResponse contains the response from method ReplicationRecoveryServicesProviders.Create.
type ReplicationRecoveryServicesProvidersCreateResponse struct {
	ReplicationRecoveryServicesProvidersCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersCreateResult contains the result from method ReplicationRecoveryServicesProviders.Create.
type ReplicationRecoveryServicesProvidersCreateResult struct {
	RecoveryServicesProvider
}

// ReplicationRecoveryServicesProvidersDeletePollerResponse contains the response from method ReplicationRecoveryServicesProviders.Delete.
type ReplicationRecoveryServicesProvidersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersDeleteResponse, error) {
	respType := ReplicationRecoveryServicesProvidersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersDeletePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryServicesProvidersDeletePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersDeleteResponse contains the response from method ReplicationRecoveryServicesProviders.Delete.
type ReplicationRecoveryServicesProvidersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersGetResponse contains the response from method ReplicationRecoveryServicesProviders.Get.
type ReplicationRecoveryServicesProvidersGetResponse struct {
	ReplicationRecoveryServicesProvidersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersGetResult contains the result from method ReplicationRecoveryServicesProviders.Get.
type ReplicationRecoveryServicesProvidersGetResult struct {
	RecoveryServicesProvider
}

// ReplicationRecoveryServicesProvidersListByReplicationFabricsResponse contains the response from method ReplicationRecoveryServicesProviders.ListByReplicationFabrics.
type ReplicationRecoveryServicesProvidersListByReplicationFabricsResponse struct {
	ReplicationRecoveryServicesProvidersListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersListByReplicationFabricsResult contains the result from method ReplicationRecoveryServicesProviders.ListByReplicationFabrics.
type ReplicationRecoveryServicesProvidersListByReplicationFabricsResult struct {
	RecoveryServicesProviderCollection
}

// ReplicationRecoveryServicesProvidersListResponse contains the response from method ReplicationRecoveryServicesProviders.List.
type ReplicationRecoveryServicesProvidersListResponse struct {
	ReplicationRecoveryServicesProvidersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersListResult contains the result from method ReplicationRecoveryServicesProviders.List.
type ReplicationRecoveryServicesProvidersListResult struct {
	RecoveryServicesProviderCollection
}

// ReplicationRecoveryServicesProvidersPurgePollerResponse contains the response from method ReplicationRecoveryServicesProviders.Purge.
type ReplicationRecoveryServicesProvidersPurgePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersPurgePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersPurgePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersPurgeResponse, error) {
	respType := ReplicationRecoveryServicesProvidersPurgeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersPurgePollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryServicesProvidersPurgePollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.Purge", token, client.pl, client.purgeHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersPurgePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersPurgeResponse contains the response from method ReplicationRecoveryServicesProviders.Purge.
type ReplicationRecoveryServicesProvidersPurgeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersRefreshProviderPollerResponse contains the response from method ReplicationRecoveryServicesProviders.RefreshProvider.
type ReplicationRecoveryServicesProvidersRefreshProviderPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationRecoveryServicesProvidersRefreshProviderPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationRecoveryServicesProvidersRefreshProviderPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationRecoveryServicesProvidersRefreshProviderResponse, error) {
	respType := ReplicationRecoveryServicesProvidersRefreshProviderResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RecoveryServicesProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationRecoveryServicesProvidersRefreshProviderPollerResponse from the provided client and resume token.
func (l *ReplicationRecoveryServicesProvidersRefreshProviderPollerResponse) Resume(ctx context.Context, client *ReplicationRecoveryServicesProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationRecoveryServicesProvidersClient.RefreshProvider", token, client.pl, client.refreshProviderHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationRecoveryServicesProvidersRefreshProviderPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationRecoveryServicesProvidersRefreshProviderResponse contains the response from method ReplicationRecoveryServicesProviders.RefreshProvider.
type ReplicationRecoveryServicesProvidersRefreshProviderResponse struct {
	ReplicationRecoveryServicesProvidersRefreshProviderResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationRecoveryServicesProvidersRefreshProviderResult contains the result from method ReplicationRecoveryServicesProviders.RefreshProvider.
type ReplicationRecoveryServicesProvidersRefreshProviderResult struct {
	RecoveryServicesProvider
}

// ReplicationStorageClassificationMappingsCreatePollerResponse contains the response from method ReplicationStorageClassificationMappings.Create.
type ReplicationStorageClassificationMappingsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationStorageClassificationMappingsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationStorageClassificationMappingsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationStorageClassificationMappingsCreateResponse, error) {
	respType := ReplicationStorageClassificationMappingsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageClassificationMapping)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationStorageClassificationMappingsCreatePollerResponse from the provided client and resume token.
func (l *ReplicationStorageClassificationMappingsCreatePollerResponse) Resume(ctx context.Context, client *ReplicationStorageClassificationMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationStorageClassificationMappingsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationStorageClassificationMappingsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationStorageClassificationMappingsCreateResponse contains the response from method ReplicationStorageClassificationMappings.Create.
type ReplicationStorageClassificationMappingsCreateResponse struct {
	ReplicationStorageClassificationMappingsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsCreateResult contains the result from method ReplicationStorageClassificationMappings.Create.
type ReplicationStorageClassificationMappingsCreateResult struct {
	StorageClassificationMapping
}

// ReplicationStorageClassificationMappingsDeletePollerResponse contains the response from method ReplicationStorageClassificationMappings.Delete.
type ReplicationStorageClassificationMappingsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationStorageClassificationMappingsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationStorageClassificationMappingsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationStorageClassificationMappingsDeleteResponse, error) {
	respType := ReplicationStorageClassificationMappingsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationStorageClassificationMappingsDeletePollerResponse from the provided client and resume token.
func (l *ReplicationStorageClassificationMappingsDeletePollerResponse) Resume(ctx context.Context, client *ReplicationStorageClassificationMappingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationStorageClassificationMappingsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationStorageClassificationMappingsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationStorageClassificationMappingsDeleteResponse contains the response from method ReplicationStorageClassificationMappings.Delete.
type ReplicationStorageClassificationMappingsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsGetResponse contains the response from method ReplicationStorageClassificationMappings.Get.
type ReplicationStorageClassificationMappingsGetResponse struct {
	ReplicationStorageClassificationMappingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsGetResult contains the result from method ReplicationStorageClassificationMappings.Get.
type ReplicationStorageClassificationMappingsGetResult struct {
	StorageClassificationMapping
}

// ReplicationStorageClassificationMappingsListByReplicationStorageClassificationsResponse contains the response from method ReplicationStorageClassificationMappings.ListByReplicationStorageClassifications.
type ReplicationStorageClassificationMappingsListByReplicationStorageClassificationsResponse struct {
	ReplicationStorageClassificationMappingsListByReplicationStorageClassificationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsListByReplicationStorageClassificationsResult contains the result from method ReplicationStorageClassificationMappings.ListByReplicationStorageClassifications.
type ReplicationStorageClassificationMappingsListByReplicationStorageClassificationsResult struct {
	StorageClassificationMappingCollection
}

// ReplicationStorageClassificationMappingsListResponse contains the response from method ReplicationStorageClassificationMappings.List.
type ReplicationStorageClassificationMappingsListResponse struct {
	ReplicationStorageClassificationMappingsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationMappingsListResult contains the result from method ReplicationStorageClassificationMappings.List.
type ReplicationStorageClassificationMappingsListResult struct {
	StorageClassificationMappingCollection
}

// ReplicationStorageClassificationsGetResponse contains the response from method ReplicationStorageClassifications.Get.
type ReplicationStorageClassificationsGetResponse struct {
	ReplicationStorageClassificationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsGetResult contains the result from method ReplicationStorageClassifications.Get.
type ReplicationStorageClassificationsGetResult struct {
	StorageClassification
}

// ReplicationStorageClassificationsListByReplicationFabricsResponse contains the response from method ReplicationStorageClassifications.ListByReplicationFabrics.
type ReplicationStorageClassificationsListByReplicationFabricsResponse struct {
	ReplicationStorageClassificationsListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsListByReplicationFabricsResult contains the result from method ReplicationStorageClassifications.ListByReplicationFabrics.
type ReplicationStorageClassificationsListByReplicationFabricsResult struct {
	StorageClassificationCollection
}

// ReplicationStorageClassificationsListResponse contains the response from method ReplicationStorageClassifications.List.
type ReplicationStorageClassificationsListResponse struct {
	ReplicationStorageClassificationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationStorageClassificationsListResult contains the result from method ReplicationStorageClassifications.List.
type ReplicationStorageClassificationsListResult struct {
	StorageClassificationCollection
}

// ReplicationVaultHealthGetResponse contains the response from method ReplicationVaultHealth.Get.
type ReplicationVaultHealthGetResponse struct {
	ReplicationVaultHealthGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultHealthGetResult contains the result from method ReplicationVaultHealth.Get.
type ReplicationVaultHealthGetResult struct {
	VaultHealthDetails
}

// ReplicationVaultHealthRefreshPollerResponse contains the response from method ReplicationVaultHealth.Refresh.
type ReplicationVaultHealthRefreshPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationVaultHealthRefreshPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationVaultHealthRefreshPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationVaultHealthRefreshResponse, error) {
	respType := ReplicationVaultHealthRefreshResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VaultHealthDetails)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationVaultHealthRefreshPollerResponse from the provided client and resume token.
func (l *ReplicationVaultHealthRefreshPollerResponse) Resume(ctx context.Context, client *ReplicationVaultHealthClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationVaultHealthClient.Refresh", token, client.pl, client.refreshHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationVaultHealthRefreshPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationVaultHealthRefreshResponse contains the response from method ReplicationVaultHealth.Refresh.
type ReplicationVaultHealthRefreshResponse struct {
	ReplicationVaultHealthRefreshResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultHealthRefreshResult contains the result from method ReplicationVaultHealth.Refresh.
type ReplicationVaultHealthRefreshResult struct {
	VaultHealthDetails
}

// ReplicationVaultSettingCreatePollerResponse contains the response from method ReplicationVaultSetting.Create.
type ReplicationVaultSettingCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationVaultSettingCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationVaultSettingCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationVaultSettingCreateResponse, error) {
	respType := ReplicationVaultSettingCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VaultSetting)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationVaultSettingCreatePollerResponse from the provided client and resume token.
func (l *ReplicationVaultSettingCreatePollerResponse) Resume(ctx context.Context, client *ReplicationVaultSettingClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationVaultSettingClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationVaultSettingCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationVaultSettingCreateResponse contains the response from method ReplicationVaultSetting.Create.
type ReplicationVaultSettingCreateResponse struct {
	ReplicationVaultSettingCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingCreateResult contains the result from method ReplicationVaultSetting.Create.
type ReplicationVaultSettingCreateResult struct {
	VaultSetting
}

// ReplicationVaultSettingGetResponse contains the response from method ReplicationVaultSetting.Get.
type ReplicationVaultSettingGetResponse struct {
	ReplicationVaultSettingGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingGetResult contains the result from method ReplicationVaultSetting.Get.
type ReplicationVaultSettingGetResult struct {
	VaultSetting
}

// ReplicationVaultSettingListResponse contains the response from method ReplicationVaultSetting.List.
type ReplicationVaultSettingListResponse struct {
	ReplicationVaultSettingListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationVaultSettingListResult contains the result from method ReplicationVaultSetting.List.
type ReplicationVaultSettingListResult struct {
	VaultSettingCollection
}

// ReplicationvCentersCreatePollerResponse contains the response from method ReplicationvCenters.Create.
type ReplicationvCentersCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersCreateResponse, error) {
	respType := ReplicationvCentersCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VCenter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersCreatePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersCreatePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersCreateResponse contains the response from method ReplicationvCenters.Create.
type ReplicationvCentersCreateResponse struct {
	ReplicationvCentersCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersCreateResult contains the result from method ReplicationvCenters.Create.
type ReplicationvCentersCreateResult struct {
	VCenter
}

// ReplicationvCentersDeletePollerResponse contains the response from method ReplicationvCenters.Delete.
type ReplicationvCentersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersDeleteResponse, error) {
	respType := ReplicationvCentersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersDeletePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersDeletePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersDeleteResponse contains the response from method ReplicationvCenters.Delete.
type ReplicationvCentersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersGetResponse contains the response from method ReplicationvCenters.Get.
type ReplicationvCentersGetResponse struct {
	ReplicationvCentersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersGetResult contains the result from method ReplicationvCenters.Get.
type ReplicationvCentersGetResult struct {
	VCenter
}

// ReplicationvCentersListByReplicationFabricsResponse contains the response from method ReplicationvCenters.ListByReplicationFabrics.
type ReplicationvCentersListByReplicationFabricsResponse struct {
	ReplicationvCentersListByReplicationFabricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersListByReplicationFabricsResult contains the result from method ReplicationvCenters.ListByReplicationFabrics.
type ReplicationvCentersListByReplicationFabricsResult struct {
	VCenterCollection
}

// ReplicationvCentersListResponse contains the response from method ReplicationvCenters.List.
type ReplicationvCentersListResponse struct {
	ReplicationvCentersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersListResult contains the result from method ReplicationvCenters.List.
type ReplicationvCentersListResult struct {
	VCenterCollection
}

// ReplicationvCentersUpdatePollerResponse contains the response from method ReplicationvCenters.Update.
type ReplicationvCentersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationvCentersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationvCentersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationvCentersUpdateResponse, error) {
	respType := ReplicationvCentersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VCenter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationvCentersUpdatePollerResponse from the provided client and resume token.
func (l *ReplicationvCentersUpdatePollerResponse) Resume(ctx context.Context, client *ReplicationvCentersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationvCentersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationvCentersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationvCentersUpdateResponse contains the response from method ReplicationvCenters.Update.
type ReplicationvCentersUpdateResponse struct {
	ReplicationvCentersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationvCentersUpdateResult contains the result from method ReplicationvCenters.Update.
type ReplicationvCentersUpdateResult struct {
	VCenter
}

// SupportedOperatingSystemsGetResponse contains the response from method SupportedOperatingSystems.Get.
type SupportedOperatingSystemsGetResponse struct {
	SupportedOperatingSystemsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SupportedOperatingSystemsGetResult contains the result from method SupportedOperatingSystems.Get.
type SupportedOperatingSystemsGetResult struct {
	SupportedOperatingSystems
}

// TargetComputeSizesListByReplicationProtectedItemsResponse contains the response from method TargetComputeSizes.ListByReplicationProtectedItems.
type TargetComputeSizesListByReplicationProtectedItemsResponse struct {
	TargetComputeSizesListByReplicationProtectedItemsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TargetComputeSizesListByReplicationProtectedItemsResult contains the result from method TargetComputeSizes.ListByReplicationProtectedItems.
type TargetComputeSizesListByReplicationProtectedItemsResult struct {
	TargetComputeSizeCollection
}
