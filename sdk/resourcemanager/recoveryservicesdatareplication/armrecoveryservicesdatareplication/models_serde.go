// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armrecoveryservicesdatareplication

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime/datetime"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AffectedObjectDetails.
func (a AffectedObjectDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", a.Description)
	if a.Type != nil {
		objectMap["type"] = "object"
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AffectedObjectDetails.
func (a *AffectedObjectDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzStackHCIClusterProperties.
func (a AzStackHCIClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterName", a.ClusterName)
	populate(objectMap, "resourceName", a.ResourceName)
	populate(objectMap, "storageAccountName", a.StorageAccountName)
	populate(objectMap, "storageContainers", a.StorageContainers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzStackHCIClusterProperties.
func (a *AzStackHCIClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterName":
			err = unpopulate(val, "ClusterName", &a.ClusterName)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, "ResourceName", &a.ResourceName)
			delete(rawMsg, key)
		case "storageAccountName":
			err = unpopulate(val, "StorageAccountName", &a.StorageAccountName)
			delete(rawMsg, key)
		case "storageContainers":
			err = unpopulate(val, "StorageContainers", &a.StorageContainers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzStackHCIFabricModelCustomProperties.
func (a AzStackHCIFabricModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applianceName", a.ApplianceName)
	populate(objectMap, "azStackHciSiteId", a.AzStackHciSiteID)
	populate(objectMap, "cluster", a.Cluster)
	populate(objectMap, "fabricContainerId", a.FabricContainerID)
	populate(objectMap, "fabricResourceId", a.FabricResourceID)
	objectMap["instanceType"] = "AzStackHCI"
	populate(objectMap, "migrationHubUri", a.MigrationHubURI)
	populate(objectMap, "migrationSolutionId", a.MigrationSolutionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzStackHCIFabricModelCustomProperties.
func (a *AzStackHCIFabricModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applianceName":
			err = unpopulate(val, "ApplianceName", &a.ApplianceName)
			delete(rawMsg, key)
		case "azStackHciSiteId":
			err = unpopulate(val, "AzStackHciSiteID", &a.AzStackHciSiteID)
			delete(rawMsg, key)
		case "cluster":
			err = unpopulate(val, "Cluster", &a.Cluster)
			delete(rawMsg, key)
		case "fabricContainerId":
			err = unpopulate(val, "FabricContainerID", &a.FabricContainerID)
			delete(rawMsg, key)
		case "fabricResourceId":
			err = unpopulate(val, "FabricResourceID", &a.FabricResourceID)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &a.InstanceType)
			delete(rawMsg, key)
		case "migrationHubUri":
			err = unpopulate(val, "MigrationHubURI", &a.MigrationHubURI)
			delete(rawMsg, key)
		case "migrationSolutionId":
			err = unpopulate(val, "MigrationSolutionID", &a.MigrationSolutionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CheckNameAvailabilityModel.
func (c CheckNameAvailabilityModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CheckNameAvailabilityModel.
func (c *CheckNameAvailabilityModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CheckNameAvailabilityResponseModel.
func (c CheckNameAvailabilityResponseModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "message", c.Message)
	populate(objectMap, "nameAvailable", c.NameAvailable)
	populate(objectMap, "reason", c.Reason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CheckNameAvailabilityResponseModel.
func (c *CheckNameAvailabilityResponseModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "message":
			err = unpopulate(val, "Message", &c.Message)
			delete(rawMsg, key)
		case "nameAvailable":
			err = unpopulate(val, "NameAvailable", &c.NameAvailable)
			delete(rawMsg, key)
		case "reason":
			err = unpopulate(val, "Reason", &c.Reason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetails.
func (c ConnectionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", c.GroupID)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "linkIdentifier", c.LinkIdentifier)
	populate(objectMap, "memberName", c.MemberName)
	populate(objectMap, "privateIpAddress", c.PrivateIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetails.
func (c *ConnectionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &c.GroupID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "linkIdentifier":
			err = unpopulate(val, "LinkIdentifier", &c.LinkIdentifier)
			delete(rawMsg, key)
		case "memberName":
			err = unpopulate(val, "MemberName", &c.MemberName)
			delete(rawMsg, key)
		case "privateIpAddress":
			err = unpopulate(val, "PrivateIPAddress", &c.PrivateIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPreflightModel.
func (d DeploymentPreflightModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resources", d.Resources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPreflightModel.
func (d *DeploymentPreflightModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resources":
			err = unpopulate(val, "Resources", &d.Resources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPreflightResource.
func (d DeploymentPreflightResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiVersion", d.APIVersion)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populateAny(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPreflightResource.
func (d *DeploymentPreflightResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
			err = unpopulate(val, "APIVersion", &d.APIVersion)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &d.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskControllerInputs.
func (d DiskControllerInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "controllerId", d.ControllerID)
	populate(objectMap, "controllerLocation", d.ControllerLocation)
	populate(objectMap, "controllerName", d.ControllerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskControllerInputs.
func (d *DiskControllerInputs) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "controllerId":
			err = unpopulate(val, "ControllerID", &d.ControllerID)
			delete(rawMsg, key)
		case "controllerLocation":
			err = unpopulate(val, "ControllerLocation", &d.ControllerLocation)
			delete(rawMsg, key)
		case "controllerName":
			err = unpopulate(val, "ControllerName", &d.ControllerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailConfigurationModel.
func (e EmailConfigurationModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailConfigurationModel.
func (e *EmailConfigurationModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailConfigurationModelListResult.
func (e EmailConfigurationModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailConfigurationModelListResult.
func (e *EmailConfigurationModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EmailConfigurationModelProperties.
func (e EmailConfigurationModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customEmailAddresses", e.CustomEmailAddresses)
	populate(objectMap, "locale", e.Locale)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "sendToOwners", e.SendToOwners)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EmailConfigurationModelProperties.
func (e *EmailConfigurationModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customEmailAddresses":
			err = unpopulate(val, "CustomEmailAddresses", &e.CustomEmailAddresses)
			delete(rawMsg, key)
		case "locale":
			err = unpopulate(val, "Locale", &e.Locale)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "sendToOwners":
			err = unpopulate(val, "SendToOwners", &e.SendToOwners)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorModel.
func (e ErrorModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "causes", e.Causes)
	populate(objectMap, "code", e.Code)
	populateTime[datetime.RFC3339](objectMap, "creationTime", e.CreationTime)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "recommendation", e.Recommendation)
	populate(objectMap, "severity", e.Severity)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorModel.
func (e *ErrorModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "causes":
			err = unpopulate(val, "Causes", &e.Causes)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTime[datetime.RFC3339](val, "CreationTime", &e.CreationTime)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, "Recommendation", &e.Recommendation)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &e.Severity)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventModel.
func (e EventModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventModel.
func (e *EventModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventModelCustomProperties.
func (e EventModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", e.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventModelCustomProperties.
func (e *EventModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &e.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventModelListResult.
func (e EventModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventModelListResult.
func (e *EventModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventModelProperties.
func (e EventModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationId", e.CorrelationID)
	populate(objectMap, "customProperties", e.CustomProperties)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "eventName", e.EventName)
	populate(objectMap, "eventType", e.EventType)
	populate(objectMap, "healthErrors", e.HealthErrors)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "resourceName", e.ResourceName)
	populate(objectMap, "resourceType", e.ResourceType)
	populate(objectMap, "severity", e.Severity)
	populateTime[datetime.RFC3339](objectMap, "timeOfOccurrence", e.TimeOfOccurrence)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventModelProperties.
func (e *EventModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationId":
			err = unpopulate(val, "CorrelationID", &e.CorrelationID)
			delete(rawMsg, key)
		case "customProperties":
			e.CustomProperties, err = unmarshalEventModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "eventName":
			err = unpopulate(val, "EventName", &e.EventName)
			delete(rawMsg, key)
		case "eventType":
			err = unpopulate(val, "EventType", &e.EventType)
			delete(rawMsg, key)
		case "healthErrors":
			err = unpopulate(val, "HealthErrors", &e.HealthErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, "ResourceName", &e.ResourceName)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &e.ResourceType)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &e.Severity)
			delete(rawMsg, key)
		case "timeOfOccurrence":
			err = unpopulateTime[datetime.RFC3339](val, "TimeOfOccurrence", &e.TimeOfOccurrence)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricAgentModel.
func (f FabricAgentModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricAgentModel.
func (f *FabricAgentModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricAgentModelCustomProperties.
func (f FabricAgentModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", f.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricAgentModelCustomProperties.
func (f *FabricAgentModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &f.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricAgentModelListResult.
func (f FabricAgentModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricAgentModelListResult.
func (f *FabricAgentModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricAgentModelProperties.
func (f FabricAgentModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authenticationIdentity", f.AuthenticationIdentity)
	populate(objectMap, "correlationId", f.CorrelationID)
	populate(objectMap, "customProperties", f.CustomProperties)
	populate(objectMap, "healthErrors", f.HealthErrors)
	populate(objectMap, "isResponsive", f.IsResponsive)
	populateTime[datetime.RFC3339](objectMap, "lastHeartbeat", f.LastHeartbeat)
	populate(objectMap, "machineId", f.MachineID)
	populate(objectMap, "machineName", f.MachineName)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "resourceAccessIdentity", f.ResourceAccessIdentity)
	populate(objectMap, "versionNumber", f.VersionNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricAgentModelProperties.
func (f *FabricAgentModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationIdentity":
			err = unpopulate(val, "AuthenticationIdentity", &f.AuthenticationIdentity)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, "CorrelationID", &f.CorrelationID)
			delete(rawMsg, key)
		case "customProperties":
			f.CustomProperties, err = unmarshalFabricAgentModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "healthErrors":
			err = unpopulate(val, "HealthErrors", &f.HealthErrors)
			delete(rawMsg, key)
		case "isResponsive":
			err = unpopulate(val, "IsResponsive", &f.IsResponsive)
			delete(rawMsg, key)
		case "lastHeartbeat":
			err = unpopulateTime[datetime.RFC3339](val, "LastHeartbeat", &f.LastHeartbeat)
			delete(rawMsg, key)
		case "machineId":
			err = unpopulate(val, "MachineID", &f.MachineID)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &f.MachineName)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &f.ProvisioningState)
			delete(rawMsg, key)
		case "resourceAccessIdentity":
			err = unpopulate(val, "ResourceAccessIdentity", &f.ResourceAccessIdentity)
			delete(rawMsg, key)
		case "versionNumber":
			err = unpopulate(val, "VersionNumber", &f.VersionNumber)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricModel.
func (f FabricModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "location", f.Location)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "tags", f.Tags)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricModel.
func (f *FabricModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &f.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &f.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricModelCustomProperties.
func (f FabricModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", f.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricModelCustomProperties.
func (f *FabricModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &f.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricModelListResult.
func (f FabricModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricModelListResult.
func (f *FabricModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricModelProperties.
func (f FabricModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", f.CustomProperties)
	populate(objectMap, "health", f.Health)
	populate(objectMap, "healthErrors", f.HealthErrors)
	populate(objectMap, "provisioningState", f.ProvisioningState)
	populate(objectMap, "serviceEndpoint", f.ServiceEndpoint)
	populate(objectMap, "serviceResourceId", f.ServiceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricModelProperties.
func (f *FabricModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			f.CustomProperties, err = unmarshalFabricModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "health":
			err = unpopulate(val, "Health", &f.Health)
			delete(rawMsg, key)
		case "healthErrors":
			err = unpopulate(val, "HealthErrors", &f.HealthErrors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &f.ProvisioningState)
			delete(rawMsg, key)
		case "serviceEndpoint":
			err = unpopulate(val, "ServiceEndpoint", &f.ServiceEndpoint)
			delete(rawMsg, key)
		case "serviceResourceId":
			err = unpopulate(val, "ServiceResourceID", &f.ServiceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricModelUpdate.
func (f FabricModelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "tags", f.Tags)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricModelUpdate.
func (f *FabricModelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &f.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &f.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FailoverJobModelCustomProperties.
func (f FailoverJobModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedObjectDetails", f.AffectedObjectDetails)
	objectMap["instanceType"] = "FailoverJobDetails"
	populate(objectMap, "protectedItemDetails", f.ProtectedItemDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailoverJobModelCustomProperties.
func (f *FailoverJobModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedObjectDetails":
			err = unpopulate(val, "AffectedObjectDetails", &f.AffectedObjectDetails)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &f.InstanceType)
			delete(rawMsg, key)
		case "protectedItemDetails":
			err = unpopulate(val, "ProtectedItemDetails", &f.ProtectedItemDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FailoverProtectedItemProperties.
func (f FailoverProtectedItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkName", f.NetworkName)
	populate(objectMap, "protectedItemName", f.ProtectedItemName)
	populate(objectMap, "recoveryPointId", f.RecoveryPointID)
	populateTime[datetime.RFC3339](objectMap, "recoveryPointTime", f.RecoveryPointTime)
	populate(objectMap, "subnet", f.Subnet)
	populate(objectMap, "testVmName", f.TestVMName)
	populate(objectMap, "vmName", f.VMName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailoverProtectedItemProperties.
func (f *FailoverProtectedItemProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkName":
			err = unpopulate(val, "NetworkName", &f.NetworkName)
			delete(rawMsg, key)
		case "protectedItemName":
			err = unpopulate(val, "ProtectedItemName", &f.ProtectedItemName)
			delete(rawMsg, key)
		case "recoveryPointId":
			err = unpopulate(val, "RecoveryPointID", &f.RecoveryPointID)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulateTime[datetime.RFC3339](val, "RecoveryPointTime", &f.RecoveryPointTime)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, "Subnet", &f.Subnet)
			delete(rawMsg, key)
		case "testVmName":
			err = unpopulate(val, "TestVMName", &f.TestVMName)
			delete(rawMsg, key)
		case "vmName":
			err = unpopulate(val, "VMName", &f.VMName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupConnectivityInformation.
func (g GroupConnectivityInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customerVisibleFqdns", g.CustomerVisibleFqdns)
	populate(objectMap, "groupId", g.GroupID)
	populate(objectMap, "internalFqdn", g.InternalFqdn)
	populate(objectMap, "memberName", g.MemberName)
	populate(objectMap, "privateLinkServiceArmRegion", g.PrivateLinkServiceArmRegion)
	populate(objectMap, "redirectMapId", g.RedirectMapID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GroupConnectivityInformation.
func (g *GroupConnectivityInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customerVisibleFqdns":
			err = unpopulate(val, "CustomerVisibleFqdns", &g.CustomerVisibleFqdns)
			delete(rawMsg, key)
		case "groupId":
			err = unpopulate(val, "GroupID", &g.GroupID)
			delete(rawMsg, key)
		case "internalFqdn":
			err = unpopulate(val, "InternalFqdn", &g.InternalFqdn)
			delete(rawMsg, key)
		case "memberName":
			err = unpopulate(val, "MemberName", &g.MemberName)
			delete(rawMsg, key)
		case "privateLinkServiceArmRegion":
			err = unpopulate(val, "PrivateLinkServiceArmRegion", &g.PrivateLinkServiceArmRegion)
			delete(rawMsg, key)
		case "redirectMapId":
			err = unpopulate(val, "RedirectMapID", &g.RedirectMapID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HealthErrorModel.
func (h HealthErrorModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedResourceCorrelationIds", h.AffectedResourceCorrelationIDs)
	populate(objectMap, "affectedResourceType", h.AffectedResourceType)
	populate(objectMap, "category", h.Category)
	populate(objectMap, "causes", h.Causes)
	populate(objectMap, "childErrors", h.ChildErrors)
	populate(objectMap, "code", h.Code)
	populateTime[datetime.RFC3339](objectMap, "creationTime", h.CreationTime)
	populate(objectMap, "healthCategory", h.HealthCategory)
	populate(objectMap, "isCustomerResolvable", h.IsCustomerResolvable)
	populate(objectMap, "message", h.Message)
	populate(objectMap, "recommendation", h.Recommendation)
	populate(objectMap, "severity", h.Severity)
	populate(objectMap, "source", h.Source)
	populate(objectMap, "summary", h.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HealthErrorModel.
func (h *HealthErrorModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedResourceCorrelationIds":
			err = unpopulate(val, "AffectedResourceCorrelationIDs", &h.AffectedResourceCorrelationIDs)
			delete(rawMsg, key)
		case "affectedResourceType":
			err = unpopulate(val, "AffectedResourceType", &h.AffectedResourceType)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &h.Category)
			delete(rawMsg, key)
		case "causes":
			err = unpopulate(val, "Causes", &h.Causes)
			delete(rawMsg, key)
		case "childErrors":
			err = unpopulate(val, "ChildErrors", &h.ChildErrors)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &h.Code)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTime[datetime.RFC3339](val, "CreationTime", &h.CreationTime)
			delete(rawMsg, key)
		case "healthCategory":
			err = unpopulate(val, "HealthCategory", &h.HealthCategory)
			delete(rawMsg, key)
		case "isCustomerResolvable":
			err = unpopulate(val, "IsCustomerResolvable", &h.IsCustomerResolvable)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &h.Message)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, "Recommendation", &h.Recommendation)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &h.Severity)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &h.Source)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &h.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVMigrateFabricModelCustomProperties.
func (h HyperVMigrateFabricModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fabricContainerId", h.FabricContainerID)
	populate(objectMap, "fabricResourceId", h.FabricResourceID)
	populate(objectMap, "hyperVSiteId", h.HyperVSiteID)
	objectMap["instanceType"] = "HyperVMigrate"
	populate(objectMap, "migrationHubUri", h.MigrationHubURI)
	populate(objectMap, "migrationSolutionId", h.MigrationSolutionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVMigrateFabricModelCustomProperties.
func (h *HyperVMigrateFabricModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fabricContainerId":
			err = unpopulate(val, "FabricContainerID", &h.FabricContainerID)
			delete(rawMsg, key)
		case "fabricResourceId":
			err = unpopulate(val, "FabricResourceID", &h.FabricResourceID)
			delete(rawMsg, key)
		case "hyperVSiteId":
			err = unpopulate(val, "HyperVSiteID", &h.HyperVSiteID)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "migrationHubUri":
			err = unpopulate(val, "MigrationHubURI", &h.MigrationHubURI)
			delete(rawMsg, key)
		case "migrationSolutionId":
			err = unpopulate(val, "MigrationSolutionID", &h.MigrationSolutionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIDiskInput.
func (h HyperVToAzStackHCIDiskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskBlockSize", h.DiskBlockSize)
	populate(objectMap, "diskController", h.DiskController)
	populate(objectMap, "diskFileFormat", h.DiskFileFormat)
	populate(objectMap, "diskId", h.DiskID)
	populate(objectMap, "diskIdentifier", h.DiskIdentifier)
	populate(objectMap, "diskLogicalSectorSize", h.DiskLogicalSectorSize)
	populate(objectMap, "diskPhysicalSectorSize", h.DiskPhysicalSectorSize)
	populate(objectMap, "diskSizeGB", h.DiskSizeGB)
	populate(objectMap, "isDynamic", h.IsDynamic)
	populate(objectMap, "isOsDisk", h.IsOsDisk)
	populate(objectMap, "storageContainerId", h.StorageContainerID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIDiskInput.
func (h *HyperVToAzStackHCIDiskInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskBlockSize":
			err = unpopulate(val, "DiskBlockSize", &h.DiskBlockSize)
			delete(rawMsg, key)
		case "diskController":
			err = unpopulate(val, "DiskController", &h.DiskController)
			delete(rawMsg, key)
		case "diskFileFormat":
			err = unpopulate(val, "DiskFileFormat", &h.DiskFileFormat)
			delete(rawMsg, key)
		case "diskId":
			err = unpopulate(val, "DiskID", &h.DiskID)
			delete(rawMsg, key)
		case "diskIdentifier":
			err = unpopulate(val, "DiskIdentifier", &h.DiskIdentifier)
			delete(rawMsg, key)
		case "diskLogicalSectorSize":
			err = unpopulate(val, "DiskLogicalSectorSize", &h.DiskLogicalSectorSize)
			delete(rawMsg, key)
		case "diskPhysicalSectorSize":
			err = unpopulate(val, "DiskPhysicalSectorSize", &h.DiskPhysicalSectorSize)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, "DiskSizeGB", &h.DiskSizeGB)
			delete(rawMsg, key)
		case "isDynamic":
			err = unpopulate(val, "IsDynamic", &h.IsDynamic)
			delete(rawMsg, key)
		case "isOsDisk":
			err = unpopulate(val, "IsOsDisk", &h.IsOsDisk)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &h.StorageContainerID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIEventModelCustomProperties.
func (h HyperVToAzStackHCIEventModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eventSourceFriendlyName", h.EventSourceFriendlyName)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "protectedItemFriendlyName", h.ProtectedItemFriendlyName)
	populate(objectMap, "serverType", h.ServerType)
	populate(objectMap, "sourceApplianceName", h.SourceApplianceName)
	populate(objectMap, "targetApplianceName", h.TargetApplianceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIEventModelCustomProperties.
func (h *HyperVToAzStackHCIEventModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eventSourceFriendlyName":
			err = unpopulate(val, "EventSourceFriendlyName", &h.EventSourceFriendlyName)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "protectedItemFriendlyName":
			err = unpopulate(val, "ProtectedItemFriendlyName", &h.ProtectedItemFriendlyName)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, "ServerType", &h.ServerType)
			delete(rawMsg, key)
		case "sourceApplianceName":
			err = unpopulate(val, "SourceApplianceName", &h.SourceApplianceName)
			delete(rawMsg, key)
		case "targetApplianceName":
			err = unpopulate(val, "TargetApplianceName", &h.TargetApplianceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCINicInput.
func (h HyperVToAzStackHCINicInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isMacMigrationEnabled", h.IsMacMigrationEnabled)
	populate(objectMap, "isStaticIpMigrationEnabled", h.IsStaticIPMigrationEnabled)
	populate(objectMap, "networkName", h.NetworkName)
	populate(objectMap, "nicId", h.NicID)
	populate(objectMap, "selectionTypeForFailover", h.SelectionTypeForFailover)
	populate(objectMap, "targetNetworkId", h.TargetNetworkID)
	populate(objectMap, "testNetworkId", h.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCINicInput.
func (h *HyperVToAzStackHCINicInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isMacMigrationEnabled":
			err = unpopulate(val, "IsMacMigrationEnabled", &h.IsMacMigrationEnabled)
			delete(rawMsg, key)
		case "isStaticIpMigrationEnabled":
			err = unpopulate(val, "IsStaticIPMigrationEnabled", &h.IsStaticIPMigrationEnabled)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &h.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &h.NicID)
			delete(rawMsg, key)
		case "selectionTypeForFailover":
			err = unpopulate(val, "SelectionTypeForFailover", &h.SelectionTypeForFailover)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &h.TargetNetworkID)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &h.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIPlannedFailoverModelCustomProperties.
func (h HyperVToAzStackHCIPlannedFailoverModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "shutdownSourceVM", h.ShutdownSourceVM)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIPlannedFailoverModelCustomProperties.
func (h *HyperVToAzStackHCIPlannedFailoverModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "shutdownSourceVM":
			err = unpopulate(val, "ShutdownSourceVM", &h.ShutdownSourceVM)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIPolicyModelCustomProperties.
func (h HyperVToAzStackHCIPolicyModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appConsistentFrequencyInMinutes", h.AppConsistentFrequencyInMinutes)
	populate(objectMap, "crashConsistentFrequencyInMinutes", h.CrashConsistentFrequencyInMinutes)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "recoveryPointHistoryInMinutes", h.RecoveryPointHistoryInMinutes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIPolicyModelCustomProperties.
func (h *HyperVToAzStackHCIPolicyModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appConsistentFrequencyInMinutes":
			err = unpopulate(val, "AppConsistentFrequencyInMinutes", &h.AppConsistentFrequencyInMinutes)
			delete(rawMsg, key)
		case "crashConsistentFrequencyInMinutes":
			err = unpopulate(val, "CrashConsistentFrequencyInMinutes", &h.CrashConsistentFrequencyInMinutes)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "recoveryPointHistoryInMinutes":
			err = unpopulate(val, "RecoveryPointHistoryInMinutes", &h.RecoveryPointHistoryInMinutes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIProtectedDiskProperties.
func (h HyperVToAzStackHCIProtectedDiskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityInBytes", h.CapacityInBytes)
	populate(objectMap, "diskBlockSize", h.DiskBlockSize)
	populate(objectMap, "diskLogicalSectorSize", h.DiskLogicalSectorSize)
	populate(objectMap, "diskPhysicalSectorSize", h.DiskPhysicalSectorSize)
	populate(objectMap, "diskType", h.DiskType)
	populate(objectMap, "isDynamic", h.IsDynamic)
	populate(objectMap, "isOsDisk", h.IsOsDisk)
	populate(objectMap, "migrateDiskName", h.MigrateDiskName)
	populate(objectMap, "seedDiskName", h.SeedDiskName)
	populate(objectMap, "sourceDiskId", h.SourceDiskID)
	populate(objectMap, "sourceDiskName", h.SourceDiskName)
	populate(objectMap, "storageContainerId", h.StorageContainerID)
	populate(objectMap, "storageContainerLocalPath", h.StorageContainerLocalPath)
	populate(objectMap, "testMigrateDiskName", h.TestMigrateDiskName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIProtectedDiskProperties.
func (h *HyperVToAzStackHCIProtectedDiskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityInBytes":
			err = unpopulate(val, "CapacityInBytes", &h.CapacityInBytes)
			delete(rawMsg, key)
		case "diskBlockSize":
			err = unpopulate(val, "DiskBlockSize", &h.DiskBlockSize)
			delete(rawMsg, key)
		case "diskLogicalSectorSize":
			err = unpopulate(val, "DiskLogicalSectorSize", &h.DiskLogicalSectorSize)
			delete(rawMsg, key)
		case "diskPhysicalSectorSize":
			err = unpopulate(val, "DiskPhysicalSectorSize", &h.DiskPhysicalSectorSize)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, "DiskType", &h.DiskType)
			delete(rawMsg, key)
		case "isDynamic":
			err = unpopulate(val, "IsDynamic", &h.IsDynamic)
			delete(rawMsg, key)
		case "isOsDisk":
			err = unpopulate(val, "IsOsDisk", &h.IsOsDisk)
			delete(rawMsg, key)
		case "migrateDiskName":
			err = unpopulate(val, "MigrateDiskName", &h.MigrateDiskName)
			delete(rawMsg, key)
		case "seedDiskName":
			err = unpopulate(val, "SeedDiskName", &h.SeedDiskName)
			delete(rawMsg, key)
		case "sourceDiskId":
			err = unpopulate(val, "SourceDiskID", &h.SourceDiskID)
			delete(rawMsg, key)
		case "sourceDiskName":
			err = unpopulate(val, "SourceDiskName", &h.SourceDiskName)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &h.StorageContainerID)
			delete(rawMsg, key)
		case "storageContainerLocalPath":
			err = unpopulate(val, "StorageContainerLocalPath", &h.StorageContainerLocalPath)
			delete(rawMsg, key)
		case "testMigrateDiskName":
			err = unpopulate(val, "TestMigrateDiskName", &h.TestMigrateDiskName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIProtectedItemModelCustomProperties.
func (h HyperVToAzStackHCIProtectedItemModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activeLocation", h.ActiveLocation)
	populate(objectMap, "customLocationRegion", h.CustomLocationRegion)
	populate(objectMap, "disksToInclude", h.DisksToInclude)
	populate(objectMap, "dynamicMemoryConfig", h.DynamicMemoryConfig)
	populate(objectMap, "fabricDiscoveryMachineId", h.FabricDiscoveryMachineID)
	populate(objectMap, "failoverRecoveryPointId", h.FailoverRecoveryPointID)
	populate(objectMap, "firmwareType", h.FirmwareType)
	populate(objectMap, "hyperVGeneration", h.HyperVGeneration)
	populate(objectMap, "initialReplicationProgressPercentage", h.InitialReplicationProgressPercentage)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "isDynamicRam", h.IsDynamicRAM)
	populate(objectMap, "lastRecoveryPointId", h.LastRecoveryPointID)
	populateTime[datetime.RFC3339](objectMap, "lastRecoveryPointReceived", h.LastRecoveryPointReceived)
	populateTime[datetime.RFC3339](objectMap, "lastReplicationUpdateTime", h.LastReplicationUpdateTime)
	populate(objectMap, "nicsToInclude", h.NicsToInclude)
	populate(objectMap, "osName", h.OSName)
	populate(objectMap, "osType", h.OSType)
	populate(objectMap, "protectedDisks", h.ProtectedDisks)
	populate(objectMap, "protectedNics", h.ProtectedNics)
	populate(objectMap, "resyncProgressPercentage", h.ResyncProgressPercentage)
	populate(objectMap, "runAsAccountId", h.RunAsAccountID)
	populate(objectMap, "sourceApplianceName", h.SourceApplianceName)
	populate(objectMap, "sourceCpuCores", h.SourceCPUCores)
	populate(objectMap, "sourceFabricAgentName", h.SourceFabricAgentName)
	populate(objectMap, "sourceMemoryInMegaBytes", h.SourceMemoryInMegaBytes)
	populate(objectMap, "sourceVmName", h.SourceVMName)
	populate(objectMap, "storageContainerId", h.StorageContainerID)
	populate(objectMap, "targetApplianceName", h.TargetApplianceName)
	populate(objectMap, "targetArcClusterCustomLocationId", h.TargetArcClusterCustomLocationID)
	populate(objectMap, "targetAzStackHciClusterName", h.TargetAzStackHciClusterName)
	populate(objectMap, "targetCpuCores", h.TargetCPUCores)
	populate(objectMap, "targetFabricAgentName", h.TargetFabricAgentName)
	populate(objectMap, "targetHciClusterId", h.TargetHciClusterID)
	populate(objectMap, "targetLocation", h.TargetLocation)
	populate(objectMap, "targetMemoryInMegaBytes", h.TargetMemoryInMegaBytes)
	populate(objectMap, "targetNetworkId", h.TargetNetworkID)
	populate(objectMap, "targetResourceGroupId", h.TargetResourceGroupID)
	populate(objectMap, "targetVmBiosId", h.TargetVMBiosID)
	populate(objectMap, "targetVmName", h.TargetVMName)
	populate(objectMap, "testNetworkId", h.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIProtectedItemModelCustomProperties.
func (h *HyperVToAzStackHCIProtectedItemModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeLocation":
			err = unpopulate(val, "ActiveLocation", &h.ActiveLocation)
			delete(rawMsg, key)
		case "customLocationRegion":
			err = unpopulate(val, "CustomLocationRegion", &h.CustomLocationRegion)
			delete(rawMsg, key)
		case "disksToInclude":
			err = unpopulate(val, "DisksToInclude", &h.DisksToInclude)
			delete(rawMsg, key)
		case "dynamicMemoryConfig":
			err = unpopulate(val, "DynamicMemoryConfig", &h.DynamicMemoryConfig)
			delete(rawMsg, key)
		case "fabricDiscoveryMachineId":
			err = unpopulate(val, "FabricDiscoveryMachineID", &h.FabricDiscoveryMachineID)
			delete(rawMsg, key)
		case "failoverRecoveryPointId":
			err = unpopulate(val, "FailoverRecoveryPointID", &h.FailoverRecoveryPointID)
			delete(rawMsg, key)
		case "firmwareType":
			err = unpopulate(val, "FirmwareType", &h.FirmwareType)
			delete(rawMsg, key)
		case "hyperVGeneration":
			err = unpopulate(val, "HyperVGeneration", &h.HyperVGeneration)
			delete(rawMsg, key)
		case "initialReplicationProgressPercentage":
			err = unpopulate(val, "InitialReplicationProgressPercentage", &h.InitialReplicationProgressPercentage)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "isDynamicRam":
			err = unpopulate(val, "IsDynamicRAM", &h.IsDynamicRAM)
			delete(rawMsg, key)
		case "lastRecoveryPointId":
			err = unpopulate(val, "LastRecoveryPointID", &h.LastRecoveryPointID)
			delete(rawMsg, key)
		case "lastRecoveryPointReceived":
			err = unpopulateTime[datetime.RFC3339](val, "LastRecoveryPointReceived", &h.LastRecoveryPointReceived)
			delete(rawMsg, key)
		case "lastReplicationUpdateTime":
			err = unpopulateTime[datetime.RFC3339](val, "LastReplicationUpdateTime", &h.LastReplicationUpdateTime)
			delete(rawMsg, key)
		case "nicsToInclude":
			err = unpopulate(val, "NicsToInclude", &h.NicsToInclude)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &h.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &h.OSType)
			delete(rawMsg, key)
		case "protectedDisks":
			err = unpopulate(val, "ProtectedDisks", &h.ProtectedDisks)
			delete(rawMsg, key)
		case "protectedNics":
			err = unpopulate(val, "ProtectedNics", &h.ProtectedNics)
			delete(rawMsg, key)
		case "resyncProgressPercentage":
			err = unpopulate(val, "ResyncProgressPercentage", &h.ResyncProgressPercentage)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &h.RunAsAccountID)
			delete(rawMsg, key)
		case "sourceApplianceName":
			err = unpopulate(val, "SourceApplianceName", &h.SourceApplianceName)
			delete(rawMsg, key)
		case "sourceCpuCores":
			err = unpopulate(val, "SourceCPUCores", &h.SourceCPUCores)
			delete(rawMsg, key)
		case "sourceFabricAgentName":
			err = unpopulate(val, "SourceFabricAgentName", &h.SourceFabricAgentName)
			delete(rawMsg, key)
		case "sourceMemoryInMegaBytes":
			err = unpopulate(val, "SourceMemoryInMegaBytes", &h.SourceMemoryInMegaBytes)
			delete(rawMsg, key)
		case "sourceVmName":
			err = unpopulate(val, "SourceVMName", &h.SourceVMName)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &h.StorageContainerID)
			delete(rawMsg, key)
		case "targetApplianceName":
			err = unpopulate(val, "TargetApplianceName", &h.TargetApplianceName)
			delete(rawMsg, key)
		case "targetArcClusterCustomLocationId":
			err = unpopulate(val, "TargetArcClusterCustomLocationID", &h.TargetArcClusterCustomLocationID)
			delete(rawMsg, key)
		case "targetAzStackHciClusterName":
			err = unpopulate(val, "TargetAzStackHciClusterName", &h.TargetAzStackHciClusterName)
			delete(rawMsg, key)
		case "targetCpuCores":
			err = unpopulate(val, "TargetCPUCores", &h.TargetCPUCores)
			delete(rawMsg, key)
		case "targetFabricAgentName":
			err = unpopulate(val, "TargetFabricAgentName", &h.TargetFabricAgentName)
			delete(rawMsg, key)
		case "targetHciClusterId":
			err = unpopulate(val, "TargetHciClusterID", &h.TargetHciClusterID)
			delete(rawMsg, key)
		case "targetLocation":
			err = unpopulate(val, "TargetLocation", &h.TargetLocation)
			delete(rawMsg, key)
		case "targetMemoryInMegaBytes":
			err = unpopulate(val, "TargetMemoryInMegaBytes", &h.TargetMemoryInMegaBytes)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &h.TargetNetworkID)
			delete(rawMsg, key)
		case "targetResourceGroupId":
			err = unpopulate(val, "TargetResourceGroupID", &h.TargetResourceGroupID)
			delete(rawMsg, key)
		case "targetVmBiosId":
			err = unpopulate(val, "TargetVMBiosID", &h.TargetVMBiosID)
			delete(rawMsg, key)
		case "targetVmName":
			err = unpopulate(val, "TargetVMName", &h.TargetVMName)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &h.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIProtectedItemModelCustomPropertiesUpdate.
func (h HyperVToAzStackHCIProtectedItemModelCustomPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicMemoryConfig", h.DynamicMemoryConfig)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "isDynamicRam", h.IsDynamicRAM)
	populate(objectMap, "nicsToInclude", h.NicsToInclude)
	populate(objectMap, "osType", h.OSType)
	populate(objectMap, "targetCpuCores", h.TargetCPUCores)
	populate(objectMap, "targetMemoryInMegaBytes", h.TargetMemoryInMegaBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIProtectedItemModelCustomPropertiesUpdate.
func (h *HyperVToAzStackHCIProtectedItemModelCustomPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicMemoryConfig":
			err = unpopulate(val, "DynamicMemoryConfig", &h.DynamicMemoryConfig)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "isDynamicRam":
			err = unpopulate(val, "IsDynamicRAM", &h.IsDynamicRAM)
			delete(rawMsg, key)
		case "nicsToInclude":
			err = unpopulate(val, "NicsToInclude", &h.NicsToInclude)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &h.OSType)
			delete(rawMsg, key)
		case "targetCpuCores":
			err = unpopulate(val, "TargetCPUCores", &h.TargetCPUCores)
			delete(rawMsg, key)
		case "targetMemoryInMegaBytes":
			err = unpopulate(val, "TargetMemoryInMegaBytes", &h.TargetMemoryInMegaBytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIProtectedNicProperties.
func (h HyperVToAzStackHCIProtectedNicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "macAddress", h.MacAddress)
	populate(objectMap, "networkName", h.NetworkName)
	populate(objectMap, "nicId", h.NicID)
	populate(objectMap, "selectionTypeForFailover", h.SelectionTypeForFailover)
	populate(objectMap, "targetNetworkId", h.TargetNetworkID)
	populate(objectMap, "testNetworkId", h.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIProtectedNicProperties.
func (h *HyperVToAzStackHCIProtectedNicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "macAddress":
			err = unpopulate(val, "MacAddress", &h.MacAddress)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &h.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &h.NicID)
			delete(rawMsg, key)
		case "selectionTypeForFailover":
			err = unpopulate(val, "SelectionTypeForFailover", &h.SelectionTypeForFailover)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &h.TargetNetworkID)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &h.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIRecoveryPointModelCustomProperties.
func (h HyperVToAzStackHCIRecoveryPointModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskIds", h.DiskIDs)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIRecoveryPointModelCustomProperties.
func (h *HyperVToAzStackHCIRecoveryPointModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskIds":
			err = unpopulate(val, "DiskIDs", &h.DiskIDs)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HyperVToAzStackHCIReplicationExtensionModelCustomProperties.
func (h HyperVToAzStackHCIReplicationExtensionModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "asrServiceUri", h.AsrServiceURI)
	populate(objectMap, "azStackHciFabricArmId", h.AzStackHciFabricArmID)
	populate(objectMap, "azStackHciSiteId", h.AzStackHciSiteID)
	populate(objectMap, "gatewayServiceUri", h.GatewayServiceURI)
	populate(objectMap, "hyperVFabricArmId", h.HyperVFabricArmID)
	populate(objectMap, "hyperVSiteId", h.HyperVSiteID)
	objectMap["instanceType"] = "HyperVToAzStackHCI"
	populate(objectMap, "rcmServiceUri", h.RcmServiceURI)
	populate(objectMap, "resourceGroup", h.ResourceGroup)
	populate(objectMap, "resourceLocation", h.ResourceLocation)
	populate(objectMap, "sourceGatewayServiceId", h.SourceGatewayServiceID)
	populate(objectMap, "sourceStorageContainerName", h.SourceStorageContainerName)
	populate(objectMap, "storageAccountId", h.StorageAccountID)
	populate(objectMap, "storageAccountSasSecretName", h.StorageAccountSasSecretName)
	populate(objectMap, "subscriptionId", h.SubscriptionID)
	populate(objectMap, "targetGatewayServiceId", h.TargetGatewayServiceID)
	populate(objectMap, "targetStorageContainerName", h.TargetStorageContainerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HyperVToAzStackHCIReplicationExtensionModelCustomProperties.
func (h *HyperVToAzStackHCIReplicationExtensionModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "asrServiceUri":
			err = unpopulate(val, "AsrServiceURI", &h.AsrServiceURI)
			delete(rawMsg, key)
		case "azStackHciFabricArmId":
			err = unpopulate(val, "AzStackHciFabricArmID", &h.AzStackHciFabricArmID)
			delete(rawMsg, key)
		case "azStackHciSiteId":
			err = unpopulate(val, "AzStackHciSiteID", &h.AzStackHciSiteID)
			delete(rawMsg, key)
		case "gatewayServiceUri":
			err = unpopulate(val, "GatewayServiceURI", &h.GatewayServiceURI)
			delete(rawMsg, key)
		case "hyperVFabricArmId":
			err = unpopulate(val, "HyperVFabricArmID", &h.HyperVFabricArmID)
			delete(rawMsg, key)
		case "hyperVSiteId":
			err = unpopulate(val, "HyperVSiteID", &h.HyperVSiteID)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &h.InstanceType)
			delete(rawMsg, key)
		case "rcmServiceUri":
			err = unpopulate(val, "RcmServiceURI", &h.RcmServiceURI)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, "ResourceGroup", &h.ResourceGroup)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, "ResourceLocation", &h.ResourceLocation)
			delete(rawMsg, key)
		case "sourceGatewayServiceId":
			err = unpopulate(val, "SourceGatewayServiceID", &h.SourceGatewayServiceID)
			delete(rawMsg, key)
		case "sourceStorageContainerName":
			err = unpopulate(val, "SourceStorageContainerName", &h.SourceStorageContainerName)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, "StorageAccountID", &h.StorageAccountID)
			delete(rawMsg, key)
		case "storageAccountSasSecretName":
			err = unpopulate(val, "StorageAccountSasSecretName", &h.StorageAccountSasSecretName)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &h.SubscriptionID)
			delete(rawMsg, key)
		case "targetGatewayServiceId":
			err = unpopulate(val, "TargetGatewayServiceID", &h.TargetGatewayServiceID)
			delete(rawMsg, key)
		case "targetStorageContainerName":
			err = unpopulate(val, "TargetStorageContainerName", &h.TargetStorageContainerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityModel.
func (i IdentityModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadAuthority", i.AADAuthority)
	populate(objectMap, "applicationId", i.ApplicationID)
	populate(objectMap, "audience", i.Audience)
	populate(objectMap, "objectId", i.ObjectID)
	populate(objectMap, "tenantId", i.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityModel.
func (i *IdentityModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadAuthority":
			err = unpopulate(val, "AADAuthority", &i.AADAuthority)
			delete(rawMsg, key)
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &i.ApplicationID)
			delete(rawMsg, key)
		case "audience":
			err = unpopulate(val, "Audience", &i.Audience)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &i.ObjectID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &i.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InnerHealthErrorModel.
func (i InnerHealthErrorModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", i.Category)
	populate(objectMap, "causes", i.Causes)
	populate(objectMap, "code", i.Code)
	populateTime[datetime.RFC3339](objectMap, "creationTime", i.CreationTime)
	populate(objectMap, "healthCategory", i.HealthCategory)
	populate(objectMap, "isCustomerResolvable", i.IsCustomerResolvable)
	populate(objectMap, "message", i.Message)
	populate(objectMap, "recommendation", i.Recommendation)
	populate(objectMap, "severity", i.Severity)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "summary", i.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InnerHealthErrorModel.
func (i *InnerHealthErrorModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, "Category", &i.Category)
			delete(rawMsg, key)
		case "causes":
			err = unpopulate(val, "Causes", &i.Causes)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTime[datetime.RFC3339](val, "CreationTime", &i.CreationTime)
			delete(rawMsg, key)
		case "healthCategory":
			err = unpopulate(val, "HealthCategory", &i.HealthCategory)
			delete(rawMsg, key)
		case "isCustomerResolvable":
			err = unpopulate(val, "IsCustomerResolvable", &i.IsCustomerResolvable)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, "Recommendation", &i.Recommendation)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &i.Severity)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, "Summary", &i.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobModel.
func (j JobModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobModel.
func (j *JobModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &j.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &j.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &j.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobModelCustomProperties.
func (j JobModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedObjectDetails", j.AffectedObjectDetails)
	populate(objectMap, "instanceType", j.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobModelCustomProperties.
func (j *JobModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedObjectDetails":
			err = unpopulate(val, "AffectedObjectDetails", &j.AffectedObjectDetails)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &j.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobModelListResult.
func (j JobModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobModelListResult.
func (j *JobModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &j.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobModelProperties.
func (j JobModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activityId", j.ActivityID)
	populate(objectMap, "allowedActions", j.AllowedActions)
	populate(objectMap, "customProperties", j.CustomProperties)
	populate(objectMap, "displayName", j.DisplayName)
	populateTime[datetime.RFC3339](objectMap, "endTime", j.EndTime)
	populate(objectMap, "errors", j.Errors)
	populate(objectMap, "objectId", j.ObjectID)
	populate(objectMap, "objectInternalId", j.ObjectInternalID)
	populate(objectMap, "objectInternalName", j.ObjectInternalName)
	populate(objectMap, "objectName", j.ObjectName)
	populate(objectMap, "objectType", j.ObjectType)
	populate(objectMap, "provisioningState", j.ProvisioningState)
	populate(objectMap, "replicationProviderId", j.ReplicationProviderID)
	populate(objectMap, "sourceFabricProviderId", j.SourceFabricProviderID)
	populateTime[datetime.RFC3339](objectMap, "startTime", j.StartTime)
	populate(objectMap, "state", j.State)
	populate(objectMap, "targetFabricProviderId", j.TargetFabricProviderID)
	populate(objectMap, "tasks", j.Tasks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobModelProperties.
func (j *JobModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, "ActivityID", &j.ActivityID)
			delete(rawMsg, key)
		case "allowedActions":
			err = unpopulate(val, "AllowedActions", &j.AllowedActions)
			delete(rawMsg, key)
		case "customProperties":
			j.CustomProperties, err = unmarshalJobModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &j.DisplayName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTime[datetime.RFC3339](val, "EndTime", &j.EndTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &j.Errors)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &j.ObjectID)
			delete(rawMsg, key)
		case "objectInternalId":
			err = unpopulate(val, "ObjectInternalID", &j.ObjectInternalID)
			delete(rawMsg, key)
		case "objectInternalName":
			err = unpopulate(val, "ObjectInternalName", &j.ObjectInternalName)
			delete(rawMsg, key)
		case "objectName":
			err = unpopulate(val, "ObjectName", &j.ObjectName)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &j.ObjectType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &j.ProvisioningState)
			delete(rawMsg, key)
		case "replicationProviderId":
			err = unpopulate(val, "ReplicationProviderID", &j.ReplicationProviderID)
			delete(rawMsg, key)
		case "sourceFabricProviderId":
			err = unpopulate(val, "SourceFabricProviderID", &j.SourceFabricProviderID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTime[datetime.RFC3339](val, "StartTime", &j.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &j.State)
			delete(rawMsg, key)
		case "targetFabricProviderId":
			err = unpopulate(val, "TargetFabricProviderID", &j.TargetFabricProviderID)
			delete(rawMsg, key)
		case "tasks":
			err = unpopulate(val, "Tasks", &j.Tasks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedServiceIdentity.
func (m *ManagedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatus.
func (o OperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endTime", o.EndTime)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatus.
func (o *OperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulate(val, "EndTime", &o.EndTime)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulate(val, "StartTime", &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlannedFailoverModel.
func (p PlannedFailoverModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlannedFailoverModel.
func (p *PlannedFailoverModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlannedFailoverModelCustomProperties.
func (p PlannedFailoverModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", p.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlannedFailoverModelCustomProperties.
func (p *PlannedFailoverModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &p.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlannedFailoverModelProperties.
func (p PlannedFailoverModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", p.CustomProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlannedFailoverModelProperties.
func (p *PlannedFailoverModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			p.CustomProperties, err = unmarshalPlannedFailoverModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyModel.
func (p PolicyModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyModel.
func (p *PolicyModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyModelCustomProperties.
func (p PolicyModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", p.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyModelCustomProperties.
func (p *PolicyModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &p.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyModelListResult.
func (p PolicyModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyModelListResult.
func (p *PolicyModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyModelProperties.
func (p PolicyModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", p.CustomProperties)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyModelProperties.
func (p *PolicyModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			p.CustomProperties, err = unmarshalPolicyModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpoint.
func (p PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpoint.
func (p *PrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionListResult.
func (p *PrivateEndpointConnectionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxy.
func (p PrivateEndpointConnectionProxy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxy.
func (p *PrivateEndpointConnectionProxy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxyListResult.
func (p PrivateEndpointConnectionProxyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxyListResult.
func (p *PrivateEndpointConnectionProxyListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionProxyProperties.
func (p PrivateEndpointConnectionProxyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "remotePrivateEndpoint", p.RemotePrivateEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionProxyProperties.
func (p *PrivateEndpointConnectionProxyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "remotePrivateEndpoint":
			err = unpopulate(val, "RemotePrivateEndpoint", &p.RemotePrivateEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionResponseProperties.
func (p PrivateEndpointConnectionResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateEndpoint", p.PrivateEndpoint)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionResponseProperties.
func (p *PrivateEndpointConnectionResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpoint":
			err = unpopulate(val, "PrivateEndpoint", &p.PrivateEndpoint)
			delete(rawMsg, key)
		case "privateLinkServiceConnectionState":
			err = unpopulate(val, "PrivateLinkServiceConnectionState", &p.PrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceListResult.
func (p *PrivateLinkResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResourceProperties.
func (p *PrivateLinkResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupId":
			err = unpopulate(val, "GroupID", &p.GroupID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "requiredMembers":
			err = unpopulate(val, "RequiredMembers", &p.RequiredMembers)
			delete(rawMsg, key)
		case "requiredZoneNames":
			err = unpopulate(val, "RequiredZoneNames", &p.RequiredZoneNames)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnection.
func (p PrivateLinkServiceConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "requestMessage", p.RequestMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnection.
func (p *PrivateLinkServiceConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupIds":
			err = unpopulate(val, "GroupIDs", &p.GroupIDs)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "requestMessage":
			err = unpopulate(val, "RequestMessage", &p.RequestMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnectionState.
func (p PrivateLinkServiceConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceConnectionState.
func (p *PrivateLinkServiceConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceProxy.
func (p PrivateLinkServiceProxy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupConnectivityInformation", p.GroupConnectivityInformation)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "remotePrivateEndpointConnection", p.RemotePrivateEndpointConnection)
	populate(objectMap, "remotePrivateLinkServiceConnectionState", p.RemotePrivateLinkServiceConnectionState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkServiceProxy.
func (p *PrivateLinkServiceProxy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupConnectivityInformation":
			err = unpopulate(val, "GroupConnectivityInformation", &p.GroupConnectivityInformation)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "remotePrivateEndpointConnection":
			err = unpopulate(val, "RemotePrivateEndpointConnection", &p.RemotePrivateEndpointConnection)
			delete(rawMsg, key)
		case "remotePrivateLinkServiceConnectionState":
			err = unpopulate(val, "RemotePrivateLinkServiceConnectionState", &p.RemotePrivateLinkServiceConnectionState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemDynamicMemoryConfig.
func (p ProtectedItemDynamicMemoryConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maximumMemoryInMegaBytes", p.MaximumMemoryInMegaBytes)
	populate(objectMap, "minimumMemoryInMegaBytes", p.MinimumMemoryInMegaBytes)
	populate(objectMap, "targetMemoryBufferPercentage", p.TargetMemoryBufferPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemDynamicMemoryConfig.
func (p *ProtectedItemDynamicMemoryConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maximumMemoryInMegaBytes":
			err = unpopulate(val, "MaximumMemoryInMegaBytes", &p.MaximumMemoryInMegaBytes)
			delete(rawMsg, key)
		case "minimumMemoryInMegaBytes":
			err = unpopulate(val, "MinimumMemoryInMegaBytes", &p.MinimumMemoryInMegaBytes)
			delete(rawMsg, key)
		case "targetMemoryBufferPercentage":
			err = unpopulate(val, "TargetMemoryBufferPercentage", &p.TargetMemoryBufferPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemJobProperties.
func (p ProtectedItemJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populateTime[datetime.RFC3339](objectMap, "endTime", p.EndTime)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "scenarioName", p.ScenarioName)
	populateTime[datetime.RFC3339](objectMap, "startTime", p.StartTime)
	populate(objectMap, "state", p.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemJobProperties.
func (p *ProtectedItemJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTime[datetime.RFC3339](val, "EndTime", &p.EndTime)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "scenarioName":
			err = unpopulate(val, "ScenarioName", &p.ScenarioName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTime[datetime.RFC3339](val, "StartTime", &p.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModel.
func (p ProtectedItemModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModel.
func (p *ProtectedItemModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelCustomProperties.
func (p ProtectedItemModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", p.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelCustomProperties.
func (p *ProtectedItemModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &p.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelCustomPropertiesUpdate.
func (p ProtectedItemModelCustomPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", p.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelCustomPropertiesUpdate.
func (p *ProtectedItemModelCustomPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &p.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelListResult.
func (p ProtectedItemModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelListResult.
func (p *ProtectedItemModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelProperties.
func (p ProtectedItemModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowedJobs", p.AllowedJobs)
	populate(objectMap, "correlationId", p.CorrelationID)
	populate(objectMap, "currentJob", p.CurrentJob)
	populate(objectMap, "customProperties", p.CustomProperties)
	populate(objectMap, "fabricAgentId", p.FabricAgentID)
	populate(objectMap, "fabricId", p.FabricID)
	populate(objectMap, "fabricObjectId", p.FabricObjectID)
	populate(objectMap, "fabricObjectName", p.FabricObjectName)
	populate(objectMap, "healthErrors", p.HealthErrors)
	populate(objectMap, "lastFailedEnableProtectionJob", p.LastFailedEnableProtectionJob)
	populate(objectMap, "lastFailedPlannedFailoverJob", p.LastFailedPlannedFailoverJob)
	populateTime[datetime.RFC3339](objectMap, "lastSuccessfulPlannedFailoverTime", p.LastSuccessfulPlannedFailoverTime)
	populateTime[datetime.RFC3339](objectMap, "lastSuccessfulTestFailoverTime", p.LastSuccessfulTestFailoverTime)
	populateTime[datetime.RFC3339](objectMap, "lastSuccessfulUnplannedFailoverTime", p.LastSuccessfulUnplannedFailoverTime)
	populate(objectMap, "lastTestFailoverJob", p.LastTestFailoverJob)
	populate(objectMap, "policyName", p.PolicyName)
	populate(objectMap, "protectionState", p.ProtectionState)
	populate(objectMap, "protectionStateDescription", p.ProtectionStateDescription)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "replicationExtensionName", p.ReplicationExtensionName)
	populate(objectMap, "replicationHealth", p.ReplicationHealth)
	populate(objectMap, "resyncRequired", p.ResyncRequired)
	populate(objectMap, "resynchronizationState", p.ResynchronizationState)
	populate(objectMap, "sourceFabricProviderId", p.SourceFabricProviderID)
	populate(objectMap, "targetFabricAgentId", p.TargetFabricAgentID)
	populate(objectMap, "targetFabricId", p.TargetFabricID)
	populate(objectMap, "targetFabricProviderId", p.TargetFabricProviderID)
	populate(objectMap, "testFailoverState", p.TestFailoverState)
	populate(objectMap, "testFailoverStateDescription", p.TestFailoverStateDescription)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelProperties.
func (p *ProtectedItemModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedJobs":
			err = unpopulate(val, "AllowedJobs", &p.AllowedJobs)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, "CorrelationID", &p.CorrelationID)
			delete(rawMsg, key)
		case "currentJob":
			err = unpopulate(val, "CurrentJob", &p.CurrentJob)
			delete(rawMsg, key)
		case "customProperties":
			p.CustomProperties, err = unmarshalProtectedItemModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "fabricAgentId":
			err = unpopulate(val, "FabricAgentID", &p.FabricAgentID)
			delete(rawMsg, key)
		case "fabricId":
			err = unpopulate(val, "FabricID", &p.FabricID)
			delete(rawMsg, key)
		case "fabricObjectId":
			err = unpopulate(val, "FabricObjectID", &p.FabricObjectID)
			delete(rawMsg, key)
		case "fabricObjectName":
			err = unpopulate(val, "FabricObjectName", &p.FabricObjectName)
			delete(rawMsg, key)
		case "healthErrors":
			err = unpopulate(val, "HealthErrors", &p.HealthErrors)
			delete(rawMsg, key)
		case "lastFailedEnableProtectionJob":
			err = unpopulate(val, "LastFailedEnableProtectionJob", &p.LastFailedEnableProtectionJob)
			delete(rawMsg, key)
		case "lastFailedPlannedFailoverJob":
			err = unpopulate(val, "LastFailedPlannedFailoverJob", &p.LastFailedPlannedFailoverJob)
			delete(rawMsg, key)
		case "lastSuccessfulPlannedFailoverTime":
			err = unpopulateTime[datetime.RFC3339](val, "LastSuccessfulPlannedFailoverTime", &p.LastSuccessfulPlannedFailoverTime)
			delete(rawMsg, key)
		case "lastSuccessfulTestFailoverTime":
			err = unpopulateTime[datetime.RFC3339](val, "LastSuccessfulTestFailoverTime", &p.LastSuccessfulTestFailoverTime)
			delete(rawMsg, key)
		case "lastSuccessfulUnplannedFailoverTime":
			err = unpopulateTime[datetime.RFC3339](val, "LastSuccessfulUnplannedFailoverTime", &p.LastSuccessfulUnplannedFailoverTime)
			delete(rawMsg, key)
		case "lastTestFailoverJob":
			err = unpopulate(val, "LastTestFailoverJob", &p.LastTestFailoverJob)
			delete(rawMsg, key)
		case "policyName":
			err = unpopulate(val, "PolicyName", &p.PolicyName)
			delete(rawMsg, key)
		case "protectionState":
			err = unpopulate(val, "ProtectionState", &p.ProtectionState)
			delete(rawMsg, key)
		case "protectionStateDescription":
			err = unpopulate(val, "ProtectionStateDescription", &p.ProtectionStateDescription)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "replicationExtensionName":
			err = unpopulate(val, "ReplicationExtensionName", &p.ReplicationExtensionName)
			delete(rawMsg, key)
		case "replicationHealth":
			err = unpopulate(val, "ReplicationHealth", &p.ReplicationHealth)
			delete(rawMsg, key)
		case "resyncRequired":
			err = unpopulate(val, "ResyncRequired", &p.ResyncRequired)
			delete(rawMsg, key)
		case "resynchronizationState":
			err = unpopulate(val, "ResynchronizationState", &p.ResynchronizationState)
			delete(rawMsg, key)
		case "sourceFabricProviderId":
			err = unpopulate(val, "SourceFabricProviderID", &p.SourceFabricProviderID)
			delete(rawMsg, key)
		case "targetFabricAgentId":
			err = unpopulate(val, "TargetFabricAgentID", &p.TargetFabricAgentID)
			delete(rawMsg, key)
		case "targetFabricId":
			err = unpopulate(val, "TargetFabricID", &p.TargetFabricID)
			delete(rawMsg, key)
		case "targetFabricProviderId":
			err = unpopulate(val, "TargetFabricProviderID", &p.TargetFabricProviderID)
			delete(rawMsg, key)
		case "testFailoverState":
			err = unpopulate(val, "TestFailoverState", &p.TestFailoverState)
			delete(rawMsg, key)
		case "testFailoverStateDescription":
			err = unpopulate(val, "TestFailoverStateDescription", &p.TestFailoverStateDescription)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelPropertiesUpdate.
func (p ProtectedItemModelPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", p.CustomProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelPropertiesUpdate.
func (p *ProtectedItemModelPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			p.CustomProperties, err = unmarshalProtectedItemModelCustomPropertiesUpdateClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedItemModelUpdate.
func (p ProtectedItemModelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedItemModelUpdate.
func (p *ProtectedItemModelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointModel.
func (r RecoveryPointModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointModel.
func (r *RecoveryPointModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointModelCustomProperties.
func (r RecoveryPointModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", r.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointModelCustomProperties.
func (r *RecoveryPointModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &r.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointModelListResult.
func (r RecoveryPointModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointModelListResult.
func (r *RecoveryPointModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryPointModelProperties.
func (r RecoveryPointModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", r.CustomProperties)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populateTime[datetime.RFC3339](objectMap, "recoveryPointTime", r.RecoveryPointTime)
	populate(objectMap, "recoveryPointType", r.RecoveryPointType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryPointModelProperties.
func (r *RecoveryPointModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			r.CustomProperties, err = unmarshalRecoveryPointModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		case "recoveryPointTime":
			err = unpopulateTime[datetime.RFC3339](val, "RecoveryPointTime", &r.RecoveryPointTime)
			delete(rawMsg, key)
		case "recoveryPointType":
			err = unpopulate(val, "RecoveryPointType", &r.RecoveryPointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemotePrivateEndpoint.
func (r RemotePrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", r.ConnectionDetails)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "manualPrivateLinkServiceConnections", r.ManualPrivateLinkServiceConnections)
	populate(objectMap, "privateLinkServiceConnections", r.PrivateLinkServiceConnections)
	populate(objectMap, "privateLinkServiceProxies", r.PrivateLinkServiceProxies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemotePrivateEndpoint.
func (r *RemotePrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &r.ConnectionDetails)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "manualPrivateLinkServiceConnections":
			err = unpopulate(val, "ManualPrivateLinkServiceConnections", &r.ManualPrivateLinkServiceConnections)
			delete(rawMsg, key)
		case "privateLinkServiceConnections":
			err = unpopulate(val, "PrivateLinkServiceConnections", &r.PrivateLinkServiceConnections)
			delete(rawMsg, key)
		case "privateLinkServiceProxies":
			err = unpopulate(val, "PrivateLinkServiceProxies", &r.PrivateLinkServiceProxies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemotePrivateEndpointConnection.
func (r RemotePrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemotePrivateEndpointConnection.
func (r *RemotePrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationExtensionModel.
func (r ReplicationExtensionModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationExtensionModel.
func (r *ReplicationExtensionModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationExtensionModelCustomProperties.
func (r ReplicationExtensionModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", r.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationExtensionModelCustomProperties.
func (r *ReplicationExtensionModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &r.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationExtensionModelListResult.
func (r ReplicationExtensionModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationExtensionModelListResult.
func (r *ReplicationExtensionModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &r.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationExtensionModelProperties.
func (r ReplicationExtensionModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", r.CustomProperties)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationExtensionModelProperties.
func (r *ReplicationExtensionModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
			r.CustomProperties, err = unmarshalReplicationExtensionModelCustomPropertiesClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &r.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageContainerProperties.
func (s StorageContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterSharedVolumePath", s.ClusterSharedVolumePath)
	populate(objectMap, "name", s.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageContainerProperties.
func (s *StorageContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterSharedVolumePath":
			err = unpopulate(val, "ClusterSharedVolumePath", &s.ClusterSharedVolumePath)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTime[datetime.RFC3339](objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTime[datetime.RFC3339](val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskModel.
func (t TaskModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "childrenJobs", t.ChildrenJobs)
	populate(objectMap, "customProperties", t.CustomProperties)
	populateTime[datetime.RFC3339](objectMap, "endTime", t.EndTime)
	populateTime[datetime.RFC3339](objectMap, "startTime", t.StartTime)
	populate(objectMap, "state", t.State)
	populate(objectMap, "taskName", t.TaskName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskModel.
func (t *TaskModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "childrenJobs":
			err = unpopulate(val, "ChildrenJobs", &t.ChildrenJobs)
			delete(rawMsg, key)
		case "customProperties":
			err = unpopulate(val, "CustomProperties", &t.CustomProperties)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTime[datetime.RFC3339](val, "EndTime", &t.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTime[datetime.RFC3339](val, "StartTime", &t.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &t.State)
			delete(rawMsg, key)
		case "taskName":
			err = unpopulate(val, "TaskName", &t.TaskName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskModelCustomProperties.
func (t TaskModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceType", t.InstanceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskModelCustomProperties.
func (t *TaskModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &t.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestFailoverCleanupJobModelCustomProperties.
func (t TestFailoverCleanupJobModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedObjectDetails", t.AffectedObjectDetails)
	populate(objectMap, "comments", t.Comments)
	objectMap["instanceType"] = "TestFailoverCleanupJobDetails"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestFailoverCleanupJobModelCustomProperties.
func (t *TestFailoverCleanupJobModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedObjectDetails":
			err = unpopulate(val, "AffectedObjectDetails", &t.AffectedObjectDetails)
			delete(rawMsg, key)
		case "comments":
			err = unpopulate(val, "Comments", &t.Comments)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &t.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TestFailoverJobModelCustomProperties.
func (t TestFailoverJobModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affectedObjectDetails", t.AffectedObjectDetails)
	objectMap["instanceType"] = "TestFailoverJobDetails"
	populate(objectMap, "protectedItemDetails", t.ProtectedItemDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestFailoverJobModelCustomProperties.
func (t *TestFailoverJobModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affectedObjectDetails":
			err = unpopulate(val, "AffectedObjectDetails", &t.AffectedObjectDetails)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &t.InstanceType)
			delete(rawMsg, key)
		case "protectedItemDetails":
			err = unpopulate(val, "ProtectedItemDetails", &t.ProtectedItemDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareFabricAgentModelCustomProperties.
func (v VMwareFabricAgentModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "biosId", v.BiosID)
	objectMap["instanceType"] = "VMware"
	populate(objectMap, "marsAuthenticationIdentity", v.MarsAuthenticationIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareFabricAgentModelCustomProperties.
func (v *VMwareFabricAgentModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "biosId":
			err = unpopulate(val, "BiosID", &v.BiosID)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "marsAuthenticationIdentity":
			err = unpopulate(val, "MarsAuthenticationIdentity", &v.MarsAuthenticationIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareMigrateFabricModelCustomProperties.
func (v VMwareMigrateFabricModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["instanceType"] = "VMwareMigrate"
	populate(objectMap, "migrationSolutionId", v.MigrationSolutionID)
	populate(objectMap, "vmwareSiteId", v.VmwareSiteID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareMigrateFabricModelCustomProperties.
func (v *VMwareMigrateFabricModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "migrationSolutionId":
			err = unpopulate(val, "MigrationSolutionID", &v.MigrationSolutionID)
			delete(rawMsg, key)
		case "vmwareSiteId":
			err = unpopulate(val, "VmwareSiteID", &v.VmwareSiteID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIDiskInput.
func (v VMwareToAzStackHCIDiskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskBlockSize", v.DiskBlockSize)
	populate(objectMap, "diskController", v.DiskController)
	populate(objectMap, "diskFileFormat", v.DiskFileFormat)
	populate(objectMap, "diskId", v.DiskID)
	populate(objectMap, "diskIdentifier", v.DiskIdentifier)
	populate(objectMap, "diskLogicalSectorSize", v.DiskLogicalSectorSize)
	populate(objectMap, "diskPhysicalSectorSize", v.DiskPhysicalSectorSize)
	populate(objectMap, "diskSizeGB", v.DiskSizeGB)
	populate(objectMap, "isDynamic", v.IsDynamic)
	populate(objectMap, "isOsDisk", v.IsOsDisk)
	populate(objectMap, "storageContainerId", v.StorageContainerID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIDiskInput.
func (v *VMwareToAzStackHCIDiskInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskBlockSize":
			err = unpopulate(val, "DiskBlockSize", &v.DiskBlockSize)
			delete(rawMsg, key)
		case "diskController":
			err = unpopulate(val, "DiskController", &v.DiskController)
			delete(rawMsg, key)
		case "diskFileFormat":
			err = unpopulate(val, "DiskFileFormat", &v.DiskFileFormat)
			delete(rawMsg, key)
		case "diskId":
			err = unpopulate(val, "DiskID", &v.DiskID)
			delete(rawMsg, key)
		case "diskIdentifier":
			err = unpopulate(val, "DiskIdentifier", &v.DiskIdentifier)
			delete(rawMsg, key)
		case "diskLogicalSectorSize":
			err = unpopulate(val, "DiskLogicalSectorSize", &v.DiskLogicalSectorSize)
			delete(rawMsg, key)
		case "diskPhysicalSectorSize":
			err = unpopulate(val, "DiskPhysicalSectorSize", &v.DiskPhysicalSectorSize)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, "DiskSizeGB", &v.DiskSizeGB)
			delete(rawMsg, key)
		case "isDynamic":
			err = unpopulate(val, "IsDynamic", &v.IsDynamic)
			delete(rawMsg, key)
		case "isOsDisk":
			err = unpopulate(val, "IsOsDisk", &v.IsOsDisk)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &v.StorageContainerID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIEventModelCustomProperties.
func (v VMwareToAzStackHCIEventModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eventSourceFriendlyName", v.EventSourceFriendlyName)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "protectedItemFriendlyName", v.ProtectedItemFriendlyName)
	populate(objectMap, "serverType", v.ServerType)
	populate(objectMap, "sourceApplianceName", v.SourceApplianceName)
	populate(objectMap, "targetApplianceName", v.TargetApplianceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIEventModelCustomProperties.
func (v *VMwareToAzStackHCIEventModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eventSourceFriendlyName":
			err = unpopulate(val, "EventSourceFriendlyName", &v.EventSourceFriendlyName)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "protectedItemFriendlyName":
			err = unpopulate(val, "ProtectedItemFriendlyName", &v.ProtectedItemFriendlyName)
			delete(rawMsg, key)
		case "serverType":
			err = unpopulate(val, "ServerType", &v.ServerType)
			delete(rawMsg, key)
		case "sourceApplianceName":
			err = unpopulate(val, "SourceApplianceName", &v.SourceApplianceName)
			delete(rawMsg, key)
		case "targetApplianceName":
			err = unpopulate(val, "TargetApplianceName", &v.TargetApplianceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCINicInput.
func (v VMwareToAzStackHCINicInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isMacMigrationEnabled", v.IsMacMigrationEnabled)
	populate(objectMap, "isStaticIpMigrationEnabled", v.IsStaticIPMigrationEnabled)
	populate(objectMap, "label", v.Label)
	populate(objectMap, "networkName", v.NetworkName)
	populate(objectMap, "nicId", v.NicID)
	populate(objectMap, "selectionTypeForFailover", v.SelectionTypeForFailover)
	populate(objectMap, "targetNetworkId", v.TargetNetworkID)
	populate(objectMap, "testNetworkId", v.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCINicInput.
func (v *VMwareToAzStackHCINicInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isMacMigrationEnabled":
			err = unpopulate(val, "IsMacMigrationEnabled", &v.IsMacMigrationEnabled)
			delete(rawMsg, key)
		case "isStaticIpMigrationEnabled":
			err = unpopulate(val, "IsStaticIPMigrationEnabled", &v.IsStaticIPMigrationEnabled)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &v.Label)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &v.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &v.NicID)
			delete(rawMsg, key)
		case "selectionTypeForFailover":
			err = unpopulate(val, "SelectionTypeForFailover", &v.SelectionTypeForFailover)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &v.TargetNetworkID)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &v.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIPlannedFailoverModelCustomProperties.
func (v VMwareToAzStackHCIPlannedFailoverModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "shutdownSourceVM", v.ShutdownSourceVM)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIPlannedFailoverModelCustomProperties.
func (v *VMwareToAzStackHCIPlannedFailoverModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "shutdownSourceVM":
			err = unpopulate(val, "ShutdownSourceVM", &v.ShutdownSourceVM)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIPolicyModelCustomProperties.
func (v VMwareToAzStackHCIPolicyModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appConsistentFrequencyInMinutes", v.AppConsistentFrequencyInMinutes)
	populate(objectMap, "crashConsistentFrequencyInMinutes", v.CrashConsistentFrequencyInMinutes)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "recoveryPointHistoryInMinutes", v.RecoveryPointHistoryInMinutes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIPolicyModelCustomProperties.
func (v *VMwareToAzStackHCIPolicyModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appConsistentFrequencyInMinutes":
			err = unpopulate(val, "AppConsistentFrequencyInMinutes", &v.AppConsistentFrequencyInMinutes)
			delete(rawMsg, key)
		case "crashConsistentFrequencyInMinutes":
			err = unpopulate(val, "CrashConsistentFrequencyInMinutes", &v.CrashConsistentFrequencyInMinutes)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "recoveryPointHistoryInMinutes":
			err = unpopulate(val, "RecoveryPointHistoryInMinutes", &v.RecoveryPointHistoryInMinutes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIProtectedDiskProperties.
func (v VMwareToAzStackHCIProtectedDiskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityInBytes", v.CapacityInBytes)
	populate(objectMap, "diskBlockSize", v.DiskBlockSize)
	populate(objectMap, "diskLogicalSectorSize", v.DiskLogicalSectorSize)
	populate(objectMap, "diskPhysicalSectorSize", v.DiskPhysicalSectorSize)
	populate(objectMap, "diskType", v.DiskType)
	populate(objectMap, "isDynamic", v.IsDynamic)
	populate(objectMap, "isOsDisk", v.IsOsDisk)
	populate(objectMap, "migrateDiskName", v.MigrateDiskName)
	populate(objectMap, "seedDiskName", v.SeedDiskName)
	populate(objectMap, "sourceDiskId", v.SourceDiskID)
	populate(objectMap, "sourceDiskName", v.SourceDiskName)
	populate(objectMap, "storageContainerId", v.StorageContainerID)
	populate(objectMap, "storageContainerLocalPath", v.StorageContainerLocalPath)
	populate(objectMap, "testMigrateDiskName", v.TestMigrateDiskName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIProtectedDiskProperties.
func (v *VMwareToAzStackHCIProtectedDiskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityInBytes":
			err = unpopulate(val, "CapacityInBytes", &v.CapacityInBytes)
			delete(rawMsg, key)
		case "diskBlockSize":
			err = unpopulate(val, "DiskBlockSize", &v.DiskBlockSize)
			delete(rawMsg, key)
		case "diskLogicalSectorSize":
			err = unpopulate(val, "DiskLogicalSectorSize", &v.DiskLogicalSectorSize)
			delete(rawMsg, key)
		case "diskPhysicalSectorSize":
			err = unpopulate(val, "DiskPhysicalSectorSize", &v.DiskPhysicalSectorSize)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, "DiskType", &v.DiskType)
			delete(rawMsg, key)
		case "isDynamic":
			err = unpopulate(val, "IsDynamic", &v.IsDynamic)
			delete(rawMsg, key)
		case "isOsDisk":
			err = unpopulate(val, "IsOsDisk", &v.IsOsDisk)
			delete(rawMsg, key)
		case "migrateDiskName":
			err = unpopulate(val, "MigrateDiskName", &v.MigrateDiskName)
			delete(rawMsg, key)
		case "seedDiskName":
			err = unpopulate(val, "SeedDiskName", &v.SeedDiskName)
			delete(rawMsg, key)
		case "sourceDiskId":
			err = unpopulate(val, "SourceDiskID", &v.SourceDiskID)
			delete(rawMsg, key)
		case "sourceDiskName":
			err = unpopulate(val, "SourceDiskName", &v.SourceDiskName)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &v.StorageContainerID)
			delete(rawMsg, key)
		case "storageContainerLocalPath":
			err = unpopulate(val, "StorageContainerLocalPath", &v.StorageContainerLocalPath)
			delete(rawMsg, key)
		case "testMigrateDiskName":
			err = unpopulate(val, "TestMigrateDiskName", &v.TestMigrateDiskName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIProtectedItemModelCustomProperties.
func (v VMwareToAzStackHCIProtectedItemModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activeLocation", v.ActiveLocation)
	populate(objectMap, "customLocationRegion", v.CustomLocationRegion)
	populate(objectMap, "disksToInclude", v.DisksToInclude)
	populate(objectMap, "dynamicMemoryConfig", v.DynamicMemoryConfig)
	populate(objectMap, "fabricDiscoveryMachineId", v.FabricDiscoveryMachineID)
	populate(objectMap, "failoverRecoveryPointId", v.FailoverRecoveryPointID)
	populate(objectMap, "firmwareType", v.FirmwareType)
	populate(objectMap, "hyperVGeneration", v.HyperVGeneration)
	populate(objectMap, "initialReplicationProgressPercentage", v.InitialReplicationProgressPercentage)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "isDynamicRam", v.IsDynamicRAM)
	populate(objectMap, "lastRecoveryPointId", v.LastRecoveryPointID)
	populateTime[datetime.RFC3339](objectMap, "lastRecoveryPointReceived", v.LastRecoveryPointReceived)
	populateTime[datetime.RFC3339](objectMap, "lastReplicationUpdateTime", v.LastReplicationUpdateTime)
	populate(objectMap, "migrationProgressPercentage", v.MigrationProgressPercentage)
	populate(objectMap, "nicsToInclude", v.NicsToInclude)
	populate(objectMap, "osName", v.OSName)
	populate(objectMap, "osType", v.OSType)
	populate(objectMap, "performAutoResync", v.PerformAutoResync)
	populate(objectMap, "protectedDisks", v.ProtectedDisks)
	populate(objectMap, "protectedNics", v.ProtectedNics)
	populate(objectMap, "resumeProgressPercentage", v.ResumeProgressPercentage)
	populate(objectMap, "resumeRetryCount", v.ResumeRetryCount)
	populate(objectMap, "resyncProgressPercentage", v.ResyncProgressPercentage)
	populate(objectMap, "resyncRequired", v.ResyncRequired)
	populate(objectMap, "resyncRetryCount", v.ResyncRetryCount)
	populate(objectMap, "resyncState", v.ResyncState)
	populate(objectMap, "runAsAccountId", v.RunAsAccountID)
	populate(objectMap, "sourceApplianceName", v.SourceApplianceName)
	populate(objectMap, "sourceCpuCores", v.SourceCPUCores)
	populate(objectMap, "sourceFabricAgentName", v.SourceFabricAgentName)
	populate(objectMap, "sourceMemoryInMegaBytes", v.SourceMemoryInMegaBytes)
	populate(objectMap, "sourceVmName", v.SourceVMName)
	populate(objectMap, "storageContainerId", v.StorageContainerID)
	populate(objectMap, "targetApplianceName", v.TargetApplianceName)
	populate(objectMap, "targetArcClusterCustomLocationId", v.TargetArcClusterCustomLocationID)
	populate(objectMap, "targetAzStackHciClusterName", v.TargetAzStackHciClusterName)
	populate(objectMap, "targetCpuCores", v.TargetCPUCores)
	populate(objectMap, "targetFabricAgentName", v.TargetFabricAgentName)
	populate(objectMap, "targetHciClusterId", v.TargetHciClusterID)
	populate(objectMap, "targetLocation", v.TargetLocation)
	populate(objectMap, "targetMemoryInMegaBytes", v.TargetMemoryInMegaBytes)
	populate(objectMap, "targetNetworkId", v.TargetNetworkID)
	populate(objectMap, "targetResourceGroupId", v.TargetResourceGroupID)
	populate(objectMap, "targetVmBiosId", v.TargetVMBiosID)
	populate(objectMap, "targetVmName", v.TargetVMName)
	populate(objectMap, "testNetworkId", v.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIProtectedItemModelCustomProperties.
func (v *VMwareToAzStackHCIProtectedItemModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeLocation":
			err = unpopulate(val, "ActiveLocation", &v.ActiveLocation)
			delete(rawMsg, key)
		case "customLocationRegion":
			err = unpopulate(val, "CustomLocationRegion", &v.CustomLocationRegion)
			delete(rawMsg, key)
		case "disksToInclude":
			err = unpopulate(val, "DisksToInclude", &v.DisksToInclude)
			delete(rawMsg, key)
		case "dynamicMemoryConfig":
			err = unpopulate(val, "DynamicMemoryConfig", &v.DynamicMemoryConfig)
			delete(rawMsg, key)
		case "fabricDiscoveryMachineId":
			err = unpopulate(val, "FabricDiscoveryMachineID", &v.FabricDiscoveryMachineID)
			delete(rawMsg, key)
		case "failoverRecoveryPointId":
			err = unpopulate(val, "FailoverRecoveryPointID", &v.FailoverRecoveryPointID)
			delete(rawMsg, key)
		case "firmwareType":
			err = unpopulate(val, "FirmwareType", &v.FirmwareType)
			delete(rawMsg, key)
		case "hyperVGeneration":
			err = unpopulate(val, "HyperVGeneration", &v.HyperVGeneration)
			delete(rawMsg, key)
		case "initialReplicationProgressPercentage":
			err = unpopulate(val, "InitialReplicationProgressPercentage", &v.InitialReplicationProgressPercentage)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "isDynamicRam":
			err = unpopulate(val, "IsDynamicRAM", &v.IsDynamicRAM)
			delete(rawMsg, key)
		case "lastRecoveryPointId":
			err = unpopulate(val, "LastRecoveryPointID", &v.LastRecoveryPointID)
			delete(rawMsg, key)
		case "lastRecoveryPointReceived":
			err = unpopulateTime[datetime.RFC3339](val, "LastRecoveryPointReceived", &v.LastRecoveryPointReceived)
			delete(rawMsg, key)
		case "lastReplicationUpdateTime":
			err = unpopulateTime[datetime.RFC3339](val, "LastReplicationUpdateTime", &v.LastReplicationUpdateTime)
			delete(rawMsg, key)
		case "migrationProgressPercentage":
			err = unpopulate(val, "MigrationProgressPercentage", &v.MigrationProgressPercentage)
			delete(rawMsg, key)
		case "nicsToInclude":
			err = unpopulate(val, "NicsToInclude", &v.NicsToInclude)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, "OSName", &v.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &v.OSType)
			delete(rawMsg, key)
		case "performAutoResync":
			err = unpopulate(val, "PerformAutoResync", &v.PerformAutoResync)
			delete(rawMsg, key)
		case "protectedDisks":
			err = unpopulate(val, "ProtectedDisks", &v.ProtectedDisks)
			delete(rawMsg, key)
		case "protectedNics":
			err = unpopulate(val, "ProtectedNics", &v.ProtectedNics)
			delete(rawMsg, key)
		case "resumeProgressPercentage":
			err = unpopulate(val, "ResumeProgressPercentage", &v.ResumeProgressPercentage)
			delete(rawMsg, key)
		case "resumeRetryCount":
			err = unpopulate(val, "ResumeRetryCount", &v.ResumeRetryCount)
			delete(rawMsg, key)
		case "resyncProgressPercentage":
			err = unpopulate(val, "ResyncProgressPercentage", &v.ResyncProgressPercentage)
			delete(rawMsg, key)
		case "resyncRequired":
			err = unpopulate(val, "ResyncRequired", &v.ResyncRequired)
			delete(rawMsg, key)
		case "resyncRetryCount":
			err = unpopulate(val, "ResyncRetryCount", &v.ResyncRetryCount)
			delete(rawMsg, key)
		case "resyncState":
			err = unpopulate(val, "ResyncState", &v.ResyncState)
			delete(rawMsg, key)
		case "runAsAccountId":
			err = unpopulate(val, "RunAsAccountID", &v.RunAsAccountID)
			delete(rawMsg, key)
		case "sourceApplianceName":
			err = unpopulate(val, "SourceApplianceName", &v.SourceApplianceName)
			delete(rawMsg, key)
		case "sourceCpuCores":
			err = unpopulate(val, "SourceCPUCores", &v.SourceCPUCores)
			delete(rawMsg, key)
		case "sourceFabricAgentName":
			err = unpopulate(val, "SourceFabricAgentName", &v.SourceFabricAgentName)
			delete(rawMsg, key)
		case "sourceMemoryInMegaBytes":
			err = unpopulate(val, "SourceMemoryInMegaBytes", &v.SourceMemoryInMegaBytes)
			delete(rawMsg, key)
		case "sourceVmName":
			err = unpopulate(val, "SourceVMName", &v.SourceVMName)
			delete(rawMsg, key)
		case "storageContainerId":
			err = unpopulate(val, "StorageContainerID", &v.StorageContainerID)
			delete(rawMsg, key)
		case "targetApplianceName":
			err = unpopulate(val, "TargetApplianceName", &v.TargetApplianceName)
			delete(rawMsg, key)
		case "targetArcClusterCustomLocationId":
			err = unpopulate(val, "TargetArcClusterCustomLocationID", &v.TargetArcClusterCustomLocationID)
			delete(rawMsg, key)
		case "targetAzStackHciClusterName":
			err = unpopulate(val, "TargetAzStackHciClusterName", &v.TargetAzStackHciClusterName)
			delete(rawMsg, key)
		case "targetCpuCores":
			err = unpopulate(val, "TargetCPUCores", &v.TargetCPUCores)
			delete(rawMsg, key)
		case "targetFabricAgentName":
			err = unpopulate(val, "TargetFabricAgentName", &v.TargetFabricAgentName)
			delete(rawMsg, key)
		case "targetHciClusterId":
			err = unpopulate(val, "TargetHciClusterID", &v.TargetHciClusterID)
			delete(rawMsg, key)
		case "targetLocation":
			err = unpopulate(val, "TargetLocation", &v.TargetLocation)
			delete(rawMsg, key)
		case "targetMemoryInMegaBytes":
			err = unpopulate(val, "TargetMemoryInMegaBytes", &v.TargetMemoryInMegaBytes)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &v.TargetNetworkID)
			delete(rawMsg, key)
		case "targetResourceGroupId":
			err = unpopulate(val, "TargetResourceGroupID", &v.TargetResourceGroupID)
			delete(rawMsg, key)
		case "targetVmBiosId":
			err = unpopulate(val, "TargetVMBiosID", &v.TargetVMBiosID)
			delete(rawMsg, key)
		case "targetVmName":
			err = unpopulate(val, "TargetVMName", &v.TargetVMName)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &v.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIProtectedItemModelCustomPropertiesUpdate.
func (v VMwareToAzStackHCIProtectedItemModelCustomPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicMemoryConfig", v.DynamicMemoryConfig)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "isDynamicRam", v.IsDynamicRAM)
	populate(objectMap, "nicsToInclude", v.NicsToInclude)
	populate(objectMap, "osType", v.OSType)
	populate(objectMap, "targetCpuCores", v.TargetCPUCores)
	populate(objectMap, "targetMemoryInMegaBytes", v.TargetMemoryInMegaBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIProtectedItemModelCustomPropertiesUpdate.
func (v *VMwareToAzStackHCIProtectedItemModelCustomPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicMemoryConfig":
			err = unpopulate(val, "DynamicMemoryConfig", &v.DynamicMemoryConfig)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "isDynamicRam":
			err = unpopulate(val, "IsDynamicRAM", &v.IsDynamicRAM)
			delete(rawMsg, key)
		case "nicsToInclude":
			err = unpopulate(val, "NicsToInclude", &v.NicsToInclude)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &v.OSType)
			delete(rawMsg, key)
		case "targetCpuCores":
			err = unpopulate(val, "TargetCPUCores", &v.TargetCPUCores)
			delete(rawMsg, key)
		case "targetMemoryInMegaBytes":
			err = unpopulate(val, "TargetMemoryInMegaBytes", &v.TargetMemoryInMegaBytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIProtectedNicProperties.
func (v VMwareToAzStackHCIProtectedNicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isPrimaryNic", v.IsPrimaryNic)
	populate(objectMap, "label", v.Label)
	populate(objectMap, "macAddress", v.MacAddress)
	populate(objectMap, "networkName", v.NetworkName)
	populate(objectMap, "nicId", v.NicID)
	populate(objectMap, "selectionTypeForFailover", v.SelectionTypeForFailover)
	populate(objectMap, "targetNetworkId", v.TargetNetworkID)
	populate(objectMap, "testNetworkId", v.TestNetworkID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIProtectedNicProperties.
func (v *VMwareToAzStackHCIProtectedNicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isPrimaryNic":
			err = unpopulate(val, "IsPrimaryNic", &v.IsPrimaryNic)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, "Label", &v.Label)
			delete(rawMsg, key)
		case "macAddress":
			err = unpopulate(val, "MacAddress", &v.MacAddress)
			delete(rawMsg, key)
		case "networkName":
			err = unpopulate(val, "NetworkName", &v.NetworkName)
			delete(rawMsg, key)
		case "nicId":
			err = unpopulate(val, "NicID", &v.NicID)
			delete(rawMsg, key)
		case "selectionTypeForFailover":
			err = unpopulate(val, "SelectionTypeForFailover", &v.SelectionTypeForFailover)
			delete(rawMsg, key)
		case "targetNetworkId":
			err = unpopulate(val, "TargetNetworkID", &v.TargetNetworkID)
			delete(rawMsg, key)
		case "testNetworkId":
			err = unpopulate(val, "TestNetworkID", &v.TestNetworkID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIRecoveryPointModelCustomProperties.
func (v VMwareToAzStackHCIRecoveryPointModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskIds", v.DiskIDs)
	objectMap["instanceType"] = "VMwareToAzStackHCIRecoveryPointModelCustomProperties"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIRecoveryPointModelCustomProperties.
func (v *VMwareToAzStackHCIRecoveryPointModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskIds":
			err = unpopulate(val, "DiskIDs", &v.DiskIDs)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMwareToAzStackHCIReplicationExtensionModelCustomProperties.
func (v VMwareToAzStackHCIReplicationExtensionModelCustomProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "asrServiceUri", v.AsrServiceURI)
	populate(objectMap, "azStackHciFabricArmId", v.AzStackHciFabricArmID)
	populate(objectMap, "azStackHciSiteId", v.AzStackHciSiteID)
	populate(objectMap, "gatewayServiceUri", v.GatewayServiceURI)
	objectMap["instanceType"] = "VMwareToAzStackHCI"
	populate(objectMap, "rcmServiceUri", v.RcmServiceURI)
	populate(objectMap, "resourceGroup", v.ResourceGroup)
	populate(objectMap, "resourceLocation", v.ResourceLocation)
	populate(objectMap, "sourceGatewayServiceId", v.SourceGatewayServiceID)
	populate(objectMap, "sourceStorageContainerName", v.SourceStorageContainerName)
	populate(objectMap, "storageAccountId", v.StorageAccountID)
	populate(objectMap, "storageAccountSasSecretName", v.StorageAccountSasSecretName)
	populate(objectMap, "subscriptionId", v.SubscriptionID)
	populate(objectMap, "targetGatewayServiceId", v.TargetGatewayServiceID)
	populate(objectMap, "targetStorageContainerName", v.TargetStorageContainerName)
	populate(objectMap, "vmwareFabricArmId", v.VmwareFabricArmID)
	populate(objectMap, "vmwareSiteId", v.VmwareSiteID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMwareToAzStackHCIReplicationExtensionModelCustomProperties.
func (v *VMwareToAzStackHCIReplicationExtensionModelCustomProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "asrServiceUri":
			err = unpopulate(val, "AsrServiceURI", &v.AsrServiceURI)
			delete(rawMsg, key)
		case "azStackHciFabricArmId":
			err = unpopulate(val, "AzStackHciFabricArmID", &v.AzStackHciFabricArmID)
			delete(rawMsg, key)
		case "azStackHciSiteId":
			err = unpopulate(val, "AzStackHciSiteID", &v.AzStackHciSiteID)
			delete(rawMsg, key)
		case "gatewayServiceUri":
			err = unpopulate(val, "GatewayServiceURI", &v.GatewayServiceURI)
			delete(rawMsg, key)
		case "instanceType":
			err = unpopulate(val, "InstanceType", &v.InstanceType)
			delete(rawMsg, key)
		case "rcmServiceUri":
			err = unpopulate(val, "RcmServiceURI", &v.RcmServiceURI)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, "ResourceGroup", &v.ResourceGroup)
			delete(rawMsg, key)
		case "resourceLocation":
			err = unpopulate(val, "ResourceLocation", &v.ResourceLocation)
			delete(rawMsg, key)
		case "sourceGatewayServiceId":
			err = unpopulate(val, "SourceGatewayServiceID", &v.SourceGatewayServiceID)
			delete(rawMsg, key)
		case "sourceStorageContainerName":
			err = unpopulate(val, "SourceStorageContainerName", &v.SourceStorageContainerName)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, "StorageAccountID", &v.StorageAccountID)
			delete(rawMsg, key)
		case "storageAccountSasSecretName":
			err = unpopulate(val, "StorageAccountSasSecretName", &v.StorageAccountSasSecretName)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &v.SubscriptionID)
			delete(rawMsg, key)
		case "targetGatewayServiceId":
			err = unpopulate(val, "TargetGatewayServiceID", &v.TargetGatewayServiceID)
			delete(rawMsg, key)
		case "targetStorageContainerName":
			err = unpopulate(val, "TargetStorageContainerName", &v.TargetStorageContainerName)
			delete(rawMsg, key)
		case "vmwareFabricArmId":
			err = unpopulate(val, "VmwareFabricArmID", &v.VmwareFabricArmID)
			delete(rawMsg, key)
		case "vmwareSiteId":
			err = unpopulate(val, "VmwareSiteID", &v.VmwareSiteID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultIdentityModel.
func (v VaultIdentityModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", v.PrincipalID)
	populate(objectMap, "tenantId", v.TenantID)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultIdentityModel.
func (v *VaultIdentityModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &v.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &v.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultModel.
func (v VaultModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultModel.
func (v *VaultModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &v.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &v.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultModelListResult.
func (v VaultModelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultModelListResult.
func (v *VaultModelListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultModelProperties.
func (v VaultModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "serviceResourceId", v.ServiceResourceID)
	populate(objectMap, "vaultType", v.VaultType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultModelProperties.
func (v *VaultModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "serviceResourceId":
			err = unpopulate(val, "ServiceResourceID", &v.ServiceResourceID)
			delete(rawMsg, key)
		case "vaultType":
			err = unpopulate(val, "VaultType", &v.VaultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultModelUpdate.
func (v VaultModelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultModelUpdate.
func (v *VaultModelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &v.Identity)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateTime[T dateTimeConstraints](m map[string]any, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
	} else if !reflect.ValueOf(t).IsNil() {
		newTime := T(*t)
		m[k] = (*T)(&newTime)
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

func unpopulateTime[T dateTimeConstraints](data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	var aux T
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	newTime := time.Time(aux)
	*t = &newTime
	return nil
}

type dateTimeConstraints interface {
	datetime.PlainDate | datetime.PlainTime | datetime.RFC1123 | datetime.RFC3339 | datetime.Unix
}
