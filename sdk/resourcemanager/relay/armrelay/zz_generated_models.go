//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrelay

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccessKeys - Namespace/Relay Connection String
type AccessKeys struct {
	// A string that describes the authorization rule.
	KeyName *string `json:"keyName,omitempty"`

	// Primary connection string of the created namespace authorization rule.
	PrimaryConnectionString *string `json:"primaryConnectionString,omitempty"`

	// A base64-encoded 256-bit primary key for signing and validating the SAS token.
	PrimaryKey *string `json:"primaryKey,omitempty"`

	// Secondary connection string of the created namespace authorization rule.
	SecondaryConnectionString *string `json:"secondaryConnectionString,omitempty"`

	// A base64-encoded 256-bit secondary key for signing and validating the SAS token.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// AuthorizationRule - Description of a namespace authorization rule.
type AuthorizationRule struct {
	Resource
	// REQUIRED; Authorization rule properties.
	Properties *AuthorizationRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationRule.
func (a AuthorizationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// AuthorizationRuleListResult - The response from the list namespace operation.
type AuthorizationRuleListResult struct {
	// Link to the next set of results. Not empty if value contains incomplete list of authorization rules.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the list authorization rules operation.
	Value []*AuthorizationRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationRuleListResult.
func (a AuthorizationRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AuthorizationRuleProperties - Authorization rule properties.
type AuthorizationRuleProperties struct {
	// REQUIRED; The rights associated with the rule.
	Rights []*AccessRights `json:"rights,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationRuleProperties.
func (a AuthorizationRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rights", a.Rights)
	return json.Marshal(objectMap)
}

// CheckNameAvailability - Description of the check name availability request properties.
type CheckNameAvailability struct {
	// REQUIRED; The namespace name to check for availability. The namespace name can contain only letters, numbers, and hyphens. The namespace must start with
	// a letter, and it must end with a letter or number.
	Name *string `json:"name,omitempty"`
}

// CheckNameAvailabilityResult - Description of the check name availability request properties.
type CheckNameAvailabilityResult struct {
	// Value indicating namespace is available. Returns true if the namespace is available; otherwise, false.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason for unavailability of a namespace.
	Reason *UnavailableReason `json:"reason,omitempty"`

	// READ-ONLY; The detailed info regarding the reason associated with the namespace.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ErrorResponse - Error reponse indicates Relay service is not able to process the incoming request. The reason is provided in the error message.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// Error code.
	Code *string `json:"code,omitempty"`

	// Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// HybridConnection - Description of hybrid connection resource.
type HybridConnection struct {
	Resource
	// Properties of the HybridConnection.
	Properties *HybridConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnection.
func (h HybridConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// HybridConnectionListResult - The response of the list hybrid connection operation.
type HybridConnectionListResult struct {
	// Link to the next set of results. Not empty if value contains incomplete list hybrid connection operation.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the list hybrid connections.
	Value []*HybridConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionListResult.
func (h HybridConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HybridConnectionProperties - Properties of the HybridConnection.
type HybridConnectionProperties struct {
	// Returns true if client authorization is needed for this hybrid connection; otherwise, false.
	RequiresClientAuthorization *bool `json:"requiresClientAuthorization,omitempty"`

	// The usermetadata is a placeholder to store user-defined string data for the hybrid connection endpoint. For example, it can be used to store descriptive
	// data, such as a list of teams and their contact
	// information. Also, user-defined configuration settings can be stored.
	UserMetadata *string `json:"userMetadata,omitempty"`

	// READ-ONLY; The time the hybrid connection was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; The number of listeners for this hybrid connection. Note that min : 1 and max:25 are supported.
	ListenerCount *int32 `json:"listenerCount,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type HybridConnectionProperties.
func (h HybridConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", h.CreatedAt)
	populate(objectMap, "listenerCount", h.ListenerCount)
	populate(objectMap, "requiresClientAuthorization", h.RequiresClientAuthorization)
	populateTimeRFC3339(objectMap, "updatedAt", h.UpdatedAt)
	populate(objectMap, "userMetadata", h.UserMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HybridConnectionProperties.
func (h *HybridConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &h.CreatedAt)
			delete(rawMsg, key)
		case "listenerCount":
			err = unpopulate(val, &h.ListenerCount)
			delete(rawMsg, key)
		case "requiresClientAuthorization":
			err = unpopulate(val, &h.RequiresClientAuthorization)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &h.UpdatedAt)
			delete(rawMsg, key)
		case "userMetadata":
			err = unpopulate(val, &h.UserMetadata)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HybridConnectionsCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the HybridConnections.CreateOrUpdateAuthorizationRule method.
type HybridConnectionsCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsCreateOrUpdateOptions contains the optional parameters for the HybridConnections.CreateOrUpdate method.
type HybridConnectionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsDeleteAuthorizationRuleOptions contains the optional parameters for the HybridConnections.DeleteAuthorizationRule method.
type HybridConnectionsDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsDeleteOptions contains the optional parameters for the HybridConnections.Delete method.
type HybridConnectionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsGetAuthorizationRuleOptions contains the optional parameters for the HybridConnections.GetAuthorizationRule method.
type HybridConnectionsGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsGetOptions contains the optional parameters for the HybridConnections.Get method.
type HybridConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsListAuthorizationRulesOptions contains the optional parameters for the HybridConnections.ListAuthorizationRules method.
type HybridConnectionsListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsListByNamespaceOptions contains the optional parameters for the HybridConnections.ListByNamespace method.
type HybridConnectionsListByNamespaceOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsListKeysOptions contains the optional parameters for the HybridConnections.ListKeys method.
type HybridConnectionsListKeysOptions struct {
	// placeholder for future optional parameters
}

// HybridConnectionsRegenerateKeysOptions contains the optional parameters for the HybridConnections.RegenerateKeys method.
type HybridConnectionsRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesBeginCreateOrUpdateOptions contains the optional parameters for the Namespaces.BeginCreateOrUpdate method.
type NamespacesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NamespacesBeginDeleteOptions contains the optional parameters for the Namespaces.BeginDelete method.
type NamespacesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCheckNameAvailabilityOptions contains the optional parameters for the Namespaces.CheckNameAvailability method.
type NamespacesCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the Namespaces.CreateOrUpdateAuthorizationRule method.
type NamespacesCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesDeleteAuthorizationRuleOptions contains the optional parameters for the Namespaces.DeleteAuthorizationRule method.
type NamespacesDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetAuthorizationRuleOptions contains the optional parameters for the Namespaces.GetAuthorizationRule method.
type NamespacesGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetOptions contains the optional parameters for the Namespaces.Get method.
type NamespacesGetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListAuthorizationRulesOptions contains the optional parameters for the Namespaces.ListAuthorizationRules method.
type NamespacesListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListByResourceGroupOptions contains the optional parameters for the Namespaces.ListByResourceGroup method.
type NamespacesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListKeysOptions contains the optional parameters for the Namespaces.ListKeys method.
type NamespacesListKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListOptions contains the optional parameters for the Namespaces.List method.
type NamespacesListOptions struct {
	// placeholder for future optional parameters
}

// NamespacesRegenerateKeysOptions contains the optional parameters for the Namespaces.RegenerateKeys method.
type NamespacesRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesUpdateOptions contains the optional parameters for the Namespaces.Update method.
type NamespacesUpdateOptions struct {
	// placeholder for future optional parameters
}

// Operation - A Relay REST API operation.
type Operation struct {
	// The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - The object that represents the operation.
type OperationDisplay struct {
	// READ-ONLY; Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Service provider: Relay.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource on which the operation is performed: Invoice, etc.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - Result of the request to list Relay operations. It contains a list of operations and a URL link to get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of Relay operations supported by resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// RegenerateAccessKeyParameters - Parameters supplied to the regenerate authorization rule operation, specifies which key neeeds to be reset.
type RegenerateAccessKeyParameters struct {
	// REQUIRED; The access key to regenerate.
	KeyType *KeyType `json:"keyType,omitempty"`

	// Optional. If the key value is provided, this is set to key type, or autogenerated key value set for key type.
	Key *string `json:"key,omitempty"`
}

// RelayNamespace - Description of a namespace resource.
type RelayNamespace struct {
	TrackedResource
	// Description of Relay namespace
	Properties *RelayNamespaceProperties `json:"properties,omitempty"`

	// SKU of the namespace.
	SKU *SKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelayNamespace.
func (r RelayNamespace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	return json.Marshal(objectMap)
}

// RelayNamespaceListResult - The response from the list namespace operation.
type RelayNamespaceListResult struct {
	// Link to the next set of results. Not empty if value contains incomplete list of namespaces.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the list namespace operation.
	Value []*RelayNamespace `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelayNamespaceListResult.
func (r RelayNamespaceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RelayNamespaceProperties - Properties of the namespace.
type RelayNamespaceProperties struct {
	// READ-ONLY; The time the namespace was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for Azure Insights metrics.
	MetricID *string `json:"metricId,omitempty" azure:"ro"`

	// READ-ONLY
	ProvisioningState *ProvisioningStateEnum `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Endpoint you can use to perform Service Bus operations.
	ServiceBusEndpoint *string `json:"serviceBusEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RelayNamespaceProperties.
func (r RelayNamespaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", r.CreatedAt)
	populate(objectMap, "metricId", r.MetricID)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "serviceBusEndpoint", r.ServiceBusEndpoint)
	populateTimeRFC3339(objectMap, "updatedAt", r.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelayNamespaceProperties.
func (r *RelayNamespaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &r.CreatedAt)
			delete(rawMsg, key)
		case "metricId":
			err = unpopulate(val, &r.MetricID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		case "serviceBusEndpoint":
			err = unpopulate(val, &r.ServiceBusEndpoint)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &r.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RelayUpdateParameters - Description of a namespace resource.
type RelayUpdateParameters struct {
	ResourceNamespacePatch
	// Description of Relay namespace.
	Properties *RelayNamespaceProperties `json:"properties,omitempty"`

	// SKU of the namespace.
	SKU *SKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelayUpdateParameters.
func (r RelayUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ResourceNamespacePatch.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "sku", r.SKU)
	return json.Marshal(objectMap)
}

// Resource - The resource definition.
type Resource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

// ResourceNamespacePatch - Definition of resource.
type ResourceNamespacePatch struct {
	Resource
	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceNamespacePatch.
func (r ResourceNamespacePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r ResourceNamespacePatch) marshalInternal(objectMap map[string]interface{}) {
	r.Resource.marshalInternal(objectMap)
	populate(objectMap, "tags", r.Tags)
}

// SKU of the namespace.
type SKU struct {
	// REQUIRED; Name of this SKU.
	Name *string `json:"name,omitempty"`

	// The tier of this SKU.
	Tier *string `json:"tier,omitempty"`
}

// TrackedResource - Definition of resource.
type TrackedResource struct {
	Resource
	// REQUIRED; Resource location.
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

// WCFRelaysCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the WCFRelays.CreateOrUpdateAuthorizationRule method.
type WCFRelaysCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysCreateOrUpdateOptions contains the optional parameters for the WCFRelays.CreateOrUpdate method.
type WCFRelaysCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysDeleteAuthorizationRuleOptions contains the optional parameters for the WCFRelays.DeleteAuthorizationRule method.
type WCFRelaysDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysDeleteOptions contains the optional parameters for the WCFRelays.Delete method.
type WCFRelaysDeleteOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysGetAuthorizationRuleOptions contains the optional parameters for the WCFRelays.GetAuthorizationRule method.
type WCFRelaysGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysGetOptions contains the optional parameters for the WCFRelays.Get method.
type WCFRelaysGetOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysListAuthorizationRulesOptions contains the optional parameters for the WCFRelays.ListAuthorizationRules method.
type WCFRelaysListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysListByNamespaceOptions contains the optional parameters for the WCFRelays.ListByNamespace method.
type WCFRelaysListByNamespaceOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysListKeysOptions contains the optional parameters for the WCFRelays.ListKeys method.
type WCFRelaysListKeysOptions struct {
	// placeholder for future optional parameters
}

// WCFRelaysRegenerateKeysOptions contains the optional parameters for the WCFRelays.RegenerateKeys method.
type WCFRelaysRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// WcfRelay - Description of the WCF relay resource.
type WcfRelay struct {
	Resource
	// Properties of the WCF relay.
	Properties *WcfRelayProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WcfRelay.
func (w WcfRelay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// WcfRelayProperties - Properties of the WCF relay.
type WcfRelayProperties struct {
	// WCF relay type.
	RelayType *Relaytype `json:"relayType,omitempty"`

	// Returns true if client authorization is needed for this relay; otherwise, false.
	RequiresClientAuthorization *bool `json:"requiresClientAuthorization,omitempty"`

	// Returns true if transport security is needed for this relay; otherwise, false.
	RequiresTransportSecurity *bool `json:"requiresTransportSecurity,omitempty"`

	// The usermetadata is a placeholder to store user-defined string data for the WCF Relay endpoint. For example, it can be used to store descriptive data,
	// such as list of teams and their contact
	// information. Also, user-defined configuration settings can be stored.
	UserMetadata *string `json:"userMetadata,omitempty"`

	// READ-ONLY; The time the WCF relay was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Returns true if the relay is dynamic; otherwise, false.
	IsDynamic *bool `json:"isDynamic,omitempty" azure:"ro"`

	// READ-ONLY; The number of listeners for this relay. Note that min :1 and max:25 are supported.
	ListenerCount *int32 `json:"listenerCount,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WcfRelayProperties.
func (w WcfRelayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", w.CreatedAt)
	populate(objectMap, "isDynamic", w.IsDynamic)
	populate(objectMap, "listenerCount", w.ListenerCount)
	populate(objectMap, "relayType", w.RelayType)
	populate(objectMap, "requiresClientAuthorization", w.RequiresClientAuthorization)
	populate(objectMap, "requiresTransportSecurity", w.RequiresTransportSecurity)
	populateTimeRFC3339(objectMap, "updatedAt", w.UpdatedAt)
	populate(objectMap, "userMetadata", w.UserMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WcfRelayProperties.
func (w *WcfRelayProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &w.CreatedAt)
			delete(rawMsg, key)
		case "isDynamic":
			err = unpopulate(val, &w.IsDynamic)
			delete(rawMsg, key)
		case "listenerCount":
			err = unpopulate(val, &w.ListenerCount)
			delete(rawMsg, key)
		case "relayType":
			err = unpopulate(val, &w.RelayType)
			delete(rawMsg, key)
		case "requiresClientAuthorization":
			err = unpopulate(val, &w.RequiresClientAuthorization)
			delete(rawMsg, key)
		case "requiresTransportSecurity":
			err = unpopulate(val, &w.RequiresTransportSecurity)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &w.UpdatedAt)
			delete(rawMsg, key)
		case "userMetadata":
			err = unpopulate(val, &w.UserMetadata)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WcfRelaysListResult - The response of the list WCF relay operation.
type WcfRelaysListResult struct {
	// Link to the next set of results. Not empty if value contains incomplete list of WCF relays.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the list WCF relay operation.
	Value []*WcfRelay `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WcfRelaysListResult.
func (w WcfRelaysListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
