// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdeployments

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client contains the methods for the Deployments group.
// Don't use this type directly, use NewClient() instead.
type Client struct {
	internal       *arm.Client
	subscriptionID string
}

// NewClient creates a new instance of Client with the specified values.
//   - subscriptionID - The Microsoft Azure subscription ID.
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - pass nil to accept the default values.
func NewClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*Client, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &Client{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// CalculateTemplateHash - Calculate the hash of the given template.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - templateParam - The template provided to calculate hash.
//   - options - ClientCalculateTemplateHashOptions contains the optional parameters for the Client.CalculateTemplateHash method.
func (client *Client) CalculateTemplateHash(ctx context.Context, templateParam any, options *ClientCalculateTemplateHashOptions) (ClientCalculateTemplateHashResponse, error) {
	var err error
	const operationName = "Client.CalculateTemplateHash"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.calculateTemplateHashCreateRequest(ctx, templateParam, options)
	if err != nil {
		return ClientCalculateTemplateHashResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCalculateTemplateHashResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientCalculateTemplateHashResponse{}, err
	}
	resp, err := client.calculateTemplateHashHandleResponse(httpResp)
	return resp, err
}

// calculateTemplateHashCreateRequest creates the CalculateTemplateHash request.
func (client *Client) calculateTemplateHashCreateRequest(ctx context.Context, templateParam any, _ *ClientCalculateTemplateHashOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/calculateTemplateHash"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, templateParam); err != nil {
		return nil, err
	}
	return req, nil
}

// calculateTemplateHashHandleResponse handles the CalculateTemplateHash response.
func (client *Client) calculateTemplateHashHandleResponse(resp *http.Response) (ClientCalculateTemplateHashResponse, error) {
	result := ClientCalculateTemplateHashResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TemplateHashResult); err != nil {
		return ClientCalculateTemplateHashResponse{}, err
	}
	return result, nil
}

// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled,
// the provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resource group partially deployed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - options - ClientCancelOptions contains the optional parameters for the Client.Cancel method.
func (client *Client) Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientCancelOptions) (ClientCancelResponse, error) {
	var err error
	const operationName = "Client.Cancel"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.cancelCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return ClientCancelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCancelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCancelResponse{}, err
	}
	return ClientCancelResponse{}, nil
}

// cancelCreateRequest creates the Cancel request.
func (client *Client) cancelCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, _ *ClientCancelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After
// the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - options - ClientCancelAtManagementGroupScopeOptions contains the optional parameters for the Client.CancelAtManagementGroupScope
//     method.
func (client *Client) CancelAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientCancelAtManagementGroupScopeOptions) (ClientCancelAtManagementGroupScopeResponse, error) {
	var err error
	const operationName = "Client.CancelAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.cancelAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return ClientCancelAtManagementGroupScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCancelAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCancelAtManagementGroupScopeResponse{}, err
	}
	return ClientCancelAtManagementGroupScopeResponse{}, nil
}

// cancelAtManagementGroupScopeCreateRequest creates the CancelAtManagementGroupScope request.
func (client *Client) cancelAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, _ *ClientCancelAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CancelAtScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment
// is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - options - ClientCancelAtScopeOptions contains the optional parameters for the Client.CancelAtScope method.
func (client *Client) CancelAtScope(ctx context.Context, scope string, deploymentName string, options *ClientCancelAtScopeOptions) (ClientCancelAtScopeResponse, error) {
	var err error
	const operationName = "Client.CancelAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.cancelAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return ClientCancelAtScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCancelAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCancelAtScopeResponse{}, err
	}
	return ClientCancelAtScopeResponse{}, nil
}

// cancelAtScopeCreateRequest creates the CancelAtScope request.
func (client *Client) cancelAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, _ *ClientCancelAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the
// deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientCancelAtSubscriptionScopeOptions contains the optional parameters for the Client.CancelAtSubscriptionScope
//     method.
func (client *Client) CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientCancelAtSubscriptionScopeOptions) (ClientCancelAtSubscriptionScopeResponse, error) {
	var err error
	const operationName = "Client.CancelAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.cancelAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientCancelAtSubscriptionScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCancelAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCancelAtSubscriptionScopeResponse{}, err
	}
	return ClientCancelAtSubscriptionScopeResponse{}, nil
}

// cancelAtSubscriptionScopeCreateRequest creates the CancelAtSubscriptionScope request.
func (client *Client) cancelAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientCancelAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CancelAtTenantScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment
// is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientCancelAtTenantScopeOptions contains the optional parameters for the Client.CancelAtTenantScope method.
func (client *Client) CancelAtTenantScope(ctx context.Context, deploymentName string, options *ClientCancelAtTenantScopeOptions) (ClientCancelAtTenantScopeResponse, error) {
	var err error
	const operationName = "Client.CancelAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.cancelAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientCancelAtTenantScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCancelAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ClientCancelAtTenantScopeResponse{}, err
	}
	return ClientCancelAtTenantScopeResponse{}, nil
}

// cancelAtTenantScopeCreateRequest creates the CancelAtTenantScope request.
func (client *Client) cancelAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientCancelAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CheckExistence - Checks whether the deployment exists.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group with the deployment to check. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - options - ClientCheckExistenceOptions contains the optional parameters for the Client.CheckExistence method.
func (client *Client) CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientCheckExistenceOptions) (ClientCheckExistenceResponse, error) {
	var err error
	const operationName = "Client.CheckExistence"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkExistenceCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return ClientCheckExistenceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckExistenceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckExistenceResponse{}, err
	}
	return ClientCheckExistenceResponse{Success: httpResp.StatusCode >= 200 && httpResp.StatusCode < 300}, nil
}

// checkExistenceCreateRequest creates the CheckExistence request.
func (client *Client) checkExistenceCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, _ *ClientCheckExistenceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - options - ClientCheckExistenceAtManagementGroupScopeOptions contains the optional parameters for the Client.CheckExistenceAtManagementGroupScope
//     method.
func (client *Client) CheckExistenceAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientCheckExistenceAtManagementGroupScopeOptions) (ClientCheckExistenceAtManagementGroupScopeResponse, error) {
	var err error
	const operationName = "Client.CheckExistenceAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkExistenceAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return ClientCheckExistenceAtManagementGroupScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckExistenceAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckExistenceAtManagementGroupScopeResponse{}, err
	}
	return ClientCheckExistenceAtManagementGroupScopeResponse{Success: httpResp.StatusCode >= 200 && httpResp.StatusCode < 300}, nil
}

// checkExistenceAtManagementGroupScopeCreateRequest creates the CheckExistenceAtManagementGroupScope request.
func (client *Client) checkExistenceAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, _ *ClientCheckExistenceAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CheckExistenceAtScope - Checks whether the deployment exists.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - options - ClientCheckExistenceAtScopeOptions contains the optional parameters for the Client.CheckExistenceAtScope method.
func (client *Client) CheckExistenceAtScope(ctx context.Context, scope string, deploymentName string, options *ClientCheckExistenceAtScopeOptions) (ClientCheckExistenceAtScopeResponse, error) {
	var err error
	const operationName = "Client.CheckExistenceAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkExistenceAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return ClientCheckExistenceAtScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckExistenceAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckExistenceAtScopeResponse{}, err
	}
	return ClientCheckExistenceAtScopeResponse{Success: httpResp.StatusCode >= 200 && httpResp.StatusCode < 300}, nil
}

// checkExistenceAtScopeCreateRequest creates the CheckExistenceAtScope request.
func (client *Client) checkExistenceAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, _ *ClientCheckExistenceAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientCheckExistenceAtSubscriptionScopeOptions contains the optional parameters for the Client.CheckExistenceAtSubscriptionScope
//     method.
func (client *Client) CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientCheckExistenceAtSubscriptionScopeOptions) (ClientCheckExistenceAtSubscriptionScopeResponse, error) {
	var err error
	const operationName = "Client.CheckExistenceAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkExistenceAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientCheckExistenceAtSubscriptionScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckExistenceAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckExistenceAtSubscriptionScopeResponse{}, err
	}
	return ClientCheckExistenceAtSubscriptionScopeResponse{Success: httpResp.StatusCode >= 200 && httpResp.StatusCode < 300}, nil
}

// checkExistenceAtSubscriptionScopeCreateRequest creates the CheckExistenceAtSubscriptionScope request.
func (client *Client) checkExistenceAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientCheckExistenceAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CheckExistenceAtTenantScope - Checks whether the deployment exists.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientCheckExistenceAtTenantScopeOptions contains the optional parameters for the Client.CheckExistenceAtTenantScope
//     method.
func (client *Client) CheckExistenceAtTenantScope(ctx context.Context, deploymentName string, options *ClientCheckExistenceAtTenantScopeOptions) (ClientCheckExistenceAtTenantScopeResponse, error) {
	var err error
	const operationName = "Client.CheckExistenceAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkExistenceAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientCheckExistenceAtTenantScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientCheckExistenceAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return ClientCheckExistenceAtTenantScopeResponse{}, err
	}
	return ClientCheckExistenceAtTenantScopeResponse{Success: httpResp.StatusCode >= 200 && httpResp.StatusCode < 300}, nil
}

// checkExistenceAtTenantScopeCreateRequest creates the CheckExistenceAtTenantScope request.
func (client *Client) checkExistenceAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientCheckExistenceAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginCreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group to deploy the resources to. The name is case insensitive. The resource
//     group must already exist.
//   - deploymentName - The name of the deployment.
//   - parameters - Additional parameters supplied to the operation.
//   - options - ClientBeginCreateOrUpdateOptions contains the optional parameters for the Client.BeginCreateOrUpdate method.
func (client *Client) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateOptions) (*runtime.Poller[ClientCreateOrUpdateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdate(ctx, resourceGroupName, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientCreateOrUpdateResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientCreateOrUpdateResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) createOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginCreateOrUpdate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *Client) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, _ *ClientBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link
// to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - parameters - Additional parameters supplied to the operation.
//   - options - ClientBeginCreateOrUpdateAtManagementGroupScopeOptions contains the optional parameters for the Client.BeginCreateOrUpdateAtManagementGroupScope
//     method.
func (client *Client) BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *ClientBeginCreateOrUpdateAtManagementGroupScopeOptions) (*runtime.Poller[ClientCreateOrUpdateAtManagementGroupScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientCreateOrUpdateAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientCreateOrUpdateAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON
// files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) createOrUpdateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *ClientBeginCreateOrUpdateAtManagementGroupScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginCreateOrUpdateAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtManagementGroupScopeCreateRequest creates the CreateOrUpdateAtManagementGroupScope request.
func (client *Client) createOrUpdateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, _ *ClientBeginCreateOrUpdateAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - parameters - Additional parameters supplied to the operation.
//   - options - ClientBeginCreateOrUpdateAtScopeOptions contains the optional parameters for the Client.BeginCreateOrUpdateAtScope
//     method.
func (client *Client) BeginCreateOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateAtScopeOptions) (*runtime.Poller[ClientCreateOrUpdateAtScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtScope(ctx, scope, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientCreateOrUpdateAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientCreateOrUpdateAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) createOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateAtScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginCreateOrUpdateAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtScopeCreateRequest creates the CreateOrUpdateAtScope request.
func (client *Client) createOrUpdateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, _ *ClientBeginCreateOrUpdateAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to
// JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Additional parameters supplied to the operation.
//   - options - ClientBeginCreateOrUpdateAtSubscriptionScopeOptions contains the optional parameters for the Client.BeginCreateOrUpdateAtSubscriptionScope
//     method.
func (client *Client) BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateAtSubscriptionScopeOptions) (*runtime.Poller[ClientCreateOrUpdateAtSubscriptionScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtSubscriptionScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientCreateOrUpdateAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientCreateOrUpdateAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON
// files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) createOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *ClientBeginCreateOrUpdateAtSubscriptionScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginCreateOrUpdateAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtSubscriptionScopeCreateRequest creates the CreateOrUpdateAtSubscriptionScope request.
func (client *Client) createOrUpdateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, _ *ClientBeginCreateOrUpdateAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON
// files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Additional parameters supplied to the operation.
//   - options - ClientBeginCreateOrUpdateAtTenantScopeOptions contains the optional parameters for the Client.BeginCreateOrUpdateAtTenantScope
//     method.
func (client *Client) BeginCreateOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *ClientBeginCreateOrUpdateAtTenantScopeOptions) (*runtime.Poller[ClientCreateOrUpdateAtTenantScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtTenantScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientCreateOrUpdateAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientCreateOrUpdateAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) createOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *ClientBeginCreateOrUpdateAtTenantScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginCreateOrUpdateAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtTenantScopeCreateRequest creates the CreateOrUpdateAtTenantScope request.
func (client *Client) createOrUpdateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, _ *ClientBeginCreateOrUpdateAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginDelete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes
// the associated deployment operations. Deleting a template deployment does not affect the state
// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is
// successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status
// of 202. When the process finishes, the URI in the Location header returns a
// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status
// code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group with the deployment to delete. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - options - ClientBeginDeleteOptions contains the optional parameters for the Client.BeginDelete method.
func (client *Client) BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientBeginDeleteOptions) (*runtime.Poller[ClientDeleteResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteOperation(ctx, resourceGroupName, deploymentName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientDeleteResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientDeleteResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Delete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the
// associated deployment operations. Deleting a template deployment does not affect the state
// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is
// successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status
// of 202. When the process finishes, the URI in the Location header returns a
// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status
// code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) deleteOperation(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientBeginDeleteOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginDelete"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *Client) deleteCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, _ *ClientBeginDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template
// deployment removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - options - ClientBeginDeleteAtManagementGroupScopeOptions contains the optional parameters for the Client.BeginDeleteAtManagementGroupScope
//     method.
func (client *Client) BeginDeleteAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientBeginDeleteAtManagementGroupScopeOptions) (*runtime.Poller[ClientDeleteAtManagementGroupScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtManagementGroupScope(ctx, groupID, deploymentName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientDeleteAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientDeleteAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment
// removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) deleteAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientBeginDeleteAtManagementGroupScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginDeleteAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtManagementGroupScopeCreateRequest creates the DeleteAtManagementGroupScope request.
func (client *Client) deleteAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, _ *ClientBeginDeleteAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment
// removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - options - ClientBeginDeleteAtScopeOptions contains the optional parameters for the Client.BeginDeleteAtScope method.
func (client *Client) BeginDeleteAtScope(ctx context.Context, scope string, deploymentName string, options *ClientBeginDeleteAtScopeOptions) (*runtime.Poller[ClientDeleteAtScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtScope(ctx, scope, deploymentName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientDeleteAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientDeleteAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes
// the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) deleteAtScope(ctx context.Context, scope string, deploymentName string, options *ClientBeginDeleteAtScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginDeleteAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtScopeCreateRequest creates the DeleteAtScope request.
func (client *Client) deleteAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, _ *ClientBeginDeleteAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template
// deployment removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientBeginDeleteAtSubscriptionScopeOptions contains the optional parameters for the Client.BeginDeleteAtSubscriptionScope
//     method.
func (client *Client) BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientBeginDeleteAtSubscriptionScopeOptions) (*runtime.Poller[ClientDeleteAtSubscriptionScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtSubscriptionScope(ctx, deploymentName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientDeleteAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientDeleteAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment
// removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) deleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientBeginDeleteAtSubscriptionScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginDeleteAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtSubscriptionScopeCreateRequest creates the DeleteAtSubscriptionScope request.
func (client *Client) deleteAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientBeginDeleteAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment
// removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientBeginDeleteAtTenantScopeOptions contains the optional parameters for the Client.BeginDeleteAtTenantScope
//     method.
func (client *Client) BeginDeleteAtTenantScope(ctx context.Context, deploymentName string, options *ClientBeginDeleteAtTenantScopeOptions) (*runtime.Poller[ClientDeleteAtTenantScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtTenantScope(ctx, deploymentName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientDeleteAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientDeleteAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment
// removes the associated deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns
// a status of 204 on success. If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) deleteAtTenantScope(ctx context.Context, deploymentName string, options *ClientBeginDeleteAtTenantScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginDeleteAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtTenantScopeCreateRequest creates the DeleteAtTenantScope request.
func (client *Client) deleteAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientBeginDeleteAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ExportTemplate - Exports the template used for specified deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - options - ClientExportTemplateOptions contains the optional parameters for the Client.ExportTemplate method.
func (client *Client) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientExportTemplateOptions) (ClientExportTemplateResponse, error) {
	var err error
	const operationName = "Client.ExportTemplate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return ClientExportTemplateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientExportTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientExportTemplateResponse{}, err
	}
	resp, err := client.exportTemplateHandleResponse(httpResp)
	return resp, err
}

// exportTemplateCreateRequest creates the ExportTemplate request.
func (client *Client) exportTemplateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, _ *ClientExportTemplateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateHandleResponse handles the ExportTemplate response.
func (client *Client) exportTemplateHandleResponse(resp *http.Response) (ClientExportTemplateResponse, error) {
	result := ClientExportTemplateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExportResult); err != nil {
		return ClientExportTemplateResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - options - ClientExportTemplateAtManagementGroupScopeOptions contains the optional parameters for the Client.ExportTemplateAtManagementGroupScope
//     method.
func (client *Client) ExportTemplateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientExportTemplateAtManagementGroupScopeOptions) (ClientExportTemplateAtManagementGroupScopeResponse, error) {
	var err error
	const operationName = "Client.ExportTemplateAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return ClientExportTemplateAtManagementGroupScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientExportTemplateAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientExportTemplateAtManagementGroupScopeResponse{}, err
	}
	resp, err := client.exportTemplateAtManagementGroupScopeHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtManagementGroupScopeCreateRequest creates the ExportTemplateAtManagementGroupScope request.
func (client *Client) exportTemplateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, _ *ClientExportTemplateAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtManagementGroupScopeHandleResponse handles the ExportTemplateAtManagementGroupScope response.
func (client *Client) exportTemplateAtManagementGroupScopeHandleResponse(resp *http.Response) (ClientExportTemplateAtManagementGroupScopeResponse, error) {
	result := ClientExportTemplateAtManagementGroupScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExportResult); err != nil {
		return ClientExportTemplateAtManagementGroupScopeResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtScope - Exports the template used for specified deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - options - ClientExportTemplateAtScopeOptions contains the optional parameters for the Client.ExportTemplateAtScope method.
func (client *Client) ExportTemplateAtScope(ctx context.Context, scope string, deploymentName string, options *ClientExportTemplateAtScopeOptions) (ClientExportTemplateAtScopeResponse, error) {
	var err error
	const operationName = "Client.ExportTemplateAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return ClientExportTemplateAtScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientExportTemplateAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientExportTemplateAtScopeResponse{}, err
	}
	resp, err := client.exportTemplateAtScopeHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtScopeCreateRequest creates the ExportTemplateAtScope request.
func (client *Client) exportTemplateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, _ *ClientExportTemplateAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtScopeHandleResponse handles the ExportTemplateAtScope response.
func (client *Client) exportTemplateAtScopeHandleResponse(resp *http.Response) (ClientExportTemplateAtScopeResponse, error) {
	result := ClientExportTemplateAtScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExportResult); err != nil {
		return ClientExportTemplateAtScopeResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientExportTemplateAtSubscriptionScopeOptions contains the optional parameters for the Client.ExportTemplateAtSubscriptionScope
//     method.
func (client *Client) ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientExportTemplateAtSubscriptionScopeOptions) (ClientExportTemplateAtSubscriptionScopeResponse, error) {
	var err error
	const operationName = "Client.ExportTemplateAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientExportTemplateAtSubscriptionScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientExportTemplateAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientExportTemplateAtSubscriptionScopeResponse{}, err
	}
	resp, err := client.exportTemplateAtSubscriptionScopeHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtSubscriptionScopeCreateRequest creates the ExportTemplateAtSubscriptionScope request.
func (client *Client) exportTemplateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientExportTemplateAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtSubscriptionScopeHandleResponse handles the ExportTemplateAtSubscriptionScope response.
func (client *Client) exportTemplateAtSubscriptionScopeHandleResponse(resp *http.Response) (ClientExportTemplateAtSubscriptionScopeResponse, error) {
	result := ClientExportTemplateAtSubscriptionScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExportResult); err != nil {
		return ClientExportTemplateAtSubscriptionScopeResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtTenantScope - Exports the template used for specified deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientExportTemplateAtTenantScopeOptions contains the optional parameters for the Client.ExportTemplateAtTenantScope
//     method.
func (client *Client) ExportTemplateAtTenantScope(ctx context.Context, deploymentName string, options *ClientExportTemplateAtTenantScopeOptions) (ClientExportTemplateAtTenantScopeResponse, error) {
	var err error
	const operationName = "Client.ExportTemplateAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientExportTemplateAtTenantScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientExportTemplateAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientExportTemplateAtTenantScopeResponse{}, err
	}
	resp, err := client.exportTemplateAtTenantScopeHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtTenantScopeCreateRequest creates the ExportTemplateAtTenantScope request.
func (client *Client) exportTemplateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientExportTemplateAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtTenantScopeHandleResponse handles the ExportTemplateAtTenantScope response.
func (client *Client) exportTemplateAtTenantScopeHandleResponse(resp *http.Response) (ClientExportTemplateAtTenantScopeResponse, error) {
	result := ClientExportTemplateAtTenantScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExportResult); err != nil {
		return ClientExportTemplateAtTenantScopeResponse{}, err
	}
	return result, nil
}

// Get - Gets a deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - options - ClientGetOptions contains the optional parameters for the Client.Get method.
func (client *Client) Get(ctx context.Context, resourceGroupName string, deploymentName string, options *ClientGetOptions) (ClientGetResponse, error) {
	var err error
	const operationName = "Client.Get"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return ClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *Client) getCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, _ *ClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *Client) getHandleResponse(resp *http.Response) (ClientGetResponse, error) {
	result := ClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExtended); err != nil {
		return ClientGetResponse{}, err
	}
	return result, nil
}

// GetAtManagementGroupScope - Gets a deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - options - ClientGetAtManagementGroupScopeOptions contains the optional parameters for the Client.GetAtManagementGroupScope
//     method.
func (client *Client) GetAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *ClientGetAtManagementGroupScopeOptions) (ClientGetAtManagementGroupScopeResponse, error) {
	var err error
	const operationName = "Client.GetAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return ClientGetAtManagementGroupScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGetAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGetAtManagementGroupScopeResponse{}, err
	}
	resp, err := client.getAtManagementGroupScopeHandleResponse(httpResp)
	return resp, err
}

// getAtManagementGroupScopeCreateRequest creates the GetAtManagementGroupScope request.
func (client *Client) getAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, _ *ClientGetAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtManagementGroupScopeHandleResponse handles the GetAtManagementGroupScope response.
func (client *Client) getAtManagementGroupScopeHandleResponse(resp *http.Response) (ClientGetAtManagementGroupScopeResponse, error) {
	result := ClientGetAtManagementGroupScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExtended); err != nil {
		return ClientGetAtManagementGroupScopeResponse{}, err
	}
	return result, nil
}

// GetAtScope - Gets a deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - options - ClientGetAtScopeOptions contains the optional parameters for the Client.GetAtScope method.
func (client *Client) GetAtScope(ctx context.Context, scope string, deploymentName string, options *ClientGetAtScopeOptions) (ClientGetAtScopeResponse, error) {
	var err error
	const operationName = "Client.GetAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return ClientGetAtScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGetAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGetAtScopeResponse{}, err
	}
	resp, err := client.getAtScopeHandleResponse(httpResp)
	return resp, err
}

// getAtScopeCreateRequest creates the GetAtScope request.
func (client *Client) getAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, _ *ClientGetAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtScopeHandleResponse handles the GetAtScope response.
func (client *Client) getAtScopeHandleResponse(resp *http.Response) (ClientGetAtScopeResponse, error) {
	result := ClientGetAtScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExtended); err != nil {
		return ClientGetAtScopeResponse{}, err
	}
	return result, nil
}

// GetAtSubscriptionScope - Gets a deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientGetAtSubscriptionScopeOptions contains the optional parameters for the Client.GetAtSubscriptionScope method.
func (client *Client) GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *ClientGetAtSubscriptionScopeOptions) (ClientGetAtSubscriptionScopeResponse, error) {
	var err error
	const operationName = "Client.GetAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientGetAtSubscriptionScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGetAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGetAtSubscriptionScopeResponse{}, err
	}
	resp, err := client.getAtSubscriptionScopeHandleResponse(httpResp)
	return resp, err
}

// getAtSubscriptionScopeCreateRequest creates the GetAtSubscriptionScope request.
func (client *Client) getAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientGetAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtSubscriptionScopeHandleResponse handles the GetAtSubscriptionScope response.
func (client *Client) getAtSubscriptionScopeHandleResponse(resp *http.Response) (ClientGetAtSubscriptionScopeResponse, error) {
	result := ClientGetAtSubscriptionScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExtended); err != nil {
		return ClientGetAtSubscriptionScopeResponse{}, err
	}
	return result, nil
}

// GetAtTenantScope - Gets a deployment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - options - ClientGetAtTenantScopeOptions contains the optional parameters for the Client.GetAtTenantScope method.
func (client *Client) GetAtTenantScope(ctx context.Context, deploymentName string, options *ClientGetAtTenantScopeOptions) (ClientGetAtTenantScopeResponse, error) {
	var err error
	const operationName = "Client.GetAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return ClientGetAtTenantScopeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ClientGetAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ClientGetAtTenantScopeResponse{}, err
	}
	resp, err := client.getAtTenantScopeHandleResponse(httpResp)
	return resp, err
}

// getAtTenantScopeCreateRequest creates the GetAtTenantScope request.
func (client *Client) getAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, _ *ClientGetAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtTenantScopeHandleResponse handles the GetAtTenantScope response.
func (client *Client) getAtTenantScopeHandleResponse(resp *http.Response) (ClientGetAtTenantScopeResponse, error) {
	result := ClientGetAtTenantScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentExtended); err != nil {
		return ClientGetAtTenantScopeResponse{}, err
	}
	return result, nil
}

// NewListAtManagementGroupScopePager - Get all the deployments for a management group.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - options - ClientListAtManagementGroupScopeOptions contains the optional parameters for the Client.NewListAtManagementGroupScopePager
//     method.
func (client *Client) NewListAtManagementGroupScopePager(groupID string, options *ClientListAtManagementGroupScopeOptions) *runtime.Pager[ClientListAtManagementGroupScopeResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListAtManagementGroupScopeResponse]{
		More: func(page ClientListAtManagementGroupScopeResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListAtManagementGroupScopeResponse) (ClientListAtManagementGroupScopeResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListAtManagementGroupScopePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtManagementGroupScopeCreateRequest(ctx, groupID, options)
			}, nil)
			if err != nil {
				return ClientListAtManagementGroupScopeResponse{}, err
			}
			return client.listAtManagementGroupScopeHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtManagementGroupScopeCreateRequest creates the ListAtManagementGroupScope request.
func (client *Client) listAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, options *ClientListAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtManagementGroupScopeHandleResponse handles the ListAtManagementGroupScope response.
func (client *Client) listAtManagementGroupScopeHandleResponse(resp *http.Response) (ClientListAtManagementGroupScopeResponse, error) {
	result := ClientListAtManagementGroupScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentListResult); err != nil {
		return ClientListAtManagementGroupScopeResponse{}, err
	}
	return result, nil
}

// NewListAtScopePager - Get all the deployments at the given scope.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - options - ClientListAtScopeOptions contains the optional parameters for the Client.NewListAtScopePager method.
func (client *Client) NewListAtScopePager(scope string, options *ClientListAtScopeOptions) *runtime.Pager[ClientListAtScopeResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListAtScopeResponse]{
		More: func(page ClientListAtScopeResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListAtScopeResponse) (ClientListAtScopeResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListAtScopePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtScopeCreateRequest(ctx, scope, options)
			}, nil)
			if err != nil {
				return ClientListAtScopeResponse{}, err
			}
			return client.listAtScopeHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtScopeCreateRequest creates the ListAtScope request.
func (client *Client) listAtScopeCreateRequest(ctx context.Context, scope string, options *ClientListAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtScopeHandleResponse handles the ListAtScope response.
func (client *Client) listAtScopeHandleResponse(resp *http.Response) (ClientListAtScopeResponse, error) {
	result := ClientListAtScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentListResult); err != nil {
		return ClientListAtScopeResponse{}, err
	}
	return result, nil
}

// NewListAtSubscriptionScopePager - Get all the deployments for a subscription.
//
// Generated from API version 2025-04-01
//   - options - ClientListAtSubscriptionScopeOptions contains the optional parameters for the Client.NewListAtSubscriptionScopePager
//     method.
func (client *Client) NewListAtSubscriptionScopePager(options *ClientListAtSubscriptionScopeOptions) *runtime.Pager[ClientListAtSubscriptionScopeResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListAtSubscriptionScopeResponse]{
		More: func(page ClientListAtSubscriptionScopeResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListAtSubscriptionScopeResponse) (ClientListAtSubscriptionScopeResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListAtSubscriptionScopePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtSubscriptionScopeCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ClientListAtSubscriptionScopeResponse{}, err
			}
			return client.listAtSubscriptionScopeHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtSubscriptionScopeCreateRequest creates the ListAtSubscriptionScope request.
func (client *Client) listAtSubscriptionScopeCreateRequest(ctx context.Context, options *ClientListAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtSubscriptionScopeHandleResponse handles the ListAtSubscriptionScope response.
func (client *Client) listAtSubscriptionScopeHandleResponse(resp *http.Response) (ClientListAtSubscriptionScopeResponse, error) {
	result := ClientListAtSubscriptionScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentListResult); err != nil {
		return ClientListAtSubscriptionScopeResponse{}, err
	}
	return result, nil
}

// NewListAtTenantScopePager - Get all the deployments at the tenant scope.
//
// Generated from API version 2025-04-01
//   - options - ClientListAtTenantScopeOptions contains the optional parameters for the Client.NewListAtTenantScopePager method.
func (client *Client) NewListAtTenantScopePager(options *ClientListAtTenantScopeOptions) *runtime.Pager[ClientListAtTenantScopeResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListAtTenantScopeResponse]{
		More: func(page ClientListAtTenantScopeResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListAtTenantScopeResponse) (ClientListAtTenantScopeResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListAtTenantScopePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtTenantScopeCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ClientListAtTenantScopeResponse{}, err
			}
			return client.listAtTenantScopeHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtTenantScopeCreateRequest creates the ListAtTenantScope request.
func (client *Client) listAtTenantScopeCreateRequest(ctx context.Context, options *ClientListAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtTenantScopeHandleResponse handles the ListAtTenantScope response.
func (client *Client) listAtTenantScopeHandleResponse(resp *http.Response) (ClientListAtTenantScopeResponse, error) {
	result := ClientListAtTenantScopeResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentListResult); err != nil {
		return ClientListAtTenantScopeResponse{}, err
	}
	return result, nil
}

// NewListByResourceGroupPager - Get all the deployments for a resource group.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group with the deployments to get. The name is case insensitive.
//   - options - ClientListByResourceGroupOptions contains the optional parameters for the Client.NewListByResourceGroupPager
//     method.
func (client *Client) NewListByResourceGroupPager(resourceGroupName string, options *ClientListByResourceGroupOptions) *runtime.Pager[ClientListByResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListByResourceGroupResponse]{
		More: func(page ClientListByResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListByResourceGroupResponse) (ClientListByResourceGroupResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "Client.NewListByResourceGroupPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
			}, nil)
			if err != nil {
				return ClientListByResourceGroupResponse{}, err
			}
			return client.listByResourceGroupHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *Client) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *ClientListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *Client) listByResourceGroupHandleResponse(resp *http.Response) (ClientListByResourceGroupResponse, error) {
	result := ClientListByResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentListResult); err != nil {
		return ClientListByResourceGroupResponse{}, err
	}
	return result, nil
}

// BeginValidate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource
// Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group the template will be deployed to. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginValidateOptions contains the optional parameters for the Client.BeginValidate method.
func (client *Client) BeginValidate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *ClientBeginValidateOptions) (*runtime.Poller[ClientValidateResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validate(ctx, resourceGroupName, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientValidateResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientValidateResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *ClientBeginValidateOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginValidate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateCreateRequest creates the Validate request.
func (client *Client) validateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, _ *ClientBeginValidateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted
// by Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginValidateAtManagementGroupScopeOptions contains the optional parameters for the Client.BeginValidateAtManagementGroupScope
//     method.
func (client *Client) BeginValidateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *ClientBeginValidateAtManagementGroupScopeOptions) (*runtime.Poller[ClientValidateAtManagementGroupScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientValidateAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientValidateAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted
// by Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) validateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *ClientBeginValidateAtManagementGroupScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginValidateAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateAtManagementGroupScopeCreateRequest creates the ValidateAtManagementGroupScope request.
func (client *Client) validateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, _ *ClientBeginValidateAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure
// Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - scope - The resource scope.
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginValidateAtScopeOptions contains the optional parameters for the Client.BeginValidateAtScope method.
func (client *Client) BeginValidateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *ClientBeginValidateAtScopeOptions) (*runtime.Poller[ClientValidateAtScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateAtScope(ctx, scope, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientValidateAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientValidateAtScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource
// Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) validateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *ClientBeginValidateAtScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginValidateAtScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateAtScopeCreateRequest creates the ValidateAtScope request.
func (client *Client) validateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, _ *ClientBeginValidateAtScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted
// by Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginValidateAtSubscriptionScopeOptions contains the optional parameters for the Client.BeginValidateAtSubscriptionScope
//     method.
func (client *Client) BeginValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *ClientBeginValidateAtSubscriptionScopeOptions) (*runtime.Poller[ClientValidateAtSubscriptionScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateAtSubscriptionScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientValidateAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientValidateAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by
// Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) validateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *ClientBeginValidateAtSubscriptionScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginValidateAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateAtSubscriptionScopeCreateRequest creates the ValidateAtSubscriptionScope request.
func (client *Client) validateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, _ *ClientBeginValidateAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by
// Azure Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginValidateAtTenantScopeOptions contains the optional parameters for the Client.BeginValidateAtTenantScope
//     method.
func (client *Client) BeginValidateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *ClientBeginValidateAtTenantScopeOptions) (*runtime.Poller[ClientValidateAtTenantScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateAtTenantScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientValidateAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientValidateAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by Azure
// Resource Manager..
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) validateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *ClientBeginValidateAtTenantScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginValidateAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateAtTenantScopeCreateRequest creates the ValidateAtTenantScope request.
func (client *Client) validateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, _ *ClientBeginValidateAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginWhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - resourceGroupName - The name of the resource group the template will be deployed to. The name is case insensitive.
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginWhatIfOptions contains the optional parameters for the Client.BeginWhatIf method.
func (client *Client) BeginWhatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *ClientBeginWhatIfOptions) (*runtime.Poller[ClientWhatIfResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.whatIf(ctx, resourceGroupName, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientWhatIfResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientWhatIfResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// WhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) whatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *ClientBeginWhatIfOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginWhatIf"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.whatIfCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// whatIfCreateRequest creates the WhatIf request.
func (client *Client) whatIfCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, _ *ClientBeginWhatIfOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginWhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the
// management group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - groupID - The management group ID.
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginWhatIfAtManagementGroupScopeOptions contains the optional parameters for the Client.BeginWhatIfAtManagementGroupScope
//     method.
func (client *Client) BeginWhatIfAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, options *ClientBeginWhatIfAtManagementGroupScopeOptions) (*runtime.Poller[ClientWhatIfAtManagementGroupScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.whatIfAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientWhatIfAtManagementGroupScopeResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientWhatIfAtManagementGroupScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// WhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the management
// group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) whatIfAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, options *ClientBeginWhatIfAtManagementGroupScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginWhatIfAtManagementGroupScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.whatIfAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// whatIfAtManagementGroupScopeCreateRequest creates the WhatIfAtManagementGroupScope request.
func (client *Client) whatIfAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, _ *ClientBeginWhatIfAtManagementGroupScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginWhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to What If.
//   - options - ClientBeginWhatIfAtSubscriptionScopeOptions contains the optional parameters for the Client.BeginWhatIfAtSubscriptionScope
//     method.
func (client *Client) BeginWhatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *ClientBeginWhatIfAtSubscriptionScopeOptions) (*runtime.Poller[ClientWhatIfAtSubscriptionScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.whatIfAtSubscriptionScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientWhatIfAtSubscriptionScopeResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientWhatIfAtSubscriptionScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// WhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) whatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *ClientBeginWhatIfAtSubscriptionScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginWhatIfAtSubscriptionScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.whatIfAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// whatIfAtSubscriptionScopeCreateRequest creates the WhatIfAtSubscriptionScope request.
func (client *Client) whatIfAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, _ *ClientBeginWhatIfAtSubscriptionScopeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginWhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
//   - deploymentName - The name of the deployment.
//   - parameters - Parameters to validate.
//   - options - ClientBeginWhatIfAtTenantScopeOptions contains the optional parameters for the Client.BeginWhatIfAtTenantScope
//     method.
func (client *Client) BeginWhatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *ClientBeginWhatIfAtTenantScopeOptions) (*runtime.Poller[ClientWhatIfAtTenantScopeResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.whatIfAtTenantScope(ctx, deploymentName, parameters, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientWhatIfAtTenantScopeResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[ClientWhatIfAtTenantScopeResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// WhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-04-01
func (client *Client) whatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *ClientBeginWhatIfAtTenantScopeOptions) (*http.Response, error) {
	var err error
	const operationName = "Client.BeginWhatIfAtTenantScope"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.whatIfAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// whatIfAtTenantScopeCreateRequest creates the WhatIfAtTenantScope request.
func (client *Client) whatIfAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, _ *ClientBeginWhatIfAtTenantScopeOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-04-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}
