// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdeployments

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// DeploymentStacksClient contains the methods for the DeploymentStacks group.
// Don't use this type directly, use NewDeploymentStacksClient() instead.
type DeploymentStacksClient struct {
	internal       *arm.Client
	subscriptionID string
}

// NewDeploymentStacksClient creates a new instance of DeploymentStacksClient with the specified values.
//   - subscriptionID - The ID of the target subscription. The value must be an UUID.
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - pass nil to accept the default values.
func NewDeploymentStacksClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*DeploymentStacksClient, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &DeploymentStacksClient{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// BeginCreateOrUpdateAtManagementGroup - Creates or updates a Deployment stack at Management Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack supplied to the operation.
//   - options - DeploymentStacksClientBeginCreateOrUpdateAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginCreateOrUpdateAtManagementGroup
//     method.
func (client *DeploymentStacksClient) BeginCreateOrUpdateAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtManagementGroupOptions) (*runtime.Poller[DeploymentStacksClientCreateOrUpdateAtManagementGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtManagementGroup(ctx, managementGroupID, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientCreateOrUpdateAtManagementGroupResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientCreateOrUpdateAtManagementGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtManagementGroup - Creates or updates a Deployment stack at Management Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) createOrUpdateAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtManagementGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginCreateOrUpdateAtManagementGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtManagementGroupCreateRequest(ctx, managementGroupID, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtManagementGroupCreateRequest creates the CreateOrUpdateAtManagementGroup request.
func (client *DeploymentStacksClient) createOrUpdateAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginCreateOrUpdateAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtResourceGroup - Creates or updates a Deployment stack at Resource Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack supplied to the operation.
//   - options - DeploymentStacksClientBeginCreateOrUpdateAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginCreateOrUpdateAtResourceGroup
//     method.
func (client *DeploymentStacksClient) BeginCreateOrUpdateAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtResourceGroupOptions) (*runtime.Poller[DeploymentStacksClientCreateOrUpdateAtResourceGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtResourceGroup(ctx, resourceGroupName, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientCreateOrUpdateAtResourceGroupResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientCreateOrUpdateAtResourceGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtResourceGroup - Creates or updates a Deployment stack at Resource Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) createOrUpdateAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtResourceGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginCreateOrUpdateAtResourceGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtResourceGroupCreateRequest(ctx, resourceGroupName, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtResourceGroupCreateRequest creates the CreateOrUpdateAtResourceGroup request.
func (client *DeploymentStacksClient) createOrUpdateAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginCreateOrUpdateAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginCreateOrUpdateAtSubscription - Creates or updates a Deployment stack at Subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack supplied to the operation.
//   - options - DeploymentStacksClientBeginCreateOrUpdateAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.BeginCreateOrUpdateAtSubscription
//     method.
func (client *DeploymentStacksClient) BeginCreateOrUpdateAtSubscription(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtSubscriptionOptions) (*runtime.Poller[DeploymentStacksClientCreateOrUpdateAtSubscriptionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.createOrUpdateAtSubscription(ctx, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientCreateOrUpdateAtSubscriptionResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientCreateOrUpdateAtSubscriptionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// CreateOrUpdateAtSubscription - Creates or updates a Deployment stack at Subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) createOrUpdateAtSubscription(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginCreateOrUpdateAtSubscriptionOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginCreateOrUpdateAtSubscription"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createOrUpdateAtSubscriptionCreateRequest(ctx, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// createOrUpdateAtSubscriptionCreateRequest creates the CreateOrUpdateAtSubscription request.
func (client *DeploymentStacksClient) createOrUpdateAtSubscriptionCreateRequest(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginCreateOrUpdateAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginDeleteAtManagementGroup - Deletes a Deployment stack by name at Management Group scope. When operation completes,
// status code 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientBeginDeleteAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginDeleteAtManagementGroup
//     method.
func (client *DeploymentStacksClient) BeginDeleteAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtManagementGroupOptions) (*runtime.Poller[DeploymentStacksClientDeleteAtManagementGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtManagementGroup(ctx, managementGroupID, deploymentStackName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientDeleteAtManagementGroupResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientDeleteAtManagementGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtManagementGroup - Deletes a Deployment stack by name at Management Group scope. When operation completes, status
// code 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) deleteAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtManagementGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginDeleteAtManagementGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtManagementGroupCreateRequest(ctx, managementGroupID, deploymentStackName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtManagementGroupCreateRequest creates the DeleteAtManagementGroup request.
func (client *DeploymentStacksClient) deleteAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	if options != nil && options.BypassStackOutOfSyncError != nil {
		reqQP.Set("bypassStackOutOfSyncError", strconv.FormatBool(*options.BypassStackOutOfSyncError))
	}
	if options != nil && options.UnmanageActionManagementGroups != nil {
		reqQP.Set("unmanageAction.ManagementGroups", string(*options.UnmanageActionManagementGroups))
	}
	if options != nil && options.UnmanageActionResourceGroups != nil {
		reqQP.Set("unmanageAction.ResourceGroups", string(*options.UnmanageActionResourceGroups))
	}
	if options != nil && options.UnmanageActionResources != nil {
		reqQP.Set("unmanageAction.Resources", string(*options.UnmanageActionResources))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtResourceGroup - Deletes a Deployment stack by name at Resource Group scope. When operation completes, status
// code 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientBeginDeleteAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginDeleteAtResourceGroup
//     method.
func (client *DeploymentStacksClient) BeginDeleteAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtResourceGroupOptions) (*runtime.Poller[DeploymentStacksClientDeleteAtResourceGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtResourceGroup(ctx, resourceGroupName, deploymentStackName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientDeleteAtResourceGroupResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientDeleteAtResourceGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtResourceGroup - Deletes a Deployment stack by name at Resource Group scope. When operation completes, status code
// 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) deleteAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtResourceGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginDeleteAtResourceGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtResourceGroupCreateRequest(ctx, resourceGroupName, deploymentStackName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtResourceGroupCreateRequest creates the DeleteAtResourceGroup request.
func (client *DeploymentStacksClient) deleteAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	if options != nil && options.BypassStackOutOfSyncError != nil {
		reqQP.Set("bypassStackOutOfSyncError", strconv.FormatBool(*options.BypassStackOutOfSyncError))
	}
	if options != nil && options.UnmanageActionManagementGroups != nil {
		reqQP.Set("unmanageAction.ManagementGroups", string(*options.UnmanageActionManagementGroups))
	}
	if options != nil && options.UnmanageActionResourceGroups != nil {
		reqQP.Set("unmanageAction.ResourceGroups", string(*options.UnmanageActionResourceGroups))
	}
	if options != nil && options.UnmanageActionResources != nil {
		reqQP.Set("unmanageAction.Resources", string(*options.UnmanageActionResources))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAtSubscription - Deletes a Deployment stack by name at Subscription scope. When operation completes, status
// code 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientBeginDeleteAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.BeginDeleteAtSubscription
//     method.
func (client *DeploymentStacksClient) BeginDeleteAtSubscription(ctx context.Context, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtSubscriptionOptions) (*runtime.Poller[DeploymentStacksClientDeleteAtSubscriptionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.deleteAtSubscription(ctx, deploymentStackName, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientDeleteAtSubscriptionResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientDeleteAtSubscriptionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAtSubscription - Deletes a Deployment stack by name at Subscription scope. When operation completes, status code
// 200 returned without content.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) deleteAtSubscription(ctx context.Context, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtSubscriptionOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginDeleteAtSubscription"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteAtSubscriptionCreateRequest(ctx, deploymentStackName, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// deleteAtSubscriptionCreateRequest creates the DeleteAtSubscription request.
func (client *DeploymentStacksClient) deleteAtSubscriptionCreateRequest(ctx context.Context, deploymentStackName string, options *DeploymentStacksClientBeginDeleteAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	if options != nil && options.BypassStackOutOfSyncError != nil {
		reqQP.Set("bypassStackOutOfSyncError", strconv.FormatBool(*options.BypassStackOutOfSyncError))
	}
	if options != nil && options.UnmanageActionManagementGroups != nil {
		reqQP.Set("unmanageAction.ManagementGroups", string(*options.UnmanageActionManagementGroups))
	}
	if options != nil && options.UnmanageActionResourceGroups != nil {
		reqQP.Set("unmanageAction.ResourceGroups", string(*options.UnmanageActionResourceGroups))
	}
	if options != nil && options.UnmanageActionResources != nil {
		reqQP.Set("unmanageAction.Resources", string(*options.UnmanageActionResources))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ExportTemplateAtManagementGroup - Exports the template used to create the Deployment stack at Management Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientExportTemplateAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.ExportTemplateAtManagementGroup
//     method.
func (client *DeploymentStacksClient) ExportTemplateAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, options *DeploymentStacksClientExportTemplateAtManagementGroupOptions) (DeploymentStacksClientExportTemplateAtManagementGroupResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.ExportTemplateAtManagementGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtManagementGroupCreateRequest(ctx, managementGroupID, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtManagementGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientExportTemplateAtManagementGroupResponse{}, err
	}
	resp, err := client.exportTemplateAtManagementGroupHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtManagementGroupCreateRequest creates the ExportTemplateAtManagementGroup request.
func (client *DeploymentStacksClient) exportTemplateAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, deploymentStackName string, _ *DeploymentStacksClientExportTemplateAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/exportTemplate"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtManagementGroupHandleResponse handles the ExportTemplateAtManagementGroup response.
func (client *DeploymentStacksClient) exportTemplateAtManagementGroupHandleResponse(resp *http.Response) (DeploymentStacksClientExportTemplateAtManagementGroupResponse, error) {
	result := DeploymentStacksClientExportTemplateAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackTemplateDefinition); err != nil {
		return DeploymentStacksClientExportTemplateAtManagementGroupResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtResourceGroup - Exports the template used to create the Deployment stack at Resource Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientExportTemplateAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.ExportTemplateAtResourceGroup
//     method.
func (client *DeploymentStacksClient) ExportTemplateAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, options *DeploymentStacksClientExportTemplateAtResourceGroupOptions) (DeploymentStacksClientExportTemplateAtResourceGroupResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.ExportTemplateAtResourceGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtResourceGroupCreateRequest(ctx, resourceGroupName, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtResourceGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientExportTemplateAtResourceGroupResponse{}, err
	}
	resp, err := client.exportTemplateAtResourceGroupHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtResourceGroupCreateRequest creates the ExportTemplateAtResourceGroup request.
func (client *DeploymentStacksClient) exportTemplateAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, deploymentStackName string, _ *DeploymentStacksClientExportTemplateAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/exportTemplate"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtResourceGroupHandleResponse handles the ExportTemplateAtResourceGroup response.
func (client *DeploymentStacksClient) exportTemplateAtResourceGroupHandleResponse(resp *http.Response) (DeploymentStacksClientExportTemplateAtResourceGroupResponse, error) {
	result := DeploymentStacksClientExportTemplateAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackTemplateDefinition); err != nil {
		return DeploymentStacksClientExportTemplateAtResourceGroupResponse{}, err
	}
	return result, nil
}

// ExportTemplateAtSubscription - Exports the template used to create the Deployment stack at Subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientExportTemplateAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.ExportTemplateAtSubscription
//     method.
func (client *DeploymentStacksClient) ExportTemplateAtSubscription(ctx context.Context, deploymentStackName string, options *DeploymentStacksClientExportTemplateAtSubscriptionOptions) (DeploymentStacksClientExportTemplateAtSubscriptionResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.ExportTemplateAtSubscription"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exportTemplateAtSubscriptionCreateRequest(ctx, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientExportTemplateAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientExportTemplateAtSubscriptionResponse{}, err
	}
	resp, err := client.exportTemplateAtSubscriptionHandleResponse(httpResp)
	return resp, err
}

// exportTemplateAtSubscriptionCreateRequest creates the ExportTemplateAtSubscription request.
func (client *DeploymentStacksClient) exportTemplateAtSubscriptionCreateRequest(ctx context.Context, deploymentStackName string, _ *DeploymentStacksClientExportTemplateAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/exportTemplate"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// exportTemplateAtSubscriptionHandleResponse handles the ExportTemplateAtSubscription response.
func (client *DeploymentStacksClient) exportTemplateAtSubscriptionHandleResponse(resp *http.Response) (DeploymentStacksClientExportTemplateAtSubscriptionResponse, error) {
	result := DeploymentStacksClientExportTemplateAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackTemplateDefinition); err != nil {
		return DeploymentStacksClientExportTemplateAtSubscriptionResponse{}, err
	}
	return result, nil
}

// GetAtManagementGroup - Gets a Deployment stack with a given name at Management Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientGetAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.GetAtManagementGroup
//     method.
func (client *DeploymentStacksClient) GetAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, options *DeploymentStacksClientGetAtManagementGroupOptions) (DeploymentStacksClientGetAtManagementGroupResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.GetAtManagementGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtManagementGroupCreateRequest(ctx, managementGroupID, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientGetAtManagementGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientGetAtManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientGetAtManagementGroupResponse{}, err
	}
	resp, err := client.getAtManagementGroupHandleResponse(httpResp)
	return resp, err
}

// getAtManagementGroupCreateRequest creates the GetAtManagementGroup request.
func (client *DeploymentStacksClient) getAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, deploymentStackName string, _ *DeploymentStacksClientGetAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtManagementGroupHandleResponse handles the GetAtManagementGroup response.
func (client *DeploymentStacksClient) getAtManagementGroupHandleResponse(resp *http.Response) (DeploymentStacksClientGetAtManagementGroupResponse, error) {
	result := DeploymentStacksClientGetAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStack); err != nil {
		return DeploymentStacksClientGetAtManagementGroupResponse{}, err
	}
	return result, nil
}

// GetAtResourceGroup - Gets a Deployment stack with a given name at Resource Group scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientGetAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.GetAtResourceGroup
//     method.
func (client *DeploymentStacksClient) GetAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, options *DeploymentStacksClientGetAtResourceGroupOptions) (DeploymentStacksClientGetAtResourceGroupResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.GetAtResourceGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtResourceGroupCreateRequest(ctx, resourceGroupName, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientGetAtResourceGroupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientGetAtResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientGetAtResourceGroupResponse{}, err
	}
	resp, err := client.getAtResourceGroupHandleResponse(httpResp)
	return resp, err
}

// getAtResourceGroupCreateRequest creates the GetAtResourceGroup request.
func (client *DeploymentStacksClient) getAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, deploymentStackName string, _ *DeploymentStacksClientGetAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtResourceGroupHandleResponse handles the GetAtResourceGroup response.
func (client *DeploymentStacksClient) getAtResourceGroupHandleResponse(resp *http.Response) (DeploymentStacksClientGetAtResourceGroupResponse, error) {
	result := DeploymentStacksClientGetAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStack); err != nil {
		return DeploymentStacksClientGetAtResourceGroupResponse{}, err
	}
	return result, nil
}

// GetAtSubscription - Gets a Deployment stack with a given name at Subscription scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - deploymentStackName - Name of the deployment stack.
//   - options - DeploymentStacksClientGetAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.GetAtSubscription
//     method.
func (client *DeploymentStacksClient) GetAtSubscription(ctx context.Context, deploymentStackName string, options *DeploymentStacksClientGetAtSubscriptionOptions) (DeploymentStacksClientGetAtSubscriptionResponse, error) {
	var err error
	const operationName = "DeploymentStacksClient.GetAtSubscription"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAtSubscriptionCreateRequest(ctx, deploymentStackName, options)
	if err != nil {
		return DeploymentStacksClientGetAtSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentStacksClientGetAtSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DeploymentStacksClientGetAtSubscriptionResponse{}, err
	}
	resp, err := client.getAtSubscriptionHandleResponse(httpResp)
	return resp, err
}

// getAtSubscriptionCreateRequest creates the GetAtSubscription request.
func (client *DeploymentStacksClient) getAtSubscriptionCreateRequest(ctx context.Context, deploymentStackName string, _ *DeploymentStacksClientGetAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAtSubscriptionHandleResponse handles the GetAtSubscription response.
func (client *DeploymentStacksClient) getAtSubscriptionHandleResponse(resp *http.Response) (DeploymentStacksClientGetAtSubscriptionResponse, error) {
	result := DeploymentStacksClientGetAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStack); err != nil {
		return DeploymentStacksClientGetAtSubscriptionResponse{}, err
	}
	return result, nil
}

// NewListAtManagementGroupPager - Lists all the Deployment stacks within the specified Management Group.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - options - DeploymentStacksClientListAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.NewListAtManagementGroupPager
//     method.
func (client *DeploymentStacksClient) NewListAtManagementGroupPager(managementGroupID string, options *DeploymentStacksClientListAtManagementGroupOptions) *runtime.Pager[DeploymentStacksClientListAtManagementGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[DeploymentStacksClientListAtManagementGroupResponse]{
		More: func(page DeploymentStacksClientListAtManagementGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *DeploymentStacksClientListAtManagementGroupResponse) (DeploymentStacksClientListAtManagementGroupResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "DeploymentStacksClient.NewListAtManagementGroupPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtManagementGroupCreateRequest(ctx, managementGroupID, options)
			}, nil)
			if err != nil {
				return DeploymentStacksClientListAtManagementGroupResponse{}, err
			}
			return client.listAtManagementGroupHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtManagementGroupCreateRequest creates the ListAtManagementGroup request.
func (client *DeploymentStacksClient) listAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, _ *DeploymentStacksClientListAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtManagementGroupHandleResponse handles the ListAtManagementGroup response.
func (client *DeploymentStacksClient) listAtManagementGroupHandleResponse(resp *http.Response) (DeploymentStacksClientListAtManagementGroupResponse, error) {
	result := DeploymentStacksClientListAtManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackListResult); err != nil {
		return DeploymentStacksClientListAtManagementGroupResponse{}, err
	}
	return result, nil
}

// NewListAtResourceGroupPager - Lists all the Deployment stacks within the specified Resource Group.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - options - DeploymentStacksClientListAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.NewListAtResourceGroupPager
//     method.
func (client *DeploymentStacksClient) NewListAtResourceGroupPager(resourceGroupName string, options *DeploymentStacksClientListAtResourceGroupOptions) *runtime.Pager[DeploymentStacksClientListAtResourceGroupResponse] {
	return runtime.NewPager(runtime.PagingHandler[DeploymentStacksClientListAtResourceGroupResponse]{
		More: func(page DeploymentStacksClientListAtResourceGroupResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *DeploymentStacksClientListAtResourceGroupResponse) (DeploymentStacksClientListAtResourceGroupResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "DeploymentStacksClient.NewListAtResourceGroupPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtResourceGroupCreateRequest(ctx, resourceGroupName, options)
			}, nil)
			if err != nil {
				return DeploymentStacksClientListAtResourceGroupResponse{}, err
			}
			return client.listAtResourceGroupHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtResourceGroupCreateRequest creates the ListAtResourceGroup request.
func (client *DeploymentStacksClient) listAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, _ *DeploymentStacksClientListAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtResourceGroupHandleResponse handles the ListAtResourceGroup response.
func (client *DeploymentStacksClient) listAtResourceGroupHandleResponse(resp *http.Response) (DeploymentStacksClientListAtResourceGroupResponse, error) {
	result := DeploymentStacksClientListAtResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackListResult); err != nil {
		return DeploymentStacksClientListAtResourceGroupResponse{}, err
	}
	return result, nil
}

// NewListAtSubscriptionPager - Lists all the Deployment stacks within the specified Subscription.
//
// Generated from API version 2024-03-01
//   - options - DeploymentStacksClientListAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.NewListAtSubscriptionPager
//     method.
func (client *DeploymentStacksClient) NewListAtSubscriptionPager(options *DeploymentStacksClientListAtSubscriptionOptions) *runtime.Pager[DeploymentStacksClientListAtSubscriptionResponse] {
	return runtime.NewPager(runtime.PagingHandler[DeploymentStacksClientListAtSubscriptionResponse]{
		More: func(page DeploymentStacksClientListAtSubscriptionResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *DeploymentStacksClientListAtSubscriptionResponse) (DeploymentStacksClientListAtSubscriptionResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "DeploymentStacksClient.NewListAtSubscriptionPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAtSubscriptionCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return DeploymentStacksClientListAtSubscriptionResponse{}, err
			}
			return client.listAtSubscriptionHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAtSubscriptionCreateRequest creates the ListAtSubscription request.
func (client *DeploymentStacksClient) listAtSubscriptionCreateRequest(ctx context.Context, _ *DeploymentStacksClientListAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAtSubscriptionHandleResponse handles the ListAtSubscription response.
func (client *DeploymentStacksClient) listAtSubscriptionHandleResponse(resp *http.Response) (DeploymentStacksClientListAtSubscriptionResponse, error) {
	result := DeploymentStacksClientListAtSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentStackListResult); err != nil {
		return DeploymentStacksClientListAtSubscriptionResponse{}, err
	}
	return result, nil
}

// BeginValidateStackAtManagementGroup - Runs preflight validation on the Management Group scoped Deployment stack template
// to verify its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - managementGroupID - Management Group id.
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack to validate.
//   - options - DeploymentStacksClientBeginValidateStackAtManagementGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginValidateStackAtManagementGroup
//     method.
func (client *DeploymentStacksClient) BeginValidateStackAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtManagementGroupOptions) (*runtime.Poller[DeploymentStacksClientValidateStackAtManagementGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateStackAtManagementGroup(ctx, managementGroupID, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientValidateStackAtManagementGroupResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientValidateStackAtManagementGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateStackAtManagementGroup - Runs preflight validation on the Management Group scoped Deployment stack template to
// verify its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) validateStackAtManagementGroup(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtManagementGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginValidateStackAtManagementGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateStackAtManagementGroupCreateRequest(ctx, managementGroupID, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateStackAtManagementGroupCreateRequest creates the ValidateStackAtManagementGroup request.
func (client *DeploymentStacksClient) validateStackAtManagementGroupCreateRequest(ctx context.Context, managementGroupID string, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginValidateStackAtManagementGroupOptions) (*policy.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/validate"
	if managementGroupID == "" {
		return nil, errors.New("parameter managementGroupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupId}", url.PathEscape(managementGroupID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateStackAtResourceGroup - Runs preflight validation on the Resource Group scoped Deployment stack template to
// verify its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack to validate.
//   - options - DeploymentStacksClientBeginValidateStackAtResourceGroupOptions contains the optional parameters for the DeploymentStacksClient.BeginValidateStackAtResourceGroup
//     method.
func (client *DeploymentStacksClient) BeginValidateStackAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtResourceGroupOptions) (*runtime.Poller[DeploymentStacksClientValidateStackAtResourceGroupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateStackAtResourceGroup(ctx, resourceGroupName, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientValidateStackAtResourceGroupResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientValidateStackAtResourceGroupResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateStackAtResourceGroup - Runs preflight validation on the Resource Group scoped Deployment stack template to verify
// its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) validateStackAtResourceGroup(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtResourceGroupOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginValidateStackAtResourceGroup"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateStackAtResourceGroupCreateRequest(ctx, resourceGroupName, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateStackAtResourceGroupCreateRequest creates the ValidateStackAtResourceGroup request.
func (client *DeploymentStacksClient) validateStackAtResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginValidateStackAtResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/validate"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginValidateStackAtSubscription - Runs preflight validation on the Subscription scoped Deployment stack template to verify
// its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
//   - deploymentStackName - Name of the deployment stack.
//   - deploymentStack - Deployment stack to validate.
//   - options - DeploymentStacksClientBeginValidateStackAtSubscriptionOptions contains the optional parameters for the DeploymentStacksClient.BeginValidateStackAtSubscription
//     method.
func (client *DeploymentStacksClient) BeginValidateStackAtSubscription(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtSubscriptionOptions) (*runtime.Poller[DeploymentStacksClientValidateStackAtSubscriptionResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.validateStackAtSubscription(ctx, deploymentStackName, deploymentStack, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[DeploymentStacksClientValidateStackAtSubscriptionResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[DeploymentStacksClientValidateStackAtSubscriptionResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// ValidateStackAtSubscription - Runs preflight validation on the Subscription scoped Deployment stack template to verify
// its acceptance to Azure Resource Manager.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-03-01
func (client *DeploymentStacksClient) validateStackAtSubscription(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, options *DeploymentStacksClientBeginValidateStackAtSubscriptionOptions) (*http.Response, error) {
	var err error
	const operationName = "DeploymentStacksClient.BeginValidateStackAtSubscription"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateStackAtSubscriptionCreateRequest(ctx, deploymentStackName, deploymentStack, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// validateStackAtSubscriptionCreateRequest creates the ValidateStackAtSubscription request.
func (client *DeploymentStacksClient) validateStackAtSubscriptionCreateRequest(ctx context.Context, deploymentStackName string, deploymentStack DeploymentStack, _ *DeploymentStacksClientBeginValidateStackAtSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deploymentStacks/{deploymentStackName}/validate"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if deploymentStackName == "" {
		return nil, errors.New("parameter deploymentStackName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentStackName}", url.PathEscape(deploymentStackName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, deploymentStack); err != nil {
		return nil, err
	}
	return req, nil
}
