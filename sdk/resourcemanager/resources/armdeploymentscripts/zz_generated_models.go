//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdeploymentscripts

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AzureCliScript - Object model for the Azure CLI script.
type AzureCliScript struct {
	DeploymentScript
	// REQUIRED; Properties of the Azure CLI script object.
	Properties *AzureCliScriptProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureCliScript.
func (a AzureCliScript) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.DeploymentScript.marshalInternal(objectMap, ScriptTypeAzureCLI)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureCliScript.
func (a *AzureCliScript) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.DeploymentScript.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureCliScriptProperties - Properties of the Azure CLI script object.
type AzureCliScriptProperties struct {
	DeploymentScriptPropertiesBase
	ScriptConfigurationBase
	// REQUIRED; Azure CLI module version to be used.
	AzCliVersion *string `json:"azCliVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureCliScriptProperties.
func (a AzureCliScriptProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.DeploymentScriptPropertiesBase.marshalInternal(objectMap)
	a.ScriptConfigurationBase.marshalInternal(objectMap)
	populate(objectMap, "azCliVersion", a.AzCliVersion)
	return json.Marshal(objectMap)
}

// AzurePowerShellScript - Object model for the Azure PowerShell script.
type AzurePowerShellScript struct {
	DeploymentScript
	// REQUIRED; Properties of the Azure PowerShell script object.
	Properties *AzurePowerShellScriptProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePowerShellScript.
func (a AzurePowerShellScript) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.DeploymentScript.marshalInternal(objectMap, ScriptTypeAzurePowerShell)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePowerShellScript.
func (a *AzurePowerShellScript) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.DeploymentScript.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzurePowerShellScriptProperties - Properties of the Azure PowerShell script object.
type AzurePowerShellScriptProperties struct {
	DeploymentScriptPropertiesBase
	ScriptConfigurationBase
	// REQUIRED; Azure PowerShell module version to be used.
	AzPowerShellVersion *string `json:"azPowerShellVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePowerShellScriptProperties.
func (a AzurePowerShellScriptProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.DeploymentScriptPropertiesBase.marshalInternal(objectMap)
	a.ScriptConfigurationBase.marshalInternal(objectMap)
	populate(objectMap, "azPowerShellVersion", a.AzPowerShellVersion)
	return json.Marshal(objectMap)
}

// AzureResourceBase - Common properties for all Azure resources.
type AzureResourceBase struct {
	// READ-ONLY; String Id used to locate any resource on Azure.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of this resource.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Type of this resource.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceBase.
func (a AzureResourceBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureResourceBase.
func (a *AzureResourceBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AzureResourceBase) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "type", a.Type)
}

func (a *AzureResourceBase) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContainerConfiguration - Settings to customize ACI container instance.
type ContainerConfiguration struct {
	// Container group name, if not specified then the name will get auto-generated. Not specifying a 'containerGroupName' indicates the system to generate
	// a unique name which might end up flagging an Azure
	// Policy as non-compliant. Use 'containerGroupName' when you have an Azure Policy that expects a specific naming convention or when you want to fully control
	// the name. 'containerGroupName' property must
	// be between 1 and 63 characters long, must contain only lowercase letters, numbers, and dashes and it cannot start or end with a dash and consecutive
	// dashes are not allowed. To specify a
	// 'containerGroupName', add the following object to properties: { "containerSettings": { "containerGroupName": "contoso-container" } }. If you do not want
	// to specify a 'containerGroupName' then do not
	// add 'containerSettings' property.
	ContainerGroupName *string `json:"containerGroupName,omitempty"`
}

// DeploymentScriptClassification provides polymorphic access to related types.
// Call the interface's GetDeploymentScript() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureCliScript, *AzurePowerShellScript, *DeploymentScript
type DeploymentScriptClassification interface {
	// GetDeploymentScript returns the DeploymentScript content of the underlying type.
	GetDeploymentScript() *DeploymentScript
}

// DeploymentScript - Deployment script object.
type DeploymentScript struct {
	AzureResourceBase
	// REQUIRED; Type of the script.
	Kind *ScriptType `json:"kind,omitempty"`

	// REQUIRED; The location of the ACI and the storage account for the deployment script.
	Location *string `json:"location,omitempty"`

	// Optional property. Managed identity to be used for this deployment script. Currently, only user-assigned MSI is supported.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetDeploymentScript implements the DeploymentScriptClassification interface for type DeploymentScript.
func (d *DeploymentScript) GetDeploymentScript() *DeploymentScript { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentScript.
func (d *DeploymentScript) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DeploymentScript) marshalInternal(objectMap map[string]interface{}, discValue ScriptType) {
	d.AzureResourceBase.marshalInternal(objectMap)
	populate(objectMap, "identity", d.Identity)
	d.Kind = &discValue
	objectMap["kind"] = d.Kind
	populate(objectMap, "location", d.Location)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
}

func (d *DeploymentScript) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &d.Identity)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.AzureResourceBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeploymentScriptListResult - List of deployment scripts.
type DeploymentScriptListResult struct {
	// An array of deployment scripts.
	Value []DeploymentScriptClassification `json:"value,omitempty"`

	// READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentScriptListResult.
func (d DeploymentScriptListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentScriptListResult.
func (d *DeploymentScriptListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &d.NextLink)
			delete(rawMsg, key)
		case "value":
			d.Value, err = unmarshalDeploymentScriptClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeploymentScriptPropertiesBase - Common properties for the deployment script.
type DeploymentScriptPropertiesBase struct {
	// The clean up preference when the script execution gets in a terminal state. Default setting is 'Always'.
	CleanupPreference *CleanupOptions `json:"cleanupPreference,omitempty"`

	// Container settings.
	ContainerSettings *ContainerConfiguration `json:"containerSettings,omitempty"`

	// Storage Account settings.
	StorageAccountSettings *StorageAccountConfiguration `json:"storageAccountSettings,omitempty"`

	// READ-ONLY; List of script outputs.
	Outputs map[string]map[string]interface{} `json:"outputs,omitempty" azure:"ro"`

	// READ-ONLY; State of the script execution. This only appears in the response.
	ProvisioningState *ScriptProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Contains the results of script execution.
	Status *ScriptStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentScriptPropertiesBase.
func (d DeploymentScriptPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (d DeploymentScriptPropertiesBase) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "cleanupPreference", d.CleanupPreference)
	populate(objectMap, "containerSettings", d.ContainerSettings)
	populate(objectMap, "outputs", d.Outputs)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "storageAccountSettings", d.StorageAccountSettings)
}

// DeploymentScriptUpdateParameter - Deployment script parameters to be updated.
type DeploymentScriptUpdateParameter struct {
	AzureResourceBase
	// Resource tags to be updated.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentScriptUpdateParameter.
func (d DeploymentScriptUpdateParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.AzureResourceBase.marshalInternal(objectMap)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentScriptUpdateParameter.
func (d *DeploymentScriptUpdateParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.AzureResourceBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeploymentScriptsBeginCreateOptions contains the optional parameters for the DeploymentScripts.BeginCreate method.
type DeploymentScriptsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsDeleteOptions contains the optional parameters for the DeploymentScripts.Delete method.
type DeploymentScriptsDeleteOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsError - Deployment scripts error response.
// Implements the error and azcore.HTTPResponse interfaces.
type DeploymentScriptsError struct {
	raw string
	// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response
	// format.)
	InnerError *ErrorResponse `json:"error,omitempty"`
}

// Error implements the error interface for type DeploymentScriptsError.
// The contents of the error text are not contractual and subject to change.
func (e DeploymentScriptsError) Error() string {
	return e.raw
}

// DeploymentScriptsGetLogsDefaultOptions contains the optional parameters for the DeploymentScripts.GetLogsDefault method.
type DeploymentScriptsGetLogsDefaultOptions struct {
	// The number of lines to show from the tail of the deployment script log. Valid value is a positive number up to 1000. If 'tail' is not provided, all available
	// logs are shown up to container instance log capacity of 4mb.
	Tail *int32
}

// DeploymentScriptsGetLogsOptions contains the optional parameters for the DeploymentScripts.GetLogs method.
type DeploymentScriptsGetLogsOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsGetOptions contains the optional parameters for the DeploymentScripts.Get method.
type DeploymentScriptsGetOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsListByResourceGroupOptions contains the optional parameters for the DeploymentScripts.ListByResourceGroup method.
type DeploymentScriptsListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsListBySubscriptionOptions contains the optional parameters for the DeploymentScripts.ListBySubscription method.
type DeploymentScriptsListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// DeploymentScriptsUpdateOptions contains the optional parameters for the DeploymentScripts.Update method.
type DeploymentScriptsUpdateOptions struct {
	// Deployment script resource with the tags to be updated.
	DeploymentScript *DeploymentScriptUpdateParameter
}

// EnvironmentVariable - The environment variable to pass to the script in the container instance.
type EnvironmentVariable struct {
	// REQUIRED; The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// The value of the secure environment variable.
	SecureValue *string `json:"secureValue,omitempty"`

	// The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.)
type ErrorResponse struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorResponse `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// LogProperties - Script log properties.
type LogProperties struct {
	// READ-ONLY; Script execution logs in text format.
	Log *string `json:"log,omitempty" azure:"ro"`
}

// ManagedServiceIdentity - Managed identity generic object.
type ManagedServiceIdentity struct {
	// Type of the managed identity.
	Type *ManagedServiceIdentityType `json:"type,omitempty"`

	// The list of user-assigned managed identities associated with the resource. Key is the Azure resource Id of the managed identity.
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; ID of the Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// ScriptConfigurationBase - Common configuration settings for both Azure PowerShell and Azure CLI scripts.
type ScriptConfigurationBase struct {
	// REQUIRED; Interval for which the service retains the script resource after it reaches a terminal state. Resource will be deleted when this duration expires.
	// Duration is based on ISO 8601 pattern (for example
	// P1D means one day).
	RetentionInterval *string `json:"retentionInterval,omitempty"`

	// Command line arguments to pass to the script. Arguments are separated by spaces. ex: -Name blue* -Location 'West US 2'
	Arguments *string `json:"arguments,omitempty"`

	// The environment variables to pass over to the script.
	EnvironmentVariables []*EnvironmentVariable `json:"environmentVariables,omitempty"`

	// Gets or sets how the deployment script should be forced to execute even if the script resource has not changed. Can be current time stamp or a GUID.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// Uri for the script. This is the entry point for the external script.
	PrimaryScriptURI *string `json:"primaryScriptUri,omitempty"`

	// Script body.
	ScriptContent *string `json:"scriptContent,omitempty"`

	// Supporting files for the external script.
	SupportingScriptUris []*string `json:"supportingScriptUris,omitempty"`

	// Maximum allowed script execution time specified in ISO 8601 format. Default value is P1D
	Timeout *string `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScriptConfigurationBase.
func (s ScriptConfigurationBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (s ScriptConfigurationBase) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "arguments", s.Arguments)
	populate(objectMap, "environmentVariables", s.EnvironmentVariables)
	populate(objectMap, "forceUpdateTag", s.ForceUpdateTag)
	populate(objectMap, "primaryScriptUri", s.PrimaryScriptURI)
	populate(objectMap, "retentionInterval", s.RetentionInterval)
	populate(objectMap, "scriptContent", s.ScriptContent)
	populate(objectMap, "supportingScriptUris", s.SupportingScriptUris)
	populate(objectMap, "timeout", s.Timeout)
}

// ScriptLog - Script execution log object.
type ScriptLog struct {
	AzureResourceBase
	// Script log properties.
	Properties *LogProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScriptLog.
func (s ScriptLog) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.AzureResourceBase.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptLog.
func (s *ScriptLog) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.AzureResourceBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ScriptLogsList - Deployment script execution logs.
type ScriptLogsList struct {
	// Deployment scripts logs.
	Value []*ScriptLog `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScriptLogsList.
func (s ScriptLogsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ScriptStatus - Generic object modeling results of script execution.
type ScriptStatus struct {
	// Error that is relayed from the script execution.
	Error *ErrorResponse `json:"error,omitempty"`

	// READ-ONLY; ACI resource Id.
	ContainerInstanceID *string `json:"containerInstanceId,omitempty" azure:"ro"`

	// READ-ONLY; End time of the script execution.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; Time the deployment script resource will expire.
	ExpirationTime *time.Time `json:"expirationTime,omitempty" azure:"ro"`

	// READ-ONLY; Start time of the script execution.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Storage account resource Id.
	StorageAccountID *string `json:"storageAccountId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScriptStatus.
func (s ScriptStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerInstanceId", s.ContainerInstanceID)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "error", s.Error)
	populateTimeRFC3339(objectMap, "expirationTime", s.ExpirationTime)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "storageAccountId", s.StorageAccountID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptStatus.
func (s *ScriptStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInstanceId":
			err = unpopulate(val, &s.ContainerInstanceID)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &s.Error)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, &s.ExpirationTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "storageAccountId":
			err = unpopulate(val, &s.StorageAccountID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageAccountConfiguration - Settings to use an existing storage account. Valid storage account kinds are: Storage, StorageV2 and FileStorage
type StorageAccountConfiguration struct {
	// The storage account access key.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// The storage account name.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UserAssignedIdentity - User-assigned managed identity.
type UserAssignedIdentity struct {
	// READ-ONLY; Client App Id associated with this identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; Azure Active Directory principal ID associated with this identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
