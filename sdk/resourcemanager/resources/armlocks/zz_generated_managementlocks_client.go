//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armlocks

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// ManagementLocksClient contains the methods for the ManagementLocks group.
// Don't use this type directly, use NewManagementLocksClient() instead.
type ManagementLocksClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewManagementLocksClient creates a new instance of ManagementLocksClient with the specified values.
func NewManagementLocksClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *ManagementLocksClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &ManagementLocksClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// CreateOrUpdateAtResourceGroupLevel - When you apply a lock at a parent scope, all child resources inherit the same lock. To create management locks,
// you must have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/*
// actions. Of the built-in roles, only Owner and User Access Administrator are granted those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) CreateOrUpdateAtResourceGroupLevel(ctx context.Context, resourceGroupName string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtResourceGroupLevelOptions) (ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse, error) {
	req, err := client.createOrUpdateAtResourceGroupLevelCreateRequest(ctx, resourceGroupName, lockName, parameters, options)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse{}, client.createOrUpdateAtResourceGroupLevelHandleError(resp)
	}
	return client.createOrUpdateAtResourceGroupLevelHandleResponse(resp)
}

// createOrUpdateAtResourceGroupLevelCreateRequest creates the CreateOrUpdateAtResourceGroupLevel request.
func (client *ManagementLocksClient) createOrUpdateAtResourceGroupLevelCreateRequest(ctx context.Context, resourceGroupName string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtResourceGroupLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceGroupLevelHandleResponse handles the CreateOrUpdateAtResourceGroupLevel response.
func (client *ManagementLocksClient) createOrUpdateAtResourceGroupLevelHandleResponse(resp *http.Response) (ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse, error) {
	result := ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateAtResourceGroupLevelHandleError handles the CreateOrUpdateAtResourceGroupLevel error response.
func (client *ManagementLocksClient) createOrUpdateAtResourceGroupLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateAtResourceLevel - When you apply a lock at a parent scope, all child resources inherit the same lock. To create management locks, you must
// have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/*
// actions. Of the built-in roles, only Owner and User Access Administrator are granted those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) CreateOrUpdateAtResourceLevel(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtResourceLevelOptions) (ManagementLocksCreateOrUpdateAtResourceLevelResponse, error) {
	req, err := client.createOrUpdateAtResourceLevelCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, lockName, parameters, options)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtResourceLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtResourceLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return ManagementLocksCreateOrUpdateAtResourceLevelResponse{}, client.createOrUpdateAtResourceLevelHandleError(resp)
	}
	return client.createOrUpdateAtResourceLevelHandleResponse(resp)
}

// createOrUpdateAtResourceLevelCreateRequest creates the CreateOrUpdateAtResourceLevel request.
func (client *ManagementLocksClient) createOrUpdateAtResourceLevelCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtResourceLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if resourceProviderNamespace == "" {
		return nil, errors.New("parameter resourceProviderNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	if resourceName == "" {
		return nil, errors.New("parameter resourceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtResourceLevelHandleResponse handles the CreateOrUpdateAtResourceLevel response.
func (client *ManagementLocksClient) createOrUpdateAtResourceLevelHandleResponse(resp *http.Response) (ManagementLocksCreateOrUpdateAtResourceLevelResponse, error) {
	result := ManagementLocksCreateOrUpdateAtResourceLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksCreateOrUpdateAtResourceLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateAtResourceLevelHandleError handles the CreateOrUpdateAtResourceLevel error response.
func (client *ManagementLocksClient) createOrUpdateAtResourceLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateAtSubscriptionLevel - When you apply a lock at a parent scope, all child resources inherit the same lock. To create management locks, you
// must have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/*
// actions. Of the built-in roles, only Owner and User Access Administrator are granted those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) CreateOrUpdateAtSubscriptionLevel(ctx context.Context, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtSubscriptionLevelOptions) (ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse, error) {
	req, err := client.createOrUpdateAtSubscriptionLevelCreateRequest(ctx, lockName, parameters, options)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse{}, client.createOrUpdateAtSubscriptionLevelHandleError(resp)
	}
	return client.createOrUpdateAtSubscriptionLevelHandleResponse(resp)
}

// createOrUpdateAtSubscriptionLevelCreateRequest creates the CreateOrUpdateAtSubscriptionLevel request.
func (client *ManagementLocksClient) createOrUpdateAtSubscriptionLevelCreateRequest(ctx context.Context, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateAtSubscriptionLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}"
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateAtSubscriptionLevelHandleResponse handles the CreateOrUpdateAtSubscriptionLevel response.
func (client *ManagementLocksClient) createOrUpdateAtSubscriptionLevelHandleResponse(resp *http.Response) (ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse, error) {
	result := ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateAtSubscriptionLevelHandleError handles the CreateOrUpdateAtSubscriptionLevel error response.
func (client *ManagementLocksClient) createOrUpdateAtSubscriptionLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateByScope - Create or update a management lock by scope.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) CreateOrUpdateByScope(ctx context.Context, scope string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateByScopeOptions) (ManagementLocksCreateOrUpdateByScopeResponse, error) {
	req, err := client.createOrUpdateByScopeCreateRequest(ctx, scope, lockName, parameters, options)
	if err != nil {
		return ManagementLocksCreateOrUpdateByScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksCreateOrUpdateByScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return ManagementLocksCreateOrUpdateByScopeResponse{}, client.createOrUpdateByScopeHandleError(resp)
	}
	return client.createOrUpdateByScopeHandleResponse(resp)
}

// createOrUpdateByScopeCreateRequest creates the CreateOrUpdateByScope request.
func (client *ManagementLocksClient) createOrUpdateByScopeCreateRequest(ctx context.Context, scope string, lockName string, parameters ManagementLockObject, options *ManagementLocksCreateOrUpdateByScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/locks/{lockName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", url.PathEscape(scope))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateByScopeHandleResponse handles the CreateOrUpdateByScope response.
func (client *ManagementLocksClient) createOrUpdateByScopeHandleResponse(resp *http.Response) (ManagementLocksCreateOrUpdateByScopeResponse, error) {
	result := ManagementLocksCreateOrUpdateByScopeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksCreateOrUpdateByScopeResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateByScopeHandleError handles the CreateOrUpdateByScope error response.
func (client *ManagementLocksClient) createOrUpdateByScopeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteAtResourceGroupLevel - To delete management locks, you must have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/* actions.
// Of the built-in roles, only Owner and User Access Administrator are granted
// those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) DeleteAtResourceGroupLevel(ctx context.Context, resourceGroupName string, lockName string, options *ManagementLocksDeleteAtResourceGroupLevelOptions) (ManagementLocksDeleteAtResourceGroupLevelResponse, error) {
	req, err := client.deleteAtResourceGroupLevelCreateRequest(ctx, resourceGroupName, lockName, options)
	if err != nil {
		return ManagementLocksDeleteAtResourceGroupLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksDeleteAtResourceGroupLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return ManagementLocksDeleteAtResourceGroupLevelResponse{}, client.deleteAtResourceGroupLevelHandleError(resp)
	}
	return ManagementLocksDeleteAtResourceGroupLevelResponse{RawResponse: resp}, nil
}

// deleteAtResourceGroupLevelCreateRequest creates the DeleteAtResourceGroupLevel request.
func (client *ManagementLocksClient) deleteAtResourceGroupLevelCreateRequest(ctx context.Context, resourceGroupName string, lockName string, options *ManagementLocksDeleteAtResourceGroupLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceGroupLevelHandleError handles the DeleteAtResourceGroupLevel error response.
func (client *ManagementLocksClient) deleteAtResourceGroupLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteAtResourceLevel - To delete management locks, you must have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/* actions. Of
// the built-in roles, only Owner and User Access Administrator are granted
// those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) DeleteAtResourceLevel(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, options *ManagementLocksDeleteAtResourceLevelOptions) (ManagementLocksDeleteAtResourceLevelResponse, error) {
	req, err := client.deleteAtResourceLevelCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, lockName, options)
	if err != nil {
		return ManagementLocksDeleteAtResourceLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksDeleteAtResourceLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return ManagementLocksDeleteAtResourceLevelResponse{}, client.deleteAtResourceLevelHandleError(resp)
	}
	return ManagementLocksDeleteAtResourceLevelResponse{RawResponse: resp}, nil
}

// deleteAtResourceLevelCreateRequest creates the DeleteAtResourceLevel request.
func (client *ManagementLocksClient) deleteAtResourceLevelCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, options *ManagementLocksDeleteAtResourceLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if resourceProviderNamespace == "" {
		return nil, errors.New("parameter resourceProviderNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	if resourceName == "" {
		return nil, errors.New("parameter resourceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtResourceLevelHandleError handles the DeleteAtResourceLevel error response.
func (client *ManagementLocksClient) deleteAtResourceLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteAtSubscriptionLevel - To delete management locks, you must have access to Microsoft.Authorization/* or Microsoft.Authorization/locks/* actions.
// Of the built-in roles, only Owner and User Access Administrator are granted
// those actions.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) DeleteAtSubscriptionLevel(ctx context.Context, lockName string, options *ManagementLocksDeleteAtSubscriptionLevelOptions) (ManagementLocksDeleteAtSubscriptionLevelResponse, error) {
	req, err := client.deleteAtSubscriptionLevelCreateRequest(ctx, lockName, options)
	if err != nil {
		return ManagementLocksDeleteAtSubscriptionLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksDeleteAtSubscriptionLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return ManagementLocksDeleteAtSubscriptionLevelResponse{}, client.deleteAtSubscriptionLevelHandleError(resp)
	}
	return ManagementLocksDeleteAtSubscriptionLevelResponse{RawResponse: resp}, nil
}

// deleteAtSubscriptionLevelCreateRequest creates the DeleteAtSubscriptionLevel request.
func (client *ManagementLocksClient) deleteAtSubscriptionLevelCreateRequest(ctx context.Context, lockName string, options *ManagementLocksDeleteAtSubscriptionLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}"
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtSubscriptionLevelHandleError handles the DeleteAtSubscriptionLevel error response.
func (client *ManagementLocksClient) deleteAtSubscriptionLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteByScope - Delete a management lock by scope.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) DeleteByScope(ctx context.Context, scope string, lockName string, options *ManagementLocksDeleteByScopeOptions) (ManagementLocksDeleteByScopeResponse, error) {
	req, err := client.deleteByScopeCreateRequest(ctx, scope, lockName, options)
	if err != nil {
		return ManagementLocksDeleteByScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksDeleteByScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return ManagementLocksDeleteByScopeResponse{}, client.deleteByScopeHandleError(resp)
	}
	return ManagementLocksDeleteByScopeResponse{RawResponse: resp}, nil
}

// deleteByScopeCreateRequest creates the DeleteByScope request.
func (client *ManagementLocksClient) deleteByScopeCreateRequest(ctx context.Context, scope string, lockName string, options *ManagementLocksDeleteByScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/locks/{lockName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", url.PathEscape(scope))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteByScopeHandleError handles the DeleteByScope error response.
func (client *ManagementLocksClient) deleteByScopeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAtResourceGroupLevel - Gets a management lock at the resource group level.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) GetAtResourceGroupLevel(ctx context.Context, resourceGroupName string, lockName string, options *ManagementLocksGetAtResourceGroupLevelOptions) (ManagementLocksGetAtResourceGroupLevelResponse, error) {
	req, err := client.getAtResourceGroupLevelCreateRequest(ctx, resourceGroupName, lockName, options)
	if err != nil {
		return ManagementLocksGetAtResourceGroupLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksGetAtResourceGroupLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagementLocksGetAtResourceGroupLevelResponse{}, client.getAtResourceGroupLevelHandleError(resp)
	}
	return client.getAtResourceGroupLevelHandleResponse(resp)
}

// getAtResourceGroupLevelCreateRequest creates the GetAtResourceGroupLevel request.
func (client *ManagementLocksClient) getAtResourceGroupLevelCreateRequest(ctx context.Context, resourceGroupName string, lockName string, options *ManagementLocksGetAtResourceGroupLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceGroupLevelHandleResponse handles the GetAtResourceGroupLevel response.
func (client *ManagementLocksClient) getAtResourceGroupLevelHandleResponse(resp *http.Response) (ManagementLocksGetAtResourceGroupLevelResponse, error) {
	result := ManagementLocksGetAtResourceGroupLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksGetAtResourceGroupLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAtResourceGroupLevelHandleError handles the GetAtResourceGroupLevel error response.
func (client *ManagementLocksClient) getAtResourceGroupLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAtResourceLevel - Get the management lock of a resource or any level below resource.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) GetAtResourceLevel(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, options *ManagementLocksGetAtResourceLevelOptions) (ManagementLocksGetAtResourceLevelResponse, error) {
	req, err := client.getAtResourceLevelCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, lockName, options)
	if err != nil {
		return ManagementLocksGetAtResourceLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksGetAtResourceLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagementLocksGetAtResourceLevelResponse{}, client.getAtResourceLevelHandleError(resp)
	}
	return client.getAtResourceLevelHandleResponse(resp)
}

// getAtResourceLevelCreateRequest creates the GetAtResourceLevel request.
func (client *ManagementLocksClient) getAtResourceLevelCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, lockName string, options *ManagementLocksGetAtResourceLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if resourceProviderNamespace == "" {
		return nil, errors.New("parameter resourceProviderNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	if resourceName == "" {
		return nil, errors.New("parameter resourceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtResourceLevelHandleResponse handles the GetAtResourceLevel response.
func (client *ManagementLocksClient) getAtResourceLevelHandleResponse(resp *http.Response) (ManagementLocksGetAtResourceLevelResponse, error) {
	result := ManagementLocksGetAtResourceLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksGetAtResourceLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAtResourceLevelHandleError handles the GetAtResourceLevel error response.
func (client *ManagementLocksClient) getAtResourceLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAtSubscriptionLevel - Gets a management lock at the subscription level.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) GetAtSubscriptionLevel(ctx context.Context, lockName string, options *ManagementLocksGetAtSubscriptionLevelOptions) (ManagementLocksGetAtSubscriptionLevelResponse, error) {
	req, err := client.getAtSubscriptionLevelCreateRequest(ctx, lockName, options)
	if err != nil {
		return ManagementLocksGetAtSubscriptionLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksGetAtSubscriptionLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagementLocksGetAtSubscriptionLevelResponse{}, client.getAtSubscriptionLevelHandleError(resp)
	}
	return client.getAtSubscriptionLevelHandleResponse(resp)
}

// getAtSubscriptionLevelCreateRequest creates the GetAtSubscriptionLevel request.
func (client *ManagementLocksClient) getAtSubscriptionLevelCreateRequest(ctx context.Context, lockName string, options *ManagementLocksGetAtSubscriptionLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}"
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAtSubscriptionLevelHandleResponse handles the GetAtSubscriptionLevel response.
func (client *ManagementLocksClient) getAtSubscriptionLevelHandleResponse(resp *http.Response) (ManagementLocksGetAtSubscriptionLevelResponse, error) {
	result := ManagementLocksGetAtSubscriptionLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksGetAtSubscriptionLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAtSubscriptionLevelHandleError handles the GetAtSubscriptionLevel error response.
func (client *ManagementLocksClient) getAtSubscriptionLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetByScope - Get a management lock by scope.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) GetByScope(ctx context.Context, scope string, lockName string, options *ManagementLocksGetByScopeOptions) (ManagementLocksGetByScopeResponse, error) {
	req, err := client.getByScopeCreateRequest(ctx, scope, lockName, options)
	if err != nil {
		return ManagementLocksGetByScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagementLocksGetByScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagementLocksGetByScopeResponse{}, client.getByScopeHandleError(resp)
	}
	return client.getByScopeHandleResponse(resp)
}

// getByScopeCreateRequest creates the GetByScope request.
func (client *ManagementLocksClient) getByScopeCreateRequest(ctx context.Context, scope string, lockName string, options *ManagementLocksGetByScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/locks/{lockName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", url.PathEscape(scope))
	if lockName == "" {
		return nil, errors.New("parameter lockName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{lockName}", url.PathEscape(lockName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByScopeHandleResponse handles the GetByScope response.
func (client *ManagementLocksClient) getByScopeHandleResponse(resp *http.Response) (ManagementLocksGetByScopeResponse, error) {
	result := ManagementLocksGetByScopeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockObject); err != nil {
		return ManagementLocksGetByScopeResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getByScopeHandleError handles the GetByScope error response.
func (client *ManagementLocksClient) getByScopeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAtResourceGroupLevel - Gets all the management locks for a resource group.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) ListAtResourceGroupLevel(resourceGroupName string, options *ManagementLocksListAtResourceGroupLevelOptions) *ManagementLocksListAtResourceGroupLevelPager {
	return &ManagementLocksListAtResourceGroupLevelPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listAtResourceGroupLevelCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp ManagementLocksListAtResourceGroupLevelResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ManagementLockListResult.NextLink)
		},
	}
}

// listAtResourceGroupLevelCreateRequest creates the ListAtResourceGroupLevel request.
func (client *ManagementLocksClient) listAtResourceGroupLevelCreateRequest(ctx context.Context, resourceGroupName string, options *ManagementLocksListAtResourceGroupLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAtResourceGroupLevelHandleResponse handles the ListAtResourceGroupLevel response.
func (client *ManagementLocksClient) listAtResourceGroupLevelHandleResponse(resp *http.Response) (ManagementLocksListAtResourceGroupLevelResponse, error) {
	result := ManagementLocksListAtResourceGroupLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockListResult); err != nil {
		return ManagementLocksListAtResourceGroupLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAtResourceGroupLevelHandleError handles the ListAtResourceGroupLevel error response.
func (client *ManagementLocksClient) listAtResourceGroupLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAtResourceLevel - Gets all the management locks for a resource or any level below resource.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) ListAtResourceLevel(resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, options *ManagementLocksListAtResourceLevelOptions) *ManagementLocksListAtResourceLevelPager {
	return &ManagementLocksListAtResourceLevelPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listAtResourceLevelCreateRequest(ctx, resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options)
		},
		advancer: func(ctx context.Context, resp ManagementLocksListAtResourceLevelResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ManagementLockListResult.NextLink)
		},
	}
}

// listAtResourceLevelCreateRequest creates the ListAtResourceLevel request.
func (client *ManagementLocksClient) listAtResourceLevelCreateRequest(ctx context.Context, resourceGroupName string, resourceProviderNamespace string, parentResourcePath string, resourceType string, resourceName string, options *ManagementLocksListAtResourceLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if resourceProviderNamespace == "" {
		return nil, errors.New("parameter resourceProviderNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceProviderNamespace}", url.PathEscape(resourceProviderNamespace))
	urlPath = strings.ReplaceAll(urlPath, "{parentResourcePath}", parentResourcePath)
	urlPath = strings.ReplaceAll(urlPath, "{resourceType}", resourceType)
	if resourceName == "" {
		return nil, errors.New("parameter resourceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceName}", url.PathEscape(resourceName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAtResourceLevelHandleResponse handles the ListAtResourceLevel response.
func (client *ManagementLocksClient) listAtResourceLevelHandleResponse(resp *http.Response) (ManagementLocksListAtResourceLevelResponse, error) {
	result := ManagementLocksListAtResourceLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockListResult); err != nil {
		return ManagementLocksListAtResourceLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAtResourceLevelHandleError handles the ListAtResourceLevel error response.
func (client *ManagementLocksClient) listAtResourceLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAtSubscriptionLevel - Gets all the management locks for a subscription.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) ListAtSubscriptionLevel(options *ManagementLocksListAtSubscriptionLevelOptions) *ManagementLocksListAtSubscriptionLevelPager {
	return &ManagementLocksListAtSubscriptionLevelPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listAtSubscriptionLevelCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp ManagementLocksListAtSubscriptionLevelResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ManagementLockListResult.NextLink)
		},
	}
}

// listAtSubscriptionLevelCreateRequest creates the ListAtSubscriptionLevel request.
func (client *ManagementLocksClient) listAtSubscriptionLevelCreateRequest(ctx context.Context, options *ManagementLocksListAtSubscriptionLevelOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAtSubscriptionLevelHandleResponse handles the ListAtSubscriptionLevel response.
func (client *ManagementLocksClient) listAtSubscriptionLevelHandleResponse(resp *http.Response) (ManagementLocksListAtSubscriptionLevelResponse, error) {
	result := ManagementLocksListAtSubscriptionLevelResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockListResult); err != nil {
		return ManagementLocksListAtSubscriptionLevelResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAtSubscriptionLevelHandleError handles the ListAtSubscriptionLevel error response.
func (client *ManagementLocksClient) listAtSubscriptionLevelHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByScope - Gets all the management locks for a scope.
// If the operation fails it returns the *ErrorResponse error type.
func (client *ManagementLocksClient) ListByScope(scope string, options *ManagementLocksListByScopeOptions) *ManagementLocksListByScopePager {
	return &ManagementLocksListByScopePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByScopeCreateRequest(ctx, scope, options)
		},
		advancer: func(ctx context.Context, resp ManagementLocksListByScopeResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ManagementLockListResult.NextLink)
		},
	}
}

// listByScopeCreateRequest creates the ListByScope request.
func (client *ManagementLocksClient) listByScopeCreateRequest(ctx context.Context, scope string, options *ManagementLocksListByScopeOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/locks"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", url.PathEscape(scope))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2020-05-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByScopeHandleResponse handles the ListByScope response.
func (client *ManagementLocksClient) listByScopeHandleResponse(resp *http.Response) (ManagementLocksListByScopeResponse, error) {
	result := ManagementLocksListByScopeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagementLockListResult); err != nil {
		return ManagementLocksListByScopeResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByScopeHandleError handles the ListByScope error response.
func (client *ManagementLocksClient) listByScopeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
