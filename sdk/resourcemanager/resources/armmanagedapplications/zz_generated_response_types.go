//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmanagedapplications

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationClientListOperationsResponse contains the response from method ApplicationClient.ListOperations.
type ApplicationClientListOperationsResponse struct {
	ApplicationClientListOperationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationClientListOperationsResult contains the result from method ApplicationClient.ListOperations.
type ApplicationClientListOperationsResult struct {
	OperationListResult
}

// ApplicationDefinitionsCreateOrUpdateByIDPollerResponse contains the response from method ApplicationDefinitions.CreateOrUpdateByID.
type ApplicationDefinitionsCreateOrUpdateByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsCreateOrUpdateByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsCreateOrUpdateByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsCreateOrUpdateByIDResponse, error) {
	respType := ApplicationDefinitionsCreateOrUpdateByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsCreateOrUpdateByIDPollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsCreateOrUpdateByIDPollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.CreateOrUpdateByID", token, client.pl, client.createOrUpdateByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsCreateOrUpdateByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsCreateOrUpdateByIDResponse contains the response from method ApplicationDefinitions.CreateOrUpdateByID.
type ApplicationDefinitionsCreateOrUpdateByIDResponse struct {
	ApplicationDefinitionsCreateOrUpdateByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsCreateOrUpdateByIDResult contains the result from method ApplicationDefinitions.CreateOrUpdateByID.
type ApplicationDefinitionsCreateOrUpdateByIDResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsCreateOrUpdatePollerResponse contains the response from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsCreateOrUpdateResponse, error) {
	respType := ApplicationDefinitionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsCreateOrUpdateResponse contains the response from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdateResponse struct {
	ApplicationDefinitionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsCreateOrUpdateResult contains the result from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdateResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsDeleteByIDPollerResponse contains the response from method ApplicationDefinitions.DeleteByID.
type ApplicationDefinitionsDeleteByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsDeleteByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsDeleteByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsDeleteByIDResponse, error) {
	respType := ApplicationDefinitionsDeleteByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsDeleteByIDPollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsDeleteByIDPollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.DeleteByID", token, client.pl, client.deleteByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsDeleteByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsDeleteByIDResponse contains the response from method ApplicationDefinitions.DeleteByID.
type ApplicationDefinitionsDeleteByIDResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsDeletePollerResponse contains the response from method ApplicationDefinitions.Delete.
type ApplicationDefinitionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsDeleteResponse, error) {
	respType := ApplicationDefinitionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsDeleteResponse contains the response from method ApplicationDefinitions.Delete.
type ApplicationDefinitionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsGetByIDResponse contains the response from method ApplicationDefinitions.GetByID.
type ApplicationDefinitionsGetByIDResponse struct {
	ApplicationDefinitionsGetByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsGetByIDResult contains the result from method ApplicationDefinitions.GetByID.
type ApplicationDefinitionsGetByIDResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsGetResponse contains the response from method ApplicationDefinitions.Get.
type ApplicationDefinitionsGetResponse struct {
	ApplicationDefinitionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsGetResult contains the result from method ApplicationDefinitions.Get.
type ApplicationDefinitionsGetResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsListByResourceGroupResponse contains the response from method ApplicationDefinitions.ListByResourceGroup.
type ApplicationDefinitionsListByResourceGroupResponse struct {
	ApplicationDefinitionsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsListByResourceGroupResult contains the result from method ApplicationDefinitions.ListByResourceGroup.
type ApplicationDefinitionsListByResourceGroupResult struct {
	ApplicationDefinitionListResult
}

// ApplicationsCreateOrUpdateByIDPollerResponse contains the response from method Applications.CreateOrUpdateByID.
type ApplicationsCreateOrUpdateByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsCreateOrUpdateByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsCreateOrUpdateByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsCreateOrUpdateByIDResponse, error) {
	respType := ApplicationsCreateOrUpdateByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Application)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsCreateOrUpdateByIDPollerResponse from the provided client and resume token.
func (l *ApplicationsCreateOrUpdateByIDPollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.CreateOrUpdateByID", token, client.pl, client.createOrUpdateByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsCreateOrUpdateByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsCreateOrUpdateByIDResponse contains the response from method Applications.CreateOrUpdateByID.
type ApplicationsCreateOrUpdateByIDResponse struct {
	ApplicationsCreateOrUpdateByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsCreateOrUpdateByIDResult contains the result from method Applications.CreateOrUpdateByID.
type ApplicationsCreateOrUpdateByIDResult struct {
	Application
}

// ApplicationsCreateOrUpdatePollerResponse contains the response from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsCreateOrUpdateResponse, error) {
	respType := ApplicationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Application)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsCreateOrUpdateResponse contains the response from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdateResponse struct {
	ApplicationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsCreateOrUpdateResult contains the result from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdateResult struct {
	Application
}

// ApplicationsDeleteByIDPollerResponse contains the response from method Applications.DeleteByID.
type ApplicationsDeleteByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsDeleteByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsDeleteByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsDeleteByIDResponse, error) {
	respType := ApplicationsDeleteByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsDeleteByIDPollerResponse from the provided client and resume token.
func (l *ApplicationsDeleteByIDPollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.DeleteByID", token, client.pl, client.deleteByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsDeleteByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsDeleteByIDResponse contains the response from method Applications.DeleteByID.
type ApplicationsDeleteByIDResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsDeletePollerResponse contains the response from method Applications.Delete.
type ApplicationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsDeleteResponse, error) {
	respType := ApplicationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsDeleteResponse contains the response from method Applications.Delete.
type ApplicationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsGetByIDResponse contains the response from method Applications.GetByID.
type ApplicationsGetByIDResponse struct {
	ApplicationsGetByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsGetByIDResult contains the result from method Applications.GetByID.
type ApplicationsGetByIDResult struct {
	Application
}

// ApplicationsGetResponse contains the response from method Applications.Get.
type ApplicationsGetResponse struct {
	ApplicationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsGetResult contains the result from method Applications.Get.
type ApplicationsGetResult struct {
	Application
}

// ApplicationsListByResourceGroupResponse contains the response from method Applications.ListByResourceGroup.
type ApplicationsListByResourceGroupResponse struct {
	ApplicationsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsListByResourceGroupResult contains the result from method Applications.ListByResourceGroup.
type ApplicationsListByResourceGroupResult struct {
	ApplicationListResult
}

// ApplicationsListBySubscriptionResponse contains the response from method Applications.ListBySubscription.
type ApplicationsListBySubscriptionResponse struct {
	ApplicationsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsListBySubscriptionResult contains the result from method Applications.ListBySubscription.
type ApplicationsListBySubscriptionResult struct {
	ApplicationListResult
}

// ApplicationsUpdateByIDResponse contains the response from method Applications.UpdateByID.
type ApplicationsUpdateByIDResponse struct {
	ApplicationsUpdateByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsUpdateByIDResult contains the result from method Applications.UpdateByID.
type ApplicationsUpdateByIDResult struct {
	Application
}

// ApplicationsUpdateResponse contains the response from method Applications.Update.
type ApplicationsUpdateResponse struct {
	ApplicationsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsUpdateResult contains the result from method Applications.Update.
type ApplicationsUpdateResult struct {
	Application
}
