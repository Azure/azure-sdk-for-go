//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicy

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// Alias - The alias type.
type Alias struct {
	// The default path for an alias.
	DefaultPath *string `json:"defaultPath,omitempty"`

	// The default pattern for an alias.
	DefaultPattern *AliasPattern `json:"defaultPattern,omitempty"`

	// The alias name.
	Name *string `json:"name,omitempty"`

	// The paths for an alias.
	Paths []*AliasPath `json:"paths,omitempty"`

	// The type of the alias.
	Type *AliasType `json:"type,omitempty"`

	// READ-ONLY; The default alias path metadata. Applies to the default path and to any alias path that doesn't have metadata
	DefaultMetadata *AliasPathMetadata `json:"defaultMetadata,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Alias.
func (a Alias) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultMetadata", a.DefaultMetadata)
	populate(objectMap, "defaultPath", a.DefaultPath)
	populate(objectMap, "defaultPattern", a.DefaultPattern)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "paths", a.Paths)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AliasPath - The type of the paths for alias.
type AliasPath struct {
	// The API versions.
	APIVersions []*string `json:"apiVersions,omitempty"`

	// The path of an alias.
	Path *string `json:"path,omitempty"`

	// The pattern for an alias path.
	Pattern *AliasPattern `json:"pattern,omitempty"`

	// READ-ONLY; The metadata of the alias path. If missing, fall back to the default metadata of the alias.
	Metadata *AliasPathMetadata `json:"metadata,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AliasPath.
func (a AliasPath) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersions", a.APIVersions)
	populate(objectMap, "metadata", a.Metadata)
	populate(objectMap, "path", a.Path)
	populate(objectMap, "pattern", a.Pattern)
	return json.Marshal(objectMap)
}

type AliasPathMetadata struct {
	// READ-ONLY; The attributes of the token that the alias path is referring to.
	Attributes *AliasPathAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The type of the token that the alias path is referring to.
	Type *AliasPathTokenType `json:"type,omitempty" azure:"ro"`
}

// AliasPattern - The type of the pattern for an alias path.
type AliasPattern struct {
	// The alias pattern phrase.
	Phrase *string `json:"phrase,omitempty"`

	// The type of alias pattern
	Type *AliasPatternType `json:"type,omitempty"`

	// The alias pattern variable.
	Variable *string `json:"variable,omitempty"`
}

// CloudError - An error response from a policy operation.
// Implements the error and azcore.HTTPResponse interfaces.
type CloudError struct {
	raw string
	// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response
	// format.)
	InnerError *ErrorResponse `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
// The contents of the error text are not contractual and subject to change.
func (e CloudError) Error() string {
	return e.raw
}

// DataEffect - The data effect definition.
type DataEffect struct {
	// The data effect details schema.
	DetailsSchema map[string]interface{} `json:"detailsSchema,omitempty"`

	// The data effect name.
	Name *string `json:"name,omitempty"`
}

// DataManifestCustomResourceFunctionDefinition - The custom resource function definition.
type DataManifestCustomResourceFunctionDefinition struct {
	// A value indicating whether the custom properties within the property bag are allowed. Needs api-version to be specified in the policy rule eg - vault('2019-06-01').
	AllowCustomProperties *bool `json:"allowCustomProperties,omitempty"`

	// The top-level properties that can be selected on the function's output. eg - [ "name", "location" ] if vault().name and vault().location are supported
	DefaultProperties []*string `json:"defaultProperties,omitempty"`

	// The fully qualified control plane resource type that this function represents. eg - 'Microsoft.KeyVault/vaults'.
	FullyQualifiedResourceType *string `json:"fullyQualifiedResourceType,omitempty"`

	// The function name as it will appear in the policy rule. eg - 'vault'.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataManifestCustomResourceFunctionDefinition.
func (d DataManifestCustomResourceFunctionDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowCustomProperties", d.AllowCustomProperties)
	populate(objectMap, "defaultProperties", d.DefaultProperties)
	populate(objectMap, "fullyQualifiedResourceType", d.FullyQualifiedResourceType)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// DataManifestResourceFunctionsDefinition - The resource functions supported by a manifest
type DataManifestResourceFunctionsDefinition struct {
	// An array of data manifest custom resource definition.
	Custom []*DataManifestCustomResourceFunctionDefinition `json:"custom,omitempty"`

	// The standard resource functions (subscription and/or resourceGroup).
	Standard []*string `json:"standard,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataManifestResourceFunctionsDefinition.
func (d DataManifestResourceFunctionsDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "custom", d.Custom)
	populate(objectMap, "standard", d.Standard)
	return json.Marshal(objectMap)
}

// DataPolicyManifest - The data policy manifest.
type DataPolicyManifest struct {
	// The data policy manifest properties.
	Properties *DataPolicyManifestProperties `json:"properties,omitempty"`

	// READ-ONLY; The ID of the data policy manifest.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the data policy manifest (it's the same as the Policy Mode).
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource (Microsoft.Authorization/dataPolicyManifests).
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DataPolicyManifestListResult - List of data policy manifests.
type DataPolicyManifestListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of data policy manifests.
	Value []*DataPolicyManifest `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataPolicyManifestListResult.
func (d DataPolicyManifestListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataPolicyManifestProperties - The properties of the data policy manifest.
type DataPolicyManifestProperties struct {
	// The effect definition.
	Effects []*DataEffect `json:"effects,omitempty"`

	// The non-alias field accessor values that can be used in the policy rule.
	FieldValues []*string `json:"fieldValues,omitempty"`

	// A value indicating whether policy mode is allowed only in built-in definitions.
	IsBuiltInOnly *bool `json:"isBuiltInOnly,omitempty"`

	// The list of namespaces for the data policy manifest.
	Namespaces []*string `json:"namespaces,omitempty"`

	// The policy mode of the data policy manifest.
	PolicyMode *string `json:"policyMode,omitempty"`

	// The resource functions definition specified in the data manifest.
	ResourceFunctions *DataManifestResourceFunctionsDefinition `json:"resourceFunctions,omitempty"`

	// An array of resource type aliases.
	ResourceTypeAliases []*ResourceTypeAliases `json:"resourceTypeAliases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataPolicyManifestProperties.
func (d DataPolicyManifestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "effects", d.Effects)
	populate(objectMap, "fieldValues", d.FieldValues)
	populate(objectMap, "isBuiltInOnly", d.IsBuiltInOnly)
	populate(objectMap, "namespaces", d.Namespaces)
	populate(objectMap, "policyMode", d.PolicyMode)
	populate(objectMap, "resourceFunctions", d.ResourceFunctions)
	populate(objectMap, "resourceTypeAliases", d.ResourceTypeAliases)
	return json.Marshal(objectMap)
}

// DataPolicyManifestsGetByPolicyModeOptions contains the optional parameters for the DataPolicyManifests.GetByPolicyMode method.
type DataPolicyManifestsGetByPolicyModeOptions struct {
	// placeholder for future optional parameters
}

// DataPolicyManifestsListOptions contains the optional parameters for the DataPolicyManifests.List method.
type DataPolicyManifestsListOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: "namespace eq '{value}'". If $filter is not provided, no filtering is performed.
	// If $filter=namespace eq '{value}' is provided, the returned list only includes all data policy manifests that have a namespace matching the provided
	// value.
	Filter *string
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.)
type ErrorResponse struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorResponse `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// Identity for the resource. Policy assignments support a maximum of one identity. That is either a system assigned identity or a single user assigned
// identity.
type Identity struct {
	// The identity type. This is the only required field when adding a system or user assigned identity to a resource.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserAssignedIdentitiesValue `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal ID of the resource identity. This property will only be provided for a system assigned identity
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of the resource identity. This property will only be provided for a system assigned identity
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// NonComplianceMessage - A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's
// non-compliant compliance results.
type NonComplianceMessage struct {
	// REQUIRED; A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant
	// compliance results.
	Message *string `json:"message,omitempty"`

	// The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns
	// a policy set definition. If this is not provided
	// the message applies to all policies assigned by this policy assignment.
	PolicyDefinitionReferenceID *string `json:"policyDefinitionReferenceId,omitempty"`
}

// ParameterDefinitionsValue - The definition of a parameter that can be provided to the policy.
type ParameterDefinitionsValue struct {
	// The allowed values for the parameter.
	AllowedValues []map[string]interface{} `json:"allowedValues,omitempty"`

	// The default value for the parameter if no value is provided.
	DefaultValue map[string]interface{} `json:"defaultValue,omitempty"`

	// General metadata for the parameter.
	Metadata *ParameterDefinitionsValueMetadata `json:"metadata,omitempty"`

	// The data type of the parameter.
	Type *ParameterType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParameterDefinitionsValue.
func (p ParameterDefinitionsValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedValues", p.AllowedValues)
	populate(objectMap, "defaultValue", p.DefaultValue)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// ParameterDefinitionsValueMetadata - General metadata for the parameter.
type ParameterDefinitionsValueMetadata struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This
	// property is useful in case you wish to assign
	// permissions outside the assignment scope.
	AssignPermissions *bool `json:"assignPermissions,omitempty"`

	// The description of the parameter.
	Description *string `json:"description,omitempty"`

	// The display name for the parameter.
	DisplayName *string `json:"displayName,omitempty"`

	// Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
	StrongType *string `json:"strongType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParameterDefinitionsValueMetadata.
func (p ParameterDefinitionsValueMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignPermissions", p.AssignPermissions)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "strongType", p.StrongType)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParameterDefinitionsValueMetadata.
func (p *ParameterDefinitionsValueMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignPermissions":
			err = unpopulate(val, &p.AssignPermissions)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &p.DisplayName)
			delete(rawMsg, key)
		case "strongType":
			err = unpopulate(val, &p.StrongType)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ParameterValuesValue - The value of a parameter.
type ParameterValuesValue struct {
	// The value of the parameter.
	Value map[string]interface{} `json:"value,omitempty"`
}

// PolicyAssignment - The policy assignment.
type PolicyAssignment struct {
	// The managed identity associated with the policy assignment.
	Identity *Identity `json:"identity,omitempty"`

	// The location of the policy assignment. Only required when utilizing managed identity.
	Location *string `json:"location,omitempty"`

	// Properties for the policy assignment.
	Properties *PolicyAssignmentProperties `json:"properties,omitempty"`

	// READ-ONLY; The ID of the policy assignment.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the policy assignment.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the policy assignment.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PolicyAssignmentListResult - List of policy assignments.
type PolicyAssignmentListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of policy assignments.
	Value []*PolicyAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyAssignmentListResult.
func (p PolicyAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PolicyAssignmentProperties - The policy assignment properties.
type PolicyAssignmentProperties struct {
	// This message will be part of response in case of policy violation.
	Description *string `json:"description,omitempty"`

	// The display name of the policy assignment.
	DisplayName *string `json:"displayName,omitempty"`

	// The policy assignment enforcement mode. Possible values are Default and DoNotEnforce.
	EnforcementMode *EnforcementMode `json:"enforcementMode,omitempty"`

	// The policy assignment metadata. Metadata is an open ended object and is typically a collection of key value pairs.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// The messages that describe why a resource is non-compliant with the policy.
	NonComplianceMessages []*NonComplianceMessage `json:"nonComplianceMessages,omitempty"`

	// The policy's excluded scopes.
	NotScopes []*string `json:"notScopes,omitempty"`

	// The parameter values for the assigned policy rule. The keys are the parameter names.
	Parameters map[string]*ParameterValuesValue `json:"parameters,omitempty"`

	// The ID of the policy definition or policy set definition being assigned.
	PolicyDefinitionID *string `json:"policyDefinitionId,omitempty"`

	// READ-ONLY; The scope for the policy assignment.
	Scope *string `json:"scope,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyAssignmentProperties.
func (p PolicyAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "enforcementMode", p.EnforcementMode)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "nonComplianceMessages", p.NonComplianceMessages)
	populate(objectMap, "notScopes", p.NotScopes)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policyDefinitionId", p.PolicyDefinitionID)
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

type PolicyAssignmentUpdate struct {
	// The managed identity associated with the policy assignment.
	Identity *Identity `json:"identity,omitempty"`

	// The location of the policy assignment. Only required when utilizing managed identity.
	Location *string `json:"location,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyAssignmentUpdate.
func (p PolicyAssignmentUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	return json.Marshal(objectMap)
}

// PolicyAssignmentsCreateByIDOptions contains the optional parameters for the PolicyAssignments.CreateByID method.
type PolicyAssignmentsCreateByIDOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsCreateOptions contains the optional parameters for the PolicyAssignments.Create method.
type PolicyAssignmentsCreateOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsDeleteByIDOptions contains the optional parameters for the PolicyAssignments.DeleteByID method.
type PolicyAssignmentsDeleteByIDOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsDeleteOptions contains the optional parameters for the PolicyAssignments.Delete method.
type PolicyAssignmentsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsGetByIDOptions contains the optional parameters for the PolicyAssignments.GetByID method.
type PolicyAssignmentsGetByIDOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsGetOptions contains the optional parameters for the PolicyAssignments.Get method.
type PolicyAssignmentsGetOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsListForManagementGroupOptions contains the optional parameters for the PolicyAssignments.ListForManagementGroup method.
type PolicyAssignmentsListForManagementGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is
	// not provided, no filtering is performed. If $filter=atScope() is provided, the returned list only includes all policy assignments that apply to the scope,
	// which is everything in the unfiltered list except those applied to sub scopes contained within the given scope. If $filter=atExactScope() is provided,
	// the returned list only includes all policy assignments that at the given scope. If $filter=policyDefinitionId eq '{value}' is provided, the returned
	// list includes all policy assignments of the policy definition whose id is {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyAssignmentsListForResourceGroupOptions contains the optional parameters for the PolicyAssignments.ListForResourceGroup method.
type PolicyAssignmentsListForResourceGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is
	// not provided, no filtering is performed. If $filter=atScope() is provided, the returned list only includes all policy assignments that apply to the scope,
	// which is everything in the unfiltered list except those applied to sub scopes contained within the given scope. If $filter=atExactScope() is provided,
	// the returned list only includes all policy assignments that at the given scope. If $filter=policyDefinitionId eq '{value}' is provided, the returned
	// list includes all policy assignments of the policy definition whose id is {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyAssignmentsListForResourceOptions contains the optional parameters for the PolicyAssignments.ListForResource method.
type PolicyAssignmentsListForResourceOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is
	// not provided, no filtering is performed. If $filter=atScope() is provided, the returned list only includes all policy assignments that apply to the scope,
	// which is everything in the unfiltered list except those applied to sub scopes contained within the given scope. If $filter=atExactScope() is provided,
	// the returned list only includes all policy assignments that at the given scope. If $filter=policyDefinitionId eq '{value}' is provided, the returned
	// list includes all policy assignments of the policy definition whose id is {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyAssignmentsListOptions contains the optional parameters for the PolicyAssignments.List method.
type PolicyAssignmentsListOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is
	// not provided, no filtering is performed. If $filter=atScope() is provided, the returned list only includes all policy assignments that apply to the scope,
	// which is everything in the unfiltered list except those applied to sub scopes contained within the given scope. If $filter=atExactScope() is provided,
	// the returned list only includes all policy assignments that at the given scope. If $filter=policyDefinitionId eq '{value}' is provided, the returned
	// list includes all policy assignments of the policy definition whose id is {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyAssignmentsUpdateByIDOptions contains the optional parameters for the PolicyAssignments.UpdateByID method.
type PolicyAssignmentsUpdateByIDOptions struct {
	// placeholder for future optional parameters
}

// PolicyAssignmentsUpdateOptions contains the optional parameters for the PolicyAssignments.Update method.
type PolicyAssignmentsUpdateOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinition - The policy definition.
type PolicyDefinition struct {
	// The policy definition properties.
	Properties *PolicyDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; The ID of the policy definition.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the policy definition.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource (Microsoft.Authorization/policyDefinitions).
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PolicyDefinitionGroup - The policy definition group.
type PolicyDefinitionGroup struct {
	// REQUIRED; The name of the group.
	Name *string `json:"name,omitempty"`

	// A resource ID of a resource that contains additional metadata about the group.
	AdditionalMetadataID *string `json:"additionalMetadataId,omitempty"`

	// The group's category.
	Category *string `json:"category,omitempty"`

	// The group's description.
	Description *string `json:"description,omitempty"`

	// The group's display name.
	DisplayName *string `json:"displayName,omitempty"`
}

// PolicyDefinitionListResult - List of policy definitions.
type PolicyDefinitionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of policy definitions.
	Value []*PolicyDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyDefinitionListResult.
func (p PolicyDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PolicyDefinitionProperties - The policy definition properties.
type PolicyDefinitionProperties struct {
	// The policy definition description.
	Description *string `json:"description,omitempty"`

	// The display name of the policy definition.
	DisplayName *string `json:"displayName,omitempty"`

	// The policy definition metadata. Metadata is an open ended object and is typically a collection of key value pairs.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// The policy definition mode. Some examples are All, Indexed, Microsoft.KeyVault.Data.
	Mode *string `json:"mode,omitempty"`

	// The parameter definitions for parameters used in the policy rule. The keys are the parameter names.
	Parameters map[string]*ParameterDefinitionsValue `json:"parameters,omitempty"`

	// The policy rule.
	PolicyRule map[string]interface{} `json:"policyRule,omitempty"`

	// The type of policy definition. Possible values are NotSpecified, BuiltIn, Custom, and Static.
	PolicyType *PolicyType `json:"policyType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyDefinitionProperties.
func (p PolicyDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "mode", p.Mode)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policyRule", p.PolicyRule)
	populate(objectMap, "policyType", p.PolicyType)
	return json.Marshal(objectMap)
}

// PolicyDefinitionReference - The policy definition reference.
type PolicyDefinitionReference struct {
	// REQUIRED; The ID of the policy definition or policy set definition.
	PolicyDefinitionID *string `json:"policyDefinitionId,omitempty"`

	// The name of the groups that this policy definition reference belongs to.
	GroupNames []*string `json:"groupNames,omitempty"`

	// The parameter values for the referenced policy rule. The keys are the parameter names.
	Parameters map[string]*ParameterValuesValue `json:"parameters,omitempty"`

	// A unique id (within the policy set definition) for this policy definition reference.
	PolicyDefinitionReferenceID *string `json:"policyDefinitionReferenceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyDefinitionReference.
func (p PolicyDefinitionReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupNames", p.GroupNames)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policyDefinitionId", p.PolicyDefinitionID)
	populate(objectMap, "policyDefinitionReferenceId", p.PolicyDefinitionReferenceID)
	return json.Marshal(objectMap)
}

// PolicyDefinitionsCreateOrUpdateAtManagementGroupOptions contains the optional parameters for the PolicyDefinitions.CreateOrUpdateAtManagementGroup method.
type PolicyDefinitionsCreateOrUpdateAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsCreateOrUpdateOptions contains the optional parameters for the PolicyDefinitions.CreateOrUpdate method.
type PolicyDefinitionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsDeleteAtManagementGroupOptions contains the optional parameters for the PolicyDefinitions.DeleteAtManagementGroup method.
type PolicyDefinitionsDeleteAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsDeleteOptions contains the optional parameters for the PolicyDefinitions.Delete method.
type PolicyDefinitionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsGetAtManagementGroupOptions contains the optional parameters for the PolicyDefinitions.GetAtManagementGroup method.
type PolicyDefinitionsGetAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsGetBuiltInOptions contains the optional parameters for the PolicyDefinitions.GetBuiltIn method.
type PolicyDefinitionsGetBuiltInOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsGetOptions contains the optional parameters for the PolicyDefinitions.Get method.
type PolicyDefinitionsGetOptions struct {
	// placeholder for future optional parameters
}

// PolicyDefinitionsListBuiltInOptions contains the optional parameters for the PolicyDefinitions.ListBuiltIn method.
type PolicyDefinitionsListBuiltInOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy definitions that at the
	// given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy definitions whose type match the {value}. Possible
	// policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes all policy
	// definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyDefinitionsListByManagementGroupOptions contains the optional parameters for the PolicyDefinitions.ListByManagementGroup method.
type PolicyDefinitionsListByManagementGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy definitions that at the
	// given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy definitions whose type match the {value}. Possible
	// policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes all policy
	// definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyDefinitionsListOptions contains the optional parameters for the PolicyDefinitions.List method.
type PolicyDefinitionsListOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy definitions that at the
	// given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy definitions whose type match the {value}. Possible
	// policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes all policy
	// definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicyExemption - The policy exemption.
type PolicyExemption struct {
	// REQUIRED; Properties for the policy exemption.
	Properties *PolicyExemptionProperties `json:"properties,omitempty"`

	// READ-ONLY; The ID of the policy exemption.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the policy exemption.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource (Microsoft.Authorization/policyExemptions).
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PolicyExemptionListResult - List of policy exemptions.
type PolicyExemptionListResult struct {
	// An array of policy exemptions.
	Value []*PolicyExemption `json:"value,omitempty"`

	// READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyExemptionListResult.
func (p PolicyExemptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PolicyExemptionProperties - The policy exemption properties.
type PolicyExemptionProperties struct {
	// REQUIRED; The policy exemption category. Possible values are Waiver and Mitigated.
	ExemptionCategory *ExemptionCategory `json:"exemptionCategory,omitempty"`

	// REQUIRED; The ID of the policy assignment that is being exempted.
	PolicyAssignmentID *string `json:"policyAssignmentId,omitempty"`

	// The description of the policy exemption.
	Description *string `json:"description,omitempty"`

	// The display name of the policy exemption.
	DisplayName *string `json:"displayName,omitempty"`

	// The expiration date and time (in UTC ISO 8601 format yyyy-MM-ddTHH:mm:ssZ) of the policy exemption.
	ExpiresOn *time.Time `json:"expiresOn,omitempty"`

	// The policy exemption metadata. Metadata is an open ended object and is typically a collection of key value pairs.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// The policy definition reference ID list when the associated policy assignment is an assignment of a policy set definition.
	PolicyDefinitionReferenceIDs []*string `json:"policyDefinitionReferenceIds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicyExemptionProperties.
func (p PolicyExemptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "exemptionCategory", p.ExemptionCategory)
	populateTimeRFC3339(objectMap, "expiresOn", p.ExpiresOn)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "policyAssignmentId", p.PolicyAssignmentID)
	populate(objectMap, "policyDefinitionReferenceIds", p.PolicyDefinitionReferenceIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyExemptionProperties.
func (p *PolicyExemptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &p.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &p.DisplayName)
			delete(rawMsg, key)
		case "exemptionCategory":
			err = unpopulate(val, &p.ExemptionCategory)
			delete(rawMsg, key)
		case "expiresOn":
			err = unpopulateTimeRFC3339(val, &p.ExpiresOn)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, &p.Metadata)
			delete(rawMsg, key)
		case "policyAssignmentId":
			err = unpopulate(val, &p.PolicyAssignmentID)
			delete(rawMsg, key)
		case "policyDefinitionReferenceIds":
			err = unpopulate(val, &p.PolicyDefinitionReferenceIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PolicyExemptionsCreateOrUpdateOptions contains the optional parameters for the PolicyExemptions.CreateOrUpdate method.
type PolicyExemptionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PolicyExemptionsDeleteOptions contains the optional parameters for the PolicyExemptions.Delete method.
type PolicyExemptionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PolicyExemptionsGetOptions contains the optional parameters for the PolicyExemptions.Get method.
type PolicyExemptionsGetOptions struct {
	// placeholder for future optional parameters
}

// PolicyExemptionsListForManagementGroupOptions contains the optional parameters for the PolicyExemptions.ListForManagementGroup method.
type PolicyExemptionsListForManagementGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
	// If $filter is not provided, no filtering is performed. If $filter is not provided, the unfiltered list includes all policy exemptions associated with
	// the scope, including those that apply directly or apply from containing scopes. If $filter=atScope() is provided, the returned list only includes all
	// policy exemptions that apply to the scope, which is everything in the unfiltered list except those applied to sub scopes contained within the given scope.
	// If $filter=atExactScope() is provided, the returned list only includes all policy exemptions that at the given scope. If $filter=excludeExpired() is
	// provided, the returned list only includes all policy exemptions that either haven't expired or didn't set expiration date. If $filter=policyAssignmentId
	// eq '{value}' is provided. the returned list only includes all policy exemptions that are associated with the give policyAssignmentId.
	Filter *string
}

// PolicyExemptionsListForResourceGroupOptions contains the optional parameters for the PolicyExemptions.ListForResourceGroup method.
type PolicyExemptionsListForResourceGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
	// If $filter is not provided, no filtering is performed. If $filter is not provided, the unfiltered list includes all policy exemptions associated with
	// the scope, including those that apply directly or apply from containing scopes. If $filter=atScope() is provided, the returned list only includes all
	// policy exemptions that apply to the scope, which is everything in the unfiltered list except those applied to sub scopes contained within the given scope.
	// If $filter=atExactScope() is provided, the returned list only includes all policy exemptions that at the given scope. If $filter=excludeExpired() is
	// provided, the returned list only includes all policy exemptions that either haven't expired or didn't set expiration date. If $filter=policyAssignmentId
	// eq '{value}' is provided. the returned list only includes all policy exemptions that are associated with the give policyAssignmentId.
	Filter *string
}

// PolicyExemptionsListForResourceOptions contains the optional parameters for the PolicyExemptions.ListForResource method.
type PolicyExemptionsListForResourceOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
	// If $filter is not provided, no filtering is performed. If $filter is not provided, the unfiltered list includes all policy exemptions associated with
	// the scope, including those that apply directly or apply from containing scopes. If $filter=atScope() is provided, the returned list only includes all
	// policy exemptions that apply to the scope, which is everything in the unfiltered list except those applied to sub scopes contained within the given scope.
	// If $filter=atExactScope() is provided, the returned list only includes all policy exemptions that at the given scope. If $filter=excludeExpired() is
	// provided, the returned list only includes all policy exemptions that either haven't expired or didn't set expiration date. If $filter=policyAssignmentId
	// eq '{value}' is provided. the returned list only includes all policy exemptions that are associated with the give policyAssignmentId.
	Filter *string
}

// PolicyExemptionsListOptions contains the optional parameters for the PolicyExemptions.List method.
type PolicyExemptionsListOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
	// If $filter is not provided, no filtering is performed. If $filter is not provided, the unfiltered list includes all policy exemptions associated with
	// the scope, including those that apply directly or apply from containing scopes. If $filter=atScope() is provided, the returned list only includes all
	// policy exemptions that apply to the scope, which is everything in the unfiltered list except those applied to sub scopes contained within the given scope.
	// If $filter=atExactScope() is provided, the returned list only includes all policy exemptions that at the given scope. If $filter=excludeExpired() is
	// provided, the returned list only includes all policy exemptions that either haven't expired or didn't set expiration date. If $filter=policyAssignmentId
	// eq '{value}' is provided. the returned list only includes all policy exemptions that are associated with the give policyAssignmentId.
	Filter *string
}

// PolicySetDefinition - The policy set definition.
type PolicySetDefinition struct {
	// The policy definition properties.
	Properties *PolicySetDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; The ID of the policy set definition.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the policy set definition.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource (Microsoft.Authorization/policySetDefinitions).
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PolicySetDefinitionListResult - List of policy set definitions.
type PolicySetDefinitionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// An array of policy set definitions.
	Value []*PolicySetDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicySetDefinitionListResult.
func (p PolicySetDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PolicySetDefinitionProperties - The policy set definition properties.
type PolicySetDefinitionProperties struct {
	// REQUIRED; An array of policy definition references.
	PolicyDefinitions []*PolicyDefinitionReference `json:"policyDefinitions,omitempty"`

	// The policy set definition description.
	Description *string `json:"description,omitempty"`

	// The display name of the policy set definition.
	DisplayName *string `json:"displayName,omitempty"`

	// The policy set definition metadata. Metadata is an open ended object and is typically a collection of key value pairs.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// The policy set definition parameters that can be used in policy definition references.
	Parameters map[string]*ParameterDefinitionsValue `json:"parameters,omitempty"`

	// The metadata describing groups of policy definition references within the policy set definition.
	PolicyDefinitionGroups []*PolicyDefinitionGroup `json:"policyDefinitionGroups,omitempty"`

	// The type of policy definition. Possible values are NotSpecified, BuiltIn, Custom, and Static.
	PolicyType *PolicyType `json:"policyType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolicySetDefinitionProperties.
func (p PolicySetDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "metadata", p.Metadata)
	populate(objectMap, "parameters", p.Parameters)
	populate(objectMap, "policyDefinitionGroups", p.PolicyDefinitionGroups)
	populate(objectMap, "policyDefinitions", p.PolicyDefinitions)
	populate(objectMap, "policyType", p.PolicyType)
	return json.Marshal(objectMap)
}

// PolicySetDefinitionsCreateOrUpdateAtManagementGroupOptions contains the optional parameters for the PolicySetDefinitions.CreateOrUpdateAtManagementGroup
// method.
type PolicySetDefinitionsCreateOrUpdateAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsCreateOrUpdateOptions contains the optional parameters for the PolicySetDefinitions.CreateOrUpdate method.
type PolicySetDefinitionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsDeleteAtManagementGroupOptions contains the optional parameters for the PolicySetDefinitions.DeleteAtManagementGroup method.
type PolicySetDefinitionsDeleteAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsDeleteOptions contains the optional parameters for the PolicySetDefinitions.Delete method.
type PolicySetDefinitionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsGetAtManagementGroupOptions contains the optional parameters for the PolicySetDefinitions.GetAtManagementGroup method.
type PolicySetDefinitionsGetAtManagementGroupOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsGetBuiltInOptions contains the optional parameters for the PolicySetDefinitions.GetBuiltIn method.
type PolicySetDefinitionsGetBuiltInOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsGetOptions contains the optional parameters for the PolicySetDefinitions.Get method.
type PolicySetDefinitionsGetOptions struct {
	// placeholder for future optional parameters
}

// PolicySetDefinitionsListBuiltInOptions contains the optional parameters for the PolicySetDefinitions.ListBuiltIn method.
type PolicySetDefinitionsListBuiltInOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy set definitions that at
	// the given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy set definitions whose type match the {value}.
	// Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes
	// all policy set definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicySetDefinitionsListByManagementGroupOptions contains the optional parameters for the PolicySetDefinitions.ListByManagementGroup method.
type PolicySetDefinitionsListByManagementGroupOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy set definitions that at
	// the given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy set definitions whose type match the {value}.
	// Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes
	// all policy set definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// PolicySetDefinitionsListOptions contains the optional parameters for the PolicySetDefinitions.List method.
type PolicySetDefinitionsListOptions struct {
	// The filter to apply on the operation. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter
	// is not provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list only includes all policy set definitions that at
	// the given scope. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy set definitions whose type match the {value}.
	// Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the returned list only includes
	// all policy set definitions whose category match the {value}.
	Filter *string
	// Maximum number of records to return. When the $top filter is not provided, it will return 500 records.
	Top *int32
}

// ResourceTypeAliases - The resource type aliases definition.
type ResourceTypeAliases struct {
	// The aliases for property names.
	Aliases []*Alias `json:"aliases,omitempty"`

	// The resource type name.
	ResourceType *string `json:"resourceType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceTypeAliases.
func (r ResourceTypeAliases) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aliases", r.Aliases)
	populate(objectMap, "resourceType", r.ResourceType)
	return json.Marshal(objectMap)
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type UserAssignedIdentitiesValue struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
