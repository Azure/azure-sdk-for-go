//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicy

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AssignmentsClientListForManagementGroupPager provides operations for iterating over paged responses.
type AssignmentsClientListForManagementGroupPager struct {
	client    *AssignmentsClient
	current   AssignmentsClientListForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssignmentsClientListForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssignmentsClientListForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssignmentsClientListForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssignmentListResult.NextLink == nil || len(*p.current.AssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssignmentsClientListForManagementGroupResponse page.
func (p *AssignmentsClientListForManagementGroupPager) PageResponse() AssignmentsClientListForManagementGroupResponse {
	return p.current
}

// AssignmentsClientListForResourceGroupPager provides operations for iterating over paged responses.
type AssignmentsClientListForResourceGroupPager struct {
	client    *AssignmentsClient
	current   AssignmentsClientListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssignmentsClientListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssignmentsClientListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssignmentsClientListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssignmentListResult.NextLink == nil || len(*p.current.AssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssignmentsClientListForResourceGroupResponse page.
func (p *AssignmentsClientListForResourceGroupPager) PageResponse() AssignmentsClientListForResourceGroupResponse {
	return p.current
}

// AssignmentsClientListForResourcePager provides operations for iterating over paged responses.
type AssignmentsClientListForResourcePager struct {
	client    *AssignmentsClient
	current   AssignmentsClientListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssignmentsClientListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssignmentsClientListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssignmentsClientListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssignmentListResult.NextLink == nil || len(*p.current.AssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssignmentsClientListForResourceResponse page.
func (p *AssignmentsClientListForResourcePager) PageResponse() AssignmentsClientListForResourceResponse {
	return p.current
}

// AssignmentsClientListPager provides operations for iterating over paged responses.
type AssignmentsClientListPager struct {
	client    *AssignmentsClient
	current   AssignmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssignmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssignmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssignmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssignmentListResult.NextLink == nil || len(*p.current.AssignmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssignmentsClientListResponse page.
func (p *AssignmentsClientListPager) PageResponse() AssignmentsClientListResponse {
	return p.current
}

// DataPolicyManifestsClientListPager provides operations for iterating over paged responses.
type DataPolicyManifestsClientListPager struct {
	client    *DataPolicyManifestsClient
	current   DataPolicyManifestsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataPolicyManifestsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataPolicyManifestsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataPolicyManifestsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataPolicyManifestListResult.NextLink == nil || len(*p.current.DataPolicyManifestListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataPolicyManifestsClientListResponse page.
func (p *DataPolicyManifestsClientListPager) PageResponse() DataPolicyManifestsClientListResponse {
	return p.current
}

// DefinitionsClientListBuiltInPager provides operations for iterating over paged responses.
type DefinitionsClientListBuiltInPager struct {
	client    *DefinitionsClient
	current   DefinitionsClientListBuiltInResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefinitionsClientListBuiltInResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DefinitionsClientListBuiltInPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DefinitionsClientListBuiltInPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DefinitionListResult.NextLink == nil || len(*p.current.DefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBuiltInHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DefinitionsClientListBuiltInResponse page.
func (p *DefinitionsClientListBuiltInPager) PageResponse() DefinitionsClientListBuiltInResponse {
	return p.current
}

// DefinitionsClientListByManagementGroupPager provides operations for iterating over paged responses.
type DefinitionsClientListByManagementGroupPager struct {
	client    *DefinitionsClient
	current   DefinitionsClientListByManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefinitionsClientListByManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DefinitionsClientListByManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DefinitionsClientListByManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DefinitionListResult.NextLink == nil || len(*p.current.DefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DefinitionsClientListByManagementGroupResponse page.
func (p *DefinitionsClientListByManagementGroupPager) PageResponse() DefinitionsClientListByManagementGroupResponse {
	return p.current
}

// DefinitionsClientListPager provides operations for iterating over paged responses.
type DefinitionsClientListPager struct {
	client    *DefinitionsClient
	current   DefinitionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefinitionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DefinitionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DefinitionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DefinitionListResult.NextLink == nil || len(*p.current.DefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DefinitionsClientListResponse page.
func (p *DefinitionsClientListPager) PageResponse() DefinitionsClientListResponse {
	return p.current
}

// ExemptionsClientListForManagementGroupPager provides operations for iterating over paged responses.
type ExemptionsClientListForManagementGroupPager struct {
	client    *ExemptionsClient
	current   ExemptionsClientListForManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExemptionsClientListForManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExemptionsClientListForManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExemptionsClientListForManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExemptionListResult.NextLink == nil || len(*p.current.ExemptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExemptionsClientListForManagementGroupResponse page.
func (p *ExemptionsClientListForManagementGroupPager) PageResponse() ExemptionsClientListForManagementGroupResponse {
	return p.current
}

// ExemptionsClientListForResourceGroupPager provides operations for iterating over paged responses.
type ExemptionsClientListForResourceGroupPager struct {
	client    *ExemptionsClient
	current   ExemptionsClientListForResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExemptionsClientListForResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExemptionsClientListForResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExemptionsClientListForResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExemptionListResult.NextLink == nil || len(*p.current.ExemptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExemptionsClientListForResourceGroupResponse page.
func (p *ExemptionsClientListForResourceGroupPager) PageResponse() ExemptionsClientListForResourceGroupResponse {
	return p.current
}

// ExemptionsClientListForResourcePager provides operations for iterating over paged responses.
type ExemptionsClientListForResourcePager struct {
	client    *ExemptionsClient
	current   ExemptionsClientListForResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExemptionsClientListForResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExemptionsClientListForResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExemptionsClientListForResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExemptionListResult.NextLink == nil || len(*p.current.ExemptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listForResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExemptionsClientListForResourceResponse page.
func (p *ExemptionsClientListForResourcePager) PageResponse() ExemptionsClientListForResourceResponse {
	return p.current
}

// ExemptionsClientListPager provides operations for iterating over paged responses.
type ExemptionsClientListPager struct {
	client    *ExemptionsClient
	current   ExemptionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExemptionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExemptionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExemptionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExemptionListResult.NextLink == nil || len(*p.current.ExemptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExemptionsClientListResponse page.
func (p *ExemptionsClientListPager) PageResponse() ExemptionsClientListResponse {
	return p.current
}

// SetDefinitionsClientListBuiltInPager provides operations for iterating over paged responses.
type SetDefinitionsClientListBuiltInPager struct {
	client    *SetDefinitionsClient
	current   SetDefinitionsClientListBuiltInResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SetDefinitionsClientListBuiltInResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SetDefinitionsClientListBuiltInPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SetDefinitionsClientListBuiltInPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SetDefinitionListResult.NextLink == nil || len(*p.current.SetDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBuiltInHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SetDefinitionsClientListBuiltInResponse page.
func (p *SetDefinitionsClientListBuiltInPager) PageResponse() SetDefinitionsClientListBuiltInResponse {
	return p.current
}

// SetDefinitionsClientListByManagementGroupPager provides operations for iterating over paged responses.
type SetDefinitionsClientListByManagementGroupPager struct {
	client    *SetDefinitionsClient
	current   SetDefinitionsClientListByManagementGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SetDefinitionsClientListByManagementGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SetDefinitionsClientListByManagementGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SetDefinitionsClientListByManagementGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SetDefinitionListResult.NextLink == nil || len(*p.current.SetDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagementGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SetDefinitionsClientListByManagementGroupResponse page.
func (p *SetDefinitionsClientListByManagementGroupPager) PageResponse() SetDefinitionsClientListByManagementGroupResponse {
	return p.current
}

// SetDefinitionsClientListPager provides operations for iterating over paged responses.
type SetDefinitionsClientListPager struct {
	client    *SetDefinitionsClient
	current   SetDefinitionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SetDefinitionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SetDefinitionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SetDefinitionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SetDefinitionListResult.NextLink == nil || len(*p.current.SetDefinitionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SetDefinitionsClientListResponse page.
func (p *SetDefinitionsClientListPager) PageResponse() SetDefinitionsClientListResponse {
	return p.current
}
