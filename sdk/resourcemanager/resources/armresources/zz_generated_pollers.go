//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// DeploymentsCreateOrUpdateAtManagementGroupScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdateAtManagementGroupScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsCreateOrUpdateAtManagementGroupScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsCreateOrUpdateAtManagementGroupScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsCreateOrUpdateAtManagementGroupScopeResponse will be returned.
func (p *DeploymentsCreateOrUpdateAtManagementGroupScopePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateAtManagementGroupScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtManagementGroupScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentExtended)
	if err != nil {
		return DeploymentsCreateOrUpdateAtManagementGroupScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsCreateOrUpdateAtManagementGroupScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsCreateOrUpdateAtScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdateAtScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsCreateOrUpdateAtScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsCreateOrUpdateAtScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsCreateOrUpdateAtScopeResponse will be returned.
func (p *DeploymentsCreateOrUpdateAtScopePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateAtScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentExtended)
	if err != nil {
		return DeploymentsCreateOrUpdateAtScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsCreateOrUpdateAtScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsCreateOrUpdateAtSubscriptionScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdateAtSubscriptionScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsCreateOrUpdateAtSubscriptionScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsCreateOrUpdateAtSubscriptionScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsCreateOrUpdateAtSubscriptionScopeResponse will be returned.
func (p *DeploymentsCreateOrUpdateAtSubscriptionScopePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateAtSubscriptionScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtSubscriptionScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentExtended)
	if err != nil {
		return DeploymentsCreateOrUpdateAtSubscriptionScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsCreateOrUpdateAtSubscriptionScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsCreateOrUpdateAtTenantScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdateAtTenantScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsCreateOrUpdateAtTenantScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsCreateOrUpdateAtTenantScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsCreateOrUpdateAtTenantScopeResponse will be returned.
func (p *DeploymentsCreateOrUpdateAtTenantScopePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateAtTenantScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtTenantScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentExtended)
	if err != nil {
		return DeploymentsCreateOrUpdateAtTenantScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsCreateOrUpdateAtTenantScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsCreateOrUpdateResponse will be returned.
func (p *DeploymentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateResponse, error) {
	respType := DeploymentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentExtended)
	if err != nil {
		return DeploymentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsDeleteAtManagementGroupScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeleteAtManagementGroupScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsDeleteAtManagementGroupScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsDeleteAtManagementGroupScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsDeleteAtManagementGroupScopeResponse will be returned.
func (p *DeploymentsDeleteAtManagementGroupScopePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteAtManagementGroupScopeResponse, error) {
	respType := DeploymentsDeleteAtManagementGroupScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteAtManagementGroupScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsDeleteAtManagementGroupScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsDeleteAtScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeleteAtScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsDeleteAtScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsDeleteAtScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsDeleteAtScopeResponse will be returned.
func (p *DeploymentsDeleteAtScopePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteAtScopeResponse, error) {
	respType := DeploymentsDeleteAtScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteAtScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsDeleteAtScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsDeleteAtSubscriptionScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeleteAtSubscriptionScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsDeleteAtSubscriptionScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsDeleteAtSubscriptionScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsDeleteAtSubscriptionScopeResponse will be returned.
func (p *DeploymentsDeleteAtSubscriptionScopePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteAtSubscriptionScopeResponse, error) {
	respType := DeploymentsDeleteAtSubscriptionScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteAtSubscriptionScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsDeleteAtSubscriptionScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsDeleteAtTenantScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeleteAtTenantScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsDeleteAtTenantScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsDeleteAtTenantScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsDeleteAtTenantScopeResponse will be returned.
func (p *DeploymentsDeleteAtTenantScopePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteAtTenantScopeResponse, error) {
	respType := DeploymentsDeleteAtTenantScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteAtTenantScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsDeleteAtTenantScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsDeleteResponse will be returned.
func (p *DeploymentsDeletePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteResponse, error) {
	respType := DeploymentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsValidateAtManagementGroupScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsValidateAtManagementGroupScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsValidateAtManagementGroupScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsValidateAtManagementGroupScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsValidateAtManagementGroupScopeResponse will be returned.
func (p *DeploymentsValidateAtManagementGroupScopePoller) FinalResponse(ctx context.Context) (DeploymentsValidateAtManagementGroupScopeResponse, error) {
	respType := DeploymentsValidateAtManagementGroupScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentValidateResult)
	if err != nil {
		return DeploymentsValidateAtManagementGroupScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsValidateAtManagementGroupScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsValidateAtScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsValidateAtScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsValidateAtScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsValidateAtScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsValidateAtScopeResponse will be returned.
func (p *DeploymentsValidateAtScopePoller) FinalResponse(ctx context.Context) (DeploymentsValidateAtScopeResponse, error) {
	respType := DeploymentsValidateAtScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentValidateResult)
	if err != nil {
		return DeploymentsValidateAtScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsValidateAtScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsValidateAtSubscriptionScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsValidateAtSubscriptionScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsValidateAtSubscriptionScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsValidateAtSubscriptionScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsValidateAtSubscriptionScopeResponse will be returned.
func (p *DeploymentsValidateAtSubscriptionScopePoller) FinalResponse(ctx context.Context) (DeploymentsValidateAtSubscriptionScopeResponse, error) {
	respType := DeploymentsValidateAtSubscriptionScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentValidateResult)
	if err != nil {
		return DeploymentsValidateAtSubscriptionScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsValidateAtSubscriptionScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsValidateAtTenantScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsValidateAtTenantScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsValidateAtTenantScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsValidateAtTenantScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsValidateAtTenantScopeResponse will be returned.
func (p *DeploymentsValidateAtTenantScopePoller) FinalResponse(ctx context.Context) (DeploymentsValidateAtTenantScopeResponse, error) {
	respType := DeploymentsValidateAtTenantScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentValidateResult)
	if err != nil {
		return DeploymentsValidateAtTenantScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsValidateAtTenantScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsValidatePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsValidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsValidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsValidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsValidateResponse will be returned.
func (p *DeploymentsValidatePoller) FinalResponse(ctx context.Context) (DeploymentsValidateResponse, error) {
	respType := DeploymentsValidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentValidateResult)
	if err != nil {
		return DeploymentsValidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsValidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsWhatIfAtManagementGroupScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsWhatIfAtManagementGroupScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsWhatIfAtManagementGroupScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsWhatIfAtManagementGroupScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsWhatIfAtManagementGroupScopeResponse will be returned.
func (p *DeploymentsWhatIfAtManagementGroupScopePoller) FinalResponse(ctx context.Context) (DeploymentsWhatIfAtManagementGroupScopeResponse, error) {
	respType := DeploymentsWhatIfAtManagementGroupScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WhatIfOperationResult)
	if err != nil {
		return DeploymentsWhatIfAtManagementGroupScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsWhatIfAtManagementGroupScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsWhatIfAtSubscriptionScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsWhatIfAtSubscriptionScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsWhatIfAtSubscriptionScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsWhatIfAtSubscriptionScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsWhatIfAtSubscriptionScopeResponse will be returned.
func (p *DeploymentsWhatIfAtSubscriptionScopePoller) FinalResponse(ctx context.Context) (DeploymentsWhatIfAtSubscriptionScopeResponse, error) {
	respType := DeploymentsWhatIfAtSubscriptionScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WhatIfOperationResult)
	if err != nil {
		return DeploymentsWhatIfAtSubscriptionScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsWhatIfAtSubscriptionScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsWhatIfAtTenantScopePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsWhatIfAtTenantScopePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsWhatIfAtTenantScopePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsWhatIfAtTenantScopePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsWhatIfAtTenantScopeResponse will be returned.
func (p *DeploymentsWhatIfAtTenantScopePoller) FinalResponse(ctx context.Context) (DeploymentsWhatIfAtTenantScopeResponse, error) {
	respType := DeploymentsWhatIfAtTenantScopeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WhatIfOperationResult)
	if err != nil {
		return DeploymentsWhatIfAtTenantScopeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsWhatIfAtTenantScopePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeploymentsWhatIfPoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsWhatIfPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeploymentsWhatIfPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeploymentsWhatIfPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeploymentsWhatIfResponse will be returned.
func (p *DeploymentsWhatIfPoller) FinalResponse(ctx context.Context) (DeploymentsWhatIfResponse, error) {
	respType := DeploymentsWhatIfResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WhatIfOperationResult)
	if err != nil {
		return DeploymentsWhatIfResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeploymentsWhatIfPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourceGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ResourceGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourceGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourceGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourceGroupsDeleteResponse will be returned.
func (p *ResourceGroupsDeletePoller) FinalResponse(ctx context.Context) (ResourceGroupsDeleteResponse, error) {
	respType := ResourceGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ResourceGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourceGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourceGroupsExportTemplatePoller provides polling facilities until the operation reaches a terminal state.
type ResourceGroupsExportTemplatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourceGroupsExportTemplatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourceGroupsExportTemplatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourceGroupsExportTemplateResponse will be returned.
func (p *ResourceGroupsExportTemplatePoller) FinalResponse(ctx context.Context) (ResourceGroupsExportTemplateResponse, error) {
	respType := ResourceGroupsExportTemplateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ResourceGroupExportResult)
	if err != nil {
		return ResourceGroupsExportTemplateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourceGroupsExportTemplatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesCreateOrUpdateByIDPoller provides polling facilities until the operation reaches a terminal state.
type ResourcesCreateOrUpdateByIDPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesCreateOrUpdateByIDPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesCreateOrUpdateByIDPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesCreateOrUpdateByIDResponse will be returned.
func (p *ResourcesCreateOrUpdateByIDPoller) FinalResponse(ctx context.Context) (ResourcesCreateOrUpdateByIDResponse, error) {
	respType := ResourcesCreateOrUpdateByIDResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GenericResource)
	if err != nil {
		return ResourcesCreateOrUpdateByIDResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesCreateOrUpdateByIDPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ResourcesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesCreateOrUpdateResponse will be returned.
func (p *ResourcesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ResourcesCreateOrUpdateResponse, error) {
	respType := ResourcesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GenericResource)
	if err != nil {
		return ResourcesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesDeleteByIDPoller provides polling facilities until the operation reaches a terminal state.
type ResourcesDeleteByIDPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesDeleteByIDPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesDeleteByIDPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesDeleteByIDResponse will be returned.
func (p *ResourcesDeleteByIDPoller) FinalResponse(ctx context.Context) (ResourcesDeleteByIDResponse, error) {
	respType := ResourcesDeleteByIDResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ResourcesDeleteByIDResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesDeleteByIDPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ResourcesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesDeleteResponse will be returned.
func (p *ResourcesDeletePoller) FinalResponse(ctx context.Context) (ResourcesDeleteResponse, error) {
	respType := ResourcesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ResourcesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesMoveResourcesPoller provides polling facilities until the operation reaches a terminal state.
type ResourcesMoveResourcesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesMoveResourcesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesMoveResourcesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesMoveResourcesResponse will be returned.
func (p *ResourcesMoveResourcesPoller) FinalResponse(ctx context.Context) (ResourcesMoveResourcesResponse, error) {
	respType := ResourcesMoveResourcesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ResourcesMoveResourcesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesMoveResourcesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesUpdateByIDPoller provides polling facilities until the operation reaches a terminal state.
type ResourcesUpdateByIDPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesUpdateByIDPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesUpdateByIDPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesUpdateByIDResponse will be returned.
func (p *ResourcesUpdateByIDPoller) FinalResponse(ctx context.Context) (ResourcesUpdateByIDResponse, error) {
	respType := ResourcesUpdateByIDResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GenericResource)
	if err != nil {
		return ResourcesUpdateByIDResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesUpdateByIDPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ResourcesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesUpdateResponse will be returned.
func (p *ResourcesUpdatePoller) FinalResponse(ctx context.Context) (ResourcesUpdateResponse, error) {
	respType := ResourcesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GenericResource)
	if err != nil {
		return ResourcesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ResourcesValidateMoveResourcesPoller provides polling facilities until the operation reaches a terminal state.
type ResourcesValidateMoveResourcesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ResourcesValidateMoveResourcesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ResourcesValidateMoveResourcesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ResourcesValidateMoveResourcesResponse will be returned.
func (p *ResourcesValidateMoveResourcesPoller) FinalResponse(ctx context.Context) (ResourcesValidateMoveResourcesResponse, error) {
	respType := ResourcesValidateMoveResourcesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ResourcesValidateMoveResourcesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ResourcesValidateMoveResourcesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
