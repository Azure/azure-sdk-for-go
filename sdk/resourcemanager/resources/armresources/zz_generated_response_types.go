//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DeploymentOperationsGetAtManagementGroupScopeResponse contains the response from method DeploymentOperations.GetAtManagementGroupScope.
type DeploymentOperationsGetAtManagementGroupScopeResponse struct {
	DeploymentOperationsGetAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsGetAtManagementGroupScopeResult contains the result from method DeploymentOperations.GetAtManagementGroupScope.
type DeploymentOperationsGetAtManagementGroupScopeResult struct {
	DeploymentOperation
}

// DeploymentOperationsGetAtScopeResponse contains the response from method DeploymentOperations.GetAtScope.
type DeploymentOperationsGetAtScopeResponse struct {
	DeploymentOperationsGetAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsGetAtScopeResult contains the result from method DeploymentOperations.GetAtScope.
type DeploymentOperationsGetAtScopeResult struct {
	DeploymentOperation
}

// DeploymentOperationsGetAtSubscriptionScopeResponse contains the response from method DeploymentOperations.GetAtSubscriptionScope.
type DeploymentOperationsGetAtSubscriptionScopeResponse struct {
	DeploymentOperationsGetAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsGetAtSubscriptionScopeResult contains the result from method DeploymentOperations.GetAtSubscriptionScope.
type DeploymentOperationsGetAtSubscriptionScopeResult struct {
	DeploymentOperation
}

// DeploymentOperationsGetAtTenantScopeResponse contains the response from method DeploymentOperations.GetAtTenantScope.
type DeploymentOperationsGetAtTenantScopeResponse struct {
	DeploymentOperationsGetAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsGetAtTenantScopeResult contains the result from method DeploymentOperations.GetAtTenantScope.
type DeploymentOperationsGetAtTenantScopeResult struct {
	DeploymentOperation
}

// DeploymentOperationsGetResponse contains the response from method DeploymentOperations.Get.
type DeploymentOperationsGetResponse struct {
	DeploymentOperationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsGetResult contains the result from method DeploymentOperations.Get.
type DeploymentOperationsGetResult struct {
	DeploymentOperation
}

// DeploymentOperationsListAtManagementGroupScopeResponse contains the response from method DeploymentOperations.ListAtManagementGroupScope.
type DeploymentOperationsListAtManagementGroupScopeResponse struct {
	DeploymentOperationsListAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsListAtManagementGroupScopeResult contains the result from method DeploymentOperations.ListAtManagementGroupScope.
type DeploymentOperationsListAtManagementGroupScopeResult struct {
	DeploymentOperationsListResult
}

// DeploymentOperationsListAtScopeResponse contains the response from method DeploymentOperations.ListAtScope.
type DeploymentOperationsListAtScopeResponse struct {
	DeploymentOperationsListAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsListAtScopeResult contains the result from method DeploymentOperations.ListAtScope.
type DeploymentOperationsListAtScopeResult struct {
	DeploymentOperationsListResult
}

// DeploymentOperationsListAtSubscriptionScopeResponse contains the response from method DeploymentOperations.ListAtSubscriptionScope.
type DeploymentOperationsListAtSubscriptionScopeResponse struct {
	DeploymentOperationsListAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsListAtSubscriptionScopeResult contains the result from method DeploymentOperations.ListAtSubscriptionScope.
type DeploymentOperationsListAtSubscriptionScopeResult struct {
	DeploymentOperationsListResult
}

// DeploymentOperationsListAtTenantScopeResponse contains the response from method DeploymentOperations.ListAtTenantScope.
type DeploymentOperationsListAtTenantScopeResponse struct {
	DeploymentOperationsListAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsListAtTenantScopeResult contains the result from method DeploymentOperations.ListAtTenantScope.
type DeploymentOperationsListAtTenantScopeResult struct {
	DeploymentOperationsListResult
}

// DeploymentOperationsListResponse contains the response from method DeploymentOperations.List.
type DeploymentOperationsListResponse struct {
	DeploymentOperationsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentOperationsListResultEnvelope contains the result from method DeploymentOperations.List.
type DeploymentOperationsListResultEnvelope struct {
	DeploymentOperationsListResult
}

// DeploymentsCalculateTemplateHashResponse contains the response from method Deployments.CalculateTemplateHash.
type DeploymentsCalculateTemplateHashResponse struct {
	DeploymentsCalculateTemplateHashResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCalculateTemplateHashResult contains the result from method Deployments.CalculateTemplateHash.
type DeploymentsCalculateTemplateHashResult struct {
	TemplateHashResult
}

// DeploymentsCancelAtManagementGroupScopeResponse contains the response from method Deployments.CancelAtManagementGroupScope.
type DeploymentsCancelAtManagementGroupScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCancelAtScopeResponse contains the response from method Deployments.CancelAtScope.
type DeploymentsCancelAtScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCancelAtSubscriptionScopeResponse contains the response from method Deployments.CancelAtSubscriptionScope.
type DeploymentsCancelAtSubscriptionScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCancelAtTenantScopeResponse contains the response from method Deployments.CancelAtTenantScope.
type DeploymentsCancelAtTenantScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCancelResponse contains the response from method Deployments.Cancel.
type DeploymentsCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceAtManagementGroupScopeResponse contains the response from method Deployments.CheckExistenceAtManagementGroupScope.
type DeploymentsCheckExistenceAtManagementGroupScopeResponse struct {
	DeploymentsCheckExistenceAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceAtManagementGroupScopeResult contains the result from method Deployments.CheckExistenceAtManagementGroupScope.
type DeploymentsCheckExistenceAtManagementGroupScopeResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DeploymentsCheckExistenceAtScopeResponse contains the response from method Deployments.CheckExistenceAtScope.
type DeploymentsCheckExistenceAtScopeResponse struct {
	DeploymentsCheckExistenceAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceAtScopeResult contains the result from method Deployments.CheckExistenceAtScope.
type DeploymentsCheckExistenceAtScopeResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DeploymentsCheckExistenceAtSubscriptionScopeResponse contains the response from method Deployments.CheckExistenceAtSubscriptionScope.
type DeploymentsCheckExistenceAtSubscriptionScopeResponse struct {
	DeploymentsCheckExistenceAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceAtSubscriptionScopeResult contains the result from method Deployments.CheckExistenceAtSubscriptionScope.
type DeploymentsCheckExistenceAtSubscriptionScopeResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DeploymentsCheckExistenceAtTenantScopeResponse contains the response from method Deployments.CheckExistenceAtTenantScope.
type DeploymentsCheckExistenceAtTenantScopeResponse struct {
	DeploymentsCheckExistenceAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceAtTenantScopeResult contains the result from method Deployments.CheckExistenceAtTenantScope.
type DeploymentsCheckExistenceAtTenantScopeResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DeploymentsCheckExistenceResponse contains the response from method Deployments.CheckExistence.
type DeploymentsCheckExistenceResponse struct {
	DeploymentsCheckExistenceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCheckExistenceResult contains the result from method Deployments.CheckExistence.
type DeploymentsCheckExistenceResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// DeploymentsCreateOrUpdateAtManagementGroupScopePollerResponse contains the response from method Deployments.CreateOrUpdateAtManagementGroupScope.
type DeploymentsCreateOrUpdateAtManagementGroupScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdateAtManagementGroupScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsCreateOrUpdateAtManagementGroupScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateAtManagementGroupScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtManagementGroupScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentExtended)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdateAtManagementGroupScopePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdateAtManagementGroupScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", token, client.pl, client.createOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdateAtManagementGroupScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateAtManagementGroupScopeResponse contains the response from method Deployments.CreateOrUpdateAtManagementGroupScope.
type DeploymentsCreateOrUpdateAtManagementGroupScopeResponse struct {
	DeploymentsCreateOrUpdateAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateAtManagementGroupScopeResult contains the result from method Deployments.CreateOrUpdateAtManagementGroupScope.
type DeploymentsCreateOrUpdateAtManagementGroupScopeResult struct {
	DeploymentExtended
}

// DeploymentsCreateOrUpdateAtScopePollerResponse contains the response from method Deployments.CreateOrUpdateAtScope.
type DeploymentsCreateOrUpdateAtScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdateAtScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsCreateOrUpdateAtScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateAtScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentExtended)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdateAtScopePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdateAtScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtScope", token, client.pl, client.createOrUpdateAtScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdateAtScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateAtScopeResponse contains the response from method Deployments.CreateOrUpdateAtScope.
type DeploymentsCreateOrUpdateAtScopeResponse struct {
	DeploymentsCreateOrUpdateAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateAtScopeResult contains the result from method Deployments.CreateOrUpdateAtScope.
type DeploymentsCreateOrUpdateAtScopeResult struct {
	DeploymentExtended
}

// DeploymentsCreateOrUpdateAtSubscriptionScopePollerResponse contains the response from method Deployments.CreateOrUpdateAtSubscriptionScope.
type DeploymentsCreateOrUpdateAtSubscriptionScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdateAtSubscriptionScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsCreateOrUpdateAtSubscriptionScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateAtSubscriptionScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtSubscriptionScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentExtended)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdateAtSubscriptionScopePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdateAtSubscriptionScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", token, client.pl, client.createOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdateAtSubscriptionScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateAtSubscriptionScopeResponse contains the response from method Deployments.CreateOrUpdateAtSubscriptionScope.
type DeploymentsCreateOrUpdateAtSubscriptionScopeResponse struct {
	DeploymentsCreateOrUpdateAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateAtSubscriptionScopeResult contains the result from method Deployments.CreateOrUpdateAtSubscriptionScope.
type DeploymentsCreateOrUpdateAtSubscriptionScopeResult struct {
	DeploymentExtended
}

// DeploymentsCreateOrUpdateAtTenantScopePollerResponse contains the response from method Deployments.CreateOrUpdateAtTenantScope.
type DeploymentsCreateOrUpdateAtTenantScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdateAtTenantScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsCreateOrUpdateAtTenantScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateAtTenantScopeResponse, error) {
	respType := DeploymentsCreateOrUpdateAtTenantScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentExtended)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdateAtTenantScopePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdateAtTenantScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtTenantScope", token, client.pl, client.createOrUpdateAtTenantScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdateAtTenantScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateAtTenantScopeResponse contains the response from method Deployments.CreateOrUpdateAtTenantScope.
type DeploymentsCreateOrUpdateAtTenantScopeResponse struct {
	DeploymentsCreateOrUpdateAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateAtTenantScopeResult contains the result from method Deployments.CreateOrUpdateAtTenantScope.
type DeploymentsCreateOrUpdateAtTenantScopeResult struct {
	DeploymentExtended
}

// DeploymentsCreateOrUpdatePollerResponse contains the response from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateResponse, error) {
	respType := DeploymentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentExtended)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DeploymentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsCreateOrUpdateResponse contains the response from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdateResponse struct {
	DeploymentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsCreateOrUpdateResult contains the result from method Deployments.CreateOrUpdate.
type DeploymentsCreateOrUpdateResult struct {
	DeploymentExtended
}

// DeploymentsDeleteAtManagementGroupScopePollerResponse contains the response from method Deployments.DeleteAtManagementGroupScope.
type DeploymentsDeleteAtManagementGroupScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeleteAtManagementGroupScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsDeleteAtManagementGroupScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteAtManagementGroupScopeResponse, error) {
	respType := DeploymentsDeleteAtManagementGroupScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeleteAtManagementGroupScopePollerResponse from the provided client and resume token.
func (l *DeploymentsDeleteAtManagementGroupScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.DeleteAtManagementGroupScope", token, client.pl, client.deleteAtManagementGroupScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeleteAtManagementGroupScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteAtManagementGroupScopeResponse contains the response from method Deployments.DeleteAtManagementGroupScope.
type DeploymentsDeleteAtManagementGroupScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsDeleteAtScopePollerResponse contains the response from method Deployments.DeleteAtScope.
type DeploymentsDeleteAtScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeleteAtScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsDeleteAtScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteAtScopeResponse, error) {
	respType := DeploymentsDeleteAtScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeleteAtScopePollerResponse from the provided client and resume token.
func (l *DeploymentsDeleteAtScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.DeleteAtScope", token, client.pl, client.deleteAtScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeleteAtScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteAtScopeResponse contains the response from method Deployments.DeleteAtScope.
type DeploymentsDeleteAtScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsDeleteAtSubscriptionScopePollerResponse contains the response from method Deployments.DeleteAtSubscriptionScope.
type DeploymentsDeleteAtSubscriptionScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeleteAtSubscriptionScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsDeleteAtSubscriptionScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteAtSubscriptionScopeResponse, error) {
	respType := DeploymentsDeleteAtSubscriptionScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeleteAtSubscriptionScopePollerResponse from the provided client and resume token.
func (l *DeploymentsDeleteAtSubscriptionScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.DeleteAtSubscriptionScope", token, client.pl, client.deleteAtSubscriptionScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeleteAtSubscriptionScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteAtSubscriptionScopeResponse contains the response from method Deployments.DeleteAtSubscriptionScope.
type DeploymentsDeleteAtSubscriptionScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsDeleteAtTenantScopePollerResponse contains the response from method Deployments.DeleteAtTenantScope.
type DeploymentsDeleteAtTenantScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeleteAtTenantScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsDeleteAtTenantScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteAtTenantScopeResponse, error) {
	respType := DeploymentsDeleteAtTenantScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeleteAtTenantScopePollerResponse from the provided client and resume token.
func (l *DeploymentsDeleteAtTenantScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.DeleteAtTenantScope", token, client.pl, client.deleteAtTenantScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeleteAtTenantScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteAtTenantScopeResponse contains the response from method Deployments.DeleteAtTenantScope.
type DeploymentsDeleteAtTenantScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsDeletePollerResponse contains the response from method Deployments.Delete.
type DeploymentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteResponse, error) {
	respType := DeploymentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsDeletePollerResponse from the provided client and resume token.
func (l *DeploymentsDeletePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsDeleteResponse contains the response from method Deployments.Delete.
type DeploymentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateAtManagementGroupScopeResponse contains the response from method Deployments.ExportTemplateAtManagementGroupScope.
type DeploymentsExportTemplateAtManagementGroupScopeResponse struct {
	DeploymentsExportTemplateAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateAtManagementGroupScopeResult contains the result from method Deployments.ExportTemplateAtManagementGroupScope.
type DeploymentsExportTemplateAtManagementGroupScopeResult struct {
	DeploymentExportResult
}

// DeploymentsExportTemplateAtScopeResponse contains the response from method Deployments.ExportTemplateAtScope.
type DeploymentsExportTemplateAtScopeResponse struct {
	DeploymentsExportTemplateAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateAtScopeResult contains the result from method Deployments.ExportTemplateAtScope.
type DeploymentsExportTemplateAtScopeResult struct {
	DeploymentExportResult
}

// DeploymentsExportTemplateAtSubscriptionScopeResponse contains the response from method Deployments.ExportTemplateAtSubscriptionScope.
type DeploymentsExportTemplateAtSubscriptionScopeResponse struct {
	DeploymentsExportTemplateAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateAtSubscriptionScopeResult contains the result from method Deployments.ExportTemplateAtSubscriptionScope.
type DeploymentsExportTemplateAtSubscriptionScopeResult struct {
	DeploymentExportResult
}

// DeploymentsExportTemplateAtTenantScopeResponse contains the response from method Deployments.ExportTemplateAtTenantScope.
type DeploymentsExportTemplateAtTenantScopeResponse struct {
	DeploymentsExportTemplateAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateAtTenantScopeResult contains the result from method Deployments.ExportTemplateAtTenantScope.
type DeploymentsExportTemplateAtTenantScopeResult struct {
	DeploymentExportResult
}

// DeploymentsExportTemplateResponse contains the response from method Deployments.ExportTemplate.
type DeploymentsExportTemplateResponse struct {
	DeploymentsExportTemplateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsExportTemplateResult contains the result from method Deployments.ExportTemplate.
type DeploymentsExportTemplateResult struct {
	DeploymentExportResult
}

// DeploymentsGetAtManagementGroupScopeResponse contains the response from method Deployments.GetAtManagementGroupScope.
type DeploymentsGetAtManagementGroupScopeResponse struct {
	DeploymentsGetAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetAtManagementGroupScopeResult contains the result from method Deployments.GetAtManagementGroupScope.
type DeploymentsGetAtManagementGroupScopeResult struct {
	DeploymentExtended
}

// DeploymentsGetAtScopeResponse contains the response from method Deployments.GetAtScope.
type DeploymentsGetAtScopeResponse struct {
	DeploymentsGetAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetAtScopeResult contains the result from method Deployments.GetAtScope.
type DeploymentsGetAtScopeResult struct {
	DeploymentExtended
}

// DeploymentsGetAtSubscriptionScopeResponse contains the response from method Deployments.GetAtSubscriptionScope.
type DeploymentsGetAtSubscriptionScopeResponse struct {
	DeploymentsGetAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetAtSubscriptionScopeResult contains the result from method Deployments.GetAtSubscriptionScope.
type DeploymentsGetAtSubscriptionScopeResult struct {
	DeploymentExtended
}

// DeploymentsGetAtTenantScopeResponse contains the response from method Deployments.GetAtTenantScope.
type DeploymentsGetAtTenantScopeResponse struct {
	DeploymentsGetAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetAtTenantScopeResult contains the result from method Deployments.GetAtTenantScope.
type DeploymentsGetAtTenantScopeResult struct {
	DeploymentExtended
}

// DeploymentsGetResponse contains the response from method Deployments.Get.
type DeploymentsGetResponse struct {
	DeploymentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsGetResult contains the result from method Deployments.Get.
type DeploymentsGetResult struct {
	DeploymentExtended
}

// DeploymentsListAtManagementGroupScopeResponse contains the response from method Deployments.ListAtManagementGroupScope.
type DeploymentsListAtManagementGroupScopeResponse struct {
	DeploymentsListAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListAtManagementGroupScopeResult contains the result from method Deployments.ListAtManagementGroupScope.
type DeploymentsListAtManagementGroupScopeResult struct {
	DeploymentListResult
}

// DeploymentsListAtScopeResponse contains the response from method Deployments.ListAtScope.
type DeploymentsListAtScopeResponse struct {
	DeploymentsListAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListAtScopeResult contains the result from method Deployments.ListAtScope.
type DeploymentsListAtScopeResult struct {
	DeploymentListResult
}

// DeploymentsListAtSubscriptionScopeResponse contains the response from method Deployments.ListAtSubscriptionScope.
type DeploymentsListAtSubscriptionScopeResponse struct {
	DeploymentsListAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListAtSubscriptionScopeResult contains the result from method Deployments.ListAtSubscriptionScope.
type DeploymentsListAtSubscriptionScopeResult struct {
	DeploymentListResult
}

// DeploymentsListAtTenantScopeResponse contains the response from method Deployments.ListAtTenantScope.
type DeploymentsListAtTenantScopeResponse struct {
	DeploymentsListAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListAtTenantScopeResult contains the result from method Deployments.ListAtTenantScope.
type DeploymentsListAtTenantScopeResult struct {
	DeploymentListResult
}

// DeploymentsListByResourceGroupResponse contains the response from method Deployments.ListByResourceGroup.
type DeploymentsListByResourceGroupResponse struct {
	DeploymentsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsListByResourceGroupResult contains the result from method Deployments.ListByResourceGroup.
type DeploymentsListByResourceGroupResult struct {
	DeploymentListResult
}

// DeploymentsValidateAtManagementGroupScopePollerResponse contains the response from method Deployments.ValidateAtManagementGroupScope.
type DeploymentsValidateAtManagementGroupScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsValidateAtManagementGroupScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsValidateAtManagementGroupScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsValidateAtManagementGroupScopeResponse, error) {
	respType := DeploymentsValidateAtManagementGroupScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsValidateAtManagementGroupScopePollerResponse from the provided client and resume token.
func (l *DeploymentsValidateAtManagementGroupScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.ValidateAtManagementGroupScope", token, client.pl, client.validateAtManagementGroupScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsValidateAtManagementGroupScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsValidateAtManagementGroupScopeResponse contains the response from method Deployments.ValidateAtManagementGroupScope.
type DeploymentsValidateAtManagementGroupScopeResponse struct {
	DeploymentsValidateAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsValidateAtManagementGroupScopeResult contains the result from method Deployments.ValidateAtManagementGroupScope.
type DeploymentsValidateAtManagementGroupScopeResult struct {
	DeploymentValidateResult
}

// DeploymentsValidateAtScopePollerResponse contains the response from method Deployments.ValidateAtScope.
type DeploymentsValidateAtScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsValidateAtScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsValidateAtScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsValidateAtScopeResponse, error) {
	respType := DeploymentsValidateAtScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsValidateAtScopePollerResponse from the provided client and resume token.
func (l *DeploymentsValidateAtScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.ValidateAtScope", token, client.pl, client.validateAtScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsValidateAtScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsValidateAtScopeResponse contains the response from method Deployments.ValidateAtScope.
type DeploymentsValidateAtScopeResponse struct {
	DeploymentsValidateAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsValidateAtScopeResult contains the result from method Deployments.ValidateAtScope.
type DeploymentsValidateAtScopeResult struct {
	DeploymentValidateResult
}

// DeploymentsValidateAtSubscriptionScopePollerResponse contains the response from method Deployments.ValidateAtSubscriptionScope.
type DeploymentsValidateAtSubscriptionScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsValidateAtSubscriptionScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsValidateAtSubscriptionScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsValidateAtSubscriptionScopeResponse, error) {
	respType := DeploymentsValidateAtSubscriptionScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsValidateAtSubscriptionScopePollerResponse from the provided client and resume token.
func (l *DeploymentsValidateAtSubscriptionScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.ValidateAtSubscriptionScope", token, client.pl, client.validateAtSubscriptionScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsValidateAtSubscriptionScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsValidateAtSubscriptionScopeResponse contains the response from method Deployments.ValidateAtSubscriptionScope.
type DeploymentsValidateAtSubscriptionScopeResponse struct {
	DeploymentsValidateAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsValidateAtSubscriptionScopeResult contains the result from method Deployments.ValidateAtSubscriptionScope.
type DeploymentsValidateAtSubscriptionScopeResult struct {
	DeploymentValidateResult
}

// DeploymentsValidateAtTenantScopePollerResponse contains the response from method Deployments.ValidateAtTenantScope.
type DeploymentsValidateAtTenantScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsValidateAtTenantScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsValidateAtTenantScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsValidateAtTenantScopeResponse, error) {
	respType := DeploymentsValidateAtTenantScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsValidateAtTenantScopePollerResponse from the provided client and resume token.
func (l *DeploymentsValidateAtTenantScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.ValidateAtTenantScope", token, client.pl, client.validateAtTenantScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsValidateAtTenantScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsValidateAtTenantScopeResponse contains the response from method Deployments.ValidateAtTenantScope.
type DeploymentsValidateAtTenantScopeResponse struct {
	DeploymentsValidateAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsValidateAtTenantScopeResult contains the result from method Deployments.ValidateAtTenantScope.
type DeploymentsValidateAtTenantScopeResult struct {
	DeploymentValidateResult
}

// DeploymentsValidatePollerResponse contains the response from method Deployments.Validate.
type DeploymentsValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsValidateResponse, error) {
	respType := DeploymentsValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeploymentValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsValidatePollerResponse from the provided client and resume token.
func (l *DeploymentsValidatePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.Validate", token, client.pl, client.validateHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsValidateResponse contains the response from method Deployments.Validate.
type DeploymentsValidateResponse struct {
	DeploymentsValidateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsValidateResult contains the result from method Deployments.Validate.
type DeploymentsValidateResult struct {
	DeploymentValidateResult
}

// DeploymentsWhatIfAtManagementGroupScopePollerResponse contains the response from method Deployments.WhatIfAtManagementGroupScope.
type DeploymentsWhatIfAtManagementGroupScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsWhatIfAtManagementGroupScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsWhatIfAtManagementGroupScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsWhatIfAtManagementGroupScopeResponse, error) {
	respType := DeploymentsWhatIfAtManagementGroupScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WhatIfOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsWhatIfAtManagementGroupScopePollerResponse from the provided client and resume token.
func (l *DeploymentsWhatIfAtManagementGroupScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtManagementGroupScope", token, client.pl, client.whatIfAtManagementGroupScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsWhatIfAtManagementGroupScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsWhatIfAtManagementGroupScopeResponse contains the response from method Deployments.WhatIfAtManagementGroupScope.
type DeploymentsWhatIfAtManagementGroupScopeResponse struct {
	DeploymentsWhatIfAtManagementGroupScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsWhatIfAtManagementGroupScopeResult contains the result from method Deployments.WhatIfAtManagementGroupScope.
type DeploymentsWhatIfAtManagementGroupScopeResult struct {
	WhatIfOperationResult
}

// DeploymentsWhatIfAtSubscriptionScopePollerResponse contains the response from method Deployments.WhatIfAtSubscriptionScope.
type DeploymentsWhatIfAtSubscriptionScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsWhatIfAtSubscriptionScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsWhatIfAtSubscriptionScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsWhatIfAtSubscriptionScopeResponse, error) {
	respType := DeploymentsWhatIfAtSubscriptionScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WhatIfOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsWhatIfAtSubscriptionScopePollerResponse from the provided client and resume token.
func (l *DeploymentsWhatIfAtSubscriptionScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtSubscriptionScope", token, client.pl, client.whatIfAtSubscriptionScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsWhatIfAtSubscriptionScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsWhatIfAtSubscriptionScopeResponse contains the response from method Deployments.WhatIfAtSubscriptionScope.
type DeploymentsWhatIfAtSubscriptionScopeResponse struct {
	DeploymentsWhatIfAtSubscriptionScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsWhatIfAtSubscriptionScopeResult contains the result from method Deployments.WhatIfAtSubscriptionScope.
type DeploymentsWhatIfAtSubscriptionScopeResult struct {
	WhatIfOperationResult
}

// DeploymentsWhatIfAtTenantScopePollerResponse contains the response from method Deployments.WhatIfAtTenantScope.
type DeploymentsWhatIfAtTenantScopePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsWhatIfAtTenantScopePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsWhatIfAtTenantScopePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsWhatIfAtTenantScopeResponse, error) {
	respType := DeploymentsWhatIfAtTenantScopeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WhatIfOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsWhatIfAtTenantScopePollerResponse from the provided client and resume token.
func (l *DeploymentsWhatIfAtTenantScopePollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtTenantScope", token, client.pl, client.whatIfAtTenantScopeHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsWhatIfAtTenantScopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsWhatIfAtTenantScopeResponse contains the response from method Deployments.WhatIfAtTenantScope.
type DeploymentsWhatIfAtTenantScopeResponse struct {
	DeploymentsWhatIfAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsWhatIfAtTenantScopeResult contains the result from method Deployments.WhatIfAtTenantScope.
type DeploymentsWhatIfAtTenantScopeResult struct {
	WhatIfOperationResult
}

// DeploymentsWhatIfPollerResponse contains the response from method Deployments.WhatIf.
type DeploymentsWhatIfPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeploymentsWhatIfPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeploymentsWhatIfPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsWhatIfResponse, error) {
	respType := DeploymentsWhatIfResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WhatIfOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeploymentsWhatIfPollerResponse from the provided client and resume token.
func (l *DeploymentsWhatIfPollerResponse) Resume(ctx context.Context, client *DeploymentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeploymentsClient.WhatIf", token, client.pl, client.whatIfHandleError)
	if err != nil {
		return err
	}
	poller := &DeploymentsWhatIfPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeploymentsWhatIfResponse contains the response from method Deployments.WhatIf.
type DeploymentsWhatIfResponse struct {
	DeploymentsWhatIfResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeploymentsWhatIfResult contains the result from method Deployments.WhatIf.
type DeploymentsWhatIfResult struct {
	WhatIfOperationResult
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// ProviderResourceTypesListResponse contains the response from method ProviderResourceTypes.List.
type ProviderResourceTypesListResponse struct {
	ProviderResourceTypesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProviderResourceTypesListResult contains the result from method ProviderResourceTypes.List.
type ProviderResourceTypesListResult struct {
	ProviderResourceTypeListResult
}

// ProvidersGetAtTenantScopeResponse contains the response from method Providers.GetAtTenantScope.
type ProvidersGetAtTenantScopeResponse struct {
	ProvidersGetAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersGetAtTenantScopeResult contains the result from method Providers.GetAtTenantScope.
type ProvidersGetAtTenantScopeResult struct {
	Provider
}

// ProvidersGetResponse contains the response from method Providers.Get.
type ProvidersGetResponse struct {
	ProvidersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersGetResult contains the result from method Providers.Get.
type ProvidersGetResult struct {
	Provider
}

// ProvidersListAtTenantScopeResponse contains the response from method Providers.ListAtTenantScope.
type ProvidersListAtTenantScopeResponse struct {
	ProvidersListAtTenantScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersListAtTenantScopeResult contains the result from method Providers.ListAtTenantScope.
type ProvidersListAtTenantScopeResult struct {
	ProviderListResult
}

// ProvidersListResponse contains the response from method Providers.List.
type ProvidersListResponse struct {
	ProvidersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersListResult contains the result from method Providers.List.
type ProvidersListResult struct {
	ProviderListResult
}

// ProvidersProviderPermissionsResponse contains the response from method Providers.ProviderPermissions.
type ProvidersProviderPermissionsResponse struct {
	ProvidersProviderPermissionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersProviderPermissionsResult contains the result from method Providers.ProviderPermissions.
type ProvidersProviderPermissionsResult struct {
	ProviderPermissionListResult
}

// ProvidersRegisterAtManagementGroupScopeResponse contains the response from method Providers.RegisterAtManagementGroupScope.
type ProvidersRegisterAtManagementGroupScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersRegisterResponse contains the response from method Providers.Register.
type ProvidersRegisterResponse struct {
	ProvidersRegisterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersRegisterResult contains the result from method Providers.Register.
type ProvidersRegisterResult struct {
	Provider
}

// ProvidersUnregisterResponse contains the response from method Providers.Unregister.
type ProvidersUnregisterResponse struct {
	ProvidersUnregisterResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProvidersUnregisterResult contains the result from method Providers.Unregister.
type ProvidersUnregisterResult struct {
	Provider
}

// ResourceGroupsCheckExistenceResponse contains the response from method ResourceGroups.CheckExistence.
type ResourceGroupsCheckExistenceResponse struct {
	ResourceGroupsCheckExistenceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsCheckExistenceResult contains the result from method ResourceGroups.CheckExistence.
type ResourceGroupsCheckExistenceResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// ResourceGroupsCreateOrUpdateResponse contains the response from method ResourceGroups.CreateOrUpdate.
type ResourceGroupsCreateOrUpdateResponse struct {
	ResourceGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsCreateOrUpdateResult contains the result from method ResourceGroups.CreateOrUpdate.
type ResourceGroupsCreateOrUpdateResult struct {
	ResourceGroup
}

// ResourceGroupsDeletePollerResponse contains the response from method ResourceGroups.Delete.
type ResourceGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourceGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourceGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourceGroupsDeleteResponse, error) {
	respType := ResourceGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourceGroupsDeletePollerResponse from the provided client and resume token.
func (l *ResourceGroupsDeletePollerResponse) Resume(ctx context.Context, client *ResourceGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourceGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ResourceGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourceGroupsDeleteResponse contains the response from method ResourceGroups.Delete.
type ResourceGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsExportTemplatePollerResponse contains the response from method ResourceGroups.ExportTemplate.
type ResourceGroupsExportTemplatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourceGroupsExportTemplatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourceGroupsExportTemplatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourceGroupsExportTemplateResponse, error) {
	respType := ResourceGroupsExportTemplateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ResourceGroupExportResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourceGroupsExportTemplatePollerResponse from the provided client and resume token.
func (l *ResourceGroupsExportTemplatePollerResponse) Resume(ctx context.Context, client *ResourceGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourceGroupsClient.ExportTemplate", token, client.pl, client.exportTemplateHandleError)
	if err != nil {
		return err
	}
	poller := &ResourceGroupsExportTemplatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourceGroupsExportTemplateResponse contains the response from method ResourceGroups.ExportTemplate.
type ResourceGroupsExportTemplateResponse struct {
	ResourceGroupsExportTemplateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsExportTemplateResult contains the result from method ResourceGroups.ExportTemplate.
type ResourceGroupsExportTemplateResult struct {
	ResourceGroupExportResult
}

// ResourceGroupsGetResponse contains the response from method ResourceGroups.Get.
type ResourceGroupsGetResponse struct {
	ResourceGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsGetResult contains the result from method ResourceGroups.Get.
type ResourceGroupsGetResult struct {
	ResourceGroup
}

// ResourceGroupsListResponse contains the response from method ResourceGroups.List.
type ResourceGroupsListResponse struct {
	ResourceGroupsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsListResult contains the result from method ResourceGroups.List.
type ResourceGroupsListResult struct {
	ResourceGroupListResult
}

// ResourceGroupsUpdateResponse contains the response from method ResourceGroups.Update.
type ResourceGroupsUpdateResponse struct {
	ResourceGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceGroupsUpdateResult contains the result from method ResourceGroups.Update.
type ResourceGroupsUpdateResult struct {
	ResourceGroup
}

// ResourcesCheckExistenceByIDResponse contains the response from method Resources.CheckExistenceByID.
type ResourcesCheckExistenceByIDResponse struct {
	ResourcesCheckExistenceByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesCheckExistenceByIDResult contains the result from method Resources.CheckExistenceByID.
type ResourcesCheckExistenceByIDResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// ResourcesCheckExistenceResponse contains the response from method Resources.CheckExistence.
type ResourcesCheckExistenceResponse struct {
	ResourcesCheckExistenceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesCheckExistenceResult contains the result from method Resources.CheckExistence.
type ResourcesCheckExistenceResult struct {
	// Success indicates if the operation succeeded or failed.
	Success bool
}

// ResourcesCreateOrUpdateByIDPollerResponse contains the response from method Resources.CreateOrUpdateByID.
type ResourcesCreateOrUpdateByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesCreateOrUpdateByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesCreateOrUpdateByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesCreateOrUpdateByIDResponse, error) {
	respType := ResourcesCreateOrUpdateByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GenericResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesCreateOrUpdateByIDPollerResponse from the provided client and resume token.
func (l *ResourcesCreateOrUpdateByIDPollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.CreateOrUpdateByID", token, client.pl, client.createOrUpdateByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesCreateOrUpdateByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesCreateOrUpdateByIDResponse contains the response from method Resources.CreateOrUpdateByID.
type ResourcesCreateOrUpdateByIDResponse struct {
	ResourcesCreateOrUpdateByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesCreateOrUpdateByIDResult contains the result from method Resources.CreateOrUpdateByID.
type ResourcesCreateOrUpdateByIDResult struct {
	GenericResource
}

// ResourcesCreateOrUpdatePollerResponse contains the response from method Resources.CreateOrUpdate.
type ResourcesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesCreateOrUpdateResponse, error) {
	respType := ResourcesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GenericResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ResourcesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesCreateOrUpdateResponse contains the response from method Resources.CreateOrUpdate.
type ResourcesCreateOrUpdateResponse struct {
	ResourcesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesCreateOrUpdateResult contains the result from method Resources.CreateOrUpdate.
type ResourcesCreateOrUpdateResult struct {
	GenericResource
}

// ResourcesDeleteByIDPollerResponse contains the response from method Resources.DeleteByID.
type ResourcesDeleteByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesDeleteByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesDeleteByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesDeleteByIDResponse, error) {
	respType := ResourcesDeleteByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesDeleteByIDPollerResponse from the provided client and resume token.
func (l *ResourcesDeleteByIDPollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.DeleteByID", token, client.pl, client.deleteByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesDeleteByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesDeleteByIDResponse contains the response from method Resources.DeleteByID.
type ResourcesDeleteByIDResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesDeletePollerResponse contains the response from method Resources.Delete.
type ResourcesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesDeleteResponse, error) {
	respType := ResourcesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesDeletePollerResponse from the provided client and resume token.
func (l *ResourcesDeletePollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesDeleteResponse contains the response from method Resources.Delete.
type ResourcesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesGetByIDResponse contains the response from method Resources.GetByID.
type ResourcesGetByIDResponse struct {
	ResourcesGetByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesGetByIDResult contains the result from method Resources.GetByID.
type ResourcesGetByIDResult struct {
	GenericResource
}

// ResourcesGetResponse contains the response from method Resources.Get.
type ResourcesGetResponse struct {
	ResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesGetResult contains the result from method Resources.Get.
type ResourcesGetResult struct {
	GenericResource
}

// ResourcesListByResourceGroupResponse contains the response from method Resources.ListByResourceGroup.
type ResourcesListByResourceGroupResponse struct {
	ResourcesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesListByResourceGroupResult contains the result from method Resources.ListByResourceGroup.
type ResourcesListByResourceGroupResult struct {
	ResourceListResult
}

// ResourcesListResponse contains the response from method Resources.List.
type ResourcesListResponse struct {
	ResourcesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesListResult contains the result from method Resources.List.
type ResourcesListResult struct {
	ResourceListResult
}

// ResourcesMoveResourcesPollerResponse contains the response from method Resources.MoveResources.
type ResourcesMoveResourcesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesMoveResourcesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesMoveResourcesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesMoveResourcesResponse, error) {
	respType := ResourcesMoveResourcesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesMoveResourcesPollerResponse from the provided client and resume token.
func (l *ResourcesMoveResourcesPollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.MoveResources", token, client.pl, client.moveResourcesHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesMoveResourcesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesMoveResourcesResponse contains the response from method Resources.MoveResources.
type ResourcesMoveResourcesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesUpdateByIDPollerResponse contains the response from method Resources.UpdateByID.
type ResourcesUpdateByIDPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesUpdateByIDPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesUpdateByIDPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesUpdateByIDResponse, error) {
	respType := ResourcesUpdateByIDResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GenericResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesUpdateByIDPollerResponse from the provided client and resume token.
func (l *ResourcesUpdateByIDPollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.UpdateByID", token, client.pl, client.updateByIDHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesUpdateByIDPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesUpdateByIDResponse contains the response from method Resources.UpdateByID.
type ResourcesUpdateByIDResponse struct {
	ResourcesUpdateByIDResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesUpdateByIDResult contains the result from method Resources.UpdateByID.
type ResourcesUpdateByIDResult struct {
	GenericResource
}

// ResourcesUpdatePollerResponse contains the response from method Resources.Update.
type ResourcesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesUpdateResponse, error) {
	respType := ResourcesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GenericResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesUpdatePollerResponse from the provided client and resume token.
func (l *ResourcesUpdatePollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesUpdateResponse contains the response from method Resources.Update.
type ResourcesUpdateResponse struct {
	ResourcesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourcesUpdateResult contains the result from method Resources.Update.
type ResourcesUpdateResult struct {
	GenericResource
}

// ResourcesValidateMoveResourcesPollerResponse contains the response from method Resources.ValidateMoveResources.
type ResourcesValidateMoveResourcesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ResourcesValidateMoveResourcesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ResourcesValidateMoveResourcesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ResourcesValidateMoveResourcesResponse, error) {
	respType := ResourcesValidateMoveResourcesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ResourcesValidateMoveResourcesPollerResponse from the provided client and resume token.
func (l *ResourcesValidateMoveResourcesPollerResponse) Resume(ctx context.Context, client *ResourcesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ResourcesClient.ValidateMoveResources", token, client.pl, client.validateMoveResourcesHandleError)
	if err != nil {
		return err
	}
	poller := &ResourcesValidateMoveResourcesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ResourcesValidateMoveResourcesResponse contains the response from method Resources.ValidateMoveResources.
type ResourcesValidateMoveResourcesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsCreateOrUpdateAtScopeResponse contains the response from method Tags.CreateOrUpdateAtScope.
type TagsCreateOrUpdateAtScopeResponse struct {
	TagsCreateOrUpdateAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsCreateOrUpdateAtScopeResult contains the result from method Tags.CreateOrUpdateAtScope.
type TagsCreateOrUpdateAtScopeResult struct {
	TagsResource
}

// TagsCreateOrUpdateResponse contains the response from method Tags.CreateOrUpdate.
type TagsCreateOrUpdateResponse struct {
	TagsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsCreateOrUpdateResult contains the result from method Tags.CreateOrUpdate.
type TagsCreateOrUpdateResult struct {
	TagDetails
}

// TagsCreateOrUpdateValueResponse contains the response from method Tags.CreateOrUpdateValue.
type TagsCreateOrUpdateValueResponse struct {
	TagsCreateOrUpdateValueResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsCreateOrUpdateValueResult contains the result from method Tags.CreateOrUpdateValue.
type TagsCreateOrUpdateValueResult struct {
	TagValue
}

// TagsDeleteAtScopeResponse contains the response from method Tags.DeleteAtScope.
type TagsDeleteAtScopeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsDeleteResponse contains the response from method Tags.Delete.
type TagsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsDeleteValueResponse contains the response from method Tags.DeleteValue.
type TagsDeleteValueResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsGetAtScopeResponse contains the response from method Tags.GetAtScope.
type TagsGetAtScopeResponse struct {
	TagsGetAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsGetAtScopeResult contains the result from method Tags.GetAtScope.
type TagsGetAtScopeResult struct {
	TagsResource
}

// TagsListResponse contains the response from method Tags.List.
type TagsListResponse struct {
	TagsListResultEnvelope
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsListResultEnvelope contains the result from method Tags.List.
type TagsListResultEnvelope struct {
	TagsListResult
}

// TagsUpdateAtScopeResponse contains the response from method Tags.UpdateAtScope.
type TagsUpdateAtScopeResponse struct {
	TagsUpdateAtScopeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TagsUpdateAtScopeResult contains the result from method Tags.UpdateAtScope.
type TagsUpdateAtScopeResult struct {
	TagsResource
}
