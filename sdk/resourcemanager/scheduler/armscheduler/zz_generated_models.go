//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armscheduler

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

type BasicAuthentication struct {
	HTTPAuthentication
	// Gets or sets the password, return value will always be empty.
	Password *string `json:"password,omitempty"`

	// Gets or sets the username.
	Username *string `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BasicAuthentication.
func (b BasicAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.HTTPAuthentication.marshalInternal(objectMap, HTTPAuthenticationTypeBasic)
	populate(objectMap, "password", b.Password)
	populate(objectMap, "username", b.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BasicAuthentication.
func (b *BasicAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			err = unpopulate(val, &b.Password)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, &b.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.HTTPAuthentication.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type ClientCertAuthentication struct {
	HTTPAuthentication
	// Gets or sets the certificate expiration date.
	CertificateExpirationDate *time.Time `json:"certificateExpirationDate,omitempty"`

	// Gets or sets the certificate subject name.
	CertificateSubjectName *string `json:"certificateSubjectName,omitempty"`

	// Gets or sets the certificate thumbprint.
	CertificateThumbprint *string `json:"certificateThumbprint,omitempty"`

	// Gets or sets the certificate password, return value will always be empty.
	Password *string `json:"password,omitempty"`

	// Gets or sets the pfx certificate. Accepts certification in base64 encoding, return value will always be empty.
	Pfx *string `json:"pfx,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClientCertAuthentication.
func (c ClientCertAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.HTTPAuthentication.marshalInternal(objectMap, HTTPAuthenticationTypeClientCertificate)
	populate(objectMap, "certificateExpirationDate", (*timeRFC3339)(c.CertificateExpirationDate))
	populate(objectMap, "certificateSubjectName", c.CertificateSubjectName)
	populate(objectMap, "certificateThumbprint", c.CertificateThumbprint)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "pfx", c.Pfx)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientCertAuthentication.
func (c *ClientCertAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateExpirationDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.CertificateExpirationDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "certificateSubjectName":
			err = unpopulate(val, &c.CertificateSubjectName)
			delete(rawMsg, key)
		case "certificateThumbprint":
			err = unpopulate(val, &c.CertificateThumbprint)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &c.Password)
			delete(rawMsg, key)
		case "pfx":
			err = unpopulate(val, &c.Pfx)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.HTTPAuthentication.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HTTPAuthenticationClassification provides polymorphic access to related types.
// Call the interface's GetHTTPAuthentication() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BasicAuthentication, *ClientCertAuthentication, *HTTPAuthentication, *OAuthAuthentication
type HTTPAuthenticationClassification interface {
	// GetHTTPAuthentication returns the HTTPAuthentication content of the underlying type.
	GetHTTPAuthentication() *HTTPAuthentication
}

type HTTPAuthentication struct {
	// REQUIRED; Gets or sets the HTTP authentication type.
	Type *HTTPAuthenticationType `json:"type,omitempty"`
}

// GetHTTPAuthentication implements the HTTPAuthenticationClassification interface for type HTTPAuthentication.
func (h *HTTPAuthentication) GetHTTPAuthentication() *HTTPAuthentication { return h }

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPAuthentication.
func (h *HTTPAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return h.unmarshalInternal(rawMsg)
}

func (h HTTPAuthentication) marshalInternal(objectMap map[string]interface{}, discValue HTTPAuthenticationType) {
	h.Type = &discValue
	objectMap["type"] = h.Type
}

func (h *HTTPAuthentication) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type HTTPRequest struct {
	// Gets or sets the authentication method of the request.
	Authentication HTTPAuthenticationClassification `json:"authentication,omitempty"`

	// Gets or sets the request body.
	Body *string `json:"body,omitempty"`

	// Gets or sets the headers.
	Headers map[string]*string `json:"headers,omitempty"`

	// Gets or sets the method of the request.
	Method *string `json:"method,omitempty"`

	// Gets or sets the URI of the request.
	URI *string `json:"uri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRequest.
func (h HTTPRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authentication", h.Authentication)
	populate(objectMap, "body", h.Body)
	populate(objectMap, "headers", h.Headers)
	populate(objectMap, "method", h.Method)
	populate(objectMap, "uri", h.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPRequest.
func (h *HTTPRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			h.Authentication, err = unmarshalHTTPAuthenticationClassification(val)
			delete(rawMsg, key)
		case "body":
			err = unpopulate(val, &h.Body)
			delete(rawMsg, key)
		case "headers":
			err = unpopulate(val, &h.Headers)
			delete(rawMsg, key)
		case "method":
			err = unpopulate(val, &h.Method)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, &h.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type JobAction struct {
	// Gets or sets the error action.
	ErrorAction *JobErrorAction `json:"errorAction,omitempty"`

	// Gets or sets the storage queue message.
	QueueMessage *StorageQueueMessage `json:"queueMessage,omitempty"`

	// Gets or sets the http requests.
	Request *HTTPRequest `json:"request,omitempty"`

	// Gets or sets the retry policy.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`

	// Gets or sets the service bus queue message.
	ServiceBusQueueMessage *ServiceBusQueueMessage `json:"serviceBusQueueMessage,omitempty"`

	// Gets or sets the service bus topic message.
	ServiceBusTopicMessage *ServiceBusTopicMessage `json:"serviceBusTopicMessage,omitempty"`

	// Gets or sets the job action type.
	Type *JobActionType `json:"type,omitempty"`
}

type JobCollectionDefinition struct {
	// Gets or sets the storage account location.
	Location *string `json:"location,omitempty"`

	// Gets or sets the job collection resource name.
	Name *string `json:"name,omitempty"`

	// Gets or sets the job collection properties.
	Properties *JobCollectionProperties `json:"properties,omitempty"`

	// Gets or sets the tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Gets the job collection resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job collection resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobCollectionDefinition.
func (j JobCollectionDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "location", j.Location)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "tags", j.Tags)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

type JobCollectionListResult struct {
	// Gets or sets the URL to get the next set of job collections.
	NextLink *string `json:"nextLink,omitempty"`

	// READ-ONLY; Gets the job collections.
	Value []*JobCollectionDefinition `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobCollectionListResult.
func (j JobCollectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

type JobCollectionProperties struct {
	// Gets or sets the job collection quota.
	Quota *JobCollectionQuota `json:"quota,omitempty"`

	// Gets or sets the SKU.
	SKU *SKU `json:"sku,omitempty"`

	// Gets or sets the state.
	State *JobCollectionState `json:"state,omitempty"`
}

type JobCollectionQuota struct {
	// Gets or set the maximum job count.
	MaxJobCount *int32 `json:"maxJobCount,omitempty"`

	// Gets or sets the maximum job occurrence.
	MaxJobOccurrence *int32 `json:"maxJobOccurrence,omitempty"`

	// Gets or set the maximum recurrence.
	MaxRecurrence *JobMaxRecurrence `json:"maxRecurrence,omitempty"`
}

// JobCollectionsBeginDeleteOptions contains the optional parameters for the JobCollections.BeginDelete method.
type JobCollectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsBeginDisableOptions contains the optional parameters for the JobCollections.BeginDisable method.
type JobCollectionsBeginDisableOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsBeginEnableOptions contains the optional parameters for the JobCollections.BeginEnable method.
type JobCollectionsBeginEnableOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsCreateOrUpdateOptions contains the optional parameters for the JobCollections.CreateOrUpdate method.
type JobCollectionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsGetOptions contains the optional parameters for the JobCollections.Get method.
type JobCollectionsGetOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsListByResourceGroupOptions contains the optional parameters for the JobCollections.ListByResourceGroup method.
type JobCollectionsListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsListBySubscriptionOptions contains the optional parameters for the JobCollections.ListBySubscription method.
type JobCollectionsListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// JobCollectionsPatchOptions contains the optional parameters for the JobCollections.Patch method.
type JobCollectionsPatchOptions struct {
	// placeholder for future optional parameters
}

type JobDefinition struct {
	// Gets or sets the job properties.
	Properties *JobProperties `json:"properties,omitempty"`

	// READ-ONLY; Gets the job resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobDefinition.
func (j JobDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

type JobErrorAction struct {
	// Gets or sets the storage queue message.
	QueueMessage *StorageQueueMessage `json:"queueMessage,omitempty"`

	// Gets or sets the http requests.
	Request *HTTPRequest `json:"request,omitempty"`

	// Gets or sets the retry policy.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`

	// Gets or sets the service bus queue message.
	ServiceBusQueueMessage *ServiceBusQueueMessage `json:"serviceBusQueueMessage,omitempty"`

	// Gets or sets the service bus topic message.
	ServiceBusTopicMessage *ServiceBusTopicMessage `json:"serviceBusTopicMessage,omitempty"`

	// Gets or sets the job error action type.
	Type *JobActionType `json:"type,omitempty"`
}

type JobHistoryDefinition struct {
	// READ-ONLY; Gets the job history identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job history name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Gets or sets the job history properties.
	Properties *JobHistoryDefinitionProperties `json:"properties,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job history resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

type JobHistoryDefinitionProperties struct {
	// READ-ONLY; Gets the job history action name.
	ActionName *JobHistoryActionName `json:"actionName,omitempty" azure:"ro"`

	// READ-ONLY; Gets the end time for this job.
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; Gets the expected execution time for this job.
	ExpectedExecutionTime *time.Time `json:"expectedExecutionTime,omitempty" azure:"ro"`

	// READ-ONLY; Gets the message for the job history.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Gets the repeat count for the job.
	RepeatCount *int32 `json:"repeatCount,omitempty" azure:"ro"`

	// READ-ONLY; Gets the retry count for job.
	RetryCount *int32 `json:"retryCount,omitempty" azure:"ro"`

	// READ-ONLY; Gets the start time for this job.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; Gets the job history status.
	Status *JobExecutionStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobHistoryDefinitionProperties.
func (j JobHistoryDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionName", j.ActionName)
	populate(objectMap, "endTime", (*timeRFC3339)(j.EndTime))
	populate(objectMap, "expectedExecutionTime", (*timeRFC3339)(j.ExpectedExecutionTime))
	populate(objectMap, "message", j.Message)
	populate(objectMap, "repeatCount", j.RepeatCount)
	populate(objectMap, "retryCount", j.RetryCount)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobHistoryDefinitionProperties.
func (j *JobHistoryDefinitionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionName":
			err = unpopulate(val, &j.ActionName)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "expectedExecutionTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.ExpectedExecutionTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &j.Message)
			delete(rawMsg, key)
		case "repeatCount":
			err = unpopulate(val, &j.RepeatCount)
			delete(rawMsg, key)
		case "retryCount":
			err = unpopulate(val, &j.RetryCount)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type JobHistoryFilter struct {
	// Gets or sets the job execution status.
	Status *JobExecutionStatus `json:"status,omitempty"`
}

type JobHistoryListResult struct {
	// Gets or sets the URL to get the next set of job histories.
	NextLink *string `json:"nextLink,omitempty"`

	// Gets or sets the job histories under job.
	Value []*JobHistoryDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobHistoryListResult.
func (j JobHistoryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

type JobListResult struct {
	// Gets or sets the URL to get the next set of jobs.
	NextLink *string `json:"nextLink,omitempty"`

	// Gets or sets all jobs under job collection.
	Value []*JobDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobListResult.
func (j JobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

type JobMaxRecurrence struct {
	// Gets or sets the frequency of recurrence (second, minute, hour, day, week, month).
	Frequency *RecurrenceFrequency `json:"frequency,omitempty"`

	// Gets or sets the interval between retries.
	Interval *int32 `json:"interval,omitempty"`
}

type JobProperties struct {
	// Gets or sets the job action.
	Action *JobAction `json:"action,omitempty"`

	// Gets or sets the job recurrence.
	Recurrence *JobRecurrence `json:"recurrence,omitempty"`

	// Gets or sets the job start time.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Gets or set the job state.
	State *JobState `json:"state,omitempty"`

	// READ-ONLY; Gets the job status.
	Status *JobStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", j.Action)
	populate(objectMap, "recurrence", j.Recurrence)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "state", j.State)
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
			err = unpopulate(val, &j.Action)
			delete(rawMsg, key)
		case "recurrence":
			err = unpopulate(val, &j.Recurrence)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &j.State)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type JobRecurrence struct {
	// Gets or sets the maximum number of times that the job should run.
	Count *int32 `json:"count,omitempty"`

	// Gets or sets the time at which the job will complete.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Gets or sets the frequency of recurrence (second, minute, hour, day, week, month).
	Frequency *RecurrenceFrequency `json:"frequency,omitempty"`

	// Gets or sets the interval between retries.
	Interval *int32                 `json:"interval,omitempty"`
	Schedule *JobRecurrenceSchedule `json:"schedule,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobRecurrence.
func (j JobRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", j.Count)
	populate(objectMap, "endTime", (*timeRFC3339)(j.EndTime))
	populate(objectMap, "frequency", j.Frequency)
	populate(objectMap, "interval", j.Interval)
	populate(objectMap, "schedule", j.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobRecurrence.
func (j *JobRecurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, &j.Count)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "frequency":
			err = unpopulate(val, &j.Frequency)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, &j.Interval)
			delete(rawMsg, key)
		case "schedule":
			err = unpopulate(val, &j.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type JobRecurrenceSchedule struct {
	// Gets or sets the hours of the day that the job should execute at.
	Hours []*int32 `json:"hours,omitempty"`

	// Gets or sets the minutes of the hour that the job should execute at.
	Minutes []*int32 `json:"minutes,omitempty"`

	// Gets or sets the days of the month that the job should execute on. Must be between 1 and 31.
	MonthDays []*int32 `json:"monthDays,omitempty"`

	// Gets or sets the occurrences of days within a month.
	MonthlyOccurrences []*JobRecurrenceScheduleMonthlyOccurrence `json:"monthlyOccurrences,omitempty"`

	// Gets or sets the days of the week that the job should execute on.
	WeekDays []*DayOfWeek `json:"weekDays,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobRecurrenceSchedule.
func (j JobRecurrenceSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hours", j.Hours)
	populate(objectMap, "minutes", j.Minutes)
	populate(objectMap, "monthDays", j.MonthDays)
	populate(objectMap, "monthlyOccurrences", j.MonthlyOccurrences)
	populate(objectMap, "weekDays", j.WeekDays)
	return json.Marshal(objectMap)
}

type JobRecurrenceScheduleMonthlyOccurrence struct {
	// Gets or sets the day. Must be one of monday, tuesday, wednesday, thursday, friday, saturday, sunday.
	Day *JobScheduleDay `json:"day,omitempty"`

	// Gets or sets the occurrence. Must be between -5 and 5.
	Occurrence *int32 `json:"Occurrence,omitempty"`
}

type JobStateFilter struct {
	// Gets or sets the job state.
	State *JobState `json:"state,omitempty"`
}

type JobStatus struct {
	// READ-ONLY; Gets the number of times this job has executed.
	ExecutionCount *int32 `json:"executionCount,omitempty" azure:"ro"`

	// READ-ONLY; Gets the number of times this job has failed.
	FailureCount *int32 `json:"failureCount,omitempty" azure:"ro"`

	// READ-ONLY; Gets the number of faulted occurrences (occurrences that were retried and failed as many times as the retry policy states).
	FaultedCount *int32 `json:"faultedCount,omitempty" azure:"ro"`

	// READ-ONLY; Gets the time the last occurrence executed in ISO-8601 format. Could be empty if job has not run yet.
	LastExecutionTime *time.Time `json:"lastExecutionTime,omitempty" azure:"ro"`

	// READ-ONLY; Gets the time of the next occurrence in ISO-8601 format. Could be empty if the job is completed.
	NextExecutionTime *time.Time `json:"nextExecutionTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobStatus.
func (j JobStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "executionCount", j.ExecutionCount)
	populate(objectMap, "failureCount", j.FailureCount)
	populate(objectMap, "faultedCount", j.FaultedCount)
	populate(objectMap, "lastExecutionTime", (*timeRFC3339)(j.LastExecutionTime))
	populate(objectMap, "nextExecutionTime", (*timeRFC3339)(j.NextExecutionTime))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobStatus.
func (j *JobStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionCount":
			err = unpopulate(val, &j.ExecutionCount)
			delete(rawMsg, key)
		case "failureCount":
			err = unpopulate(val, &j.FailureCount)
			delete(rawMsg, key)
		case "faultedCount":
			err = unpopulate(val, &j.FaultedCount)
			delete(rawMsg, key)
		case "lastExecutionTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.LastExecutionTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "nextExecutionTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.NextExecutionTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobsCreateOrUpdateOptions contains the optional parameters for the Jobs.CreateOrUpdate method.
type JobsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// JobsDeleteOptions contains the optional parameters for the Jobs.Delete method.
type JobsDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobsGetOptions contains the optional parameters for the Jobs.Get method.
type JobsGetOptions struct {
	// placeholder for future optional parameters
}

// JobsListJobHistoryOptions contains the optional parameters for the Jobs.ListJobHistory method.
type JobsListJobHistoryOptions struct {
	// The filter to apply on the job state.
	Filter *string
	// The (0-based) index of the job history list from which to begin requesting entries.
	Skip *int32
	// the number of job history to request, in the of range of [1..100].
	Top *int32
}

// JobsListOptions contains the optional parameters for the Jobs.List method.
type JobsListOptions struct {
	// The filter to apply on the job state.
	Filter *string
	// The (0-based) index of the job history list from which to begin requesting entries.
	Skip *int32
	// The number of jobs to request, in the of range of [1..100].
	Top *int32
}

// JobsPatchOptions contains the optional parameters for the Jobs.Patch method.
type JobsPatchOptions struct {
	// placeholder for future optional parameters
}

// JobsRunOptions contains the optional parameters for the Jobs.Run method.
type JobsRunOptions struct {
	// placeholder for future optional parameters
}

type OAuthAuthentication struct {
	HTTPAuthentication
	// Gets or sets the audience.
	Audience *string `json:"audience,omitempty"`

	// Gets or sets the client identifier.
	ClientID *string `json:"clientId,omitempty"`

	// Gets or sets the secret, return value will always be empty.
	Secret *string `json:"secret,omitempty"`

	// Gets or sets the tenant.
	Tenant *string `json:"tenant,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OAuthAuthentication.
func (o OAuthAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.HTTPAuthentication.marshalInternal(objectMap, HTTPAuthenticationTypeActiveDirectoryOAuth)
	populate(objectMap, "audience", o.Audience)
	populate(objectMap, "clientId", o.ClientID)
	populate(objectMap, "secret", o.Secret)
	populate(objectMap, "tenant", o.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OAuthAuthentication.
func (o *OAuthAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audience":
			err = unpopulate(val, &o.Audience)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, &o.ClientID)
			delete(rawMsg, key)
		case "secret":
			err = unpopulate(val, &o.Secret)
			delete(rawMsg, key)
		case "tenant":
			err = unpopulate(val, &o.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := o.HTTPAuthentication.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type RetryPolicy struct {
	// Gets or sets the number of times a retry should be attempted.
	RetryCount *int32 `json:"retryCount,omitempty"`

	// Gets or sets the retry interval between retries, specify duration in ISO 8601 format.
	RetryInterval *string `json:"retryInterval,omitempty"`

	// Gets or sets the retry strategy to be used.
	RetryType *RetryType `json:"retryType,omitempty"`
}

type SKU struct {
	// Gets or set the SKU.
	Name *SKUDefinition `json:"name,omitempty"`
}

type ServiceBusAuthentication struct {
	// Gets or sets the SAS key.
	SasKey *string `json:"sasKey,omitempty"`

	// Gets or sets the SAS key name.
	SasKeyName *string `json:"sasKeyName,omitempty"`

	// Gets or sets the authentication type.
	Type *ServiceBusAuthenticationType `json:"type,omitempty"`
}

type ServiceBusBrokeredMessageProperties struct {
	// Gets or sets the content type.
	ContentType *string `json:"contentType,omitempty"`

	// Gets or sets the correlation ID.
	CorrelationID *string `json:"correlationId,omitempty"`

	// Gets or sets the force persistence.
	ForcePersistence *bool `json:"forcePersistence,omitempty"`

	// Gets or sets the label.
	Label *string `json:"label,omitempty"`

	// Gets or sets the message ID.
	MessageID *string `json:"messageId,omitempty"`

	// Gets or sets the partition key.
	PartitionKey *string `json:"partitionKey,omitempty"`

	// Gets or sets the reply to.
	ReplyTo *string `json:"replyTo,omitempty"`

	// Gets or sets the reply to session ID.
	ReplyToSessionID *string `json:"replyToSessionId,omitempty"`

	// Gets or sets the scheduled enqueue time UTC.
	ScheduledEnqueueTimeUTC *time.Time `json:"scheduledEnqueueTimeUtc,omitempty"`

	// Gets or sets the session ID.
	SessionID *string `json:"sessionId,omitempty"`

	// Gets or sets the time to live.
	TimeToLive *string `json:"timeToLive,omitempty"`

	// Gets or sets the to.
	To *string `json:"to,omitempty"`

	// Gets or sets the via partition key.
	ViaPartitionKey *string `json:"viaPartitionKey,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusBrokeredMessageProperties.
func (s ServiceBusBrokeredMessageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", s.ContentType)
	populate(objectMap, "correlationId", s.CorrelationID)
	populate(objectMap, "forcePersistence", s.ForcePersistence)
	populate(objectMap, "label", s.Label)
	populate(objectMap, "messageId", s.MessageID)
	populate(objectMap, "partitionKey", s.PartitionKey)
	populate(objectMap, "replyTo", s.ReplyTo)
	populate(objectMap, "replyToSessionId", s.ReplyToSessionID)
	populate(objectMap, "scheduledEnqueueTimeUtc", (*timeRFC3339)(s.ScheduledEnqueueTimeUTC))
	populate(objectMap, "sessionId", s.SessionID)
	populate(objectMap, "timeToLive", s.TimeToLive)
	populate(objectMap, "to", s.To)
	populate(objectMap, "viaPartitionKey", s.ViaPartitionKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusBrokeredMessageProperties.
func (s *ServiceBusBrokeredMessageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentType":
			err = unpopulate(val, &s.ContentType)
			delete(rawMsg, key)
		case "correlationId":
			err = unpopulate(val, &s.CorrelationID)
			delete(rawMsg, key)
		case "forcePersistence":
			err = unpopulate(val, &s.ForcePersistence)
			delete(rawMsg, key)
		case "label":
			err = unpopulate(val, &s.Label)
			delete(rawMsg, key)
		case "messageId":
			err = unpopulate(val, &s.MessageID)
			delete(rawMsg, key)
		case "partitionKey":
			err = unpopulate(val, &s.PartitionKey)
			delete(rawMsg, key)
		case "replyTo":
			err = unpopulate(val, &s.ReplyTo)
			delete(rawMsg, key)
		case "replyToSessionId":
			err = unpopulate(val, &s.ReplyToSessionID)
			delete(rawMsg, key)
		case "scheduledEnqueueTimeUtc":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.ScheduledEnqueueTimeUTC = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sessionId":
			err = unpopulate(val, &s.SessionID)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, &s.TimeToLive)
			delete(rawMsg, key)
		case "to":
			err = unpopulate(val, &s.To)
			delete(rawMsg, key)
		case "viaPartitionKey":
			err = unpopulate(val, &s.ViaPartitionKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type ServiceBusMessage struct {
	// Gets or sets the Service Bus authentication.
	Authentication *ServiceBusAuthentication `json:"authentication,omitempty"`

	// Gets or sets the brokered message properties.
	BrokeredMessageProperties *ServiceBusBrokeredMessageProperties `json:"brokeredMessageProperties,omitempty"`

	// Gets or sets the custom message properties.
	CustomMessageProperties map[string]*string `json:"customMessageProperties,omitempty"`

	// Gets or sets the message.
	Message *string `json:"message,omitempty"`

	// Gets or sets the namespace.
	Namespace *string `json:"namespace,omitempty"`

	// Gets or sets the transport type.
	TransportType *ServiceBusTransportType `json:"transportType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusMessage.
func (s ServiceBusMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (s ServiceBusMessage) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "authentication", s.Authentication)
	populate(objectMap, "brokeredMessageProperties", s.BrokeredMessageProperties)
	populate(objectMap, "customMessageProperties", s.CustomMessageProperties)
	populate(objectMap, "message", s.Message)
	populate(objectMap, "namespace", s.Namespace)
	populate(objectMap, "transportType", s.TransportType)
}

type ServiceBusQueueMessage struct {
	ServiceBusMessage
	// Gets or sets the queue name.
	QueueName *string `json:"queueName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueMessage.
func (s ServiceBusQueueMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceBusMessage.marshalInternal(objectMap)
	populate(objectMap, "queueName", s.QueueName)
	return json.Marshal(objectMap)
}

type ServiceBusTopicMessage struct {
	ServiceBusMessage
	// Gets or sets the topic path.
	TopicPath *string `json:"topicPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicMessage.
func (s ServiceBusTopicMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceBusMessage.marshalInternal(objectMap)
	populate(objectMap, "topicPath", s.TopicPath)
	return json.Marshal(objectMap)
}

type StorageQueueMessage struct {
	// Gets or sets the message.
	Message *string `json:"message,omitempty"`

	// Gets or sets the queue name.
	QueueName *string `json:"queueName,omitempty"`

	// Gets or sets the SAS key.
	SasToken *string `json:"sasToken,omitempty"`

	// Gets or sets the storage account name.
	StorageAccount *string `json:"storageAccount,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
