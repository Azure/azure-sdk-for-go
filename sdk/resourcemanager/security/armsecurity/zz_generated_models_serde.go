//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsecurity

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AADExternalSecuritySolution.
func (a AADExternalSecuritySolution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADExternalSecuritySolution.
func (a *AADExternalSecuritySolution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AADSolutionProperties.
func (a AADSolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectivityState", a.ConnectivityState)
	populate(objectMap, "deviceType", a.DeviceType)
	populate(objectMap, "deviceVendor", a.DeviceVendor)
	populate(objectMap, "workspace", a.Workspace)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADSolutionProperties.
func (a *AADSolutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityState":
			err = unpopulate(val, "ConnectivityState", &a.ConnectivityState)
			delete(rawMsg, key)
		case "deviceType":
			err = unpopulate(val, "DeviceType", &a.DeviceType)
			delete(rawMsg, key)
		case "deviceVendor":
			err = unpopulate(val, "DeviceVendor", &a.DeviceVendor)
			delete(rawMsg, key)
		case "workspace":
			err = unpopulate(val, "Workspace", &a.Workspace)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActiveConnectionsNotInAllowedRange.
func (a ActiveConnectionsNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "maxThreshold", a.MaxThreshold)
	populate(objectMap, "minThreshold", a.MinThreshold)
	objectMap["ruleType"] = "ActiveConnectionsNotInAllowedRange"
	populate(objectMap, "timeWindowSize", a.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActiveConnectionsNotInAllowedRange.
func (a *ActiveConnectionsNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &a.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &a.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &a.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &a.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdaptiveApplicationControlGroupData.
func (a AdaptiveApplicationControlGroupData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configurationStatus", a.ConfigurationStatus)
	populate(objectMap, "enforcementMode", a.EnforcementMode)
	populate(objectMap, "issues", a.Issues)
	populate(objectMap, "pathRecommendations", a.PathRecommendations)
	populate(objectMap, "protectionMode", a.ProtectionMode)
	populate(objectMap, "recommendationStatus", a.RecommendationStatus)
	populate(objectMap, "sourceSystem", a.SourceSystem)
	populate(objectMap, "vmRecommendations", a.VMRecommendations)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AdaptiveNetworkHardeningEnforceRequest.
func (a AdaptiveNetworkHardeningEnforceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkSecurityGroups", a.NetworkSecurityGroups)
	populate(objectMap, "rules", a.Rules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AdaptiveNetworkHardeningProperties.
func (a AdaptiveNetworkHardeningProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "effectiveNetworkSecurityGroups", a.EffectiveNetworkSecurityGroups)
	populate(objectMap, "rules", a.Rules)
	populateTimeRFC3339(objectMap, "rulesCalculationTime", a.RulesCalculationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdaptiveNetworkHardeningProperties.
func (a *AdaptiveNetworkHardeningProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "effectiveNetworkSecurityGroups":
			err = unpopulate(val, "EffectiveNetworkSecurityGroups", &a.EffectiveNetworkSecurityGroups)
			delete(rawMsg, key)
		case "rules":
			err = unpopulate(val, "Rules", &a.Rules)
			delete(rawMsg, key)
		case "rulesCalculationTime":
			err = unpopulateTimeRFC3339(val, "RulesCalculationTime", &a.RulesCalculationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdditionalWorkspacesProperties.
func (a AdditionalWorkspacesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataTypes", a.DataTypes)
	populate(objectMap, "type", a.Type)
	populate(objectMap, "workspace", a.Workspace)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertEntity.
func (a AlertEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "type", a.Type)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertEntity.
func (a *AlertEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertProperties.
func (a AlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDisplayName", a.AlertDisplayName)
	populate(objectMap, "alertType", a.AlertType)
	populate(objectMap, "alertUri", a.AlertURI)
	populate(objectMap, "compromisedEntity", a.CompromisedEntity)
	populate(objectMap, "correlationKey", a.CorrelationKey)
	populate(objectMap, "description", a.Description)
	populateTimeRFC3339(objectMap, "endTimeUtc", a.EndTimeUTC)
	populate(objectMap, "entities", a.Entities)
	populate(objectMap, "extendedLinks", a.ExtendedLinks)
	populate(objectMap, "extendedProperties", a.ExtendedProperties)
	populate(objectMap, "intent", a.Intent)
	populate(objectMap, "isIncident", a.IsIncident)
	populateTimeRFC3339(objectMap, "processingEndTimeUtc", a.ProcessingEndTimeUTC)
	populate(objectMap, "productComponentName", a.ProductComponentName)
	populate(objectMap, "productName", a.ProductName)
	populate(objectMap, "remediationSteps", a.RemediationSteps)
	populate(objectMap, "resourceIdentifiers", a.ResourceIdentifiers)
	populate(objectMap, "severity", a.Severity)
	populateTimeRFC3339(objectMap, "startTimeUtc", a.StartTimeUTC)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "systemAlertId", a.SystemAlertID)
	populateTimeRFC3339(objectMap, "timeGeneratedUtc", a.TimeGeneratedUTC)
	populate(objectMap, "vendorName", a.VendorName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertProperties.
func (a *AlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertDisplayName":
			err = unpopulate(val, "AlertDisplayName", &a.AlertDisplayName)
			delete(rawMsg, key)
		case "alertType":
			err = unpopulate(val, "AlertType", &a.AlertType)
			delete(rawMsg, key)
		case "alertUri":
			err = unpopulate(val, "AlertURI", &a.AlertURI)
			delete(rawMsg, key)
		case "compromisedEntity":
			err = unpopulate(val, "CompromisedEntity", &a.CompromisedEntity)
			delete(rawMsg, key)
		case "correlationKey":
			err = unpopulate(val, "CorrelationKey", &a.CorrelationKey)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, "EndTimeUTC", &a.EndTimeUTC)
			delete(rawMsg, key)
		case "entities":
			err = unpopulate(val, "Entities", &a.Entities)
			delete(rawMsg, key)
		case "extendedLinks":
			err = unpopulate(val, "ExtendedLinks", &a.ExtendedLinks)
			delete(rawMsg, key)
		case "extendedProperties":
			err = unpopulate(val, "ExtendedProperties", &a.ExtendedProperties)
			delete(rawMsg, key)
		case "intent":
			err = unpopulate(val, "Intent", &a.Intent)
			delete(rawMsg, key)
		case "isIncident":
			err = unpopulate(val, "IsIncident", &a.IsIncident)
			delete(rawMsg, key)
		case "processingEndTimeUtc":
			err = unpopulateTimeRFC3339(val, "ProcessingEndTimeUTC", &a.ProcessingEndTimeUTC)
			delete(rawMsg, key)
		case "productComponentName":
			err = unpopulate(val, "ProductComponentName", &a.ProductComponentName)
			delete(rawMsg, key)
		case "productName":
			err = unpopulate(val, "ProductName", &a.ProductName)
			delete(rawMsg, key)
		case "remediationSteps":
			err = unpopulate(val, "RemediationSteps", &a.RemediationSteps)
			delete(rawMsg, key)
		case "resourceIdentifiers":
			a.ResourceIdentifiers, err = unmarshalResourceIdentifierClassificationArray(val)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, "Severity", &a.Severity)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateTimeRFC3339(val, "StartTimeUTC", &a.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		case "systemAlertId":
			err = unpopulate(val, "SystemAlertID", &a.SystemAlertID)
			delete(rawMsg, key)
		case "timeGeneratedUtc":
			err = unpopulateTimeRFC3339(val, "TimeGeneratedUTC", &a.TimeGeneratedUTC)
			delete(rawMsg, key)
		case "vendorName":
			err = unpopulate(val, "VendorName", &a.VendorName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertSimulatorBundlesRequestProperties.
func (a AlertSimulatorBundlesRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bundles", a.Bundles)
	objectMap["kind"] = KindBundles
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertSimulatorBundlesRequestProperties.
func (a *AlertSimulatorBundlesRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bundles":
			err = unpopulate(val, "Bundles", &a.Bundles)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertSimulatorRequestBody.
func (a AlertSimulatorRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertSimulatorRequestBody.
func (a *AlertSimulatorRequestBody) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			a.Properties, err = unmarshalAlertSimulatorRequestPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertSimulatorRequestProperties.
func (a AlertSimulatorRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = a.Kind
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertSimulatorRequestProperties.
func (a *AlertSimulatorRequestProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertSyncSettings.
func (a AlertSyncSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = SettingKindAlertSyncSettings
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertSyncSettings.
func (a *AlertSyncSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertsSuppressionRuleProperties.
func (a AlertsSuppressionRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertType", a.AlertType)
	populate(objectMap, "comment", a.Comment)
	populateTimeRFC3339(objectMap, "expirationDateUtc", a.ExpirationDateUTC)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", a.LastModifiedUTC)
	populate(objectMap, "reason", a.Reason)
	populate(objectMap, "state", a.State)
	populate(objectMap, "suppressionAlertsScope", a.SuppressionAlertsScope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertsSuppressionRuleProperties.
func (a *AlertsSuppressionRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertType":
			err = unpopulate(val, "AlertType", &a.AlertType)
			delete(rawMsg, key)
		case "comment":
			err = unpopulate(val, "Comment", &a.Comment)
			delete(rawMsg, key)
		case "expirationDateUtc":
			err = unpopulateTimeRFC3339(val, "ExpirationDateUTC", &a.ExpirationDateUTC)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, "LastModifiedUTC", &a.LastModifiedUTC)
			delete(rawMsg, key)
		case "reason":
			err = unpopulate(val, "Reason", &a.Reason)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &a.State)
			delete(rawMsg, key)
		case "suppressionAlertsScope":
			err = unpopulate(val, "SuppressionAlertsScope", &a.SuppressionAlertsScope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AllowedConnectionsResourceProperties.
func (a AllowedConnectionsResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "calculatedDateTime", a.CalculatedDateTime)
	populate(objectMap, "connectableResources", a.ConnectableResources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AllowedConnectionsResourceProperties.
func (a *AllowedConnectionsResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "calculatedDateTime":
			err = unpopulateTimeRFC3339(val, "CalculatedDateTime", &a.CalculatedDateTime)
			delete(rawMsg, key)
		case "connectableResources":
			err = unpopulate(val, "ConnectableResources", &a.ConnectableResources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AllowlistCustomAlertRule.
func (a AllowlistCustomAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistValues", a.AllowlistValues)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isEnabled", a.IsEnabled)
	objectMap["ruleType"] = "AllowlistCustomAlertRule"
	populate(objectMap, "valueType", a.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AllowlistCustomAlertRule.
func (a *AllowlistCustomAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistValues":
			err = unpopulate(val, "AllowlistValues", &a.AllowlistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &a.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &a.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmqpC2DMessagesNotInAllowedRange.
func (a AmqpC2DMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "maxThreshold", a.MaxThreshold)
	populate(objectMap, "minThreshold", a.MinThreshold)
	objectMap["ruleType"] = "AmqpC2DMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", a.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmqpC2DMessagesNotInAllowedRange.
func (a *AmqpC2DMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &a.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &a.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &a.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &a.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmqpC2DRejectedMessagesNotInAllowedRange.
func (a AmqpC2DRejectedMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "maxThreshold", a.MaxThreshold)
	populate(objectMap, "minThreshold", a.MinThreshold)
	objectMap["ruleType"] = "AmqpC2DRejectedMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", a.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmqpC2DRejectedMessagesNotInAllowedRange.
func (a *AmqpC2DRejectedMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &a.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &a.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &a.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &a.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmqpD2CMessagesNotInAllowedRange.
func (a AmqpD2CMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "maxThreshold", a.MaxThreshold)
	populate(objectMap, "minThreshold", a.MinThreshold)
	objectMap["ruleType"] = "AmqpD2CMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", a.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmqpD2CMessagesNotInAllowedRange.
func (a *AmqpD2CMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &a.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &a.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &a.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &a.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentMetadataProperties.
func (a AssessmentMetadataProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentType", a.AssessmentType)
	populate(objectMap, "categories", a.Categories)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "implementationEffort", a.ImplementationEffort)
	populate(objectMap, "partnerData", a.PartnerData)
	populate(objectMap, "policyDefinitionId", a.PolicyDefinitionID)
	populate(objectMap, "preview", a.Preview)
	populate(objectMap, "remediationDescription", a.RemediationDescription)
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "threats", a.Threats)
	populate(objectMap, "userImpact", a.UserImpact)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentMetadataPropertiesResponse.
func (a AssessmentMetadataPropertiesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentType", a.AssessmentType)
	populate(objectMap, "categories", a.Categories)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "implementationEffort", a.ImplementationEffort)
	populate(objectMap, "partnerData", a.PartnerData)
	populate(objectMap, "plannedDeprecationDate", a.PlannedDeprecationDate)
	populate(objectMap, "policyDefinitionId", a.PolicyDefinitionID)
	populate(objectMap, "preview", a.Preview)
	populate(objectMap, "publishDates", a.PublishDates)
	populate(objectMap, "remediationDescription", a.RemediationDescription)
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "tactics", a.Tactics)
	populate(objectMap, "techniques", a.Techniques)
	populate(objectMap, "threats", a.Threats)
	populate(objectMap, "userImpact", a.UserImpact)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentProperties.
func (a AssessmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", a.AdditionalData)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "links", a.Links)
	populate(objectMap, "metadata", a.Metadata)
	populate(objectMap, "partnersData", a.PartnersData)
	populate(objectMap, "resourceDetails", a.ResourceDetails)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentProperties.
func (a *AssessmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, "AdditionalData", &a.AdditionalData)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, "Links", &a.Links)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &a.Metadata)
			delete(rawMsg, key)
		case "partnersData":
			err = unpopulate(val, "PartnersData", &a.PartnersData)
			delete(rawMsg, key)
		case "resourceDetails":
			a.ResourceDetails, err = unmarshalResourceDetailsClassification(val)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentPropertiesBase.
func (a AssessmentPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", a.AdditionalData)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "links", a.Links)
	populate(objectMap, "metadata", a.Metadata)
	populate(objectMap, "partnersData", a.PartnersData)
	populate(objectMap, "resourceDetails", a.ResourceDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentPropertiesBase.
func (a *AssessmentPropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, "AdditionalData", &a.AdditionalData)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, "Links", &a.Links)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &a.Metadata)
			delete(rawMsg, key)
		case "partnersData":
			err = unpopulate(val, "PartnersData", &a.PartnersData)
			delete(rawMsg, key)
		case "resourceDetails":
			a.ResourceDetails, err = unmarshalResourceDetailsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentPropertiesResponse.
func (a AssessmentPropertiesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", a.AdditionalData)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "links", a.Links)
	populate(objectMap, "metadata", a.Metadata)
	populate(objectMap, "partnersData", a.PartnersData)
	populate(objectMap, "resourceDetails", a.ResourceDetails)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentPropertiesResponse.
func (a *AssessmentPropertiesResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, "AdditionalData", &a.AdditionalData)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &a.DisplayName)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, "Links", &a.Links)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &a.Metadata)
			delete(rawMsg, key)
		case "partnersData":
			err = unpopulate(val, "PartnersData", &a.PartnersData)
			delete(rawMsg, key)
		case "resourceDetails":
			a.ResourceDetails, err = unmarshalResourceDetailsClassification(val)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssessmentStatusResponse.
func (a AssessmentStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cause", a.Cause)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "description", a.Description)
	populateTimeRFC3339(objectMap, "firstEvaluationDate", a.FirstEvaluationDate)
	populateTimeRFC3339(objectMap, "statusChangeDate", a.StatusChangeDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssessmentStatusResponse.
func (a *AssessmentStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cause":
			err = unpopulate(val, "Cause", &a.Cause)
			delete(rawMsg, key)
		case "code":
			err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "firstEvaluationDate":
			err = unpopulateTimeRFC3339(val, "FirstEvaluationDate", &a.FirstEvaluationDate)
			delete(rawMsg, key)
		case "statusChangeDate":
			err = unpopulateTimeRFC3339(val, "StatusChangeDate", &a.StatusChangeDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AtaExternalSecuritySolution.
func (a AtaExternalSecuritySolution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AtaExternalSecuritySolution.
func (a *AtaExternalSecuritySolution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AtaSolutionProperties.
func (a AtaSolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deviceType", a.DeviceType)
	populate(objectMap, "deviceVendor", a.DeviceVendor)
	populate(objectMap, "lastEventReceived", a.LastEventReceived)
	populate(objectMap, "workspace", a.Workspace)
	if a.AdditionalProperties != nil {
		for key, val := range a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AtaSolutionProperties.
func (a *AtaSolutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceType":
			err = unpopulate(val, "DeviceType", &a.DeviceType)
			delete(rawMsg, key)
		case "deviceVendor":
			err = unpopulate(val, "DeviceVendor", &a.DeviceVendor)
			delete(rawMsg, key)
		case "lastEventReceived":
			err = unpopulate(val, "LastEventReceived", &a.LastEventReceived)
			delete(rawMsg, key)
		case "workspace":
			err = unpopulate(val, "Workspace", &a.Workspace)
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				a.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthenticationDetailsProperties.
func (a AuthenticationDetailsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationProvisioningState", a.AuthenticationProvisioningState)
	objectMap["authenticationType"] = a.AuthenticationType
	populate(objectMap, "grantedPermissions", a.GrantedPermissions)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Automation.
func (a Automation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutomationActionEventHub.
func (a AutomationActionEventHub) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["actionType"] = ActionTypeEventHub
	populate(objectMap, "connectionString", a.ConnectionString)
	populate(objectMap, "eventHubResourceId", a.EventHubResourceID)
	populate(objectMap, "sasPolicyName", a.SasPolicyName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationActionEventHub.
func (a *AutomationActionEventHub) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &a.ActionType)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, "ConnectionString", &a.ConnectionString)
			delete(rawMsg, key)
		case "eventHubResourceId":
			err = unpopulate(val, "EventHubResourceID", &a.EventHubResourceID)
			delete(rawMsg, key)
		case "sasPolicyName":
			err = unpopulate(val, "SasPolicyName", &a.SasPolicyName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationActionLogicApp.
func (a AutomationActionLogicApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["actionType"] = ActionTypeLogicApp
	populate(objectMap, "logicAppResourceId", a.LogicAppResourceID)
	populate(objectMap, "uri", a.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationActionLogicApp.
func (a *AutomationActionLogicApp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &a.ActionType)
			delete(rawMsg, key)
		case "logicAppResourceId":
			err = unpopulate(val, "LogicAppResourceID", &a.LogicAppResourceID)
			delete(rawMsg, key)
		case "uri":
			err = unpopulate(val, "URI", &a.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationActionWorkspace.
func (a AutomationActionWorkspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["actionType"] = ActionTypeWorkspace
	populate(objectMap, "workspaceResourceId", a.WorkspaceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationActionWorkspace.
func (a *AutomationActionWorkspace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &a.ActionType)
			delete(rawMsg, key)
		case "workspaceResourceId":
			err = unpopulate(val, "WorkspaceResourceID", &a.WorkspaceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationProperties.
func (a AutomationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", a.Actions)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "scopes", a.Scopes)
	populate(objectMap, "sources", a.Sources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationProperties.
func (a *AutomationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			a.Actions, err = unmarshalAutomationActionClassificationArray(val)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &a.IsEnabled)
			delete(rawMsg, key)
		case "scopes":
			err = unpopulate(val, "Scopes", &a.Scopes)
			delete(rawMsg, key)
		case "sources":
			err = unpopulate(val, "Sources", &a.Sources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRuleSet.
func (a AutomationRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rules", a.Rules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AutomationSource.
func (a AutomationSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eventSource", a.EventSource)
	populate(objectMap, "ruleSets", a.RuleSets)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AwAssumeRoleAuthenticationDetailsProperties.
func (a AwAssumeRoleAuthenticationDetailsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountId", a.AccountID)
	populate(objectMap, "authenticationProvisioningState", a.AuthenticationProvisioningState)
	objectMap["authenticationType"] = AuthenticationTypeAwsAssumeRole
	populate(objectMap, "awsAssumeRoleArn", a.AwsAssumeRoleArn)
	populate(objectMap, "awsExternalId", a.AwsExternalID)
	populate(objectMap, "grantedPermissions", a.GrantedPermissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwAssumeRoleAuthenticationDetailsProperties.
func (a *AwAssumeRoleAuthenticationDetailsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountId":
			err = unpopulate(val, "AccountID", &a.AccountID)
			delete(rawMsg, key)
		case "authenticationProvisioningState":
			err = unpopulate(val, "AuthenticationProvisioningState", &a.AuthenticationProvisioningState)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &a.AuthenticationType)
			delete(rawMsg, key)
		case "awsAssumeRoleArn":
			err = unpopulate(val, "AwsAssumeRoleArn", &a.AwsAssumeRoleArn)
			delete(rawMsg, key)
		case "awsExternalId":
			err = unpopulate(val, "AwsExternalID", &a.AwsExternalID)
			delete(rawMsg, key)
		case "grantedPermissions":
			err = unpopulate(val, "GrantedPermissions", &a.GrantedPermissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AwsCredsAuthenticationDetailsProperties.
func (a AwsCredsAuthenticationDetailsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountId", a.AccountID)
	populate(objectMap, "authenticationProvisioningState", a.AuthenticationProvisioningState)
	objectMap["authenticationType"] = AuthenticationTypeAwsCreds
	populate(objectMap, "awsAccessKeyId", a.AwsAccessKeyID)
	populate(objectMap, "awsSecretAccessKey", a.AwsSecretAccessKey)
	populate(objectMap, "grantedPermissions", a.GrantedPermissions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwsCredsAuthenticationDetailsProperties.
func (a *AwsCredsAuthenticationDetailsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountId":
			err = unpopulate(val, "AccountID", &a.AccountID)
			delete(rawMsg, key)
		case "authenticationProvisioningState":
			err = unpopulate(val, "AuthenticationProvisioningState", &a.AuthenticationProvisioningState)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &a.AuthenticationType)
			delete(rawMsg, key)
		case "awsAccessKeyId":
			err = unpopulate(val, "AwsAccessKeyID", &a.AwsAccessKeyID)
			delete(rawMsg, key)
		case "awsSecretAccessKey":
			err = unpopulate(val, "AwsSecretAccessKey", &a.AwsSecretAccessKey)
			delete(rawMsg, key)
		case "grantedPermissions":
			err = unpopulate(val, "GrantedPermissions", &a.GrantedPermissions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceDetails.
func (a AzureResourceDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["source"] = SourceAzure
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureResourceDetails.
func (a *AzureResourceDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceIdentifier.
func (a AzureResourceIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureResourceId", a.AzureResourceID)
	objectMap["type"] = ResourceIdentifierTypeAzureResource
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureResourceIdentifier.
func (a *AzureResourceIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureResourceId":
			err = unpopulate(val, "AzureResourceID", &a.AzureResourceID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Baseline.
func (b Baseline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expectedResults", b.ExpectedResults)
	populateTimeRFC3339(objectMap, "updatedTime", b.UpdatedTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Baseline.
func (b *Baseline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expectedResults":
			err = unpopulate(val, "ExpectedResults", &b.ExpectedResults)
			delete(rawMsg, key)
		case "updatedTime":
			err = unpopulateTimeRFC3339(val, "UpdatedTime", &b.UpdatedTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaselineAdjustedResult.
func (b BaselineAdjustedResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseline", b.Baseline)
	populate(objectMap, "resultsNotInBaseline", b.ResultsNotInBaseline)
	populate(objectMap, "resultsOnlyInBaseline", b.ResultsOnlyInBaseline)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CefExternalSecuritySolution.
func (c CefExternalSecuritySolution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CefExternalSecuritySolution.
func (c *CefExternalSecuritySolution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CefSolutionProperties.
func (c CefSolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agent", c.Agent)
	populate(objectMap, "deviceType", c.DeviceType)
	populate(objectMap, "deviceVendor", c.DeviceVendor)
	populate(objectMap, "hostname", c.Hostname)
	populate(objectMap, "lastEventReceived", c.LastEventReceived)
	populate(objectMap, "workspace", c.Workspace)
	if c.AdditionalProperties != nil {
		for key, val := range c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CefSolutionProperties.
func (c *CefSolutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agent":
			err = unpopulate(val, "Agent", &c.Agent)
			delete(rawMsg, key)
		case "deviceType":
			err = unpopulate(val, "DeviceType", &c.DeviceType)
			delete(rawMsg, key)
		case "deviceVendor":
			err = unpopulate(val, "DeviceVendor", &c.DeviceVendor)
			delete(rawMsg, key)
		case "hostname":
			err = unpopulate(val, "Hostname", &c.Hostname)
			delete(rawMsg, key)
		case "lastEventReceived":
			err = unpopulate(val, "LastEventReceived", &c.LastEventReceived)
			delete(rawMsg, key)
		case "workspace":
			err = unpopulate(val, "Workspace", &c.Workspace)
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				c.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComplianceProperties.
func (c ComplianceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentResult", c.AssessmentResult)
	populateTimeRFC3339(objectMap, "assessmentTimestampUtcDate", c.AssessmentTimestampUTCDate)
	populate(objectMap, "resourceCount", c.ResourceCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComplianceProperties.
func (c *ComplianceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentResult":
			err = unpopulate(val, "AssessmentResult", &c.AssessmentResult)
			delete(rawMsg, key)
		case "assessmentTimestampUtcDate":
			err = unpopulateTimeRFC3339(val, "AssessmentTimestampUTCDate", &c.AssessmentTimestampUTCDate)
			delete(rawMsg, key)
		case "resourceCount":
			err = unpopulate(val, "ResourceCount", &c.ResourceCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectableResource.
func (c ConnectableResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "inboundConnectedResources", c.InboundConnectedResources)
	populate(objectMap, "outboundConnectedResources", c.OutboundConnectedResources)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionFromIPNotAllowed.
func (c ConnectionFromIPNotAllowed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistValues", c.AllowlistValues)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "isEnabled", c.IsEnabled)
	objectMap["ruleType"] = "ConnectionFromIpNotAllowed"
	populate(objectMap, "valueType", c.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionFromIPNotAllowed.
func (c *ConnectionFromIPNotAllowed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistValues":
			err = unpopulate(val, "AllowlistValues", &c.AllowlistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &c.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &c.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &c.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionToIPNotAllowed.
func (c ConnectionToIPNotAllowed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistValues", c.AllowlistValues)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "isEnabled", c.IsEnabled)
	objectMap["ruleType"] = "ConnectionToIpNotAllowed"
	populate(objectMap, "valueType", c.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionToIPNotAllowed.
func (c *ConnectionToIPNotAllowed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistValues":
			err = unpopulate(val, "AllowlistValues", &c.AllowlistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &c.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &c.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &c.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Connector.
func (c Connector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorProperties.
func (c ConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cloudName", c.CloudName)
	populate(objectMap, "hierarchyIdentifier", c.HierarchyIdentifier)
	populate(objectMap, "offerings", c.Offerings)
	populate(objectMap, "organizationalData", c.OrganizationalData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorProperties.
func (c *ConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudName":
			err = unpopulate(val, "CloudName", &c.CloudName)
			delete(rawMsg, key)
		case "hierarchyIdentifier":
			err = unpopulate(val, "HierarchyIdentifier", &c.HierarchyIdentifier)
			delete(rawMsg, key)
		case "offerings":
			c.Offerings, err = unmarshalCloudOfferingClassificationArray(val)
			delete(rawMsg, key)
		case "organizationalData":
			err = unpopulate(val, "OrganizationalData", &c.OrganizationalData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorPropertiesOrganizationalData.
func (c ConnectorPropertiesOrganizationalData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "excludedAccountIds", c.ExcludedAccountIDs)
	populate(objectMap, "organizationMembershipType", c.OrganizationMembershipType)
	populate(objectMap, "parentHierarchyId", c.ParentHierarchyID)
	populate(objectMap, "stacksetName", c.StacksetName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectorSettingProperties.
func (c ConnectorSettingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationDetails", c.AuthenticationDetails)
	populate(objectMap, "hybridComputeSettings", c.HybridComputeSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectorSettingProperties.
func (c *ConnectorSettingProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationDetails":
			c.AuthenticationDetails, err = unmarshalAuthenticationDetailsPropertiesClassification(val)
			delete(rawMsg, key)
		case "hybridComputeSettings":
			err = unpopulate(val, "HybridComputeSettings", &c.HybridComputeSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Contact.
func (c Contact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ContainerRegistryVulnerabilityProperties.
func (c ContainerRegistryVulnerabilityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["assessedResourceType"] = AssessedResourceTypeContainerRegistryVulnerability
	populate(objectMap, "cve", c.Cve)
	populate(objectMap, "cvss", c.Cvss)
	populate(objectMap, "imageDigest", c.ImageDigest)
	populate(objectMap, "patchable", c.Patchable)
	populateTimeRFC3339(objectMap, "publishedTime", c.PublishedTime)
	populate(objectMap, "repositoryName", c.RepositoryName)
	populate(objectMap, "type", c.Type)
	populate(objectMap, "vendorReferences", c.VendorReferences)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerRegistryVulnerabilityProperties.
func (c *ContainerRegistryVulnerabilityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedResourceType":
			err = unpopulate(val, "AssessedResourceType", &c.AssessedResourceType)
			delete(rawMsg, key)
		case "cve":
			err = unpopulate(val, "Cve", &c.Cve)
			delete(rawMsg, key)
		case "cvss":
			err = unpopulate(val, "Cvss", &c.Cvss)
			delete(rawMsg, key)
		case "imageDigest":
			err = unpopulate(val, "ImageDigest", &c.ImageDigest)
			delete(rawMsg, key)
		case "patchable":
			err = unpopulate(val, "Patchable", &c.Patchable)
			delete(rawMsg, key)
		case "publishedTime":
			err = unpopulateTimeRFC3339(val, "PublishedTime", &c.PublishedTime)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &c.RepositoryName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "vendorReferences":
			err = unpopulate(val, "VendorReferences", &c.VendorReferences)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CspmMonitorAwsOffering.
func (c CspmMonitorAwsOffering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "nativeCloudConnection", c.NativeCloudConnection)
	objectMap["offeringType"] = OfferingTypeCspmMonitorAws
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CspmMonitorAwsOffering.
func (c *CspmMonitorAwsOffering) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "nativeCloudConnection":
			err = unpopulate(val, "NativeCloudConnection", &c.NativeCloudConnection)
			delete(rawMsg, key)
		case "offeringType":
			err = unpopulate(val, "OfferingType", &c.OfferingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataExportSettings.
func (d DataExportSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	objectMap["kind"] = SettingKindDataExportSettings
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataExportSettings.
func (d *DataExportSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, "Kind", &d.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefenderForContainersAwsOffering.
func (d DefenderForContainersAwsOffering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cloudWatchToKinesis", d.CloudWatchToKinesis)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "kinesisToS3", d.KinesisToS3)
	populate(objectMap, "kubernetesScubaReader", d.KubernetesScubaReader)
	populate(objectMap, "kubernetesService", d.KubernetesService)
	objectMap["offeringType"] = OfferingTypeDefenderForContainersAws
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefenderForContainersAwsOffering.
func (d *DefenderForContainersAwsOffering) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudWatchToKinesis":
			err = unpopulate(val, "CloudWatchToKinesis", &d.CloudWatchToKinesis)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "kinesisToS3":
			err = unpopulate(val, "KinesisToS3", &d.KinesisToS3)
			delete(rawMsg, key)
		case "kubernetesScubaReader":
			err = unpopulate(val, "KubernetesScubaReader", &d.KubernetesScubaReader)
			delete(rawMsg, key)
		case "kubernetesService":
			err = unpopulate(val, "KubernetesService", &d.KubernetesService)
			delete(rawMsg, key)
		case "offeringType":
			err = unpopulate(val, "OfferingType", &d.OfferingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefenderForServersAwsOffering.
func (d DefenderForServersAwsOffering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "arcAutoProvisioning", d.ArcAutoProvisioning)
	populate(objectMap, "defenderForServers", d.DefenderForServers)
	populate(objectMap, "description", d.Description)
	objectMap["offeringType"] = OfferingTypeDefenderForServersAws
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefenderForServersAwsOffering.
func (d *DefenderForServersAwsOffering) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "arcAutoProvisioning":
			err = unpopulate(val, "ArcAutoProvisioning", &d.ArcAutoProvisioning)
			delete(rawMsg, key)
		case "defenderForServers":
			err = unpopulate(val, "DefenderForServers", &d.DefenderForServers)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "offeringType":
			err = unpopulate(val, "OfferingType", &d.OfferingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DenylistCustomAlertRule.
func (d DenylistCustomAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "denylistValues", d.DenylistValues)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isEnabled", d.IsEnabled)
	objectMap["ruleType"] = "DenylistCustomAlertRule"
	populate(objectMap, "valueType", d.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DenylistCustomAlertRule.
func (d *DenylistCustomAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "denylistValues":
			err = unpopulate(val, "DenylistValues", &d.DenylistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &d.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &d.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &d.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeviceSecurityGroupProperties.
func (d DeviceSecurityGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistRules", d.AllowlistRules)
	populate(objectMap, "denylistRules", d.DenylistRules)
	populate(objectMap, "thresholdRules", d.ThresholdRules)
	populate(objectMap, "timeWindowRules", d.TimeWindowRules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeviceSecurityGroupProperties.
func (d *DeviceSecurityGroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistRules":
			d.AllowlistRules, err = unmarshalAllowlistCustomAlertRuleClassificationArray(val)
			delete(rawMsg, key)
		case "denylistRules":
			err = unpopulate(val, "DenylistRules", &d.DenylistRules)
			delete(rawMsg, key)
		case "thresholdRules":
			d.ThresholdRules, err = unmarshalThresholdCustomAlertRuleClassificationArray(val)
			delete(rawMsg, key)
		case "timeWindowRules":
			d.TimeWindowRules, err = unmarshalTimeWindowCustomAlertRuleClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DirectMethodInvokesNotInAllowedRange.
func (d DirectMethodInvokesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isEnabled", d.IsEnabled)
	populate(objectMap, "maxThreshold", d.MaxThreshold)
	populate(objectMap, "minThreshold", d.MinThreshold)
	objectMap["ruleType"] = "DirectMethodInvokesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", d.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DirectMethodInvokesNotInAllowedRange.
func (d *DirectMethodInvokesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &d.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &d.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &d.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &d.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &d.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EffectiveNetworkSecurityGroups.
func (e EffectiveNetworkSecurityGroups) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkInterface", e.NetworkInterface)
	populate(objectMap, "networkSecurityGroups", e.NetworkSecurityGroups)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ExternalSecuritySolutionProperties.
func (e ExternalSecuritySolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deviceType", e.DeviceType)
	populate(objectMap, "deviceVendor", e.DeviceVendor)
	populate(objectMap, "workspace", e.Workspace)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalSecuritySolutionProperties.
func (e *ExternalSecuritySolutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deviceType":
			err = unpopulate(val, "DeviceType", &e.DeviceType)
			delete(rawMsg, key)
		case "deviceVendor":
			err = unpopulate(val, "DeviceVendor", &e.DeviceVendor)
			delete(rawMsg, key)
		case "workspace":
			err = unpopulate(val, "Workspace", &e.Workspace)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FailedLocalLoginsNotInAllowedRange.
func (f FailedLocalLoginsNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", f.Description)
	populate(objectMap, "displayName", f.DisplayName)
	populate(objectMap, "isEnabled", f.IsEnabled)
	populate(objectMap, "maxThreshold", f.MaxThreshold)
	populate(objectMap, "minThreshold", f.MinThreshold)
	objectMap["ruleType"] = "FailedLocalLoginsNotInAllowedRange"
	populate(objectMap, "timeWindowSize", f.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FailedLocalLoginsNotInAllowedRange.
func (f *FailedLocalLoginsNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &f.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &f.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &f.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &f.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &f.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &f.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileUploadsNotInAllowedRange.
func (f FileUploadsNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", f.Description)
	populate(objectMap, "displayName", f.DisplayName)
	populate(objectMap, "isEnabled", f.IsEnabled)
	populate(objectMap, "maxThreshold", f.MaxThreshold)
	populate(objectMap, "minThreshold", f.MinThreshold)
	objectMap["ruleType"] = "FileUploadsNotInAllowedRange"
	populate(objectMap, "timeWindowSize", f.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileUploadsNotInAllowedRange.
func (f *FileUploadsNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &f.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &f.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &f.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &f.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &f.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &f.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &f.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GcpCredentialsDetailsProperties.
func (g GcpCredentialsDetailsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authProviderX509CertUrl", g.AuthProviderX509CertURL)
	populate(objectMap, "authUri", g.AuthURI)
	populate(objectMap, "authenticationProvisioningState", g.AuthenticationProvisioningState)
	objectMap["authenticationType"] = AuthenticationTypeGcpCredentials
	populate(objectMap, "clientEmail", g.ClientEmail)
	populate(objectMap, "clientId", g.ClientID)
	populate(objectMap, "clientX509CertUrl", g.ClientX509CertURL)
	populate(objectMap, "grantedPermissions", g.GrantedPermissions)
	populate(objectMap, "organizationId", g.OrganizationID)
	populate(objectMap, "privateKey", g.PrivateKey)
	populate(objectMap, "privateKeyId", g.PrivateKeyID)
	populate(objectMap, "projectId", g.ProjectID)
	populate(objectMap, "tokenUri", g.TokenURI)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GcpCredentialsDetailsProperties.
func (g *GcpCredentialsDetailsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authProviderX509CertUrl":
			err = unpopulate(val, "AuthProviderX509CertURL", &g.AuthProviderX509CertURL)
			delete(rawMsg, key)
		case "authUri":
			err = unpopulate(val, "AuthURI", &g.AuthURI)
			delete(rawMsg, key)
		case "authenticationProvisioningState":
			err = unpopulate(val, "AuthenticationProvisioningState", &g.AuthenticationProvisioningState)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, "AuthenticationType", &g.AuthenticationType)
			delete(rawMsg, key)
		case "clientEmail":
			err = unpopulate(val, "ClientEmail", &g.ClientEmail)
			delete(rawMsg, key)
		case "clientId":
			err = unpopulate(val, "ClientID", &g.ClientID)
			delete(rawMsg, key)
		case "clientX509CertUrl":
			err = unpopulate(val, "ClientX509CertURL", &g.ClientX509CertURL)
			delete(rawMsg, key)
		case "grantedPermissions":
			err = unpopulate(val, "GrantedPermissions", &g.GrantedPermissions)
			delete(rawMsg, key)
		case "organizationId":
			err = unpopulate(val, "OrganizationID", &g.OrganizationID)
			delete(rawMsg, key)
		case "privateKey":
			err = unpopulate(val, "PrivateKey", &g.PrivateKey)
			delete(rawMsg, key)
		case "privateKeyId":
			err = unpopulate(val, "PrivateKeyID", &g.PrivateKeyID)
			delete(rawMsg, key)
		case "projectId":
			err = unpopulate(val, "ProjectID", &g.ProjectID)
			delete(rawMsg, key)
		case "tokenUri":
			err = unpopulate(val, "TokenURI", &g.TokenURI)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPC2DMessagesNotInAllowedRange.
func (h HTTPC2DMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", h.Description)
	populate(objectMap, "displayName", h.DisplayName)
	populate(objectMap, "isEnabled", h.IsEnabled)
	populate(objectMap, "maxThreshold", h.MaxThreshold)
	populate(objectMap, "minThreshold", h.MinThreshold)
	objectMap["ruleType"] = "HttpC2DMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", h.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPC2DMessagesNotInAllowedRange.
func (h *HTTPC2DMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &h.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &h.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &h.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &h.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &h.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &h.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPC2DRejectedMessagesNotInAllowedRange.
func (h HTTPC2DRejectedMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", h.Description)
	populate(objectMap, "displayName", h.DisplayName)
	populate(objectMap, "isEnabled", h.IsEnabled)
	populate(objectMap, "maxThreshold", h.MaxThreshold)
	populate(objectMap, "minThreshold", h.MinThreshold)
	objectMap["ruleType"] = "HttpC2DRejectedMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", h.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPC2DRejectedMessagesNotInAllowedRange.
func (h *HTTPC2DRejectedMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &h.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &h.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &h.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &h.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &h.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &h.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPD2CMessagesNotInAllowedRange.
func (h HTTPD2CMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", h.Description)
	populate(objectMap, "displayName", h.DisplayName)
	populate(objectMap, "isEnabled", h.IsEnabled)
	populate(objectMap, "maxThreshold", h.MaxThreshold)
	populate(objectMap, "minThreshold", h.MinThreshold)
	objectMap["ruleType"] = "HttpD2CMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", h.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPD2CMessagesNotInAllowedRange.
func (h *HTTPD2CMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &h.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &h.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &h.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &h.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &h.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &h.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &h.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformationProtectionAwsOffering.
func (i InformationProtectionAwsOffering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", i.Description)
	populate(objectMap, "informationProtection", i.InformationProtection)
	objectMap["offeringType"] = OfferingTypeInformationProtectionAws
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformationProtectionAwsOffering.
func (i *InformationProtectionAwsOffering) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "informationProtection":
			err = unpopulate(val, "InformationProtection", &i.InformationProtection)
			delete(rawMsg, key)
		case "offeringType":
			err = unpopulate(val, "OfferingType", &i.OfferingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformationProtectionPolicyProperties.
func (i InformationProtectionPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "informationTypes", i.InformationTypes)
	populate(objectMap, "labels", i.Labels)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", i.LastModifiedUTC)
	populate(objectMap, "version", i.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformationProtectionPolicyProperties.
func (i *InformationProtectionPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "informationTypes":
			err = unpopulate(val, "InformationTypes", &i.InformationTypes)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, "Labels", &i.Labels)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, "LastModifiedUTC", &i.LastModifiedUTC)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InformationType.
func (i InformationType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "custom", i.Custom)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "enabled", i.Enabled)
	populate(objectMap, "keywords", i.Keywords)
	populate(objectMap, "order", i.Order)
	populate(objectMap, "recommendedLabelId", i.RecommendedLabelID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecurityAggregatedAlert.
func (i IoTSecurityAggregatedAlert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecurityAggregatedAlertProperties.
func (i IoTSecurityAggregatedAlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionTaken", i.ActionTaken)
	populateDateType(objectMap, "aggregatedDateUtc", i.AggregatedDateUTC)
	populate(objectMap, "alertDisplayName", i.AlertDisplayName)
	populate(objectMap, "alertType", i.AlertType)
	populate(objectMap, "count", i.Count)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "effectedResourceType", i.EffectedResourceType)
	populate(objectMap, "logAnalyticsQuery", i.LogAnalyticsQuery)
	populate(objectMap, "remediationSteps", i.RemediationSteps)
	populate(objectMap, "reportedSeverity", i.ReportedSeverity)
	populate(objectMap, "systemSource", i.SystemSource)
	populate(objectMap, "topDevicesList", i.TopDevicesList)
	populate(objectMap, "vendorName", i.VendorName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTSecurityAggregatedAlertProperties.
func (i *IoTSecurityAggregatedAlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionTaken":
			err = unpopulate(val, "ActionTaken", &i.ActionTaken)
			delete(rawMsg, key)
		case "aggregatedDateUtc":
			err = unpopulateDateType(val, "AggregatedDateUTC", &i.AggregatedDateUTC)
			delete(rawMsg, key)
		case "alertDisplayName":
			err = unpopulate(val, "AlertDisplayName", &i.AlertDisplayName)
			delete(rawMsg, key)
		case "alertType":
			err = unpopulate(val, "AlertType", &i.AlertType)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, "Count", &i.Count)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "effectedResourceType":
			err = unpopulate(val, "EffectedResourceType", &i.EffectedResourceType)
			delete(rawMsg, key)
		case "logAnalyticsQuery":
			err = unpopulate(val, "LogAnalyticsQuery", &i.LogAnalyticsQuery)
			delete(rawMsg, key)
		case "remediationSteps":
			err = unpopulate(val, "RemediationSteps", &i.RemediationSteps)
			delete(rawMsg, key)
		case "reportedSeverity":
			err = unpopulate(val, "ReportedSeverity", &i.ReportedSeverity)
			delete(rawMsg, key)
		case "systemSource":
			err = unpopulate(val, "SystemSource", &i.SystemSource)
			delete(rawMsg, key)
		case "topDevicesList":
			err = unpopulate(val, "TopDevicesList", &i.TopDevicesList)
			delete(rawMsg, key)
		case "vendorName":
			err = unpopulate(val, "VendorName", &i.VendorName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecurityAggregatedRecommendation.
func (i IoTSecurityAggregatedRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecuritySolutionAnalyticsModelProperties.
func (i IoTSecuritySolutionAnalyticsModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "devicesMetrics", i.DevicesMetrics)
	populate(objectMap, "metrics", i.Metrics)
	populate(objectMap, "mostPrevalentDeviceAlerts", i.MostPrevalentDeviceAlerts)
	populate(objectMap, "mostPrevalentDeviceRecommendations", i.MostPrevalentDeviceRecommendations)
	populate(objectMap, "topAlertedDevices", i.TopAlertedDevices)
	populate(objectMap, "unhealthyDeviceCount", i.UnhealthyDeviceCount)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem.
func (i IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "date", i.Date)
	populate(objectMap, "devicesMetrics", i.DevicesMetrics)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem.
func (i *IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "date":
			err = unpopulateTimeRFC3339(val, "Date", &i.Date)
			delete(rawMsg, key)
		case "devicesMetrics":
			err = unpopulate(val, "DevicesMetrics", &i.DevicesMetrics)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecuritySolutionModel.
func (i IoTSecuritySolutionModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IoTSecuritySolutionProperties.
func (i IoTSecuritySolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalWorkspaces", i.AdditionalWorkspaces)
	populate(objectMap, "autoDiscoveredResources", i.AutoDiscoveredResources)
	populate(objectMap, "disabledDataSources", i.DisabledDataSources)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "export", i.Export)
	populate(objectMap, "iotHubs", i.IotHubs)
	populate(objectMap, "recommendationsConfiguration", i.RecommendationsConfiguration)
	populate(objectMap, "status", i.Status)
	populate(objectMap, "unmaskedIpLoggingStatus", i.UnmaskedIPLoggingStatus)
	populate(objectMap, "userDefinedResources", i.UserDefinedResources)
	populate(objectMap, "workspace", i.Workspace)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPolicyInitiatePort.
func (j JitNetworkAccessPolicyInitiatePort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedSourceAddressPrefix", j.AllowedSourceAddressPrefix)
	populateTimeRFC3339(objectMap, "endTimeUtc", j.EndTimeUTC)
	populate(objectMap, "number", j.Number)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JitNetworkAccessPolicyInitiatePort.
func (j *JitNetworkAccessPolicyInitiatePort) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedSourceAddressPrefix":
			err = unpopulate(val, "AllowedSourceAddressPrefix", &j.AllowedSourceAddressPrefix)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, "EndTimeUTC", &j.EndTimeUTC)
			delete(rawMsg, key)
		case "number":
			err = unpopulate(val, "Number", &j.Number)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPolicyInitiateRequest.
func (j JitNetworkAccessPolicyInitiateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "justification", j.Justification)
	populate(objectMap, "virtualMachines", j.VirtualMachines)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPolicyInitiateVirtualMachine.
func (j JitNetworkAccessPolicyInitiateVirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "ports", j.Ports)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPolicyProperties.
func (j JitNetworkAccessPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "provisioningState", j.ProvisioningState)
	populate(objectMap, "requests", j.Requests)
	populate(objectMap, "virtualMachines", j.VirtualMachines)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPolicyVirtualMachine.
func (j JitNetworkAccessPolicyVirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "ports", j.Ports)
	populate(objectMap, "publicIpAddress", j.PublicIPAddress)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessPortRule.
func (j JitNetworkAccessPortRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedSourceAddressPrefix", j.AllowedSourceAddressPrefix)
	populate(objectMap, "allowedSourceAddressPrefixes", j.AllowedSourceAddressPrefixes)
	populate(objectMap, "maxRequestAccessDuration", j.MaxRequestAccessDuration)
	populate(objectMap, "number", j.Number)
	populate(objectMap, "protocol", j.Protocol)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessRequest.
func (j JitNetworkAccessRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "justification", j.Justification)
	populate(objectMap, "requestor", j.Requestor)
	populateTimeRFC3339(objectMap, "startTimeUtc", j.StartTimeUTC)
	populate(objectMap, "virtualMachines", j.VirtualMachines)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JitNetworkAccessRequest.
func (j *JitNetworkAccessRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "justification":
			err = unpopulate(val, "Justification", &j.Justification)
			delete(rawMsg, key)
		case "requestor":
			err = unpopulate(val, "Requestor", &j.Requestor)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateTimeRFC3339(val, "StartTimeUTC", &j.StartTimeUTC)
			delete(rawMsg, key)
		case "virtualMachines":
			err = unpopulate(val, "VirtualMachines", &j.VirtualMachines)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessRequestPort.
func (j JitNetworkAccessRequestPort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedSourceAddressPrefix", j.AllowedSourceAddressPrefix)
	populate(objectMap, "allowedSourceAddressPrefixes", j.AllowedSourceAddressPrefixes)
	populateTimeRFC3339(objectMap, "endTimeUtc", j.EndTimeUTC)
	populate(objectMap, "mappedPort", j.MappedPort)
	populate(objectMap, "number", j.Number)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "statusReason", j.StatusReason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JitNetworkAccessRequestPort.
func (j *JitNetworkAccessRequestPort) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedSourceAddressPrefix":
			err = unpopulate(val, "AllowedSourceAddressPrefix", &j.AllowedSourceAddressPrefix)
			delete(rawMsg, key)
		case "allowedSourceAddressPrefixes":
			err = unpopulate(val, "AllowedSourceAddressPrefixes", &j.AllowedSourceAddressPrefixes)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, "EndTimeUTC", &j.EndTimeUTC)
			delete(rawMsg, key)
		case "mappedPort":
			err = unpopulate(val, "MappedPort", &j.MappedPort)
			delete(rawMsg, key)
		case "number":
			err = unpopulate(val, "Number", &j.Number)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		case "statusReason":
			err = unpopulate(val, "StatusReason", &j.StatusReason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JitNetworkAccessRequestVirtualMachine.
func (j JitNetworkAccessRequestVirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "ports", j.Ports)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ListCustomAlertRule.
func (l ListCustomAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", l.Description)
	populate(objectMap, "displayName", l.DisplayName)
	populate(objectMap, "isEnabled", l.IsEnabled)
	objectMap["ruleType"] = "ListCustomAlertRule"
	populate(objectMap, "valueType", l.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListCustomAlertRule.
func (l *ListCustomAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &l.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &l.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &l.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &l.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LocalUserNotAllowed.
func (l LocalUserNotAllowed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistValues", l.AllowlistValues)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "displayName", l.DisplayName)
	populate(objectMap, "isEnabled", l.IsEnabled)
	objectMap["ruleType"] = "LocalUserNotAllowed"
	populate(objectMap, "valueType", l.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LocalUserNotAllowed.
func (l *LocalUserNotAllowed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistValues":
			err = unpopulate(val, "AllowlistValues", &l.AllowlistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &l.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &l.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &l.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &l.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogAnalyticsIdentifier.
func (l LogAnalyticsIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentId", l.AgentID)
	objectMap["type"] = ResourceIdentifierTypeLogAnalytics
	populate(objectMap, "workspaceId", l.WorkspaceID)
	populate(objectMap, "workspaceResourceGroup", l.WorkspaceResourceGroup)
	populate(objectMap, "workspaceSubscriptionId", l.WorkspaceSubscriptionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogAnalyticsIdentifier.
func (l *LogAnalyticsIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentId":
			err = unpopulate(val, "AgentID", &l.AgentID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &l.WorkspaceID)
			delete(rawMsg, key)
		case "workspaceResourceGroup":
			err = unpopulate(val, "WorkspaceResourceGroup", &l.WorkspaceResourceGroup)
			delete(rawMsg, key)
		case "workspaceSubscriptionId":
			err = unpopulate(val, "WorkspaceSubscriptionID", &l.WorkspaceSubscriptionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MdeOnboardingDataProperties.
func (m MdeOnboardingDataProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "onboardingPackageLinux", m.OnboardingPackageLinux, runtime.Base64StdFormat)
	populateByteArray(objectMap, "onboardingPackageWindows", m.OnboardingPackageWindows, runtime.Base64StdFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MdeOnboardingDataProperties.
func (m *MdeOnboardingDataProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "onboardingPackageLinux":
			err = runtime.DecodeByteArray(string(val), &m.OnboardingPackageLinux, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "onboardingPackageWindows":
			err = runtime.DecodeByteArray(string(val), &m.OnboardingPackageWindows, runtime.Base64StdFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MqttC2DMessagesNotInAllowedRange.
func (m MqttC2DMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "maxThreshold", m.MaxThreshold)
	populate(objectMap, "minThreshold", m.MinThreshold)
	objectMap["ruleType"] = "MqttC2DMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", m.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MqttC2DMessagesNotInAllowedRange.
func (m *MqttC2DMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &m.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &m.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &m.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &m.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &m.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MqttC2DRejectedMessagesNotInAllowedRange.
func (m MqttC2DRejectedMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "maxThreshold", m.MaxThreshold)
	populate(objectMap, "minThreshold", m.MinThreshold)
	objectMap["ruleType"] = "MqttC2DRejectedMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", m.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MqttC2DRejectedMessagesNotInAllowedRange.
func (m *MqttC2DRejectedMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &m.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &m.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &m.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &m.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &m.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MqttD2CMessagesNotInAllowedRange.
func (m MqttD2CMessagesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "maxThreshold", m.MaxThreshold)
	populate(objectMap, "minThreshold", m.MinThreshold)
	objectMap["ruleType"] = "MqttD2CMessagesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", m.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MqttD2CMessagesNotInAllowedRange.
func (m *MqttD2CMessagesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &m.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &m.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &m.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &m.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &m.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremiseResourceDetails.
func (o OnPremiseResourceDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "machineName", o.MachineName)
	objectMap["source"] = SourceOnPremise
	populate(objectMap, "sourceComputerId", o.SourceComputerID)
	populate(objectMap, "vmuuid", o.Vmuuid)
	populate(objectMap, "workspaceId", o.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremiseResourceDetails.
func (o *OnPremiseResourceDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "machineName":
			err = unpopulate(val, "MachineName", &o.MachineName)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &o.Source)
			delete(rawMsg, key)
		case "sourceComputerId":
			err = unpopulate(val, "SourceComputerID", &o.SourceComputerID)
			delete(rawMsg, key)
		case "vmuuid":
			err = unpopulate(val, "Vmuuid", &o.Vmuuid)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &o.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremiseSQLResourceDetails.
func (o OnPremiseSQLResourceDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", o.DatabaseName)
	populate(objectMap, "machineName", o.MachineName)
	populate(objectMap, "serverName", o.ServerName)
	objectMap["source"] = SourceOnPremiseSQL
	populate(objectMap, "sourceComputerId", o.SourceComputerID)
	populate(objectMap, "vmuuid", o.Vmuuid)
	populate(objectMap, "workspaceId", o.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremiseSQLResourceDetails.
func (o *OnPremiseSQLResourceDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, "DatabaseName", &o.DatabaseName)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, "MachineName", &o.MachineName)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, "ServerName", &o.ServerName)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &o.Source)
			delete(rawMsg, key)
		case "sourceComputerId":
			err = unpopulate(val, "SourceComputerID", &o.SourceComputerID)
			delete(rawMsg, key)
		case "vmuuid":
			err = unpopulate(val, "Vmuuid", &o.Vmuuid)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &o.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathRecommendation.
func (p PathRecommendation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", p.Action)
	populate(objectMap, "common", p.Common)
	populate(objectMap, "configurationStatus", p.ConfigurationStatus)
	populate(objectMap, "fileType", p.FileType)
	populate(objectMap, "path", p.Path)
	populate(objectMap, "publisherInfo", p.PublisherInfo)
	populate(objectMap, "type", p.Type)
	populate(objectMap, "userSids", p.UserSids)
	populate(objectMap, "usernames", p.Usernames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ProcessNotAllowed.
func (p ProcessNotAllowed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowlistValues", p.AllowlistValues)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "isEnabled", p.IsEnabled)
	objectMap["ruleType"] = "ProcessNotAllowed"
	populate(objectMap, "valueType", p.ValueType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessNotAllowed.
func (p *ProcessNotAllowed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowlistValues":
			err = unpopulate(val, "AllowlistValues", &p.AllowlistValues)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &p.IsEnabled)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &p.RuleType)
			delete(rawMsg, key)
		case "valueType":
			err = unpopulate(val, "ValueType", &p.ValueType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueryCheck.
func (q QueryCheck) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columnNames", q.ColumnNames)
	populate(objectMap, "expectedResult", q.ExpectedResult)
	populate(objectMap, "query", q.Query)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type QueuePurgesNotInAllowedRange.
func (q QueuePurgesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", q.Description)
	populate(objectMap, "displayName", q.DisplayName)
	populate(objectMap, "isEnabled", q.IsEnabled)
	populate(objectMap, "maxThreshold", q.MaxThreshold)
	populate(objectMap, "minThreshold", q.MinThreshold)
	objectMap["ruleType"] = "QueuePurgesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", q.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueuePurgesNotInAllowedRange.
func (q *QueuePurgesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &q.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &q.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &q.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &q.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &q.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &q.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &q.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Remediation.
func (r Remediation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "automated", r.Automated)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "portalLink", r.PortalLink)
	populate(objectMap, "scripts", r.Scripts)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Rule.
func (r Rule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destinationPort", r.DestinationPort)
	populate(objectMap, "direction", r.Direction)
	populate(objectMap, "ipAddresses", r.IPAddresses)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "protocols", r.Protocols)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RuleResultsInput.
func (r RuleResultsInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "latestScan", r.LatestScan)
	populate(objectMap, "results", r.Results)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RuleResultsProperties.
func (r RuleResultsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "results", r.Results)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RulesResultsInput.
func (r RulesResultsInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "latestScan", r.LatestScan)
	populate(objectMap, "results", r.Results)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerVulnerabilityProperties.
func (s SQLServerVulnerabilityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["assessedResourceType"] = AssessedResourceTypeSQLServerVulnerability
	populate(objectMap, "query", s.Query)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerVulnerabilityProperties.
func (s *SQLServerVulnerabilityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedResourceType":
			err = unpopulate(val, "AssessedResourceType", &s.AssessedResourceType)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, "Query", &s.Query)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScanProperties.
func (s ScanProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "database", s.Database)
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "highSeverityFailedRulesCount", s.HighSeverityFailedRulesCount)
	populate(objectMap, "isBaselineApplied", s.IsBaselineApplied)
	populate(objectMap, "lowSeverityFailedRulesCount", s.LowSeverityFailedRulesCount)
	populate(objectMap, "mediumSeverityFailedRulesCount", s.MediumSeverityFailedRulesCount)
	populate(objectMap, "sqlVersion", s.SQLVersion)
	populate(objectMap, "server", s.Server)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "state", s.State)
	populate(objectMap, "totalFailedRulesCount", s.TotalFailedRulesCount)
	populate(objectMap, "totalPassedRulesCount", s.TotalPassedRulesCount)
	populate(objectMap, "totalRulesCount", s.TotalRulesCount)
	populate(objectMap, "triggerType", s.TriggerType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScanProperties.
func (s *ScanProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			err = unpopulate(val, "Database", &s.Database)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, "EndTime", &s.EndTime)
			delete(rawMsg, key)
		case "highSeverityFailedRulesCount":
			err = unpopulate(val, "HighSeverityFailedRulesCount", &s.HighSeverityFailedRulesCount)
			delete(rawMsg, key)
		case "isBaselineApplied":
			err = unpopulate(val, "IsBaselineApplied", &s.IsBaselineApplied)
			delete(rawMsg, key)
		case "lowSeverityFailedRulesCount":
			err = unpopulate(val, "LowSeverityFailedRulesCount", &s.LowSeverityFailedRulesCount)
			delete(rawMsg, key)
		case "mediumSeverityFailedRulesCount":
			err = unpopulate(val, "MediumSeverityFailedRulesCount", &s.MediumSeverityFailedRulesCount)
			delete(rawMsg, key)
		case "sqlVersion":
			err = unpopulate(val, "SQLVersion", &s.SQLVersion)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, "Server", &s.Server)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &s.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &s.State)
			delete(rawMsg, key)
		case "totalFailedRulesCount":
			err = unpopulate(val, "TotalFailedRulesCount", &s.TotalFailedRulesCount)
			delete(rawMsg, key)
		case "totalPassedRulesCount":
			err = unpopulate(val, "TotalPassedRulesCount", &s.TotalPassedRulesCount)
			delete(rawMsg, key)
		case "totalRulesCount":
			err = unpopulate(val, "TotalRulesCount", &s.TotalRulesCount)
			delete(rawMsg, key)
		case "triggerType":
			err = unpopulate(val, "TriggerType", &s.TriggerType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScanResultProperties.
func (s ScanResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baselineAdjustedResult", s.BaselineAdjustedResult)
	populate(objectMap, "isTrimmed", s.IsTrimmed)
	populate(objectMap, "queryResults", s.QueryResults)
	populate(objectMap, "remediation", s.Remediation)
	populate(objectMap, "ruleId", s.RuleID)
	populate(objectMap, "ruleMetadata", s.RuleMetadata)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScopeElement.
func (s ScopeElement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "field", s.Field)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScopeElement.
func (s *ScopeElement) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "field":
			err = unpopulate(val, "Field", &s.Field)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecureScoreControlDefinitionItemProperties.
func (s SecureScoreControlDefinitionItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentDefinitions", s.AssessmentDefinitions)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "maxScore", s.MaxScore)
	populate(objectMap, "source", s.Source)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ServerVulnerabilityProperties.
func (s ServerVulnerabilityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["assessedResourceType"] = "ServerVulnerabilityAssessment"
	populate(objectMap, "cve", s.Cve)
	populate(objectMap, "cvss", s.Cvss)
	populate(objectMap, "patchable", s.Patchable)
	populateTimeRFC3339(objectMap, "publishedTime", s.PublishedTime)
	populate(objectMap, "threat", s.Threat)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "vendorReferences", s.VendorReferences)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerVulnerabilityProperties.
func (s *ServerVulnerabilityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessedResourceType":
			err = unpopulate(val, "AssessedResourceType", &s.AssessedResourceType)
			delete(rawMsg, key)
		case "cve":
			err = unpopulate(val, "Cve", &s.Cve)
			delete(rawMsg, key)
		case "cvss":
			err = unpopulate(val, "Cvss", &s.Cvss)
			delete(rawMsg, key)
		case "patchable":
			err = unpopulate(val, "Patchable", &s.Patchable)
			delete(rawMsg, key)
		case "publishedTime":
			err = unpopulateTimeRFC3339(val, "PublishedTime", &s.PublishedTime)
			delete(rawMsg, key)
		case "threat":
			err = unpopulate(val, "Threat", &s.Threat)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "vendorReferences":
			err = unpopulate(val, "VendorReferences", &s.VendorReferences)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SettingsList.
func (s *SettingsList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			s.Value, err = unmarshalSettingClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubAssessmentProperties.
func (s SubAssessmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", s.AdditionalData)
	populate(objectMap, "category", s.Category)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "impact", s.Impact)
	populate(objectMap, "remediation", s.Remediation)
	populate(objectMap, "resourceDetails", s.ResourceDetails)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "timeGenerated", s.TimeGenerated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubAssessmentProperties.
func (s *SubAssessmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			s.AdditionalData, err = unmarshalAdditionalDataClassification(val)
			delete(rawMsg, key)
		case "category":
			err = unpopulate(val, "Category", &s.Category)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &s.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "impact":
			err = unpopulate(val, "Impact", &s.Impact)
			delete(rawMsg, key)
		case "remediation":
			err = unpopulate(val, "Remediation", &s.Remediation)
			delete(rawMsg, key)
		case "resourceDetails":
			s.ResourceDetails, err = unmarshalResourceDetailsClassification(val)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "timeGenerated":
			err = unpopulateTimeRFC3339(val, "TimeGenerated", &s.TimeGenerated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuppressionAlertsScope.
func (s SuppressionAlertsScope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allOf", s.AllOf)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Tags.
func (t Tags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TagsResource.
func (t TagsResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", t.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TaskParameters.
func (t TaskParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", t.Name)
	if t.AdditionalProperties != nil {
		for key, val := range t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskParameters.
func (t *TaskParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				t.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaskProperties.
func (t TaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationTimeUtc", t.CreationTimeUTC)
	populateTimeRFC3339(objectMap, "lastStateChangeTimeUtc", t.LastStateChangeTimeUTC)
	populate(objectMap, "securityTaskParameters", t.SecurityTaskParameters)
	populate(objectMap, "state", t.State)
	populate(objectMap, "subState", t.SubState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaskProperties.
func (t *TaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTimeUtc":
			err = unpopulateTimeRFC3339(val, "CreationTimeUTC", &t.CreationTimeUTC)
			delete(rawMsg, key)
		case "lastStateChangeTimeUtc":
			err = unpopulateTimeRFC3339(val, "LastStateChangeTimeUTC", &t.LastStateChangeTimeUTC)
			delete(rawMsg, key)
		case "securityTaskParameters":
			err = unpopulate(val, "SecurityTaskParameters", &t.SecurityTaskParameters)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &t.State)
			delete(rawMsg, key)
		case "subState":
			err = unpopulate(val, "SubState", &t.SubState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThresholdCustomAlertRule.
func (t ThresholdCustomAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "isEnabled", t.IsEnabled)
	populate(objectMap, "maxThreshold", t.MaxThreshold)
	populate(objectMap, "minThreshold", t.MinThreshold)
	objectMap["ruleType"] = "ThresholdCustomAlertRule"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThresholdCustomAlertRule.
func (t *ThresholdCustomAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &t.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &t.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &t.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &t.RuleType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimeWindowCustomAlertRule.
func (t TimeWindowCustomAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "isEnabled", t.IsEnabled)
	populate(objectMap, "maxThreshold", t.MaxThreshold)
	populate(objectMap, "minThreshold", t.MinThreshold)
	objectMap["ruleType"] = "TimeWindowCustomAlertRule"
	populate(objectMap, "timeWindowSize", t.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimeWindowCustomAlertRule.
func (t *TimeWindowCustomAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &t.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &t.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &t.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &t.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &t.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TopologyResourceProperties.
func (t TopologyResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "calculatedDateTime", t.CalculatedDateTime)
	populate(objectMap, "topologyResources", t.TopologyResources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopologyResourceProperties.
func (t *TopologyResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "calculatedDateTime":
			err = unpopulateTimeRFC3339(val, "CalculatedDateTime", &t.CalculatedDateTime)
			delete(rawMsg, key)
		case "topologyResources":
			err = unpopulate(val, "TopologyResources", &t.TopologyResources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TopologySingleResource.
func (t TopologySingleResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "children", t.Children)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "networkZones", t.NetworkZones)
	populate(objectMap, "parents", t.Parents)
	populate(objectMap, "recommendationsExist", t.RecommendationsExist)
	populate(objectMap, "resourceId", t.ResourceID)
	populate(objectMap, "severity", t.Severity)
	populate(objectMap, "topologyScore", t.TopologyScore)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "kind", t.Kind)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TwinUpdatesNotInAllowedRange.
func (t TwinUpdatesNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "isEnabled", t.IsEnabled)
	populate(objectMap, "maxThreshold", t.MaxThreshold)
	populate(objectMap, "minThreshold", t.MinThreshold)
	objectMap["ruleType"] = "TwinUpdatesNotInAllowedRange"
	populate(objectMap, "timeWindowSize", t.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TwinUpdatesNotInAllowedRange.
func (t *TwinUpdatesNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &t.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &t.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &t.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &t.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &t.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnauthorizedOperationsNotInAllowedRange.
func (u UnauthorizedOperationsNotInAllowedRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", u.Description)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "isEnabled", u.IsEnabled)
	populate(objectMap, "maxThreshold", u.MaxThreshold)
	populate(objectMap, "minThreshold", u.MinThreshold)
	objectMap["ruleType"] = "UnauthorizedOperationsNotInAllowedRange"
	populate(objectMap, "timeWindowSize", u.TimeWindowSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnauthorizedOperationsNotInAllowedRange.
func (u *UnauthorizedOperationsNotInAllowedRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, "IsEnabled", &u.IsEnabled)
			delete(rawMsg, key)
		case "maxThreshold":
			err = unpopulate(val, "MaxThreshold", &u.MaxThreshold)
			delete(rawMsg, key)
		case "minThreshold":
			err = unpopulate(val, "MinThreshold", &u.MinThreshold)
			delete(rawMsg, key)
		case "ruleType":
			err = unpopulate(val, "RuleType", &u.RuleType)
			delete(rawMsg, key)
		case "timeWindowSize":
			err = unpopulate(val, "TimeWindowSize", &u.TimeWindowSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIoTSecuritySolutionProperties.
func (u UpdateIoTSecuritySolutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "recommendationsConfiguration", u.RecommendationsConfiguration)
	populate(objectMap, "userDefinedResources", u.UserDefinedResources)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIotSecuritySolutionData.
func (u UpdateIotSecuritySolutionData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type UserDefinedResourcesProperties.
func (u UserDefinedResourcesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "query", u.Query)
	populate(objectMap, "querySubscriptions", u.QuerySubscriptions)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VaRule.
func (v VaRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "benchmarkReferences", v.BenchmarkReferences)
	populate(objectMap, "category", v.Category)
	populate(objectMap, "description", v.Description)
	populate(objectMap, "queryCheck", v.QueryCheck)
	populate(objectMap, "rationale", v.Rationale)
	populate(objectMap, "ruleId", v.RuleID)
	populate(objectMap, "ruleType", v.RuleType)
	populate(objectMap, "severity", v.Severity)
	populate(objectMap, "title", v.Title)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceSetting.
func (w WorkspaceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
