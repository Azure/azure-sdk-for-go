//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsecurity

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AdaptiveNetworkHardeningsListByExtendedResourcePager provides operations for iterating over paged responses.
type AdaptiveNetworkHardeningsListByExtendedResourcePager struct {
	client    *AdaptiveNetworkHardeningsClient
	current   AdaptiveNetworkHardeningsListByExtendedResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AdaptiveNetworkHardeningsListByExtendedResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AdaptiveNetworkHardeningsListByExtendedResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AdaptiveNetworkHardeningsListByExtendedResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AdaptiveNetworkHardeningsList.NextLink == nil || len(*p.current.AdaptiveNetworkHardeningsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByExtendedResourceHandleError(resp)
		return false
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AdaptiveNetworkHardeningsListByExtendedResourceResponse page.
func (p *AdaptiveNetworkHardeningsListByExtendedResourcePager) PageResponse() AdaptiveNetworkHardeningsListByExtendedResourceResponse {
	return p.current
}

// AlertsListByResourceGroupPager provides operations for iterating over paged responses.
type AlertsListByResourceGroupPager struct {
	client    *AlertsClient
	current   AlertsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsListByResourceGroupResponse page.
func (p *AlertsListByResourceGroupPager) PageResponse() AlertsListByResourceGroupResponse {
	return p.current
}

// AlertsListPager provides operations for iterating over paged responses.
type AlertsListPager struct {
	client    *AlertsClient
	current   AlertsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsListResponse page.
func (p *AlertsListPager) PageResponse() AlertsListResponse {
	return p.current
}

// AlertsListResourceGroupLevelByRegionPager provides operations for iterating over paged responses.
type AlertsListResourceGroupLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsListResourceGroupLevelByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsListResourceGroupLevelByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsListResourceGroupLevelByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsListResourceGroupLevelByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listResourceGroupLevelByRegionHandleError(resp)
		return false
	}
	result, err := p.client.listResourceGroupLevelByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsListResourceGroupLevelByRegionResponse page.
func (p *AlertsListResourceGroupLevelByRegionPager) PageResponse() AlertsListResourceGroupLevelByRegionResponse {
	return p.current
}

// AlertsListSubscriptionLevelByRegionPager provides operations for iterating over paged responses.
type AlertsListSubscriptionLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsListSubscriptionLevelByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsListSubscriptionLevelByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsListSubscriptionLevelByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsListSubscriptionLevelByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listSubscriptionLevelByRegionHandleError(resp)
		return false
	}
	result, err := p.client.listSubscriptionLevelByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsListSubscriptionLevelByRegionResponse page.
func (p *AlertsListSubscriptionLevelByRegionPager) PageResponse() AlertsListSubscriptionLevelByRegionResponse {
	return p.current
}

// AlertsSuppressionRulesListPager provides operations for iterating over paged responses.
type AlertsSuppressionRulesListPager struct {
	client    *AlertsSuppressionRulesClient
	current   AlertsSuppressionRulesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsSuppressionRulesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsSuppressionRulesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsSuppressionRulesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertsSuppressionRulesList.NextLink == nil || len(*p.current.AlertsSuppressionRulesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsSuppressionRulesListResponse page.
func (p *AlertsSuppressionRulesListPager) PageResponse() AlertsSuppressionRulesListResponse {
	return p.current
}

// AllowedConnectionsListByHomeRegionPager provides operations for iterating over paged responses.
type AllowedConnectionsListByHomeRegionPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AllowedConnectionsListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AllowedConnectionsListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHomeRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AllowedConnectionsListByHomeRegionResponse page.
func (p *AllowedConnectionsListByHomeRegionPager) PageResponse() AllowedConnectionsListByHomeRegionResponse {
	return p.current
}

// AllowedConnectionsListPager provides operations for iterating over paged responses.
type AllowedConnectionsListPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AllowedConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AllowedConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AllowedConnectionsListResponse page.
func (p *AllowedConnectionsListPager) PageResponse() AllowedConnectionsListResponse {
	return p.current
}

// AssessmentsListPager provides operations for iterating over paged responses.
type AssessmentsListPager struct {
	client    *AssessmentsClient
	current   AssessmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityAssessmentList.NextLink == nil || len(*p.current.SecurityAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsListResponse page.
func (p *AssessmentsListPager) PageResponse() AssessmentsListResponse {
	return p.current
}

// AssessmentsMetadataListBySubscriptionPager provides operations for iterating over paged responses.
type AssessmentsMetadataListBySubscriptionPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsMetadataListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsMetadataListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityAssessmentMetadataResponseList.NextLink == nil || len(*p.current.SecurityAssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsMetadataListBySubscriptionResponse page.
func (p *AssessmentsMetadataListBySubscriptionPager) PageResponse() AssessmentsMetadataListBySubscriptionResponse {
	return p.current
}

// AssessmentsMetadataListPager provides operations for iterating over paged responses.
type AssessmentsMetadataListPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsMetadataListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsMetadataListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityAssessmentMetadataResponseList.NextLink == nil || len(*p.current.SecurityAssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsMetadataListResponse page.
func (p *AssessmentsMetadataListPager) PageResponse() AssessmentsMetadataListResponse {
	return p.current
}

// AutoProvisioningSettingsListPager provides operations for iterating over paged responses.
type AutoProvisioningSettingsListPager struct {
	client    *AutoProvisioningSettingsClient
	current   AutoProvisioningSettingsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutoProvisioningSettingsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutoProvisioningSettingsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutoProvisioningSettingsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoProvisioningSettingList.NextLink == nil || len(*p.current.AutoProvisioningSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutoProvisioningSettingsListResponse page.
func (p *AutoProvisioningSettingsListPager) PageResponse() AutoProvisioningSettingsListResponse {
	return p.current
}

// AutomationsListByResourceGroupPager provides operations for iterating over paged responses.
type AutomationsListByResourceGroupPager struct {
	client    *AutomationsClient
	current   AutomationsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationsListByResourceGroupResponse page.
func (p *AutomationsListByResourceGroupPager) PageResponse() AutomationsListByResourceGroupResponse {
	return p.current
}

// AutomationsListPager provides operations for iterating over paged responses.
type AutomationsListPager struct {
	client    *AutomationsClient
	current   AutomationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationsListResponse page.
func (p *AutomationsListPager) PageResponse() AutomationsListResponse {
	return p.current
}

// ComplianceResultsListPager provides operations for iterating over paged responses.
type ComplianceResultsListPager struct {
	client    *ComplianceResultsClient
	current   ComplianceResultsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ComplianceResultsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ComplianceResultsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ComplianceResultsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceResultList.NextLink == nil || len(*p.current.ComplianceResultList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ComplianceResultsListResponse page.
func (p *ComplianceResultsListPager) PageResponse() ComplianceResultsListResponse {
	return p.current
}

// CompliancesListPager provides operations for iterating over paged responses.
type CompliancesListPager struct {
	client    *CompliancesClient
	current   CompliancesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CompliancesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CompliancesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CompliancesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceList.NextLink == nil || len(*p.current.ComplianceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CompliancesListResponse page.
func (p *CompliancesListPager) PageResponse() CompliancesListResponse {
	return p.current
}

// ConnectorsListPager provides operations for iterating over paged responses.
type ConnectorsListPager struct {
	client    *ConnectorsClient
	current   ConnectorsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectorsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectorsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorSettingList.NextLink == nil || len(*p.current.ConnectorSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectorsListResponse page.
func (p *ConnectorsListPager) PageResponse() ConnectorsListResponse {
	return p.current
}

// CustomAssessmentAutomationsListByResourceGroupPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsListByResourceGroupPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomAssessmentAutomationsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomAssessmentAutomationsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomAssessmentAutomationsListByResourceGroupResponse page.
func (p *CustomAssessmentAutomationsListByResourceGroupPager) PageResponse() CustomAssessmentAutomationsListByResourceGroupResponse {
	return p.current
}

// CustomAssessmentAutomationsListBySubscriptionPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsListBySubscriptionPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomAssessmentAutomationsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomAssessmentAutomationsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomAssessmentAutomationsListBySubscriptionResponse page.
func (p *CustomAssessmentAutomationsListBySubscriptionPager) PageResponse() CustomAssessmentAutomationsListBySubscriptionResponse {
	return p.current
}

// CustomEntityStoreAssignmentsListByResourceGroupPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsListByResourceGroupPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomEntityStoreAssignmentsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomEntityStoreAssignmentsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomEntityStoreAssignmentsListByResourceGroupResponse page.
func (p *CustomEntityStoreAssignmentsListByResourceGroupPager) PageResponse() CustomEntityStoreAssignmentsListByResourceGroupResponse {
	return p.current
}

// CustomEntityStoreAssignmentsListBySubscriptionPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsListBySubscriptionPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomEntityStoreAssignmentsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomEntityStoreAssignmentsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomEntityStoreAssignmentsListBySubscriptionResponse page.
func (p *CustomEntityStoreAssignmentsListBySubscriptionPager) PageResponse() CustomEntityStoreAssignmentsListBySubscriptionResponse {
	return p.current
}

// DeviceSecurityGroupsListPager provides operations for iterating over paged responses.
type DeviceSecurityGroupsListPager struct {
	client    *DeviceSecurityGroupsClient
	current   DeviceSecurityGroupsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeviceSecurityGroupsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeviceSecurityGroupsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeviceSecurityGroupsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeviceSecurityGroupList.NextLink == nil || len(*p.current.DeviceSecurityGroupList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeviceSecurityGroupsListResponse page.
func (p *DeviceSecurityGroupsListPager) PageResponse() DeviceSecurityGroupsListResponse {
	return p.current
}

// DiscoveredSecuritySolutionsListByHomeRegionPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsListByHomeRegionPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiscoveredSecuritySolutionsListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiscoveredSecuritySolutionsListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHomeRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiscoveredSecuritySolutionsListByHomeRegionResponse page.
func (p *DiscoveredSecuritySolutionsListByHomeRegionPager) PageResponse() DiscoveredSecuritySolutionsListByHomeRegionResponse {
	return p.current
}

// DiscoveredSecuritySolutionsListPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsListPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiscoveredSecuritySolutionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiscoveredSecuritySolutionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiscoveredSecuritySolutionsListResponse page.
func (p *DiscoveredSecuritySolutionsListPager) PageResponse() DiscoveredSecuritySolutionsListResponse {
	return p.current
}

// ExternalSecuritySolutionsListByHomeRegionPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsListByHomeRegionPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExternalSecuritySolutionsListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExternalSecuritySolutionsListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHomeRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExternalSecuritySolutionsListByHomeRegionResponse page.
func (p *ExternalSecuritySolutionsListByHomeRegionPager) PageResponse() ExternalSecuritySolutionsListByHomeRegionResponse {
	return p.current
}

// ExternalSecuritySolutionsListPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsListPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExternalSecuritySolutionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExternalSecuritySolutionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExternalSecuritySolutionsListResponse page.
func (p *ExternalSecuritySolutionsListPager) PageResponse() ExternalSecuritySolutionsListResponse {
	return p.current
}

// InformationProtectionPoliciesListPager provides operations for iterating over paged responses.
type InformationProtectionPoliciesListPager struct {
	client    *InformationProtectionPoliciesClient
	current   InformationProtectionPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InformationProtectionPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InformationProtectionPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InformationProtectionPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InformationProtectionPolicyList.NextLink == nil || len(*p.current.InformationProtectionPolicyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InformationProtectionPoliciesListResponse page.
func (p *InformationProtectionPoliciesListPager) PageResponse() InformationProtectionPoliciesListResponse {
	return p.current
}

// IngestionSettingsListPager provides operations for iterating over paged responses.
type IngestionSettingsListPager struct {
	client    *IngestionSettingsClient
	current   IngestionSettingsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IngestionSettingsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IngestionSettingsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IngestionSettingsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IngestionSettingList.NextLink == nil || len(*p.current.IngestionSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IngestionSettingsListResponse page.
func (p *IngestionSettingsListPager) PageResponse() IngestionSettingsListResponse {
	return p.current
}

// IotSecuritySolutionListByResourceGroupPager provides operations for iterating over paged responses.
type IotSecuritySolutionListByResourceGroupPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionListByResourceGroupResponse page.
func (p *IotSecuritySolutionListByResourceGroupPager) PageResponse() IotSecuritySolutionListByResourceGroupResponse {
	return p.current
}

// IotSecuritySolutionListBySubscriptionPager provides operations for iterating over paged responses.
type IotSecuritySolutionListBySubscriptionPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionListBySubscriptionResponse page.
func (p *IotSecuritySolutionListBySubscriptionPager) PageResponse() IotSecuritySolutionListBySubscriptionResponse {
	return p.current
}

// IotSecuritySolutionsAnalyticsAggregatedAlertListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsAggregatedAlertListPager struct {
	client    *IotSecuritySolutionsAnalyticsAggregatedAlertClient
	current   IotSecuritySolutionsAnalyticsAggregatedAlertListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsAggregatedAlertListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedAlertList.NextLink == nil || len(*p.current.IoTSecurityAggregatedAlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionsAnalyticsAggregatedAlertListResponse page.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertListPager) PageResponse() IotSecuritySolutionsAnalyticsAggregatedAlertListResponse {
	return p.current
}

// IotSecuritySolutionsAnalyticsRecommendationListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsRecommendationListPager struct {
	client    *IotSecuritySolutionsAnalyticsRecommendationClient
	current   IotSecuritySolutionsAnalyticsRecommendationListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsRecommendationListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionsAnalyticsRecommendationListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionsAnalyticsRecommendationListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedRecommendationList.NextLink == nil || len(*p.current.IoTSecurityAggregatedRecommendationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionsAnalyticsRecommendationListResponse page.
func (p *IotSecuritySolutionsAnalyticsRecommendationListPager) PageResponse() IotSecuritySolutionsAnalyticsRecommendationListResponse {
	return p.current
}

// JitNetworkAccessPoliciesListByRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesListByRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesListByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesListByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesListByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesListByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesListByRegionResponse page.
func (p *JitNetworkAccessPoliciesListByRegionPager) PageResponse() JitNetworkAccessPoliciesListByRegionResponse {
	return p.current
}

// JitNetworkAccessPoliciesListByResourceGroupAndRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesListByResourceGroupAndRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesListByResourceGroupAndRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesListByResourceGroupAndRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesListByResourceGroupAndRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesListByResourceGroupAndRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupAndRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupAndRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesListByResourceGroupAndRegionResponse page.
func (p *JitNetworkAccessPoliciesListByResourceGroupAndRegionPager) PageResponse() JitNetworkAccessPoliciesListByResourceGroupAndRegionResponse {
	return p.current
}

// JitNetworkAccessPoliciesListByResourceGroupPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesListByResourceGroupPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesListByResourceGroupResponse page.
func (p *JitNetworkAccessPoliciesListByResourceGroupPager) PageResponse() JitNetworkAccessPoliciesListByResourceGroupResponse {
	return p.current
}

// JitNetworkAccessPoliciesListPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesListPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesListResponse page.
func (p *JitNetworkAccessPoliciesListPager) PageResponse() JitNetworkAccessPoliciesListResponse {
	return p.current
}

// LocationsListPager provides operations for iterating over paged responses.
type LocationsListPager struct {
	client    *LocationsClient
	current   LocationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LocationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LocationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AscLocationList.NextLink == nil || len(*p.current.AscLocationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LocationsListResponse page.
func (p *LocationsListPager) PageResponse() LocationsListResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// RegulatoryComplianceAssessmentsListPager provides operations for iterating over paged responses.
type RegulatoryComplianceAssessmentsListPager struct {
	client    *RegulatoryComplianceAssessmentsClient
	current   RegulatoryComplianceAssessmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceAssessmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceAssessmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceAssessmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceAssessmentList.NextLink == nil || len(*p.current.RegulatoryComplianceAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceAssessmentsListResponse page.
func (p *RegulatoryComplianceAssessmentsListPager) PageResponse() RegulatoryComplianceAssessmentsListResponse {
	return p.current
}

// RegulatoryComplianceControlsListPager provides operations for iterating over paged responses.
type RegulatoryComplianceControlsListPager struct {
	client    *RegulatoryComplianceControlsClient
	current   RegulatoryComplianceControlsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceControlsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceControlsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceControlsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceControlList.NextLink == nil || len(*p.current.RegulatoryComplianceControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceControlsListResponse page.
func (p *RegulatoryComplianceControlsListPager) PageResponse() RegulatoryComplianceControlsListResponse {
	return p.current
}

// RegulatoryComplianceStandardsListPager provides operations for iterating over paged responses.
type RegulatoryComplianceStandardsListPager struct {
	client    *RegulatoryComplianceStandardsClient
	current   RegulatoryComplianceStandardsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceStandardsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceStandardsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceStandardsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceStandardList.NextLink == nil || len(*p.current.RegulatoryComplianceStandardList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceStandardsListResponse page.
func (p *RegulatoryComplianceStandardsListPager) PageResponse() RegulatoryComplianceStandardsListResponse {
	return p.current
}

// SecureScoreControlDefinitionsListBySubscriptionPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsListBySubscriptionPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlDefinitionsListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlDefinitionsListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlDefinitionsListBySubscriptionResponse page.
func (p *SecureScoreControlDefinitionsListBySubscriptionPager) PageResponse() SecureScoreControlDefinitionsListBySubscriptionResponse {
	return p.current
}

// SecureScoreControlDefinitionsListPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsListPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlDefinitionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlDefinitionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlDefinitionsListResponse page.
func (p *SecureScoreControlDefinitionsListPager) PageResponse() SecureScoreControlDefinitionsListResponse {
	return p.current
}

// SecureScoreControlsListBySecureScorePager provides operations for iterating over paged responses.
type SecureScoreControlsListBySecureScorePager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsListBySecureScoreResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsListBySecureScoreResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlsListBySecureScorePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlsListBySecureScorePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySecureScoreHandleError(resp)
		return false
	}
	result, err := p.client.listBySecureScoreHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlsListBySecureScoreResponse page.
func (p *SecureScoreControlsListBySecureScorePager) PageResponse() SecureScoreControlsListBySecureScoreResponse {
	return p.current
}

// SecureScoreControlsListPager provides operations for iterating over paged responses.
type SecureScoreControlsListPager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlsListResponse page.
func (p *SecureScoreControlsListPager) PageResponse() SecureScoreControlsListResponse {
	return p.current
}

// SecureScoresListPager provides operations for iterating over paged responses.
type SecureScoresListPager struct {
	client    *SecureScoresClient
	current   SecureScoresListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoresListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoresListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoresListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoresList.NextLink == nil || len(*p.current.SecureScoresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoresListResponse page.
func (p *SecureScoresListPager) PageResponse() SecureScoresListResponse {
	return p.current
}

// SecurityConnectorsListByResourceGroupPager provides operations for iterating over paged responses.
type SecurityConnectorsListByResourceGroupPager struct {
	client    *SecurityConnectorsClient
	current   SecurityConnectorsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityConnectorsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityConnectorsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityConnectorsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityConnectorsList.NextLink == nil || len(*p.current.SecurityConnectorsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityConnectorsListByResourceGroupResponse page.
func (p *SecurityConnectorsListByResourceGroupPager) PageResponse() SecurityConnectorsListByResourceGroupResponse {
	return p.current
}

// SecurityConnectorsListPager provides operations for iterating over paged responses.
type SecurityConnectorsListPager struct {
	client    *SecurityConnectorsClient
	current   SecurityConnectorsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityConnectorsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityConnectorsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityConnectorsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityConnectorsList.NextLink == nil || len(*p.current.SecurityConnectorsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityConnectorsListResponse page.
func (p *SecurityConnectorsListPager) PageResponse() SecurityConnectorsListResponse {
	return p.current
}

// SecurityContactsListPager provides operations for iterating over paged responses.
type SecurityContactsListPager struct {
	client    *SecurityContactsClient
	current   SecurityContactsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityContactsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecurityContactsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecurityContactsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityContactList.NextLink == nil || len(*p.current.SecurityContactList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecurityContactsListResponse page.
func (p *SecurityContactsListPager) PageResponse() SecurityContactsListResponse {
	return p.current
}

// SecuritySolutionsListPager provides operations for iterating over paged responses.
type SecuritySolutionsListPager struct {
	client    *SecuritySolutionsClient
	current   SecuritySolutionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecuritySolutionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecuritySolutionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecuritySolutionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecuritySolutionList.NextLink == nil || len(*p.current.SecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecuritySolutionsListResponse page.
func (p *SecuritySolutionsListPager) PageResponse() SecuritySolutionsListResponse {
	return p.current
}

// SettingsListPager provides operations for iterating over paged responses.
type SettingsListPager struct {
	client    *SettingsClient
	current   SettingsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SettingsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SettingsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SettingsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SettingsList.NextLink == nil || len(*p.current.SettingsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SettingsListResponse page.
func (p *SettingsListPager) PageResponse() SettingsListResponse {
	return p.current
}

// SoftwareInventoriesListByExtendedResourcePager provides operations for iterating over paged responses.
type SoftwareInventoriesListByExtendedResourcePager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesListByExtendedResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesListByExtendedResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SoftwareInventoriesListByExtendedResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SoftwareInventoriesListByExtendedResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByExtendedResourceHandleError(resp)
		return false
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SoftwareInventoriesListByExtendedResourceResponse page.
func (p *SoftwareInventoriesListByExtendedResourcePager) PageResponse() SoftwareInventoriesListByExtendedResourceResponse {
	return p.current
}

// SoftwareInventoriesListBySubscriptionPager provides operations for iterating over paged responses.
type SoftwareInventoriesListBySubscriptionPager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SoftwareInventoriesListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SoftwareInventoriesListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SoftwareInventoriesListBySubscriptionResponse page.
func (p *SoftwareInventoriesListBySubscriptionPager) PageResponse() SoftwareInventoriesListBySubscriptionResponse {
	return p.current
}

// SubAssessmentsListAllPager provides operations for iterating over paged responses.
type SubAssessmentsListAllPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubAssessmentsListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubAssessmentsListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecuritySubAssessmentList.NextLink == nil || len(*p.current.SecuritySubAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubAssessmentsListAllResponse page.
func (p *SubAssessmentsListAllPager) PageResponse() SubAssessmentsListAllResponse {
	return p.current
}

// SubAssessmentsListPager provides operations for iterating over paged responses.
type SubAssessmentsListPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubAssessmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubAssessmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecuritySubAssessmentList.NextLink == nil || len(*p.current.SecuritySubAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubAssessmentsListResponse page.
func (p *SubAssessmentsListPager) PageResponse() SubAssessmentsListResponse {
	return p.current
}

// TasksListByHomeRegionPager provides operations for iterating over paged responses.
type TasksListByHomeRegionPager struct {
	client    *TasksClient
	current   TasksListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityTaskList.NextLink == nil || len(*p.current.SecurityTaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHomeRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksListByHomeRegionResponse page.
func (p *TasksListByHomeRegionPager) PageResponse() TasksListByHomeRegionResponse {
	return p.current
}

// TasksListByResourceGroupPager provides operations for iterating over paged responses.
type TasksListByResourceGroupPager struct {
	client    *TasksClient
	current   TasksListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityTaskList.NextLink == nil || len(*p.current.SecurityTaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksListByResourceGroupResponse page.
func (p *TasksListByResourceGroupPager) PageResponse() TasksListByResourceGroupResponse {
	return p.current
}

// TasksListPager provides operations for iterating over paged responses.
type TasksListPager struct {
	client    *TasksClient
	current   TasksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityTaskList.NextLink == nil || len(*p.current.SecurityTaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksListResponse page.
func (p *TasksListPager) PageResponse() TasksListResponse {
	return p.current
}

// TopologyListByHomeRegionPager provides operations for iterating over paged responses.
type TopologyListByHomeRegionPager struct {
	client    *TopologyClient
	current   TopologyListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopologyListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopologyListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHomeRegionHandleError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopologyListByHomeRegionResponse page.
func (p *TopologyListByHomeRegionPager) PageResponse() TopologyListByHomeRegionResponse {
	return p.current
}

// TopologyListPager provides operations for iterating over paged responses.
type TopologyListPager struct {
	client    *TopologyClient
	current   TopologyListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopologyListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopologyListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopologyListResponse page.
func (p *TopologyListPager) PageResponse() TopologyListResponse {
	return p.current
}

// WorkspaceSettingsListPager provides operations for iterating over paged responses.
type WorkspaceSettingsListPager struct {
	client    *WorkspaceSettingsClient
	current   WorkspaceSettingsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceSettingsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceSettingsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceSettingsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceSettingList.NextLink == nil || len(*p.current.WorkspaceSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceSettingsListResponse page.
func (p *WorkspaceSettingsListPager) PageResponse() WorkspaceSettingsListResponse {
	return p.current
}
