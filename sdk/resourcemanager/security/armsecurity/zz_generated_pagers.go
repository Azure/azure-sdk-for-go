//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsecurity

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountConnectorsClientListPager provides operations for iterating over paged responses.
type AccountConnectorsClientListPager struct {
	client    *AccountConnectorsClient
	current   AccountConnectorsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountConnectorsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AccountConnectorsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AccountConnectorsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorSettingList.NextLink == nil || len(*p.current.ConnectorSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AccountConnectorsClientListResponse page.
func (p *AccountConnectorsClientListPager) PageResponse() AccountConnectorsClientListResponse {
	return p.current
}

// AdaptiveNetworkHardeningsClientListByExtendedResourcePager provides operations for iterating over paged responses.
type AdaptiveNetworkHardeningsClientListByExtendedResourcePager struct {
	client    *AdaptiveNetworkHardeningsClient
	current   AdaptiveNetworkHardeningsClientListByExtendedResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AdaptiveNetworkHardeningsClientListByExtendedResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AdaptiveNetworkHardeningsClientListByExtendedResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AdaptiveNetworkHardeningsClientListByExtendedResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AdaptiveNetworkHardeningsList.NextLink == nil || len(*p.current.AdaptiveNetworkHardeningsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AdaptiveNetworkHardeningsClientListByExtendedResourceResponse page.
func (p *AdaptiveNetworkHardeningsClientListByExtendedResourcePager) PageResponse() AdaptiveNetworkHardeningsClientListByExtendedResourceResponse {
	return p.current
}

// AlertsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AlertsClientListByResourceGroupPager struct {
	client    *AlertsClient
	current   AlertsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsClientListByResourceGroupResponse page.
func (p *AlertsClientListByResourceGroupPager) PageResponse() AlertsClientListByResourceGroupResponse {
	return p.current
}

// AlertsClientListPager provides operations for iterating over paged responses.
type AlertsClientListPager struct {
	client    *AlertsClient
	current   AlertsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsClientListResponse page.
func (p *AlertsClientListPager) PageResponse() AlertsClientListResponse {
	return p.current
}

// AlertsClientListResourceGroupLevelByRegionPager provides operations for iterating over paged responses.
type AlertsClientListResourceGroupLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsClientListResourceGroupLevelByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListResourceGroupLevelByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsClientListResourceGroupLevelByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsClientListResourceGroupLevelByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listResourceGroupLevelByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsClientListResourceGroupLevelByRegionResponse page.
func (p *AlertsClientListResourceGroupLevelByRegionPager) PageResponse() AlertsClientListResourceGroupLevelByRegionResponse {
	return p.current
}

// AlertsClientListSubscriptionLevelByRegionPager provides operations for iterating over paged responses.
type AlertsClientListSubscriptionLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsClientListSubscriptionLevelByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListSubscriptionLevelByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsClientListSubscriptionLevelByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsClientListSubscriptionLevelByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSubscriptionLevelByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsClientListSubscriptionLevelByRegionResponse page.
func (p *AlertsClientListSubscriptionLevelByRegionPager) PageResponse() AlertsClientListSubscriptionLevelByRegionResponse {
	return p.current
}

// AlertsSuppressionRulesClientListPager provides operations for iterating over paged responses.
type AlertsSuppressionRulesClientListPager struct {
	client    *AlertsSuppressionRulesClient
	current   AlertsSuppressionRulesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsSuppressionRulesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AlertsSuppressionRulesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AlertsSuppressionRulesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertsSuppressionRulesList.NextLink == nil || len(*p.current.AlertsSuppressionRulesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AlertsSuppressionRulesClientListResponse page.
func (p *AlertsSuppressionRulesClientListPager) PageResponse() AlertsSuppressionRulesClientListResponse {
	return p.current
}

// AllowedConnectionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type AllowedConnectionsClientListByHomeRegionPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsClientListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AllowedConnectionsClientListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AllowedConnectionsClientListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AllowedConnectionsClientListByHomeRegionResponse page.
func (p *AllowedConnectionsClientListByHomeRegionPager) PageResponse() AllowedConnectionsClientListByHomeRegionResponse {
	return p.current
}

// AllowedConnectionsClientListPager provides operations for iterating over paged responses.
type AllowedConnectionsClientListPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AllowedConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AllowedConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AllowedConnectionsClientListResponse page.
func (p *AllowedConnectionsClientListPager) PageResponse() AllowedConnectionsClientListResponse {
	return p.current
}

// AssessmentsClientListPager provides operations for iterating over paged responses.
type AssessmentsClientListPager struct {
	client    *AssessmentsClient
	current   AssessmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentList.NextLink == nil || len(*p.current.AssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsClientListResponse page.
func (p *AssessmentsClientListPager) PageResponse() AssessmentsClientListResponse {
	return p.current
}

// AssessmentsMetadataClientListBySubscriptionPager provides operations for iterating over paged responses.
type AssessmentsMetadataClientListBySubscriptionPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsMetadataClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsMetadataClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentMetadataResponseList.NextLink == nil || len(*p.current.AssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsMetadataClientListBySubscriptionResponse page.
func (p *AssessmentsMetadataClientListBySubscriptionPager) PageResponse() AssessmentsMetadataClientListBySubscriptionResponse {
	return p.current
}

// AssessmentsMetadataClientListPager provides operations for iterating over paged responses.
type AssessmentsMetadataClientListPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AssessmentsMetadataClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AssessmentsMetadataClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentMetadataResponseList.NextLink == nil || len(*p.current.AssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AssessmentsMetadataClientListResponse page.
func (p *AssessmentsMetadataClientListPager) PageResponse() AssessmentsMetadataClientListResponse {
	return p.current
}

// AutoProvisioningSettingsClientListPager provides operations for iterating over paged responses.
type AutoProvisioningSettingsClientListPager struct {
	client    *AutoProvisioningSettingsClient
	current   AutoProvisioningSettingsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutoProvisioningSettingsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutoProvisioningSettingsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutoProvisioningSettingsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoProvisioningSettingList.NextLink == nil || len(*p.current.AutoProvisioningSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutoProvisioningSettingsClientListResponse page.
func (p *AutoProvisioningSettingsClientListPager) PageResponse() AutoProvisioningSettingsClientListResponse {
	return p.current
}

// AutomationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AutomationsClientListByResourceGroupPager struct {
	client    *AutomationsClient
	current   AutomationsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationsClientListByResourceGroupResponse page.
func (p *AutomationsClientListByResourceGroupPager) PageResponse() AutomationsClientListByResourceGroupResponse {
	return p.current
}

// AutomationsClientListPager provides operations for iterating over paged responses.
type AutomationsClientListPager struct {
	client    *AutomationsClient
	current   AutomationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AutomationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AutomationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AutomationsClientListResponse page.
func (p *AutomationsClientListPager) PageResponse() AutomationsClientListResponse {
	return p.current
}

// ComplianceResultsClientListPager provides operations for iterating over paged responses.
type ComplianceResultsClientListPager struct {
	client    *ComplianceResultsClient
	current   ComplianceResultsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ComplianceResultsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ComplianceResultsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ComplianceResultsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceResultList.NextLink == nil || len(*p.current.ComplianceResultList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ComplianceResultsClientListResponse page.
func (p *ComplianceResultsClientListPager) PageResponse() ComplianceResultsClientListResponse {
	return p.current
}

// CompliancesClientListPager provides operations for iterating over paged responses.
type CompliancesClientListPager struct {
	client    *CompliancesClient
	current   CompliancesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CompliancesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CompliancesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CompliancesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceList.NextLink == nil || len(*p.current.ComplianceList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CompliancesClientListResponse page.
func (p *CompliancesClientListPager) PageResponse() CompliancesClientListResponse {
	return p.current
}

// ConnectorsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ConnectorsClientListByResourceGroupPager struct {
	client    *ConnectorsClient
	current   ConnectorsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectorsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectorsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorsList.NextLink == nil || len(*p.current.ConnectorsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectorsClientListByResourceGroupResponse page.
func (p *ConnectorsClientListByResourceGroupPager) PageResponse() ConnectorsClientListByResourceGroupResponse {
	return p.current
}

// ConnectorsClientListPager provides operations for iterating over paged responses.
type ConnectorsClientListPager struct {
	client    *ConnectorsClient
	current   ConnectorsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ConnectorsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ConnectorsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorsList.NextLink == nil || len(*p.current.ConnectorsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ConnectorsClientListResponse page.
func (p *ConnectorsClientListPager) PageResponse() ConnectorsClientListResponse {
	return p.current
}

// ContactsClientListPager provides operations for iterating over paged responses.
type ContactsClientListPager struct {
	client    *ContactsClient
	current   ContactsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContactsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContactsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContactsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContactList.NextLink == nil || len(*p.current.ContactList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContactsClientListResponse page.
func (p *ContactsClientListPager) PageResponse() ContactsClientListResponse {
	return p.current
}

// CustomAssessmentAutomationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsClientListByResourceGroupPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomAssessmentAutomationsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomAssessmentAutomationsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomAssessmentAutomationsClientListByResourceGroupResponse page.
func (p *CustomAssessmentAutomationsClientListByResourceGroupPager) PageResponse() CustomAssessmentAutomationsClientListByResourceGroupResponse {
	return p.current
}

// CustomAssessmentAutomationsClientListBySubscriptionPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsClientListBySubscriptionPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomAssessmentAutomationsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomAssessmentAutomationsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomAssessmentAutomationsClientListBySubscriptionResponse page.
func (p *CustomAssessmentAutomationsClientListBySubscriptionPager) PageResponse() CustomAssessmentAutomationsClientListBySubscriptionResponse {
	return p.current
}

// CustomEntityStoreAssignmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsClientListByResourceGroupPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomEntityStoreAssignmentsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomEntityStoreAssignmentsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomEntityStoreAssignmentsClientListByResourceGroupResponse page.
func (p *CustomEntityStoreAssignmentsClientListByResourceGroupPager) PageResponse() CustomEntityStoreAssignmentsClientListByResourceGroupResponse {
	return p.current
}

// CustomEntityStoreAssignmentsClientListBySubscriptionPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsClientListBySubscriptionPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *CustomEntityStoreAssignmentsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *CustomEntityStoreAssignmentsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current CustomEntityStoreAssignmentsClientListBySubscriptionResponse page.
func (p *CustomEntityStoreAssignmentsClientListBySubscriptionPager) PageResponse() CustomEntityStoreAssignmentsClientListBySubscriptionResponse {
	return p.current
}

// DeviceSecurityGroupsClientListPager provides operations for iterating over paged responses.
type DeviceSecurityGroupsClientListPager struct {
	client    *DeviceSecurityGroupsClient
	current   DeviceSecurityGroupsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeviceSecurityGroupsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeviceSecurityGroupsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeviceSecurityGroupsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeviceSecurityGroupList.NextLink == nil || len(*p.current.DeviceSecurityGroupList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeviceSecurityGroupsClientListResponse page.
func (p *DeviceSecurityGroupsClientListPager) PageResponse() DeviceSecurityGroupsClientListResponse {
	return p.current
}

// DiscoveredSecuritySolutionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsClientListByHomeRegionPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsClientListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiscoveredSecuritySolutionsClientListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiscoveredSecuritySolutionsClientListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiscoveredSecuritySolutionsClientListByHomeRegionResponse page.
func (p *DiscoveredSecuritySolutionsClientListByHomeRegionPager) PageResponse() DiscoveredSecuritySolutionsClientListByHomeRegionResponse {
	return p.current
}

// DiscoveredSecuritySolutionsClientListPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsClientListPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiscoveredSecuritySolutionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiscoveredSecuritySolutionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiscoveredSecuritySolutionsClientListResponse page.
func (p *DiscoveredSecuritySolutionsClientListPager) PageResponse() DiscoveredSecuritySolutionsClientListResponse {
	return p.current
}

// ExternalSecuritySolutionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsClientListByHomeRegionPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsClientListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExternalSecuritySolutionsClientListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExternalSecuritySolutionsClientListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExternalSecuritySolutionsClientListByHomeRegionResponse page.
func (p *ExternalSecuritySolutionsClientListByHomeRegionPager) PageResponse() ExternalSecuritySolutionsClientListByHomeRegionResponse {
	return p.current
}

// ExternalSecuritySolutionsClientListPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsClientListPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExternalSecuritySolutionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExternalSecuritySolutionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExternalSecuritySolutionsClientListResponse page.
func (p *ExternalSecuritySolutionsClientListPager) PageResponse() ExternalSecuritySolutionsClientListResponse {
	return p.current
}

// InformationProtectionPoliciesClientListPager provides operations for iterating over paged responses.
type InformationProtectionPoliciesClientListPager struct {
	client    *InformationProtectionPoliciesClient
	current   InformationProtectionPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InformationProtectionPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InformationProtectionPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InformationProtectionPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InformationProtectionPolicyList.NextLink == nil || len(*p.current.InformationProtectionPolicyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InformationProtectionPoliciesClientListResponse page.
func (p *InformationProtectionPoliciesClientListPager) PageResponse() InformationProtectionPoliciesClientListResponse {
	return p.current
}

// IngestionSettingsClientListPager provides operations for iterating over paged responses.
type IngestionSettingsClientListPager struct {
	client    *IngestionSettingsClient
	current   IngestionSettingsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IngestionSettingsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IngestionSettingsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IngestionSettingsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IngestionSettingList.NextLink == nil || len(*p.current.IngestionSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IngestionSettingsClientListResponse page.
func (p *IngestionSettingsClientListPager) PageResponse() IngestionSettingsClientListResponse {
	return p.current
}

// IotSecuritySolutionClientListByResourceGroupPager provides operations for iterating over paged responses.
type IotSecuritySolutionClientListByResourceGroupPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionClientListByResourceGroupResponse page.
func (p *IotSecuritySolutionClientListByResourceGroupPager) PageResponse() IotSecuritySolutionClientListByResourceGroupResponse {
	return p.current
}

// IotSecuritySolutionClientListBySubscriptionPager provides operations for iterating over paged responses.
type IotSecuritySolutionClientListBySubscriptionPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionClientListBySubscriptionResponse page.
func (p *IotSecuritySolutionClientListBySubscriptionPager) PageResponse() IotSecuritySolutionClientListBySubscriptionResponse {
	return p.current
}

// IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager struct {
	client    *IotSecuritySolutionsAnalyticsAggregatedAlertClient
	current   IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedAlertList.NextLink == nil || len(*p.current.IoTSecurityAggregatedAlertList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse page.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager) PageResponse() IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse {
	return p.current
}

// IotSecuritySolutionsAnalyticsRecommendationClientListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsRecommendationClientListPager struct {
	client    *IotSecuritySolutionsAnalyticsRecommendationClient
	current   IotSecuritySolutionsAnalyticsRecommendationClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsRecommendationClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IotSecuritySolutionsAnalyticsRecommendationClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IotSecuritySolutionsAnalyticsRecommendationClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedRecommendationList.NextLink == nil || len(*p.current.IoTSecurityAggregatedRecommendationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IotSecuritySolutionsAnalyticsRecommendationClientListResponse page.
func (p *IotSecuritySolutionsAnalyticsRecommendationClientListPager) PageResponse() IotSecuritySolutionsAnalyticsRecommendationClientListResponse {
	return p.current
}

// JitNetworkAccessPoliciesClientListByRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesClientListByRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesClientListByRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesClientListByRegionResponse page.
func (p *JitNetworkAccessPoliciesClientListByRegionPager) PageResponse() JitNetworkAccessPoliciesClientListByRegionResponse {
	return p.current
}

// JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupAndRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse page.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager) PageResponse() JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse {
	return p.current
}

// JitNetworkAccessPoliciesClientListByResourceGroupPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByResourceGroupPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesClientListByResourceGroupResponse page.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupPager) PageResponse() JitNetworkAccessPoliciesClientListByResourceGroupResponse {
	return p.current
}

// JitNetworkAccessPoliciesClientListPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JitNetworkAccessPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JitNetworkAccessPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JitNetworkAccessPoliciesClientListResponse page.
func (p *JitNetworkAccessPoliciesClientListPager) PageResponse() JitNetworkAccessPoliciesClientListResponse {
	return p.current
}

// LocationsClientListPager provides operations for iterating over paged responses.
type LocationsClientListPager struct {
	client    *LocationsClient
	current   LocationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LocationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LocationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AscLocationList.NextLink == nil || len(*p.current.AscLocationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LocationsClientListResponse page.
func (p *LocationsClientListPager) PageResponse() LocationsClientListResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// RegulatoryComplianceAssessmentsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceAssessmentsClientListPager struct {
	client    *RegulatoryComplianceAssessmentsClient
	current   RegulatoryComplianceAssessmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceAssessmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceAssessmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceAssessmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceAssessmentList.NextLink == nil || len(*p.current.RegulatoryComplianceAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceAssessmentsClientListResponse page.
func (p *RegulatoryComplianceAssessmentsClientListPager) PageResponse() RegulatoryComplianceAssessmentsClientListResponse {
	return p.current
}

// RegulatoryComplianceControlsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceControlsClientListPager struct {
	client    *RegulatoryComplianceControlsClient
	current   RegulatoryComplianceControlsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceControlsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceControlsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceControlsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceControlList.NextLink == nil || len(*p.current.RegulatoryComplianceControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceControlsClientListResponse page.
func (p *RegulatoryComplianceControlsClientListPager) PageResponse() RegulatoryComplianceControlsClientListResponse {
	return p.current
}

// RegulatoryComplianceStandardsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceStandardsClientListPager struct {
	client    *RegulatoryComplianceStandardsClient
	current   RegulatoryComplianceStandardsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceStandardsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RegulatoryComplianceStandardsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RegulatoryComplianceStandardsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceStandardList.NextLink == nil || len(*p.current.RegulatoryComplianceStandardList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RegulatoryComplianceStandardsClientListResponse page.
func (p *RegulatoryComplianceStandardsClientListPager) PageResponse() RegulatoryComplianceStandardsClientListResponse {
	return p.current
}

// SecureScoreControlDefinitionsClientListBySubscriptionPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsClientListBySubscriptionPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlDefinitionsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlDefinitionsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlDefinitionsClientListBySubscriptionResponse page.
func (p *SecureScoreControlDefinitionsClientListBySubscriptionPager) PageResponse() SecureScoreControlDefinitionsClientListBySubscriptionResponse {
	return p.current
}

// SecureScoreControlDefinitionsClientListPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsClientListPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlDefinitionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlDefinitionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlDefinitionsClientListResponse page.
func (p *SecureScoreControlDefinitionsClientListPager) PageResponse() SecureScoreControlDefinitionsClientListResponse {
	return p.current
}

// SecureScoreControlsClientListBySecureScorePager provides operations for iterating over paged responses.
type SecureScoreControlsClientListBySecureScorePager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsClientListBySecureScoreResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsClientListBySecureScoreResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlsClientListBySecureScorePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlsClientListBySecureScorePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySecureScoreHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlsClientListBySecureScoreResponse page.
func (p *SecureScoreControlsClientListBySecureScorePager) PageResponse() SecureScoreControlsClientListBySecureScoreResponse {
	return p.current
}

// SecureScoreControlsClientListPager provides operations for iterating over paged responses.
type SecureScoreControlsClientListPager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoreControlsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoreControlsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoreControlsClientListResponse page.
func (p *SecureScoreControlsClientListPager) PageResponse() SecureScoreControlsClientListResponse {
	return p.current
}

// SecureScoresClientListPager provides operations for iterating over paged responses.
type SecureScoresClientListPager struct {
	client    *SecureScoresClient
	current   SecureScoresClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoresClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SecureScoresClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SecureScoresClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoresList.NextLink == nil || len(*p.current.SecureScoresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SecureScoresClientListResponse page.
func (p *SecureScoresClientListPager) PageResponse() SecureScoresClientListResponse {
	return p.current
}

// SettingsClientListPager provides operations for iterating over paged responses.
type SettingsClientListPager struct {
	client    *SettingsClient
	current   SettingsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SettingsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SettingsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SettingsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SettingsList.NextLink == nil || len(*p.current.SettingsList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SettingsClientListResponse page.
func (p *SettingsClientListPager) PageResponse() SettingsClientListResponse {
	return p.current
}

// SoftwareInventoriesClientListByExtendedResourcePager provides operations for iterating over paged responses.
type SoftwareInventoriesClientListByExtendedResourcePager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesClientListByExtendedResourceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesClientListByExtendedResourceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SoftwareInventoriesClientListByExtendedResourcePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SoftwareInventoriesClientListByExtendedResourcePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SoftwareInventoriesClientListByExtendedResourceResponse page.
func (p *SoftwareInventoriesClientListByExtendedResourcePager) PageResponse() SoftwareInventoriesClientListByExtendedResourceResponse {
	return p.current
}

// SoftwareInventoriesClientListBySubscriptionPager provides operations for iterating over paged responses.
type SoftwareInventoriesClientListBySubscriptionPager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SoftwareInventoriesClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SoftwareInventoriesClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SoftwareInventoriesClientListBySubscriptionResponse page.
func (p *SoftwareInventoriesClientListBySubscriptionPager) PageResponse() SoftwareInventoriesClientListBySubscriptionResponse {
	return p.current
}

// SolutionsClientListPager provides operations for iterating over paged responses.
type SolutionsClientListPager struct {
	client    *SolutionsClient
	current   SolutionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SolutionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SolutionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SolutionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SolutionList.NextLink == nil || len(*p.current.SolutionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SolutionsClientListResponse page.
func (p *SolutionsClientListPager) PageResponse() SolutionsClientListResponse {
	return p.current
}

// SubAssessmentsClientListAllPager provides operations for iterating over paged responses.
type SubAssessmentsClientListAllPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubAssessmentsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubAssessmentsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubAssessmentList.NextLink == nil || len(*p.current.SubAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubAssessmentsClientListAllResponse page.
func (p *SubAssessmentsClientListAllPager) PageResponse() SubAssessmentsClientListAllResponse {
	return p.current
}

// SubAssessmentsClientListPager provides operations for iterating over paged responses.
type SubAssessmentsClientListPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubAssessmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubAssessmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubAssessmentList.NextLink == nil || len(*p.current.SubAssessmentList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubAssessmentsClientListResponse page.
func (p *SubAssessmentsClientListPager) PageResponse() SubAssessmentsClientListResponse {
	return p.current
}

// TasksClientListByHomeRegionPager provides operations for iterating over paged responses.
type TasksClientListByHomeRegionPager struct {
	client    *TasksClient
	current   TasksClientListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksClientListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksClientListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksClientListByHomeRegionResponse page.
func (p *TasksClientListByHomeRegionPager) PageResponse() TasksClientListByHomeRegionResponse {
	return p.current
}

// TasksClientListByResourceGroupPager provides operations for iterating over paged responses.
type TasksClientListByResourceGroupPager struct {
	client    *TasksClient
	current   TasksClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksClientListByResourceGroupResponse page.
func (p *TasksClientListByResourceGroupPager) PageResponse() TasksClientListByResourceGroupResponse {
	return p.current
}

// TasksClientListPager provides operations for iterating over paged responses.
type TasksClientListPager struct {
	client    *TasksClient
	current   TasksClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TasksClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TasksClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TasksClientListResponse page.
func (p *TasksClientListPager) PageResponse() TasksClientListResponse {
	return p.current
}

// TopologyClientListByHomeRegionPager provides operations for iterating over paged responses.
type TopologyClientListByHomeRegionPager struct {
	client    *TopologyClient
	current   TopologyClientListByHomeRegionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyClientListByHomeRegionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopologyClientListByHomeRegionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopologyClientListByHomeRegionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopologyClientListByHomeRegionResponse page.
func (p *TopologyClientListByHomeRegionPager) PageResponse() TopologyClientListByHomeRegionResponse {
	return p.current
}

// TopologyClientListPager provides operations for iterating over paged responses.
type TopologyClientListPager struct {
	client    *TopologyClient
	current   TopologyClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TopologyClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TopologyClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TopologyClientListResponse page.
func (p *TopologyClientListPager) PageResponse() TopologyClientListResponse {
	return p.current
}

// WorkspaceSettingsClientListPager provides operations for iterating over paged responses.
type WorkspaceSettingsClientListPager struct {
	client    *WorkspaceSettingsClient
	current   WorkspaceSettingsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceSettingsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceSettingsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceSettingsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceSettingList.NextLink == nil || len(*p.current.WorkspaceSettingList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceSettingsClientListResponse page.
func (p *WorkspaceSettingsClientListPager) PageResponse() WorkspaceSettingsClientListResponse {
	return p.current
}
