//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsecurityinsights

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type AADCheckRequirements.
func (a *AADCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AADCheckRequirements.
func (a AADCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindAzureActiveDirectory
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADCheckRequirements.
func (a *AADCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type AADDataConnector.
func (a *AADDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AADDataConnector.
func (a AADDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = DataConnectorKindAzureActiveDirectory
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AADDataConnector.
func (a *AADDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type AATPCheckRequirements.
func (a *AATPCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AATPCheckRequirements.
func (a AATPCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindAzureAdvancedThreatProtection
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AATPCheckRequirements.
func (a *AATPCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type AATPDataConnector.
func (a *AATPDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AATPDataConnector.
func (a AATPDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = DataConnectorKindAzureAdvancedThreatProtection
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AATPDataConnector.
func (a *AATPDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type ASCCheckRequirements.
func (a *ASCCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ASCCheckRequirements.
func (a ASCCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindAzureSecurityCenter
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ASCCheckRequirements.
func (a *ASCCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type ASCDataConnector.
func (a *ASCDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ASCDataConnector.
func (a ASCDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = DataConnectorKindAzureSecurityCenter
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ASCDataConnector.
func (a *ASCDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type AccountEntity.
func (a *AccountEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       a.Kind,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AccountEntity.
func (a AccountEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = EntityKindAccount
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountEntity.
func (a *AccountEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountEntityProperties.
func (a AccountEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aadTenantId", a.AADTenantID)
	populate(objectMap, "aadUserId", a.AADUserID)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "additionalData", a.AdditionalData)
	populate(objectMap, "dnsDomain", a.DNSDomain)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "hostEntityId", a.HostEntityID)
	populate(objectMap, "isDomainJoined", a.IsDomainJoined)
	populate(objectMap, "ntDomain", a.NtDomain)
	populate(objectMap, "objectGuid", a.ObjectGUID)
	populate(objectMap, "puid", a.Puid)
	populate(objectMap, "sid", a.Sid)
	populate(objectMap, "upnSuffix", a.UpnSuffix)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ActionsList.
func (a ActionsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// GetCustomEntityQuery implements the CustomEntityQueryClassification interface for type ActivityCustomEntityQuery.
func (a *ActivityCustomEntityQuery) GetCustomEntityQuery() *CustomEntityQuery {
	return &CustomEntityQuery{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ActivityCustomEntityQuery.
func (a ActivityCustomEntityQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = CustomEntityQueryKindActivity
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityCustomEntityQuery.
func (a *ActivityCustomEntityQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityEntityQueriesProperties.
func (a ActivityEntityQueriesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", a.Content)
	populateTimeRFC3339(objectMap, "createdTimeUtc", a.CreatedTimeUTC)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "enabled", a.Enabled)
	populate(objectMap, "entitiesFilter", a.EntitiesFilter)
	populate(objectMap, "inputEntityType", a.InputEntityType)
	populateTimeRFC3339(objectMap, "lastModifiedTimeUtc", a.LastModifiedTimeUTC)
	populate(objectMap, "queryDefinitions", a.QueryDefinitions)
	populate(objectMap, "requiredInputFieldsSets", a.RequiredInputFieldsSets)
	populate(objectMap, "templateName", a.TemplateName)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityEntityQueriesProperties.
func (a *ActivityEntityQueriesProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, &a.Content)
			delete(rawMsg, key)
		case "createdTimeUtc":
			err = unpopulateTimeRFC3339(val, &a.CreatedTimeUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &a.Enabled)
			delete(rawMsg, key)
		case "entitiesFilter":
			err = unpopulate(val, &a.EntitiesFilter)
			delete(rawMsg, key)
		case "inputEntityType":
			err = unpopulate(val, &a.InputEntityType)
			delete(rawMsg, key)
		case "lastModifiedTimeUtc":
			err = unpopulateTimeRFC3339(val, &a.LastModifiedTimeUTC)
			delete(rawMsg, key)
		case "queryDefinitions":
			err = unpopulate(val, &a.QueryDefinitions)
			delete(rawMsg, key)
		case "requiredInputFieldsSets":
			err = unpopulate(val, &a.RequiredInputFieldsSets)
			delete(rawMsg, key)
		case "templateName":
			err = unpopulate(val, &a.TemplateName)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityQuery implements the EntityQueryClassification interface for type ActivityEntityQuery.
func (a *ActivityEntityQuery) GetEntityQuery() *EntityQuery {
	return &EntityQuery{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ActivityEntityQuery.
func (a ActivityEntityQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = EntityQueryKindActivity
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityEntityQuery.
func (a *ActivityEntityQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityQueryTemplate implements the EntityQueryTemplateClassification interface for type ActivityEntityQueryTemplate.
func (a *ActivityEntityQueryTemplate) GetEntityQueryTemplate() *EntityQueryTemplate {
	return &EntityQueryTemplate{
		Kind:       a.Kind,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ActivityEntityQueryTemplate.
func (a ActivityEntityQueryTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = EntityQueryTemplateKindActivity
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityEntityQueryTemplate.
func (a *ActivityEntityQueryTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ActivityEntityQueryTemplateProperties.
func (a ActivityEntityQueryTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", a.Content)
	populate(objectMap, "dataTypes", a.DataTypes)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "entitiesFilter", a.EntitiesFilter)
	populate(objectMap, "inputEntityType", a.InputEntityType)
	populate(objectMap, "queryDefinitions", a.QueryDefinitions)
	populate(objectMap, "requiredInputFieldsSets", a.RequiredInputFieldsSets)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// GetEntityTimelineItem implements the EntityTimelineItemClassification interface for type ActivityTimelineItem.
func (a *ActivityTimelineItem) GetEntityTimelineItem() *EntityTimelineItem {
	return &EntityTimelineItem{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ActivityTimelineItem.
func (a ActivityTimelineItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "bucketEndTimeUTC", a.BucketEndTimeUTC)
	populateTimeRFC3339(objectMap, "bucketStartTimeUTC", a.BucketStartTimeUTC)
	populate(objectMap, "content", a.Content)
	populateTimeRFC3339(objectMap, "firstActivityTimeUTC", a.FirstActivityTimeUTC)
	objectMap["kind"] = EntityTimelineKindActivity
	populateTimeRFC3339(objectMap, "lastActivityTimeUTC", a.LastActivityTimeUTC)
	populate(objectMap, "queryId", a.QueryID)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityTimelineItem.
func (a *ActivityTimelineItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketEndTimeUTC":
			err = unpopulateTimeRFC3339(val, &a.BucketEndTimeUTC)
			delete(rawMsg, key)
		case "bucketStartTimeUTC":
			err = unpopulateTimeRFC3339(val, &a.BucketStartTimeUTC)
			delete(rawMsg, key)
		case "content":
			err = unpopulate(val, &a.Content)
			delete(rawMsg, key)
		case "firstActivityTimeUTC":
			err = unpopulateTimeRFC3339(val, &a.FirstActivityTimeUTC)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "lastActivityTimeUTC":
			err = unpopulateTimeRFC3339(val, &a.LastActivityTimeUTC)
			delete(rawMsg, key)
		case "queryId":
			err = unpopulate(val, &a.QueryID)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRule implements the AlertRuleClassification interface for type AlertRule.
func (a *AlertRule) GetAlertRule() *AlertRule { return a }

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type AlertRuleTemplate.
func (a *AlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate { return a }

// MarshalJSON implements the json.Marshaller interface for type AlertRuleTemplateDataSource.
func (a AlertRuleTemplateDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectorId", a.ConnectorID)
	populate(objectMap, "dataTypes", a.DataTypes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleTemplatePropertiesBase.
func (a AlertRuleTemplatePropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", a.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", a.CreatedDateUTC)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", a.LastUpdatedDateUTC)
	populate(objectMap, "requiredDataConnectors", a.RequiredDataConnectors)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertRuleTemplatePropertiesBase.
func (a *AlertRuleTemplatePropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &a.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &a.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &a.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &a.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &a.RequiredDataConnectors)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleTemplateWithMitreProperties.
func (a AlertRuleTemplateWithMitreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", a.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", a.CreatedDateUTC)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "displayName", a.DisplayName)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", a.LastUpdatedDateUTC)
	populate(objectMap, "requiredDataConnectors", a.RequiredDataConnectors)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "tactics", a.Tactics)
	populate(objectMap, "techniques", a.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertRuleTemplateWithMitreProperties.
func (a *AlertRuleTemplateWithMitreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &a.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &a.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &a.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &a.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &a.RequiredDataConnectors)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &a.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &a.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertRuleTemplatesList.
func (a AlertRuleTemplatesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertRuleTemplatesList.
func (a *AlertRuleTemplatesList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &a.NextLink)
			delete(rawMsg, key)
		case "value":
			a.Value, err = unmarshalAlertRuleTemplateClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AlertRulesList.
func (a AlertRulesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertRulesList.
func (a *AlertRulesList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &a.NextLink)
			delete(rawMsg, key)
		case "value":
			a.Value, err = unmarshalAlertRuleClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSettings implements the SettingsClassification interface for type Anomalies.
func (a *Anomalies) GetSettings() *Settings {
	return &Settings{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Anomalies.
func (a Anomalies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = SettingKindAnomalies
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Anomalies.
func (a *Anomalies) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAutomationRuleAction implements the AutomationRuleActionClassification interface for type AutomationRuleAction.
func (a *AutomationRuleAction) GetAutomationRuleAction() *AutomationRuleAction { return a }

// GetAutomationRuleCondition implements the AutomationRuleConditionClassification interface for type AutomationRuleCondition.
func (a *AutomationRuleCondition) GetAutomationRuleCondition() *AutomationRuleCondition { return a }

// GetAutomationRuleAction implements the AutomationRuleActionClassification interface for type AutomationRuleModifyPropertiesAction.
func (a *AutomationRuleModifyPropertiesAction) GetAutomationRuleAction() *AutomationRuleAction {
	return &AutomationRuleAction{
		Order:      a.Order,
		ActionType: a.ActionType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRuleModifyPropertiesAction.
func (a AutomationRuleModifyPropertiesAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionConfiguration", a.ActionConfiguration)
	objectMap["actionType"] = ActionTypeModifyProperties
	populate(objectMap, "order", a.Order)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationRuleModifyPropertiesAction.
func (a *AutomationRuleModifyPropertiesAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionConfiguration":
			err = unpopulate(val, &a.ActionConfiguration)
			delete(rawMsg, key)
		case "actionType":
			err = unpopulate(val, &a.ActionType)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, &a.Order)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRuleProperties.
func (a AutomationRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", a.Actions)
	populate(objectMap, "createdBy", a.CreatedBy)
	populateTimeRFC3339(objectMap, "createdTimeUtc", a.CreatedTimeUTC)
	populate(objectMap, "displayName", a.DisplayName)
	populate(objectMap, "lastModifiedBy", a.LastModifiedBy)
	populateTimeRFC3339(objectMap, "lastModifiedTimeUtc", a.LastModifiedTimeUTC)
	populate(objectMap, "order", a.Order)
	populate(objectMap, "triggeringLogic", a.TriggeringLogic)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationRuleProperties.
func (a *AutomationRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			a.Actions, err = unmarshalAutomationRuleActionClassificationArray(val)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &a.CreatedBy)
			delete(rawMsg, key)
		case "createdTimeUtc":
			err = unpopulateTimeRFC3339(val, &a.CreatedTimeUTC)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &a.DisplayName)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &a.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedTimeUtc":
			err = unpopulateTimeRFC3339(val, &a.LastModifiedTimeUTC)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, &a.Order)
			delete(rawMsg, key)
		case "triggeringLogic":
			err = unpopulate(val, &a.TriggeringLogic)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRulePropertyValuesCondition.
func (a AutomationRulePropertyValuesCondition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operator", a.Operator)
	populate(objectMap, "propertyName", a.PropertyName)
	populate(objectMap, "propertyValues", a.PropertyValues)
	return json.Marshal(objectMap)
}

// GetAutomationRuleAction implements the AutomationRuleActionClassification interface for type AutomationRuleRunPlaybookAction.
func (a *AutomationRuleRunPlaybookAction) GetAutomationRuleAction() *AutomationRuleAction {
	return &AutomationRuleAction{
		Order:      a.Order,
		ActionType: a.ActionType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRuleRunPlaybookAction.
func (a AutomationRuleRunPlaybookAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actionConfiguration", a.ActionConfiguration)
	objectMap["actionType"] = ActionTypeRunPlaybook
	populate(objectMap, "order", a.Order)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationRuleRunPlaybookAction.
func (a *AutomationRuleRunPlaybookAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionConfiguration":
			err = unpopulate(val, &a.ActionConfiguration)
			delete(rawMsg, key)
		case "actionType":
			err = unpopulate(val, &a.ActionType)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, &a.Order)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRuleTriggeringLogic.
func (a AutomationRuleTriggeringLogic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "conditions", a.Conditions)
	populateTimeRFC3339(objectMap, "expirationTimeUtc", a.ExpirationTimeUTC)
	populate(objectMap, "isEnabled", a.IsEnabled)
	populate(objectMap, "triggersOn", a.TriggersOn)
	populate(objectMap, "triggersWhen", a.TriggersWhen)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomationRuleTriggeringLogic.
func (a *AutomationRuleTriggeringLogic) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conditions":
			a.Conditions, err = unmarshalAutomationRuleConditionClassificationArray(val)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateTimeRFC3339(val, &a.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &a.IsEnabled)
			delete(rawMsg, key)
		case "triggersOn":
			err = unpopulate(val, &a.TriggersOn)
			delete(rawMsg, key)
		case "triggersWhen":
			err = unpopulate(val, &a.TriggersWhen)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomationRulesList.
func (a AutomationRulesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type AwsCloudTrailCheckRequirements.
func (a *AwsCloudTrailCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AwsCloudTrailCheckRequirements.
func (a AwsCloudTrailCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindAmazonWebServicesCloudTrail
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwsCloudTrailCheckRequirements.
func (a *AwsCloudTrailCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type AwsCloudTrailDataConnector.
func (a *AwsCloudTrailDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AwsCloudTrailDataConnector.
func (a AwsCloudTrailDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = DataConnectorKindAmazonWebServicesCloudTrail
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwsCloudTrailDataConnector.
func (a *AwsCloudTrailDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type AwsS3CheckRequirements.
func (a *AwsS3CheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AwsS3CheckRequirements.
func (a AwsS3CheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindAmazonWebServicesS3
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwsS3CheckRequirements.
func (a *AwsS3CheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type AwsS3DataConnector.
func (a *AwsS3DataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       a.Kind,
		Etag:       a.Etag,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AwsS3DataConnector.
func (a AwsS3DataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = DataConnectorKindAmazonWebServicesS3
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AwsS3DataConnector.
func (a *AwsS3DataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AwsS3DataConnectorProperties.
func (a AwsS3DataConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataTypes", a.DataTypes)
	populate(objectMap, "destinationTable", a.DestinationTable)
	populate(objectMap, "roleArn", a.RoleArn)
	populate(objectMap, "sqsUrls", a.SqsUrls)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type AzureResourceEntity.
func (a *AzureResourceEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       a.Kind,
		ID:         a.ID,
		Name:       a.Name,
		Type:       a.Type,
		SystemData: a.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceEntity.
func (a AzureResourceEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = EntityKindAzureResource
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureResourceEntity.
func (a *AzureResourceEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureResourceEntityProperties.
func (a AzureResourceEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", a.AdditionalData)
	populate(objectMap, "friendlyName", a.FriendlyName)
	populate(objectMap, "resourceId", a.ResourceID)
	populate(objectMap, "subscriptionId", a.SubscriptionID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkEntityMappings.
func (b BookmarkEntityMappings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entityType", b.EntityType)
	populate(objectMap, "fieldMappings", b.FieldMappings)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkExpandParameters.
func (b BookmarkExpandParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "expansionId", b.ExpansionID)
	populateTimeRFC3339(objectMap, "startTime", b.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BookmarkExpandParameters.
func (b *BookmarkExpandParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &b.EndTime)
			delete(rawMsg, key)
		case "expansionId":
			err = unpopulate(val, &b.ExpansionID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &b.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkExpandResponseValue.
func (b BookmarkExpandResponseValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "edges", b.Edges)
	populate(objectMap, "entities", b.Entities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BookmarkExpandResponseValue.
func (b *BookmarkExpandResponseValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "edges":
			err = unpopulate(val, &b.Edges)
			delete(rawMsg, key)
		case "entities":
			b.Entities, err = unmarshalEntityClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkList.
func (b BookmarkList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkProperties.
func (b BookmarkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", b.Created)
	populate(objectMap, "createdBy", b.CreatedBy)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "entityMappings", b.EntityMappings)
	populateTimeRFC3339(objectMap, "eventTime", b.EventTime)
	populate(objectMap, "incidentInfo", b.IncidentInfo)
	populate(objectMap, "labels", b.Labels)
	populate(objectMap, "notes", b.Notes)
	populate(objectMap, "query", b.Query)
	populateTimeRFC3339(objectMap, "queryEndTime", b.QueryEndTime)
	populate(objectMap, "queryResult", b.QueryResult)
	populateTimeRFC3339(objectMap, "queryStartTime", b.QueryStartTime)
	populate(objectMap, "tactics", b.Tactics)
	populate(objectMap, "techniques", b.Techniques)
	populateTimeRFC3339(objectMap, "updated", b.Updated)
	populate(objectMap, "updatedBy", b.UpdatedBy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BookmarkProperties.
func (b *BookmarkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &b.Created)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &b.CreatedBy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &b.DisplayName)
			delete(rawMsg, key)
		case "entityMappings":
			err = unpopulate(val, &b.EntityMappings)
			delete(rawMsg, key)
		case "eventTime":
			err = unpopulateTimeRFC3339(val, &b.EventTime)
			delete(rawMsg, key)
		case "incidentInfo":
			err = unpopulate(val, &b.IncidentInfo)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &b.Labels)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &b.Notes)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &b.Query)
			delete(rawMsg, key)
		case "queryEndTime":
			err = unpopulateTimeRFC3339(val, &b.QueryEndTime)
			delete(rawMsg, key)
		case "queryResult":
			err = unpopulate(val, &b.QueryResult)
			delete(rawMsg, key)
		case "queryStartTime":
			err = unpopulateTimeRFC3339(val, &b.QueryStartTime)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &b.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &b.Techniques)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeRFC3339(val, &b.Updated)
			delete(rawMsg, key)
		case "updatedBy":
			err = unpopulate(val, &b.UpdatedBy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityTimelineItem implements the EntityTimelineItemClassification interface for type BookmarkTimelineItem.
func (b *BookmarkTimelineItem) GetEntityTimelineItem() *EntityTimelineItem {
	return &EntityTimelineItem{
		Kind: b.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BookmarkTimelineItem.
func (b BookmarkTimelineItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureResourceId", b.AzureResourceID)
	populate(objectMap, "createdBy", b.CreatedBy)
	populate(objectMap, "displayName", b.DisplayName)
	populateTimeRFC3339(objectMap, "endTimeUtc", b.EndTimeUTC)
	populateTimeRFC3339(objectMap, "eventTime", b.EventTime)
	objectMap["kind"] = EntityTimelineKindBookmark
	populate(objectMap, "labels", b.Labels)
	populate(objectMap, "notes", b.Notes)
	populateTimeRFC3339(objectMap, "startTimeUtc", b.StartTimeUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BookmarkTimelineItem.
func (b *BookmarkTimelineItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureResourceId":
			err = unpopulate(val, &b.AzureResourceID)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &b.CreatedBy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &b.DisplayName)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, &b.EndTimeUTC)
			delete(rawMsg, key)
		case "eventTime":
			err = unpopulateTimeRFC3339(val, &b.EventTime)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &b.Labels)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &b.Notes)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateTimeRFC3339(val, &b.StartTimeUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type CloudApplicationEntity.
func (c *CloudApplicationEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       c.Kind,
		ID:         c.ID,
		Name:       c.Name,
		Type:       c.Type,
		SystemData: c.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CloudApplicationEntity.
func (c CloudApplicationEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = EntityKindCloudApplication
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudApplicationEntity.
func (c *CloudApplicationEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &c.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudApplicationEntityProperties.
func (c CloudApplicationEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", c.AdditionalData)
	populate(objectMap, "appId", c.AppID)
	populate(objectMap, "appName", c.AppName)
	populate(objectMap, "friendlyName", c.FriendlyName)
	populate(objectMap, "instanceName", c.InstanceName)
	return json.Marshal(objectMap)
}

// GetDataConnector implements the DataConnectorClassification interface for type CodelessAPIPollingDataConnector.
func (c *CodelessAPIPollingDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       c.Kind,
		Etag:       c.Etag,
		ID:         c.ID,
		Name:       c.Name,
		Type:       c.Type,
		SystemData: c.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CodelessAPIPollingDataConnector.
func (c CodelessAPIPollingDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = DataConnectorKindAPIPolling
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CodelessAPIPollingDataConnector.
func (c *CodelessAPIPollingDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &c.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &c.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CodelessConnectorPollingResponseProperties.
func (c CodelessConnectorPollingResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eventsJsonPaths", c.EventsJSONPaths)
	populate(objectMap, "isGzipCompressed", c.IsGzipCompressed)
	populate(objectMap, "successStatusJsonPath", c.SuccessStatusJSONPath)
	populate(objectMap, "successStatusValue", c.SuccessStatusValue)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CodelessUIConnectorConfigProperties.
func (c CodelessUIConnectorConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availability", c.Availability)
	populate(objectMap, "connectivityCriteria", c.ConnectivityCriteria)
	populate(objectMap, "customImage", c.CustomImage)
	populate(objectMap, "dataTypes", c.DataTypes)
	populate(objectMap, "descriptionMarkdown", c.DescriptionMarkdown)
	populate(objectMap, "graphQueries", c.GraphQueries)
	populate(objectMap, "graphQueriesTableName", c.GraphQueriesTableName)
	populate(objectMap, "instructionSteps", c.InstructionSteps)
	populate(objectMap, "permissions", c.Permissions)
	populate(objectMap, "publisher", c.Publisher)
	populate(objectMap, "sampleQueries", c.SampleQueries)
	populate(objectMap, "title", c.Title)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CodelessUIConnectorConfigPropertiesConnectivityCriteriaItem.
func (c CodelessUIConnectorConfigPropertiesConnectivityCriteriaItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "type", c.Type)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CodelessUIConnectorConfigPropertiesInstructionStepsItem.
func (c CodelessUIConnectorConfigPropertiesInstructionStepsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "instructions", c.Instructions)
	populate(objectMap, "title", c.Title)
	return json.Marshal(objectMap)
}

// GetDataConnector implements the DataConnectorClassification interface for type CodelessUIDataConnector.
func (c *CodelessUIDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       c.Kind,
		Etag:       c.Etag,
		ID:         c.ID,
		Name:       c.Name,
		Type:       c.Type,
		SystemData: c.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CodelessUIDataConnector.
func (c CodelessUIDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = DataConnectorKindGenericUI
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CodelessUIDataConnector.
func (c *CodelessUIDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &c.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &c.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectivityCriteria.
func (c ConnectivityCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "type", c.Type)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// GetCustomEntityQuery implements the CustomEntityQueryClassification interface for type CustomEntityQuery.
func (c *CustomEntityQuery) GetCustomEntityQuery() *CustomEntityQuery { return c }

// GetEntity implements the EntityClassification interface for type DNSEntity.
func (d *DNSEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       d.Kind,
		ID:         d.ID,
		Name:       d.Name,
		Type:       d.Type,
		SystemData: d.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DNSEntity.
func (d DNSEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	objectMap["kind"] = EntityKindDNSResolution
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSEntity.
func (d *DNSEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSEntityProperties.
func (d DNSEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", d.AdditionalData)
	populate(objectMap, "dnsServerIpEntityId", d.DNSServerIPEntityID)
	populate(objectMap, "domainName", d.DomainName)
	populate(objectMap, "friendlyName", d.FriendlyName)
	populate(objectMap, "hostIpAddressEntityId", d.HostIPAddressEntityID)
	populate(objectMap, "ipAddressEntityIds", d.IPAddressEntityIDs)
	return json.Marshal(objectMap)
}

// GetDataConnector implements the DataConnectorClassification interface for type DataConnector.
func (d *DataConnector) GetDataConnector() *DataConnector { return d }

// MarshalJSON implements the json.Marshaller interface for type DataConnectorConnectBody.
func (d DataConnectorConnectBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiKey", d.APIKey)
	populate(objectMap, "authorizationCode", d.AuthorizationCode)
	populate(objectMap, "clientId", d.ClientID)
	populate(objectMap, "clientSecret", d.ClientSecret)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "password", d.Password)
	populate(objectMap, "requestConfigUserInputValues", d.RequestConfigUserInputValues)
	populate(objectMap, "userName", d.UserName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DataConnectorList.
func (d DataConnectorList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectorList.
func (d *DataConnectorList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &d.NextLink)
			delete(rawMsg, key)
		case "value":
			d.Value, err = unmarshalDataConnectorClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type DataConnectorsCheckRequirements.
func (d *DataConnectorsCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return d
}

// MarshalJSON implements the json.Marshaller interface for type Deployment.
func (d Deployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deploymentId", d.DeploymentID)
	populate(objectMap, "deploymentLogsUrl", d.DeploymentLogsURL)
	populate(objectMap, "deploymentResult", d.DeploymentResult)
	populate(objectMap, "deploymentState", d.DeploymentState)
	populateTimeRFC3339(objectMap, "deploymentTime", d.DeploymentTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Deployment.
func (d *Deployment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deploymentId":
			err = unpopulate(val, &d.DeploymentID)
			delete(rawMsg, key)
		case "deploymentLogsUrl":
			err = unpopulate(val, &d.DeploymentLogsURL)
			delete(rawMsg, key)
		case "deploymentResult":
			err = unpopulate(val, &d.DeploymentResult)
			delete(rawMsg, key)
		case "deploymentState":
			err = unpopulate(val, &d.DeploymentState)
			delete(rawMsg, key)
		case "deploymentTime":
			err = unpopulateTimeRFC3339(val, &d.DeploymentTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type Dynamics365CheckRequirements.
func (d *Dynamics365CheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: d.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Dynamics365CheckRequirements.
func (d Dynamics365CheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindDynamics365
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dynamics365CheckRequirements.
func (d *Dynamics365CheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type Dynamics365DataConnector.
func (d *Dynamics365DataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       d.Kind,
		Etag:       d.Etag,
		ID:         d.ID,
		Name:       d.Name,
		Type:       d.Type,
		SystemData: d.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Dynamics365DataConnector.
func (d Dynamics365DataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	objectMap["kind"] = DataConnectorKindDynamics365
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dynamics365DataConnector.
func (d *Dynamics365DataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnrichmentDomainWhois.
func (e EnrichmentDomainWhois) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", e.Created)
	populate(objectMap, "domain", e.Domain)
	populateTimeRFC3339(objectMap, "expires", e.Expires)
	populate(objectMap, "parsedWhois", e.ParsedWhois)
	populate(objectMap, "server", e.Server)
	populateTimeRFC3339(objectMap, "updated", e.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnrichmentDomainWhois.
func (e *EnrichmentDomainWhois) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &e.Created)
			delete(rawMsg, key)
		case "domain":
			err = unpopulate(val, &e.Domain)
			delete(rawMsg, key)
		case "expires":
			err = unpopulateTimeRFC3339(val, &e.Expires)
			delete(rawMsg, key)
		case "parsedWhois":
			err = unpopulate(val, &e.ParsedWhois)
			delete(rawMsg, key)
		case "server":
			err = unpopulate(val, &e.Server)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeRFC3339(val, &e.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnrichmentDomainWhoisContact.
func (e EnrichmentDomainWhoisContact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "city", e.City)
	populate(objectMap, "country", e.Country)
	populate(objectMap, "email", e.Email)
	populate(objectMap, "fax", e.Fax)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "org", e.Org)
	populate(objectMap, "phone", e.Phone)
	populate(objectMap, "postal", e.Postal)
	populate(objectMap, "state", e.State)
	populate(objectMap, "street", e.Street)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EnrichmentDomainWhoisDetails.
func (e EnrichmentDomainWhoisDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contacts", e.Contacts)
	populate(objectMap, "nameServers", e.NameServers)
	populate(objectMap, "registrar", e.Registrar)
	populate(objectMap, "statuses", e.Statuses)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type Entity.
func (e *Entity) GetEntity() *Entity { return e }

// GetSettings implements the SettingsClassification interface for type EntityAnalytics.
func (e *EntityAnalytics) GetSettings() *Settings {
	return &Settings{
		Kind:       e.Kind,
		Etag:       e.Etag,
		ID:         e.ID,
		Name:       e.Name,
		Type:       e.Type,
		SystemData: e.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EntityAnalytics.
func (e EntityAnalytics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", e.Etag)
	populate(objectMap, "id", e.ID)
	objectMap["kind"] = SettingKindEntityAnalytics
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityAnalytics.
func (e *EntityAnalytics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &e.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &e.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityAnalyticsProperties.
func (e EntityAnalyticsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entityProviders", e.EntityProviders)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityCommonProperties.
func (e EntityCommonProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", e.AdditionalData)
	populate(objectMap, "friendlyName", e.FriendlyName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityEdges.
func (e EntityEdges) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", e.AdditionalData)
	populate(objectMap, "targetEntityId", e.TargetEntityID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityExpandParameters.
func (e EntityExpandParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", e.EndTime)
	populate(objectMap, "expansionId", e.ExpansionID)
	populateTimeRFC3339(objectMap, "startTime", e.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityExpandParameters.
func (e *EntityExpandParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &e.EndTime)
			delete(rawMsg, key)
		case "expansionId":
			err = unpopulate(val, &e.ExpansionID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &e.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityExpandResponseValue.
func (e EntityExpandResponseValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "edges", e.Edges)
	populate(objectMap, "entities", e.Entities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityExpandResponseValue.
func (e *EntityExpandResponseValue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "edges":
			err = unpopulate(val, &e.Edges)
			delete(rawMsg, key)
		case "entities":
			e.Entities, err = unmarshalEntityClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityGetInsightsParameters.
func (e EntityGetInsightsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "addDefaultExtendedTimeRange", e.AddDefaultExtendedTimeRange)
	populateTimeRFC3339(objectMap, "endTime", e.EndTime)
	populate(objectMap, "insightQueryIds", e.InsightQueryIDs)
	populateTimeRFC3339(objectMap, "startTime", e.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityGetInsightsParameters.
func (e *EntityGetInsightsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addDefaultExtendedTimeRange":
			err = unpopulate(val, &e.AddDefaultExtendedTimeRange)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeRFC3339(val, &e.EndTime)
			delete(rawMsg, key)
		case "insightQueryIds":
			err = unpopulate(val, &e.InsightQueryIDs)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &e.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityGetInsightsResponse.
func (e EntityGetInsightsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metaData", e.MetaData)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityInsightItem.
func (e EntityInsightItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "chartQueryResults", e.ChartQueryResults)
	populate(objectMap, "queryId", e.QueryID)
	populate(objectMap, "queryTimeInterval", e.QueryTimeInterval)
	populate(objectMap, "tableQueryResults", e.TableQueryResults)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityInsightItemQueryTimeInterval.
func (e EntityInsightItemQueryTimeInterval) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", e.EndTime)
	populateTimeRFC3339(objectMap, "startTime", e.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityInsightItemQueryTimeInterval.
func (e *EntityInsightItemQueryTimeInterval) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &e.EndTime)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &e.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityList.
func (e EntityList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityList.
func (e *EntityList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &e.NextLink)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEntityClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityMapping.
func (e EntityMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entityType", e.EntityType)
	populate(objectMap, "fieldMappings", e.FieldMappings)
	return json.Marshal(objectMap)
}

// GetEntityQuery implements the EntityQueryClassification interface for type EntityQuery.
func (e *EntityQuery) GetEntityQuery() *EntityQuery { return e }

// GetEntityQueryItem implements the EntityQueryItemClassification interface for type EntityQueryItem.
func (e *EntityQueryItem) GetEntityQueryItem() *EntityQueryItem { return e }

// MarshalJSON implements the json.Marshaller interface for type EntityQueryItemProperties.
func (e EntityQueryItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataTypes", e.DataTypes)
	populate(objectMap, "entitiesFilter", &e.EntitiesFilter)
	populate(objectMap, "inputEntityType", e.InputEntityType)
	populate(objectMap, "requiredInputFieldsSets", e.RequiredInputFieldsSets)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EntityQueryList.
func (e EntityQueryList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityQueryList.
func (e *EntityQueryList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &e.NextLink)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEntityQueryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityQueryTemplate implements the EntityQueryTemplateClassification interface for type EntityQueryTemplate.
func (e *EntityQueryTemplate) GetEntityQueryTemplate() *EntityQueryTemplate { return e }

// MarshalJSON implements the json.Marshaller interface for type EntityQueryTemplateList.
func (e EntityQueryTemplateList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityQueryTemplateList.
func (e *EntityQueryTemplateList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &e.NextLink)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEntityQueryTemplateClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityTimelineItem implements the EntityTimelineItemClassification interface for type EntityTimelineItem.
func (e *EntityTimelineItem) GetEntityTimelineItem() *EntityTimelineItem { return e }

// MarshalJSON implements the json.Marshaller interface for type EntityTimelineParameters.
func (e EntityTimelineParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", e.EndTime)
	populate(objectMap, "kinds", e.Kinds)
	populate(objectMap, "numberOfBucket", e.NumberOfBucket)
	populateTimeRFC3339(objectMap, "startTime", e.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityTimelineParameters.
func (e *EntityTimelineParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &e.EndTime)
			delete(rawMsg, key)
		case "kinds":
			err = unpopulate(val, &e.Kinds)
			delete(rawMsg, key)
		case "numberOfBucket":
			err = unpopulate(val, &e.NumberOfBucket)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &e.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityTimelineResponse.
func (e EntityTimelineResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metaData", e.MetaData)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityTimelineResponse.
func (e *EntityTimelineResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metaData":
			err = unpopulate(val, &e.MetaData)
			delete(rawMsg, key)
		case "value":
			e.Value, err = unmarshalEntityTimelineItemClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpansionEntityQueriesProperties.
func (e ExpansionEntityQueriesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSources", e.DataSources)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "inputEntityType", e.InputEntityType)
	populate(objectMap, "inputFields", e.InputFields)
	populate(objectMap, "outputEntityTypes", e.OutputEntityTypes)
	populate(objectMap, "queryTemplate", e.QueryTemplate)
	return json.Marshal(objectMap)
}

// GetEntityQuery implements the EntityQueryClassification interface for type ExpansionEntityQuery.
func (e *ExpansionEntityQuery) GetEntityQuery() *EntityQuery {
	return &EntityQuery{
		Kind:       e.Kind,
		Etag:       e.Etag,
		ID:         e.ID,
		Name:       e.Name,
		Type:       e.Type,
		SystemData: e.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExpansionEntityQuery.
func (e ExpansionEntityQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", e.Etag)
	populate(objectMap, "id", e.ID)
	objectMap["kind"] = EntityQueryKindExpansion
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpansionEntityQuery.
func (e *ExpansionEntityQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &e.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &e.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpansionResultsMetadata.
func (e ExpansionResultsMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregations", e.Aggregations)
	return json.Marshal(objectMap)
}

// GetSettings implements the SettingsClassification interface for type EyesOn.
func (e *EyesOn) GetSettings() *Settings {
	return &Settings{
		Kind:       e.Kind,
		Etag:       e.Etag,
		ID:         e.ID,
		Name:       e.Name,
		Type:       e.Type,
		SystemData: e.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EyesOn.
func (e EyesOn) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", e.Etag)
	populate(objectMap, "id", e.ID)
	objectMap["kind"] = SettingKindEyesOn
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EyesOn.
func (e *EyesOn) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &e.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &e.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &e.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &e.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &e.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type FileEntity.
func (f *FileEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       f.Kind,
		ID:         f.ID,
		Name:       f.Name,
		Type:       f.Type,
		SystemData: f.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileEntity.
func (f FileEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", f.ID)
	objectMap["kind"] = EntityKindFile
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileEntity.
func (f *FileEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &f.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileEntityProperties.
func (f FileEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", f.AdditionalData)
	populate(objectMap, "directory", f.Directory)
	populate(objectMap, "fileHashEntityIds", f.FileHashEntityIDs)
	populate(objectMap, "fileName", f.FileName)
	populate(objectMap, "friendlyName", f.FriendlyName)
	populate(objectMap, "hostEntityId", f.HostEntityID)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type FileHashEntity.
func (f *FileHashEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       f.Kind,
		ID:         f.ID,
		Name:       f.Name,
		Type:       f.Type,
		SystemData: f.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FileHashEntity.
func (f FileHashEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", f.ID)
	objectMap["kind"] = EntityKindFileHash
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileHashEntity.
func (f *FileHashEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &f.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileHashEntityProperties.
func (f FileHashEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", f.AdditionalData)
	populate(objectMap, "algorithm", f.Algorithm)
	populate(objectMap, "friendlyName", f.FriendlyName)
	populate(objectMap, "hashValue", f.HashValue)
	return json.Marshal(objectMap)
}

// GetAlertRule implements the AlertRuleClassification interface for type FusionAlertRule.
func (f *FusionAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       f.Kind,
		Etag:       f.Etag,
		ID:         f.ID,
		Name:       f.Name,
		Type:       f.Type,
		SystemData: f.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FusionAlertRule.
func (f FusionAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", f.Etag)
	populate(objectMap, "id", f.ID)
	objectMap["kind"] = AlertRuleKindFusion
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FusionAlertRule.
func (f *FusionAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &f.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &f.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FusionAlertRuleProperties.
func (f FusionAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRuleTemplateName", f.AlertRuleTemplateName)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "displayName", f.DisplayName)
	populate(objectMap, "enabled", f.Enabled)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", f.LastModifiedUTC)
	populate(objectMap, "scenarioExclusionPatterns", f.ScenarioExclusionPatterns)
	populate(objectMap, "severity", f.Severity)
	populate(objectMap, "sourceSettings", f.SourceSettings)
	populate(objectMap, "tactics", f.Tactics)
	populate(objectMap, "techniques", f.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FusionAlertRuleProperties.
func (f *FusionAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRuleTemplateName":
			err = unpopulate(val, &f.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &f.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &f.Enabled)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &f.LastModifiedUTC)
			delete(rawMsg, key)
		case "scenarioExclusionPatterns":
			err = unpopulate(val, &f.ScenarioExclusionPatterns)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &f.Severity)
			delete(rawMsg, key)
		case "sourceSettings":
			err = unpopulate(val, &f.SourceSettings)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &f.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &f.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type FusionAlertRuleTemplate.
func (f *FusionAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       f.Kind,
		ID:         f.ID,
		Name:       f.Name,
		Type:       f.Type,
		SystemData: f.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type FusionAlertRuleTemplate.
func (f FusionAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", f.ID)
	objectMap["kind"] = AlertRuleKindFusion
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "systemData", f.SystemData)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FusionAlertRuleTemplate.
func (f *FusionAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &f.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &f.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &f.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FusionAlertRuleTemplateProperties.
func (f FusionAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", f.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", f.CreatedDateUTC)
	populate(objectMap, "description", f.Description)
	populate(objectMap, "displayName", f.DisplayName)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", f.LastUpdatedDateUTC)
	populate(objectMap, "requiredDataConnectors", f.RequiredDataConnectors)
	populate(objectMap, "severity", f.Severity)
	populate(objectMap, "sourceSettings", f.SourceSettings)
	populate(objectMap, "status", f.Status)
	populate(objectMap, "tactics", f.Tactics)
	populate(objectMap, "techniques", f.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FusionAlertRuleTemplateProperties.
func (f *FusionAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &f.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &f.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &f.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &f.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &f.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &f.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &f.Severity)
			delete(rawMsg, key)
		case "sourceSettings":
			err = unpopulate(val, &f.SourceSettings)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &f.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &f.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &f.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FusionSourceSettings.
func (f FusionSourceSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", f.Enabled)
	populate(objectMap, "sourceName", f.SourceName)
	populate(objectMap, "sourceSubTypes", f.SourceSubTypes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FusionSubTypeSeverityFilter.
func (f FusionSubTypeSeverityFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filters", f.Filters)
	populate(objectMap, "isSupported", f.IsSupported)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FusionTemplateSourceSetting.
func (f FusionTemplateSourceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sourceName", f.SourceName)
	populate(objectMap, "sourceSubTypes", f.SourceSubTypes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FusionTemplateSubTypeSeverityFilter.
func (f FusionTemplateSubTypeSeverityFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isSupported", f.IsSupported)
	populate(objectMap, "severityFilters", f.SeverityFilters)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GetInsightsResultsMetadata.
func (g GetInsightsResultsMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "totalCount", g.TotalCount)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GetQueriesResponse.
func (g GetQueriesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetQueriesResponse.
func (g *GetQueriesResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			g.Value, err = unmarshalEntityQueryItemClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GroupingConfiguration.
func (g GroupingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", g.Enabled)
	populate(objectMap, "groupByAlertDetails", g.GroupByAlertDetails)
	populate(objectMap, "groupByCustomDetails", g.GroupByCustomDetails)
	populate(objectMap, "groupByEntities", g.GroupByEntities)
	populate(objectMap, "lookbackDuration", g.LookbackDuration)
	populate(objectMap, "matchingMethod", g.MatchingMethod)
	populate(objectMap, "reopenClosedIncident", g.ReopenClosedIncident)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type HostEntity.
func (h *HostEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       h.Kind,
		ID:         h.ID,
		Name:       h.Name,
		Type:       h.Type,
		SystemData: h.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HostEntity.
func (h HostEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", h.ID)
	objectMap["kind"] = EntityKindHost
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HostEntity.
func (h *HostEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &h.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &h.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &h.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HostEntityProperties.
func (h HostEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", h.AdditionalData)
	populate(objectMap, "azureID", h.AzureID)
	populate(objectMap, "dnsDomain", h.DNSDomain)
	populate(objectMap, "friendlyName", h.FriendlyName)
	populate(objectMap, "hostName", h.HostName)
	populate(objectMap, "isDomainJoined", h.IsDomainJoined)
	populate(objectMap, "netBiosName", h.NetBiosName)
	populate(objectMap, "ntDomain", h.NtDomain)
	populate(objectMap, "osFamily", h.OSFamily)
	populate(objectMap, "osVersion", h.OSVersion)
	populate(objectMap, "omsAgentID", h.OmsAgentID)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type HuntingBookmark.
func (h *HuntingBookmark) GetEntity() *Entity {
	return &Entity{
		Kind:       h.Kind,
		ID:         h.ID,
		Name:       h.Name,
		Type:       h.Type,
		SystemData: h.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HuntingBookmark.
func (h HuntingBookmark) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", h.ID)
	objectMap["kind"] = EntityKindBookmark
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HuntingBookmark.
func (h *HuntingBookmark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &h.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &h.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &h.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &h.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HuntingBookmarkProperties.
func (h HuntingBookmarkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", h.AdditionalData)
	populateTimeRFC3339(objectMap, "created", h.Created)
	populate(objectMap, "createdBy", h.CreatedBy)
	populate(objectMap, "displayName", h.DisplayName)
	populateTimeRFC3339(objectMap, "eventTime", h.EventTime)
	populate(objectMap, "friendlyName", h.FriendlyName)
	populate(objectMap, "incidentInfo", h.IncidentInfo)
	populate(objectMap, "labels", h.Labels)
	populate(objectMap, "notes", h.Notes)
	populate(objectMap, "query", h.Query)
	populate(objectMap, "queryResult", h.QueryResult)
	populateTimeRFC3339(objectMap, "updated", h.Updated)
	populate(objectMap, "updatedBy", h.UpdatedBy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HuntingBookmarkProperties.
func (h *HuntingBookmarkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &h.AdditionalData)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &h.Created)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &h.CreatedBy)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &h.DisplayName)
			delete(rawMsg, key)
		case "eventTime":
			err = unpopulateTimeRFC3339(val, &h.EventTime)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &h.FriendlyName)
			delete(rawMsg, key)
		case "incidentInfo":
			err = unpopulate(val, &h.IncidentInfo)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &h.Labels)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &h.Notes)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &h.Query)
			delete(rawMsg, key)
		case "queryResult":
			err = unpopulate(val, &h.QueryResult)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeRFC3339(val, &h.Updated)
			delete(rawMsg, key)
		case "updatedBy":
			err = unpopulate(val, &h.UpdatedBy)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type IPEntity.
func (i *IPEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       i.Kind,
		ID:         i.ID,
		Name:       i.Name,
		Type:       i.Type,
		SystemData: i.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IPEntity.
func (i IPEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	objectMap["kind"] = EntityKindIP
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPEntity.
func (i *IPEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPEntityProperties.
func (i IPEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", i.AdditionalData)
	populate(objectMap, "address", i.Address)
	populate(objectMap, "friendlyName", i.FriendlyName)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "threatIntelligence", i.ThreatIntelligence)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentAdditionalData.
func (i IncidentAdditionalData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertProductNames", i.AlertProductNames)
	populate(objectMap, "alertsCount", i.AlertsCount)
	populate(objectMap, "bookmarksCount", i.BookmarksCount)
	populate(objectMap, "commentsCount", i.CommentsCount)
	populate(objectMap, "providerIncidentUrl", i.ProviderIncidentURL)
	populate(objectMap, "tactics", i.Tactics)
	populate(objectMap, "techniques", i.Techniques)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentAlertList.
func (i IncidentAlertList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentBookmarkList.
func (i IncidentBookmarkList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentCommentList.
func (i IncidentCommentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentCommentProperties.
func (i IncidentCommentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", i.Author)
	populateTimeRFC3339(objectMap, "createdTimeUtc", i.CreatedTimeUTC)
	populateTimeRFC3339(objectMap, "lastModifiedTimeUtc", i.LastModifiedTimeUTC)
	populate(objectMap, "message", i.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IncidentCommentProperties.
func (i *IncidentCommentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &i.Author)
			delete(rawMsg, key)
		case "createdTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.CreatedTimeUTC)
			delete(rawMsg, key)
		case "lastModifiedTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.LastModifiedTimeUTC)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &i.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IncidentEntitiesResponse.
func (i IncidentEntitiesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entities", i.Entities)
	populate(objectMap, "metaData", i.MetaData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IncidentEntitiesResponse.
func (i *IncidentEntitiesResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entities":
			i.Entities, err = unmarshalEntityClassificationArray(val)
			delete(rawMsg, key)
		case "metaData":
			err = unpopulate(val, &i.MetaData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IncidentList.
func (i IncidentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type IncidentProperties.
func (i IncidentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", i.AdditionalData)
	populate(objectMap, "classification", i.Classification)
	populate(objectMap, "classificationComment", i.ClassificationComment)
	populate(objectMap, "classificationReason", i.ClassificationReason)
	populateTimeRFC3339(objectMap, "createdTimeUtc", i.CreatedTimeUTC)
	populate(objectMap, "description", i.Description)
	populateTimeRFC3339(objectMap, "firstActivityTimeUtc", i.FirstActivityTimeUTC)
	populate(objectMap, "incidentNumber", i.IncidentNumber)
	populate(objectMap, "incidentUrl", i.IncidentURL)
	populate(objectMap, "labels", i.Labels)
	populateTimeRFC3339(objectMap, "lastActivityTimeUtc", i.LastActivityTimeUTC)
	populateTimeRFC3339(objectMap, "lastModifiedTimeUtc", i.LastModifiedTimeUTC)
	populate(objectMap, "owner", i.Owner)
	populate(objectMap, "providerIncidentId", i.ProviderIncidentID)
	populate(objectMap, "providerName", i.ProviderName)
	populate(objectMap, "relatedAnalyticRuleIds", i.RelatedAnalyticRuleIDs)
	populate(objectMap, "severity", i.Severity)
	populate(objectMap, "status", i.Status)
	populate(objectMap, "teamInformation", i.TeamInformation)
	populate(objectMap, "title", i.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IncidentProperties.
func (i *IncidentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &i.AdditionalData)
			delete(rawMsg, key)
		case "classification":
			err = unpopulate(val, &i.Classification)
			delete(rawMsg, key)
		case "classificationComment":
			err = unpopulate(val, &i.ClassificationComment)
			delete(rawMsg, key)
		case "classificationReason":
			err = unpopulate(val, &i.ClassificationReason)
			delete(rawMsg, key)
		case "createdTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.CreatedTimeUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "firstActivityTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.FirstActivityTimeUTC)
			delete(rawMsg, key)
		case "incidentNumber":
			err = unpopulate(val, &i.IncidentNumber)
			delete(rawMsg, key)
		case "incidentUrl":
			err = unpopulate(val, &i.IncidentURL)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &i.Labels)
			delete(rawMsg, key)
		case "lastActivityTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.LastActivityTimeUTC)
			delete(rawMsg, key)
		case "lastModifiedTimeUtc":
			err = unpopulateTimeRFC3339(val, &i.LastModifiedTimeUTC)
			delete(rawMsg, key)
		case "owner":
			err = unpopulate(val, &i.Owner)
			delete(rawMsg, key)
		case "providerIncidentId":
			err = unpopulate(val, &i.ProviderIncidentID)
			delete(rawMsg, key)
		case "providerName":
			err = unpopulate(val, &i.ProviderName)
			delete(rawMsg, key)
		case "relatedAnalyticRuleIds":
			err = unpopulate(val, &i.RelatedAnalyticRuleIDs)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &i.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &i.Status)
			delete(rawMsg, key)
		case "teamInformation":
			err = unpopulate(val, &i.TeamInformation)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &i.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IncidentPropertiesAction.
func (i IncidentPropertiesAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "classification", i.Classification)
	populate(objectMap, "classificationComment", i.ClassificationComment)
	populate(objectMap, "classificationReason", i.ClassificationReason)
	populate(objectMap, "labels", i.Labels)
	populate(objectMap, "owner", i.Owner)
	populate(objectMap, "severity", i.Severity)
	populate(objectMap, "status", i.Status)
	return json.Marshal(objectMap)
}

// GetEntityQueryItem implements the EntityQueryItemClassification interface for type InsightQueryItem.
func (i *InsightQueryItem) GetEntityQueryItem() *EntityQueryItem {
	return &EntityQueryItem{
		ID:   i.ID,
		Name: i.Name,
		Type: i.Type,
		Kind: i.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InsightQueryItem.
func (i InsightQueryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	objectMap["kind"] = EntityQueryKindInsight
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InsightQueryItem.
func (i *InsightQueryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InsightQueryItemProperties.
func (i InsightQueryItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalQuery", i.AdditionalQuery)
	populate(objectMap, "baseQuery", i.BaseQuery)
	populate(objectMap, "chartQuery", &i.ChartQuery)
	populate(objectMap, "dataTypes", i.DataTypes)
	populate(objectMap, "defaultTimeRange", i.DefaultTimeRange)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "entitiesFilter", &i.EntitiesFilter)
	populate(objectMap, "inputEntityType", i.InputEntityType)
	populate(objectMap, "referenceTimeRange", i.ReferenceTimeRange)
	populate(objectMap, "requiredInputFieldsSets", i.RequiredInputFieldsSets)
	populate(objectMap, "tableQuery", i.TableQuery)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InsightQueryItemPropertiesTableQuery.
func (i InsightQueryItemPropertiesTableQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columnsDefinitions", i.ColumnsDefinitions)
	populate(objectMap, "queriesDefinitions", i.QueriesDefinitions)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InsightQueryItemPropertiesTableQueryQueriesDefinitionsItem.
func (i InsightQueryItemPropertiesTableQueryQueriesDefinitionsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filter", i.Filter)
	populate(objectMap, "linkColumnsDefinitions", i.LinkColumnsDefinitions)
	populate(objectMap, "project", i.Project)
	populate(objectMap, "summarize", i.Summarize)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InsightsTableResult.
func (i InsightsTableResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columns", i.Columns)
	populate(objectMap, "rows", i.Rows)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InstructionSteps.
func (i InstructionSteps) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", i.Description)
	populate(objectMap, "instructions", i.Instructions)
	populate(objectMap, "title", i.Title)
	return json.Marshal(objectMap)
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type IoTCheckRequirements.
func (i *IoTCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: i.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IoTCheckRequirements.
func (i IoTCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindIOT
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTCheckRequirements.
func (i *IoTCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type IoTDataConnector.
func (i *IoTDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       i.Kind,
		Etag:       i.Etag,
		ID:         i.ID,
		Name:       i.Name,
		Type:       i.Type,
		SystemData: i.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IoTDataConnector.
func (i IoTDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", i.Etag)
	populate(objectMap, "id", i.ID)
	objectMap["kind"] = DataConnectorKindIOT
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTDataConnector.
func (i *IoTDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &i.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type IoTDeviceEntity.
func (i *IoTDeviceEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       i.Kind,
		ID:         i.ID,
		Name:       i.Name,
		Type:       i.Type,
		SystemData: i.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IoTDeviceEntity.
func (i IoTDeviceEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	objectMap["kind"] = EntityKindIoTDevice
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTDeviceEntity.
func (i *IoTDeviceEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IoTDeviceEntityProperties.
func (i IoTDeviceEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", i.AdditionalData)
	populate(objectMap, "deviceId", i.DeviceID)
	populate(objectMap, "deviceName", i.DeviceName)
	populate(objectMap, "deviceType", i.DeviceType)
	populate(objectMap, "edgeId", i.EdgeID)
	populate(objectMap, "firmwareVersion", i.FirmwareVersion)
	populate(objectMap, "friendlyName", i.FriendlyName)
	populate(objectMap, "hostEntityId", i.HostEntityID)
	populate(objectMap, "ipAddressEntityId", i.IPAddressEntityID)
	populate(objectMap, "iotHubEntityId", i.IotHubEntityID)
	populate(objectMap, "iotSecurityAgentId", i.IotSecurityAgentID)
	populate(objectMap, "macAddress", i.MacAddress)
	populate(objectMap, "model", i.Model)
	populate(objectMap, "operatingSystem", i.OperatingSystem)
	populate(objectMap, "protocols", i.Protocols)
	populate(objectMap, "serialNumber", i.SerialNumber)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "threatIntelligence", i.ThreatIntelligence)
	populate(objectMap, "vendor", i.Vendor)
	return json.Marshal(objectMap)
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type MCASCheckRequirements.
func (m *MCASCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MCASCheckRequirements.
func (m MCASCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindMicrosoftCloudAppSecurity
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MCASCheckRequirements.
func (m *MCASCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type MCASDataConnector.
func (m *MCASDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MCASDataConnector.
func (m MCASDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = DataConnectorKindMicrosoftCloudAppSecurity
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MCASDataConnector.
func (m *MCASDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type MDATPCheckRequirements.
func (m *MDATPCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MDATPCheckRequirements.
func (m MDATPCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindMicrosoftDefenderAdvancedThreatProtection
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MDATPCheckRequirements.
func (m *MDATPCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type MDATPDataConnector.
func (m *MDATPDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MDATPDataConnector.
func (m MDATPDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = DataConnectorKindMicrosoftDefenderAdvancedThreatProtection
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MDATPDataConnector.
func (m *MDATPDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRule implements the AlertRuleClassification interface for type MLBehaviorAnalyticsAlertRule.
func (m *MLBehaviorAnalyticsAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MLBehaviorAnalyticsAlertRule.
func (m MLBehaviorAnalyticsAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = AlertRuleKindMLBehaviorAnalytics
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLBehaviorAnalyticsAlertRule.
func (m *MLBehaviorAnalyticsAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLBehaviorAnalyticsAlertRuleProperties.
func (m MLBehaviorAnalyticsAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRuleTemplateName", m.AlertRuleTemplateName)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "enabled", m.Enabled)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", m.LastModifiedUTC)
	populate(objectMap, "severity", m.Severity)
	populate(objectMap, "tactics", m.Tactics)
	populate(objectMap, "techniques", m.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLBehaviorAnalyticsAlertRuleProperties.
func (m *MLBehaviorAnalyticsAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRuleTemplateName":
			err = unpopulate(val, &m.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &m.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &m.Enabled)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedUTC)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &m.Severity)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &m.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &m.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type MLBehaviorAnalyticsAlertRuleTemplate.
func (m *MLBehaviorAnalyticsAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MLBehaviorAnalyticsAlertRuleTemplate.
func (m MLBehaviorAnalyticsAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = AlertRuleKindMLBehaviorAnalytics
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLBehaviorAnalyticsAlertRuleTemplate.
func (m *MLBehaviorAnalyticsAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MLBehaviorAnalyticsAlertRuleTemplateProperties.
func (m MLBehaviorAnalyticsAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", m.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", m.CreatedDateUTC)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", m.LastUpdatedDateUTC)
	populate(objectMap, "requiredDataConnectors", m.RequiredDataConnectors)
	populate(objectMap, "severity", m.Severity)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "tactics", m.Tactics)
	populate(objectMap, "techniques", m.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MLBehaviorAnalyticsAlertRuleTemplateProperties.
func (m *MLBehaviorAnalyticsAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &m.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &m.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &m.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &m.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &m.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &m.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &m.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &m.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type MSTICheckRequirements.
func (m *MSTICheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MSTICheckRequirements.
func (m MSTICheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindMicrosoftThreatIntelligence
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MSTICheckRequirements.
func (m *MSTICheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type MSTIDataConnector.
func (m *MSTIDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MSTIDataConnector.
func (m MSTIDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = DataConnectorKindMicrosoftThreatIntelligence
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MSTIDataConnector.
func (m *MSTIDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type MTPDataConnector.
func (m *MTPDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MTPDataConnector.
func (m MTPDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = DataConnectorKindMicrosoftThreatProtection
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MTPDataConnector.
func (m *MTPDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type MailClusterEntity.
func (m *MailClusterEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MailClusterEntity.
func (m MailClusterEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = EntityKindMailCluster
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MailClusterEntity.
func (m *MailClusterEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MailClusterEntityProperties.
func (m MailClusterEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", m.AdditionalData)
	populate(objectMap, "clusterGroup", m.ClusterGroup)
	populateTimeRFC3339(objectMap, "clusterQueryEndTime", m.ClusterQueryEndTime)
	populateTimeRFC3339(objectMap, "clusterQueryStartTime", m.ClusterQueryStartTime)
	populate(objectMap, "clusterSourceIdentifier", m.ClusterSourceIdentifier)
	populate(objectMap, "clusterSourceType", m.ClusterSourceType)
	populate(objectMap, "countByDeliveryStatus", &m.CountByDeliveryStatus)
	populate(objectMap, "countByProtectionStatus", &m.CountByProtectionStatus)
	populate(objectMap, "countByThreatType", &m.CountByThreatType)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "isVolumeAnomaly", m.IsVolumeAnomaly)
	populate(objectMap, "mailCount", m.MailCount)
	populate(objectMap, "networkMessageIds", m.NetworkMessageIDs)
	populate(objectMap, "query", m.Query)
	populateTimeRFC3339(objectMap, "queryTime", m.QueryTime)
	populate(objectMap, "source", m.Source)
	populate(objectMap, "threats", m.Threats)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MailClusterEntityProperties.
func (m *MailClusterEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &m.AdditionalData)
			delete(rawMsg, key)
		case "clusterGroup":
			err = unpopulate(val, &m.ClusterGroup)
			delete(rawMsg, key)
		case "clusterQueryEndTime":
			err = unpopulateTimeRFC3339(val, &m.ClusterQueryEndTime)
			delete(rawMsg, key)
		case "clusterQueryStartTime":
			err = unpopulateTimeRFC3339(val, &m.ClusterQueryStartTime)
			delete(rawMsg, key)
		case "clusterSourceIdentifier":
			err = unpopulate(val, &m.ClusterSourceIdentifier)
			delete(rawMsg, key)
		case "clusterSourceType":
			err = unpopulate(val, &m.ClusterSourceType)
			delete(rawMsg, key)
		case "countByDeliveryStatus":
			err = unpopulate(val, &m.CountByDeliveryStatus)
			delete(rawMsg, key)
		case "countByProtectionStatus":
			err = unpopulate(val, &m.CountByProtectionStatus)
			delete(rawMsg, key)
		case "countByThreatType":
			err = unpopulate(val, &m.CountByThreatType)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &m.FriendlyName)
			delete(rawMsg, key)
		case "isVolumeAnomaly":
			err = unpopulate(val, &m.IsVolumeAnomaly)
			delete(rawMsg, key)
		case "mailCount":
			err = unpopulate(val, &m.MailCount)
			delete(rawMsg, key)
		case "networkMessageIds":
			err = unpopulate(val, &m.NetworkMessageIDs)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &m.Query)
			delete(rawMsg, key)
		case "queryTime":
			err = unpopulateTimeRFC3339(val, &m.QueryTime)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &m.Source)
			delete(rawMsg, key)
		case "threats":
			err = unpopulate(val, &m.Threats)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type MailMessageEntity.
func (m *MailMessageEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MailMessageEntity.
func (m MailMessageEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = EntityKindMailMessage
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MailMessageEntity.
func (m *MailMessageEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MailMessageEntityProperties.
func (m MailMessageEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", m.AdditionalData)
	populate(objectMap, "antispamDirection", m.AntispamDirection)
	populate(objectMap, "bodyFingerprintBin1", m.BodyFingerprintBin1)
	populate(objectMap, "bodyFingerprintBin2", m.BodyFingerprintBin2)
	populate(objectMap, "bodyFingerprintBin3", m.BodyFingerprintBin3)
	populate(objectMap, "bodyFingerprintBin4", m.BodyFingerprintBin4)
	populate(objectMap, "bodyFingerprintBin5", m.BodyFingerprintBin5)
	populate(objectMap, "deliveryAction", m.DeliveryAction)
	populate(objectMap, "deliveryLocation", m.DeliveryLocation)
	populate(objectMap, "fileEntityIds", m.FileEntityIDs)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "internetMessageId", m.InternetMessageID)
	populate(objectMap, "language", m.Language)
	populate(objectMap, "networkMessageId", m.NetworkMessageID)
	populate(objectMap, "p1Sender", m.P1Sender)
	populate(objectMap, "p1SenderDisplayName", m.P1SenderDisplayName)
	populate(objectMap, "p1SenderDomain", m.P1SenderDomain)
	populate(objectMap, "p2Sender", m.P2Sender)
	populate(objectMap, "p2SenderDisplayName", m.P2SenderDisplayName)
	populate(objectMap, "p2SenderDomain", m.P2SenderDomain)
	populateTimeRFC3339(objectMap, "receiveDate", m.ReceiveDate)
	populate(objectMap, "recipient", m.Recipient)
	populate(objectMap, "senderIP", m.SenderIP)
	populate(objectMap, "subject", m.Subject)
	populate(objectMap, "threatDetectionMethods", m.ThreatDetectionMethods)
	populate(objectMap, "threats", m.Threats)
	populate(objectMap, "urls", m.Urls)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MailMessageEntityProperties.
func (m *MailMessageEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &m.AdditionalData)
			delete(rawMsg, key)
		case "antispamDirection":
			err = unpopulate(val, &m.AntispamDirection)
			delete(rawMsg, key)
		case "bodyFingerprintBin1":
			err = unpopulate(val, &m.BodyFingerprintBin1)
			delete(rawMsg, key)
		case "bodyFingerprintBin2":
			err = unpopulate(val, &m.BodyFingerprintBin2)
			delete(rawMsg, key)
		case "bodyFingerprintBin3":
			err = unpopulate(val, &m.BodyFingerprintBin3)
			delete(rawMsg, key)
		case "bodyFingerprintBin4":
			err = unpopulate(val, &m.BodyFingerprintBin4)
			delete(rawMsg, key)
		case "bodyFingerprintBin5":
			err = unpopulate(val, &m.BodyFingerprintBin5)
			delete(rawMsg, key)
		case "deliveryAction":
			err = unpopulate(val, &m.DeliveryAction)
			delete(rawMsg, key)
		case "deliveryLocation":
			err = unpopulate(val, &m.DeliveryLocation)
			delete(rawMsg, key)
		case "fileEntityIds":
			err = unpopulate(val, &m.FileEntityIDs)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &m.FriendlyName)
			delete(rawMsg, key)
		case "internetMessageId":
			err = unpopulate(val, &m.InternetMessageID)
			delete(rawMsg, key)
		case "language":
			err = unpopulate(val, &m.Language)
			delete(rawMsg, key)
		case "networkMessageId":
			err = unpopulate(val, &m.NetworkMessageID)
			delete(rawMsg, key)
		case "p1Sender":
			err = unpopulate(val, &m.P1Sender)
			delete(rawMsg, key)
		case "p1SenderDisplayName":
			err = unpopulate(val, &m.P1SenderDisplayName)
			delete(rawMsg, key)
		case "p1SenderDomain":
			err = unpopulate(val, &m.P1SenderDomain)
			delete(rawMsg, key)
		case "p2Sender":
			err = unpopulate(val, &m.P2Sender)
			delete(rawMsg, key)
		case "p2SenderDisplayName":
			err = unpopulate(val, &m.P2SenderDisplayName)
			delete(rawMsg, key)
		case "p2SenderDomain":
			err = unpopulate(val, &m.P2SenderDomain)
			delete(rawMsg, key)
		case "receiveDate":
			err = unpopulateTimeRFC3339(val, &m.ReceiveDate)
			delete(rawMsg, key)
		case "recipient":
			err = unpopulate(val, &m.Recipient)
			delete(rawMsg, key)
		case "senderIP":
			err = unpopulate(val, &m.SenderIP)
			delete(rawMsg, key)
		case "subject":
			err = unpopulate(val, &m.Subject)
			delete(rawMsg, key)
		case "threatDetectionMethods":
			err = unpopulate(val, &m.ThreatDetectionMethods)
			delete(rawMsg, key)
		case "threats":
			err = unpopulate(val, &m.Threats)
			delete(rawMsg, key)
		case "urls":
			err = unpopulate(val, &m.Urls)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type MailboxEntity.
func (m *MailboxEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MailboxEntity.
func (m MailboxEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = EntityKindMailbox
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MailboxEntity.
func (m *MailboxEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MailboxEntityProperties.
func (m MailboxEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", m.AdditionalData)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "externalDirectoryObjectId", m.ExternalDirectoryObjectID)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "mailboxPrimaryAddress", m.MailboxPrimaryAddress)
	populate(objectMap, "upn", m.Upn)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type MalwareEntity.
func (m *MalwareEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MalwareEntity.
func (m MalwareEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = EntityKindMalware
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MalwareEntity.
func (m *MalwareEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MalwareEntityProperties.
func (m MalwareEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", m.AdditionalData)
	populate(objectMap, "category", m.Category)
	populate(objectMap, "fileEntityIds", m.FileEntityIDs)
	populate(objectMap, "friendlyName", m.FriendlyName)
	populate(objectMap, "malwareName", m.MalwareName)
	populate(objectMap, "processEntityIds", m.ProcessEntityIDs)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetadataCategories.
func (m MetadataCategories) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domains", m.Domains)
	populate(objectMap, "verticals", m.Verticals)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetadataDependencies.
func (m MetadataDependencies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentId", m.ContentID)
	populate(objectMap, "criteria", m.Criteria)
	populate(objectMap, "kind", m.Kind)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "operator", m.Operator)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetadataList.
func (m MetadataList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetadataPatch.
func (m MetadataPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MetadataProperties.
func (m MetadataProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", m.Author)
	populate(objectMap, "categories", m.Categories)
	populate(objectMap, "contentId", m.ContentID)
	populate(objectMap, "contentSchemaVersion", m.ContentSchemaVersion)
	populate(objectMap, "customVersion", m.CustomVersion)
	populate(objectMap, "dependencies", m.Dependencies)
	populateDateType(objectMap, "firstPublishDate", m.FirstPublishDate)
	populate(objectMap, "icon", m.Icon)
	populate(objectMap, "kind", m.Kind)
	populateDateType(objectMap, "lastPublishDate", m.LastPublishDate)
	populate(objectMap, "parentId", m.ParentID)
	populate(objectMap, "previewImages", m.PreviewImages)
	populate(objectMap, "previewImagesDark", m.PreviewImagesDark)
	populate(objectMap, "providers", m.Providers)
	populate(objectMap, "source", m.Source)
	populate(objectMap, "support", m.Support)
	populate(objectMap, "threatAnalysisTactics", m.ThreatAnalysisTactics)
	populate(objectMap, "threatAnalysisTechniques", m.ThreatAnalysisTechniques)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataProperties.
func (m *MetadataProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &m.Author)
			delete(rawMsg, key)
		case "categories":
			err = unpopulate(val, &m.Categories)
			delete(rawMsg, key)
		case "contentId":
			err = unpopulate(val, &m.ContentID)
			delete(rawMsg, key)
		case "contentSchemaVersion":
			err = unpopulate(val, &m.ContentSchemaVersion)
			delete(rawMsg, key)
		case "customVersion":
			err = unpopulate(val, &m.CustomVersion)
			delete(rawMsg, key)
		case "dependencies":
			err = unpopulate(val, &m.Dependencies)
			delete(rawMsg, key)
		case "firstPublishDate":
			err = unpopulateDateType(val, &m.FirstPublishDate)
			delete(rawMsg, key)
		case "icon":
			err = unpopulate(val, &m.Icon)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "lastPublishDate":
			err = unpopulateDateType(val, &m.LastPublishDate)
			delete(rawMsg, key)
		case "parentId":
			err = unpopulate(val, &m.ParentID)
			delete(rawMsg, key)
		case "previewImages":
			err = unpopulate(val, &m.PreviewImages)
			delete(rawMsg, key)
		case "previewImagesDark":
			err = unpopulate(val, &m.PreviewImagesDark)
			delete(rawMsg, key)
		case "providers":
			err = unpopulate(val, &m.Providers)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &m.Source)
			delete(rawMsg, key)
		case "support":
			err = unpopulate(val, &m.Support)
			delete(rawMsg, key)
		case "threatAnalysisTactics":
			err = unpopulate(val, &m.ThreatAnalysisTactics)
			delete(rawMsg, key)
		case "threatAnalysisTechniques":
			err = unpopulate(val, &m.ThreatAnalysisTechniques)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &m.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetadataPropertiesPatch.
func (m MetadataPropertiesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", m.Author)
	populate(objectMap, "categories", m.Categories)
	populate(objectMap, "contentId", m.ContentID)
	populate(objectMap, "contentSchemaVersion", m.ContentSchemaVersion)
	populate(objectMap, "customVersion", m.CustomVersion)
	populate(objectMap, "dependencies", m.Dependencies)
	populateDateType(objectMap, "firstPublishDate", m.FirstPublishDate)
	populate(objectMap, "icon", m.Icon)
	populate(objectMap, "kind", m.Kind)
	populateDateType(objectMap, "lastPublishDate", m.LastPublishDate)
	populate(objectMap, "parentId", m.ParentID)
	populate(objectMap, "previewImages", m.PreviewImages)
	populate(objectMap, "previewImagesDark", m.PreviewImagesDark)
	populate(objectMap, "providers", m.Providers)
	populate(objectMap, "source", m.Source)
	populate(objectMap, "support", m.Support)
	populate(objectMap, "threatAnalysisTactics", m.ThreatAnalysisTactics)
	populate(objectMap, "threatAnalysisTechniques", m.ThreatAnalysisTechniques)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataPropertiesPatch.
func (m *MetadataPropertiesPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
			err = unpopulate(val, &m.Author)
			delete(rawMsg, key)
		case "categories":
			err = unpopulate(val, &m.Categories)
			delete(rawMsg, key)
		case "contentId":
			err = unpopulate(val, &m.ContentID)
			delete(rawMsg, key)
		case "contentSchemaVersion":
			err = unpopulate(val, &m.ContentSchemaVersion)
			delete(rawMsg, key)
		case "customVersion":
			err = unpopulate(val, &m.CustomVersion)
			delete(rawMsg, key)
		case "dependencies":
			err = unpopulate(val, &m.Dependencies)
			delete(rawMsg, key)
		case "firstPublishDate":
			err = unpopulateDateType(val, &m.FirstPublishDate)
			delete(rawMsg, key)
		case "icon":
			err = unpopulate(val, &m.Icon)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "lastPublishDate":
			err = unpopulateDateType(val, &m.LastPublishDate)
			delete(rawMsg, key)
		case "parentId":
			err = unpopulate(val, &m.ParentID)
			delete(rawMsg, key)
		case "previewImages":
			err = unpopulate(val, &m.PreviewImages)
			delete(rawMsg, key)
		case "previewImagesDark":
			err = unpopulate(val, &m.PreviewImagesDark)
			delete(rawMsg, key)
		case "providers":
			err = unpopulate(val, &m.Providers)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &m.Source)
			delete(rawMsg, key)
		case "support":
			err = unpopulate(val, &m.Support)
			delete(rawMsg, key)
		case "threatAnalysisTactics":
			err = unpopulate(val, &m.ThreatAnalysisTactics)
			delete(rawMsg, key)
		case "threatAnalysisTechniques":
			err = unpopulate(val, &m.ThreatAnalysisTechniques)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &m.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRule implements the AlertRuleClassification interface for type MicrosoftSecurityIncidentCreationAlertRule.
func (m *MicrosoftSecurityIncidentCreationAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       m.Kind,
		Etag:       m.Etag,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSecurityIncidentCreationAlertRule.
func (m MicrosoftSecurityIncidentCreationAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = AlertRuleKindMicrosoftSecurityIncidentCreation
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSecurityIncidentCreationAlertRule.
func (m *MicrosoftSecurityIncidentCreationAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleCommonProperties.
func (m MicrosoftSecurityIncidentCreationAlertRuleCommonProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayNamesExcludeFilter", m.DisplayNamesExcludeFilter)
	populate(objectMap, "displayNamesFilter", m.DisplayNamesFilter)
	populate(objectMap, "productFilter", m.ProductFilter)
	populate(objectMap, "severitiesFilter", m.SeveritiesFilter)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleProperties.
func (m MicrosoftSecurityIncidentCreationAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRuleTemplateName", m.AlertRuleTemplateName)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "displayNamesExcludeFilter", m.DisplayNamesExcludeFilter)
	populate(objectMap, "displayNamesFilter", m.DisplayNamesFilter)
	populate(objectMap, "enabled", m.Enabled)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", m.LastModifiedUTC)
	populate(objectMap, "productFilter", m.ProductFilter)
	populate(objectMap, "severitiesFilter", m.SeveritiesFilter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleProperties.
func (m *MicrosoftSecurityIncidentCreationAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRuleTemplateName":
			err = unpopulate(val, &m.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &m.DisplayName)
			delete(rawMsg, key)
		case "displayNamesExcludeFilter":
			err = unpopulate(val, &m.DisplayNamesExcludeFilter)
			delete(rawMsg, key)
		case "displayNamesFilter":
			err = unpopulate(val, &m.DisplayNamesFilter)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &m.Enabled)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedUTC)
			delete(rawMsg, key)
		case "productFilter":
			err = unpopulate(val, &m.ProductFilter)
			delete(rawMsg, key)
		case "severitiesFilter":
			err = unpopulate(val, &m.SeveritiesFilter)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type MicrosoftSecurityIncidentCreationAlertRuleTemplate.
func (m *MicrosoftSecurityIncidentCreationAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       m.Kind,
		ID:         m.ID,
		Name:       m.Name,
		Type:       m.Type,
		SystemData: m.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleTemplate.
func (m MicrosoftSecurityIncidentCreationAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = AlertRuleKindMicrosoftSecurityIncidentCreation
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleTemplate.
func (m *MicrosoftSecurityIncidentCreationAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &m.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleTemplateProperties.
func (m MicrosoftSecurityIncidentCreationAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", m.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", m.CreatedDateUTC)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "displayNamesExcludeFilter", m.DisplayNamesExcludeFilter)
	populate(objectMap, "displayNamesFilter", m.DisplayNamesFilter)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", m.LastUpdatedDateUTC)
	populate(objectMap, "productFilter", m.ProductFilter)
	populate(objectMap, "requiredDataConnectors", m.RequiredDataConnectors)
	populate(objectMap, "severitiesFilter", m.SeveritiesFilter)
	populate(objectMap, "status", m.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSecurityIncidentCreationAlertRuleTemplateProperties.
func (m *MicrosoftSecurityIncidentCreationAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &m.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &m.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &m.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &m.DisplayName)
			delete(rawMsg, key)
		case "displayNamesExcludeFilter":
			err = unpopulate(val, &m.DisplayNamesExcludeFilter)
			delete(rawMsg, key)
		case "displayNamesFilter":
			err = unpopulate(val, &m.DisplayNamesFilter)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &m.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "productFilter":
			err = unpopulate(val, &m.ProductFilter)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &m.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severitiesFilter":
			err = unpopulate(val, &m.SeveritiesFilter)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type MtpCheckRequirements.
func (m *MtpCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MtpCheckRequirements.
func (m MtpCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindMicrosoftThreatProtection
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MtpCheckRequirements.
func (m *MtpCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &m.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRule implements the AlertRuleClassification interface for type NrtAlertRule.
func (n *NrtAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       n.Kind,
		Etag:       n.Etag,
		ID:         n.ID,
		Name:       n.Name,
		Type:       n.Type,
		SystemData: n.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NrtAlertRule.
func (n NrtAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", n.Etag)
	populate(objectMap, "id", n.ID)
	objectMap["kind"] = AlertRuleKindNRT
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NrtAlertRule.
func (n *NrtAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &n.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &n.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &n.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NrtAlertRuleProperties.
func (n NrtAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", n.AlertDetailsOverride)
	populate(objectMap, "alertRuleTemplateName", n.AlertRuleTemplateName)
	populate(objectMap, "customDetails", n.CustomDetails)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "displayName", n.DisplayName)
	populate(objectMap, "enabled", n.Enabled)
	populate(objectMap, "entityMappings", n.EntityMappings)
	populate(objectMap, "incidentConfiguration", n.IncidentConfiguration)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", n.LastModifiedUTC)
	populate(objectMap, "query", n.Query)
	populate(objectMap, "severity", n.Severity)
	populate(objectMap, "suppressionDuration", n.SuppressionDuration)
	populate(objectMap, "suppressionEnabled", n.SuppressionEnabled)
	populate(objectMap, "tactics", n.Tactics)
	populate(objectMap, "techniques", n.Techniques)
	populate(objectMap, "templateVersion", n.TemplateVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NrtAlertRuleProperties.
func (n *NrtAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertDetailsOverride":
			err = unpopulate(val, &n.AlertDetailsOverride)
			delete(rawMsg, key)
		case "alertRuleTemplateName":
			err = unpopulate(val, &n.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "customDetails":
			err = unpopulate(val, &n.CustomDetails)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &n.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &n.Enabled)
			delete(rawMsg, key)
		case "entityMappings":
			err = unpopulate(val, &n.EntityMappings)
			delete(rawMsg, key)
		case "incidentConfiguration":
			err = unpopulate(val, &n.IncidentConfiguration)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &n.LastModifiedUTC)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &n.Query)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &n.Severity)
			delete(rawMsg, key)
		case "suppressionDuration":
			err = unpopulate(val, &n.SuppressionDuration)
			delete(rawMsg, key)
		case "suppressionEnabled":
			err = unpopulate(val, &n.SuppressionEnabled)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &n.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &n.Techniques)
			delete(rawMsg, key)
		case "templateVersion":
			err = unpopulate(val, &n.TemplateVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type NrtAlertRuleTemplate.
func (n *NrtAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       n.Kind,
		ID:         n.ID,
		Name:       n.Name,
		Type:       n.Type,
		SystemData: n.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NrtAlertRuleTemplate.
func (n NrtAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", n.ID)
	objectMap["kind"] = AlertRuleKindNRT
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NrtAlertRuleTemplate.
func (n *NrtAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &n.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &n.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &n.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &n.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NrtAlertRuleTemplateProperties.
func (n NrtAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", n.AlertDetailsOverride)
	populate(objectMap, "alertRulesCreatedByTemplateCount", n.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", n.CreatedDateUTC)
	populate(objectMap, "customDetails", n.CustomDetails)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "displayName", n.DisplayName)
	populate(objectMap, "entityMappings", n.EntityMappings)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", n.LastUpdatedDateUTC)
	populate(objectMap, "query", n.Query)
	populate(objectMap, "requiredDataConnectors", n.RequiredDataConnectors)
	populate(objectMap, "severity", n.Severity)
	populate(objectMap, "status", n.Status)
	populate(objectMap, "tactics", n.Tactics)
	populate(objectMap, "techniques", n.Techniques)
	populate(objectMap, "version", n.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NrtAlertRuleTemplateProperties.
func (n *NrtAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertDetailsOverride":
			err = unpopulate(val, &n.AlertDetailsOverride)
			delete(rawMsg, key)
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &n.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &n.CreatedDateUTC)
			delete(rawMsg, key)
		case "customDetails":
			err = unpopulate(val, &n.CustomDetails)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &n.DisplayName)
			delete(rawMsg, key)
		case "entityMappings":
			err = unpopulate(val, &n.EntityMappings)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &n.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &n.Query)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &n.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &n.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &n.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &n.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &n.Techniques)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &n.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type Office365ProjectCheckRequirements.
func (o *Office365ProjectCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: o.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Office365ProjectCheckRequirements.
func (o Office365ProjectCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindOffice365Project
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365ProjectCheckRequirements.
func (o *Office365ProjectCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type Office365ProjectDataConnector.
func (o *Office365ProjectDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       o.Kind,
		Etag:       o.Etag,
		ID:         o.ID,
		Name:       o.Name,
		Type:       o.Type,
		SystemData: o.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Office365ProjectDataConnector.
func (o Office365ProjectDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "id", o.ID)
	objectMap["kind"] = DataConnectorKindOffice365Project
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365ProjectDataConnector.
func (o *Office365ProjectDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type OfficeATPCheckRequirements.
func (o *OfficeATPCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: o.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficeATPCheckRequirements.
func (o OfficeATPCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindOfficeATP
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficeATPCheckRequirements.
func (o *OfficeATPCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type OfficeATPDataConnector.
func (o *OfficeATPDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       o.Kind,
		Etag:       o.Etag,
		ID:         o.ID,
		Name:       o.Name,
		Type:       o.Type,
		SystemData: o.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficeATPDataConnector.
func (o OfficeATPDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "id", o.ID)
	objectMap["kind"] = DataConnectorKindOfficeATP
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficeATPDataConnector.
func (o *OfficeATPDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OfficeConsentList.
func (o OfficeConsentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// GetDataConnector implements the DataConnectorClassification interface for type OfficeDataConnector.
func (o *OfficeDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       o.Kind,
		Etag:       o.Etag,
		ID:         o.ID,
		Name:       o.Name,
		Type:       o.Type,
		SystemData: o.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficeDataConnector.
func (o OfficeDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "id", o.ID)
	objectMap["kind"] = DataConnectorKindOffice365
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficeDataConnector.
func (o *OfficeDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type OfficeIRMCheckRequirements.
func (o *OfficeIRMCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: o.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficeIRMCheckRequirements.
func (o OfficeIRMCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindOfficeIRM
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficeIRMCheckRequirements.
func (o *OfficeIRMCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type OfficeIRMDataConnector.
func (o *OfficeIRMDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       o.Kind,
		Etag:       o.Etag,
		ID:         o.ID,
		Name:       o.Name,
		Type:       o.Type,
		SystemData: o.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficeIRMDataConnector.
func (o OfficeIRMDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "id", o.ID)
	objectMap["kind"] = DataConnectorKindOfficeIRM
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficeIRMDataConnector.
func (o *OfficeIRMDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type OfficePowerBICheckRequirements.
func (o *OfficePowerBICheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: o.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficePowerBICheckRequirements.
func (o OfficePowerBICheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindOfficePowerBI
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficePowerBICheckRequirements.
func (o *OfficePowerBICheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type OfficePowerBIDataConnector.
func (o *OfficePowerBIDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       o.Kind,
		Etag:       o.Etag,
		ID:         o.ID,
		Name:       o.Name,
		Type:       o.Type,
		SystemData: o.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OfficePowerBIDataConnector.
func (o OfficePowerBIDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "id", o.ID)
	objectMap["kind"] = DataConnectorKindOfficePowerBI
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "systemData", o.SystemData)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OfficePowerBIDataConnector.
func (o *OfficePowerBIDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &o.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &o.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationsList.
func (o OperationsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Permissions.
func (p Permissions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customs", p.Customs)
	populate(objectMap, "resourceProvider", p.ResourceProvider)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type ProcessEntity.
func (p *ProcessEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       p.Kind,
		ID:         p.ID,
		Name:       p.Name,
		Type:       p.Type,
		SystemData: p.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ProcessEntity.
func (p ProcessEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	objectMap["kind"] = EntityKindProcess
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessEntity.
func (p *ProcessEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &p.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProcessEntityProperties.
func (p ProcessEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountEntityId", p.AccountEntityID)
	populate(objectMap, "additionalData", p.AdditionalData)
	populate(objectMap, "commandLine", p.CommandLine)
	populateTimeRFC3339(objectMap, "creationTimeUtc", p.CreationTimeUTC)
	populate(objectMap, "elevationToken", p.ElevationToken)
	populate(objectMap, "friendlyName", p.FriendlyName)
	populate(objectMap, "hostEntityId", p.HostEntityID)
	populate(objectMap, "hostLogonSessionEntityId", p.HostLogonSessionEntityID)
	populate(objectMap, "imageFileEntityId", p.ImageFileEntityID)
	populate(objectMap, "parentProcessEntityId", p.ParentProcessEntityID)
	populate(objectMap, "processId", p.ProcessID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessEntityProperties.
func (p *ProcessEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountEntityId":
			err = unpopulate(val, &p.AccountEntityID)
			delete(rawMsg, key)
		case "additionalData":
			err = unpopulate(val, &p.AdditionalData)
			delete(rawMsg, key)
		case "commandLine":
			err = unpopulate(val, &p.CommandLine)
			delete(rawMsg, key)
		case "creationTimeUtc":
			err = unpopulateTimeRFC3339(val, &p.CreationTimeUTC)
			delete(rawMsg, key)
		case "elevationToken":
			err = unpopulate(val, &p.ElevationToken)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &p.FriendlyName)
			delete(rawMsg, key)
		case "hostEntityId":
			err = unpopulate(val, &p.HostEntityID)
			delete(rawMsg, key)
		case "hostLogonSessionEntityId":
			err = unpopulate(val, &p.HostLogonSessionEntityID)
			delete(rawMsg, key)
		case "imageFileEntityId":
			err = unpopulate(val, &p.ImageFileEntityID)
			delete(rawMsg, key)
		case "parentProcessEntityId":
			err = unpopulate(val, &p.ParentProcessEntityID)
			delete(rawMsg, key)
		case "processId":
			err = unpopulate(val, &p.ProcessID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAutomationRuleCondition implements the AutomationRuleConditionClassification interface for type PropertyConditionProperties.
func (p *PropertyConditionProperties) GetAutomationRuleCondition() *AutomationRuleCondition {
	return &AutomationRuleCondition{
		ConditionType: p.ConditionType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PropertyConditionProperties.
func (p PropertyConditionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "conditionProperties", p.ConditionProperties)
	objectMap["conditionType"] = ConditionTypeProperty
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PropertyConditionProperties.
func (p *PropertyConditionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conditionProperties":
			err = unpopulate(val, &p.ConditionProperties)
			delete(rawMsg, key)
		case "conditionType":
			err = unpopulate(val, &p.ConditionType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueryBasedAlertRuleTemplateProperties.
func (q QueryBasedAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", q.AlertDetailsOverride)
	populate(objectMap, "customDetails", q.CustomDetails)
	populate(objectMap, "entityMappings", q.EntityMappings)
	populate(objectMap, "query", q.Query)
	populate(objectMap, "severity", q.Severity)
	populate(objectMap, "version", q.Version)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type RegistryKeyEntity.
func (r *RegistryKeyEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       r.Kind,
		ID:         r.ID,
		Name:       r.Name,
		Type:       r.Type,
		SystemData: r.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RegistryKeyEntity.
func (r RegistryKeyEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	objectMap["kind"] = EntityKindRegistryKey
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistryKeyEntity.
func (r *RegistryKeyEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistryKeyEntityProperties.
func (r RegistryKeyEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", r.AdditionalData)
	populate(objectMap, "friendlyName", r.FriendlyName)
	populate(objectMap, "hive", r.Hive)
	populate(objectMap, "key", r.Key)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type RegistryValueEntity.
func (r *RegistryValueEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       r.Kind,
		ID:         r.ID,
		Name:       r.Name,
		Type:       r.Type,
		SystemData: r.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type RegistryValueEntity.
func (r RegistryValueEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	objectMap["kind"] = EntityKindRegistryValue
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RegistryValueEntity.
func (r *RegistryValueEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &r.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &r.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RegistryValueEntityProperties.
func (r RegistryValueEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", r.AdditionalData)
	populate(objectMap, "friendlyName", r.FriendlyName)
	populate(objectMap, "keyEntityId", r.KeyEntityID)
	populate(objectMap, "valueData", r.ValueData)
	populate(objectMap, "valueName", r.ValueName)
	populate(objectMap, "valueType", r.ValueType)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RelationList.
func (r RelationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Repo.
func (r Repo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "branches", r.Branches)
	populate(objectMap, "fullName", r.FullName)
	populate(objectMap, "url", r.URL)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RepoList.
func (r RepoList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Repository.
func (r Repository) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "branch", r.Branch)
	populate(objectMap, "deploymentLogsUrl", r.DeploymentLogsURL)
	populate(objectMap, "displayUrl", r.DisplayURL)
	populate(objectMap, "pathMapping", r.PathMapping)
	populate(objectMap, "url", r.URL)
	return json.Marshal(objectMap)
}

// GetAlertRule implements the AlertRuleClassification interface for type ScheduledAlertRule.
func (s *ScheduledAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       s.Kind,
		Etag:       s.Etag,
		ID:         s.ID,
		Name:       s.Name,
		Type:       s.Type,
		SystemData: s.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledAlertRule.
func (s ScheduledAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "id", s.ID)
	objectMap["kind"] = AlertRuleKindScheduled
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledAlertRule.
func (s *ScheduledAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledAlertRuleCommonProperties.
func (s ScheduledAlertRuleCommonProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", s.AlertDetailsOverride)
	populate(objectMap, "customDetails", s.CustomDetails)
	populate(objectMap, "entityMappings", s.EntityMappings)
	populate(objectMap, "eventGroupingSettings", s.EventGroupingSettings)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryFrequency", s.QueryFrequency)
	populate(objectMap, "queryPeriod", s.QueryPeriod)
	populate(objectMap, "severity", s.Severity)
	populate(objectMap, "triggerOperator", s.TriggerOperator)
	populate(objectMap, "triggerThreshold", s.TriggerThreshold)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledAlertRuleProperties.
func (s ScheduledAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", s.AlertDetailsOverride)
	populate(objectMap, "alertRuleTemplateName", s.AlertRuleTemplateName)
	populate(objectMap, "customDetails", s.CustomDetails)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "enabled", s.Enabled)
	populate(objectMap, "entityMappings", s.EntityMappings)
	populate(objectMap, "eventGroupingSettings", s.EventGroupingSettings)
	populate(objectMap, "incidentConfiguration", s.IncidentConfiguration)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", s.LastModifiedUTC)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryFrequency", s.QueryFrequency)
	populate(objectMap, "queryPeriod", s.QueryPeriod)
	populate(objectMap, "severity", s.Severity)
	populate(objectMap, "suppressionDuration", s.SuppressionDuration)
	populate(objectMap, "suppressionEnabled", s.SuppressionEnabled)
	populate(objectMap, "tactics", s.Tactics)
	populate(objectMap, "techniques", s.Techniques)
	populate(objectMap, "templateVersion", s.TemplateVersion)
	populate(objectMap, "triggerOperator", s.TriggerOperator)
	populate(objectMap, "triggerThreshold", s.TriggerThreshold)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledAlertRuleProperties.
func (s *ScheduledAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertDetailsOverride":
			err = unpopulate(val, &s.AlertDetailsOverride)
			delete(rawMsg, key)
		case "alertRuleTemplateName":
			err = unpopulate(val, &s.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "customDetails":
			err = unpopulate(val, &s.CustomDetails)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &s.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &s.Enabled)
			delete(rawMsg, key)
		case "entityMappings":
			err = unpopulate(val, &s.EntityMappings)
			delete(rawMsg, key)
		case "eventGroupingSettings":
			err = unpopulate(val, &s.EventGroupingSettings)
			delete(rawMsg, key)
		case "incidentConfiguration":
			err = unpopulate(val, &s.IncidentConfiguration)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedUTC)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryFrequency":
			err = unpopulate(val, &s.QueryFrequency)
			delete(rawMsg, key)
		case "queryPeriod":
			err = unpopulate(val, &s.QueryPeriod)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &s.Severity)
			delete(rawMsg, key)
		case "suppressionDuration":
			err = unpopulate(val, &s.SuppressionDuration)
			delete(rawMsg, key)
		case "suppressionEnabled":
			err = unpopulate(val, &s.SuppressionEnabled)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &s.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &s.Techniques)
			delete(rawMsg, key)
		case "templateVersion":
			err = unpopulate(val, &s.TemplateVersion)
			delete(rawMsg, key)
		case "triggerOperator":
			err = unpopulate(val, &s.TriggerOperator)
			delete(rawMsg, key)
		case "triggerThreshold":
			err = unpopulate(val, &s.TriggerThreshold)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type ScheduledAlertRuleTemplate.
func (s *ScheduledAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       s.Kind,
		ID:         s.ID,
		Name:       s.Name,
		Type:       s.Type,
		SystemData: s.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledAlertRuleTemplate.
func (s ScheduledAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	objectMap["kind"] = AlertRuleKindScheduled
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledAlertRuleTemplate.
func (s *ScheduledAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduledAlertRuleTemplateProperties.
func (s ScheduledAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertDetailsOverride", s.AlertDetailsOverride)
	populate(objectMap, "alertRulesCreatedByTemplateCount", s.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", s.CreatedDateUTC)
	populate(objectMap, "customDetails", s.CustomDetails)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "entityMappings", s.EntityMappings)
	populate(objectMap, "eventGroupingSettings", s.EventGroupingSettings)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", s.LastUpdatedDateUTC)
	populate(objectMap, "query", s.Query)
	populate(objectMap, "queryFrequency", s.QueryFrequency)
	populate(objectMap, "queryPeriod", s.QueryPeriod)
	populate(objectMap, "requiredDataConnectors", s.RequiredDataConnectors)
	populate(objectMap, "severity", s.Severity)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "tactics", s.Tactics)
	populate(objectMap, "techniques", s.Techniques)
	populate(objectMap, "triggerOperator", s.TriggerOperator)
	populate(objectMap, "triggerThreshold", s.TriggerThreshold)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduledAlertRuleTemplateProperties.
func (s *ScheduledAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertDetailsOverride":
			err = unpopulate(val, &s.AlertDetailsOverride)
			delete(rawMsg, key)
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &s.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &s.CreatedDateUTC)
			delete(rawMsg, key)
		case "customDetails":
			err = unpopulate(val, &s.CustomDetails)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &s.DisplayName)
			delete(rawMsg, key)
		case "entityMappings":
			err = unpopulate(val, &s.EntityMappings)
			delete(rawMsg, key)
		case "eventGroupingSettings":
			err = unpopulate(val, &s.EventGroupingSettings)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &s.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "query":
			err = unpopulate(val, &s.Query)
			delete(rawMsg, key)
		case "queryFrequency":
			err = unpopulate(val, &s.QueryFrequency)
			delete(rawMsg, key)
		case "queryPeriod":
			err = unpopulate(val, &s.QueryPeriod)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &s.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &s.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &s.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &s.Techniques)
			delete(rawMsg, key)
		case "triggerOperator":
			err = unpopulate(val, &s.TriggerOperator)
			delete(rawMsg, key)
		case "triggerThreshold":
			err = unpopulate(val, &s.TriggerThreshold)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type SecurityAlert.
func (s *SecurityAlert) GetEntity() *Entity {
	return &Entity{
		Kind:       s.Kind,
		ID:         s.ID,
		Name:       s.Name,
		Type:       s.Type,
		SystemData: s.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SecurityAlert.
func (s SecurityAlert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	objectMap["kind"] = EntityKindSecurityAlert
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityAlert.
func (s *SecurityAlert) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityAlertProperties.
func (s SecurityAlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", s.AdditionalData)
	populate(objectMap, "alertDisplayName", s.AlertDisplayName)
	populate(objectMap, "alertLink", s.AlertLink)
	populate(objectMap, "alertType", s.AlertType)
	populate(objectMap, "compromisedEntity", s.CompromisedEntity)
	populate(objectMap, "confidenceLevel", s.ConfidenceLevel)
	populate(objectMap, "confidenceReasons", s.ConfidenceReasons)
	populate(objectMap, "confidenceScore", s.ConfidenceScore)
	populate(objectMap, "confidenceScoreStatus", s.ConfidenceScoreStatus)
	populate(objectMap, "description", s.Description)
	populateTimeRFC3339(objectMap, "endTimeUtc", s.EndTimeUTC)
	populate(objectMap, "friendlyName", s.FriendlyName)
	populate(objectMap, "intent", s.Intent)
	populateTimeRFC3339(objectMap, "processingEndTime", s.ProcessingEndTime)
	populate(objectMap, "productComponentName", s.ProductComponentName)
	populate(objectMap, "productName", s.ProductName)
	populate(objectMap, "productVersion", s.ProductVersion)
	populate(objectMap, "providerAlertId", s.ProviderAlertID)
	populate(objectMap, "remediationSteps", s.RemediationSteps)
	populate(objectMap, "resourceIdentifiers", s.ResourceIdentifiers)
	populate(objectMap, "severity", s.Severity)
	populateTimeRFC3339(objectMap, "startTimeUtc", s.StartTimeUTC)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "systemAlertId", s.SystemAlertID)
	populate(objectMap, "tactics", s.Tactics)
	populateTimeRFC3339(objectMap, "timeGenerated", s.TimeGenerated)
	populate(objectMap, "vendorName", s.VendorName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityAlertProperties.
func (s *SecurityAlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &s.AdditionalData)
			delete(rawMsg, key)
		case "alertDisplayName":
			err = unpopulate(val, &s.AlertDisplayName)
			delete(rawMsg, key)
		case "alertLink":
			err = unpopulate(val, &s.AlertLink)
			delete(rawMsg, key)
		case "alertType":
			err = unpopulate(val, &s.AlertType)
			delete(rawMsg, key)
		case "compromisedEntity":
			err = unpopulate(val, &s.CompromisedEntity)
			delete(rawMsg, key)
		case "confidenceLevel":
			err = unpopulate(val, &s.ConfidenceLevel)
			delete(rawMsg, key)
		case "confidenceReasons":
			err = unpopulate(val, &s.ConfidenceReasons)
			delete(rawMsg, key)
		case "confidenceScore":
			err = unpopulate(val, &s.ConfidenceScore)
			delete(rawMsg, key)
		case "confidenceScoreStatus":
			err = unpopulate(val, &s.ConfidenceScoreStatus)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, &s.EndTimeUTC)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &s.FriendlyName)
			delete(rawMsg, key)
		case "intent":
			err = unpopulate(val, &s.Intent)
			delete(rawMsg, key)
		case "processingEndTime":
			err = unpopulateTimeRFC3339(val, &s.ProcessingEndTime)
			delete(rawMsg, key)
		case "productComponentName":
			err = unpopulate(val, &s.ProductComponentName)
			delete(rawMsg, key)
		case "productName":
			err = unpopulate(val, &s.ProductName)
			delete(rawMsg, key)
		case "productVersion":
			err = unpopulate(val, &s.ProductVersion)
			delete(rawMsg, key)
		case "providerAlertId":
			err = unpopulate(val, &s.ProviderAlertID)
			delete(rawMsg, key)
		case "remediationSteps":
			err = unpopulate(val, &s.RemediationSteps)
			delete(rawMsg, key)
		case "resourceIdentifiers":
			err = unpopulate(val, &s.ResourceIdentifiers)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &s.Severity)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateTimeRFC3339(val, &s.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "systemAlertId":
			err = unpopulate(val, &s.SystemAlertID)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &s.Tactics)
			delete(rawMsg, key)
		case "timeGenerated":
			err = unpopulateTimeRFC3339(val, &s.TimeGenerated)
			delete(rawMsg, key)
		case "vendorName":
			err = unpopulate(val, &s.VendorName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntityTimelineItem implements the EntityTimelineItemClassification interface for type SecurityAlertTimelineItem.
func (s *SecurityAlertTimelineItem) GetEntityTimelineItem() *EntityTimelineItem {
	return &EntityTimelineItem{
		Kind: s.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SecurityAlertTimelineItem.
func (s SecurityAlertTimelineItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertType", s.AlertType)
	populate(objectMap, "azureResourceId", s.AzureResourceID)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populateTimeRFC3339(objectMap, "endTimeUtc", s.EndTimeUTC)
	objectMap["kind"] = EntityTimelineKindSecurityAlert
	populate(objectMap, "productName", s.ProductName)
	populate(objectMap, "severity", s.Severity)
	populateTimeRFC3339(objectMap, "startTimeUtc", s.StartTimeUTC)
	populateTimeRFC3339(objectMap, "timeGenerated", s.TimeGenerated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityAlertTimelineItem.
func (s *SecurityAlertTimelineItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertType":
			err = unpopulate(val, &s.AlertType)
			delete(rawMsg, key)
		case "azureResourceId":
			err = unpopulate(val, &s.AzureResourceID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &s.DisplayName)
			delete(rawMsg, key)
		case "endTimeUtc":
			err = unpopulateTimeRFC3339(val, &s.EndTimeUTC)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "productName":
			err = unpopulate(val, &s.ProductName)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &s.Severity)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulateTimeRFC3339(val, &s.StartTimeUTC)
			delete(rawMsg, key)
		case "timeGenerated":
			err = unpopulateTimeRFC3339(val, &s.TimeGenerated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetEntity implements the EntityClassification interface for type SecurityGroupEntity.
func (s *SecurityGroupEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       s.Kind,
		ID:         s.ID,
		Name:       s.Name,
		Type:       s.Type,
		SystemData: s.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SecurityGroupEntity.
func (s SecurityGroupEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	objectMap["kind"] = EntityKindSecurityGroup
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityGroupEntity.
func (s *SecurityGroupEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityGroupEntityProperties.
func (s SecurityGroupEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", s.AdditionalData)
	populate(objectMap, "distinguishedName", s.DistinguishedName)
	populate(objectMap, "friendlyName", s.FriendlyName)
	populate(objectMap, "objectGuid", s.ObjectGUID)
	populate(objectMap, "sid", s.Sid)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SentinelOnboardingStatesList.
func (s SentinelOnboardingStatesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SettingList.
func (s SettingList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SettingList.
func (s *SettingList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			s.Value, err = unmarshalSettingsClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSettings implements the SettingsClassification interface for type Settings.
func (s *Settings) GetSettings() *Settings { return s }

// MarshalJSON implements the json.Marshaller interface for type SourceControlList.
func (s SourceControlList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SourceControlProperties.
func (s SourceControlProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentTypes", s.ContentTypes)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "lastDeploymentInfo", s.LastDeploymentInfo)
	populate(objectMap, "repoType", s.RepoType)
	populate(objectMap, "repository", s.Repository)
	populate(objectMap, "repositoryResourceInfo", s.RepositoryResourceInfo)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type SubmissionMailEntity.
func (s *SubmissionMailEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       s.Kind,
		ID:         s.ID,
		Name:       s.Name,
		Type:       s.Type,
		SystemData: s.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SubmissionMailEntity.
func (s SubmissionMailEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	objectMap["kind"] = EntityKindSubmissionMail
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubmissionMailEntity.
func (s *SubmissionMailEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubmissionMailEntityProperties.
func (s SubmissionMailEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", s.AdditionalData)
	populate(objectMap, "friendlyName", s.FriendlyName)
	populate(objectMap, "networkMessageId", s.NetworkMessageID)
	populate(objectMap, "recipient", s.Recipient)
	populate(objectMap, "reportType", s.ReportType)
	populate(objectMap, "sender", s.Sender)
	populate(objectMap, "senderIp", s.SenderIP)
	populate(objectMap, "subject", s.Subject)
	populateTimeRFC3339(objectMap, "submissionDate", s.SubmissionDate)
	populate(objectMap, "submissionId", s.SubmissionID)
	populate(objectMap, "submitter", s.Submitter)
	populateTimeRFC3339(objectMap, "timestamp", s.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubmissionMailEntityProperties.
func (s *SubmissionMailEntityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalData":
			err = unpopulate(val, &s.AdditionalData)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &s.FriendlyName)
			delete(rawMsg, key)
		case "networkMessageId":
			err = unpopulate(val, &s.NetworkMessageID)
			delete(rawMsg, key)
		case "recipient":
			err = unpopulate(val, &s.Recipient)
			delete(rawMsg, key)
		case "reportType":
			err = unpopulate(val, &s.ReportType)
			delete(rawMsg, key)
		case "sender":
			err = unpopulate(val, &s.Sender)
			delete(rawMsg, key)
		case "senderIp":
			err = unpopulate(val, &s.SenderIP)
			delete(rawMsg, key)
		case "subject":
			err = unpopulate(val, &s.Subject)
			delete(rawMsg, key)
		case "submissionDate":
			err = unpopulateTimeRFC3339(val, &s.SubmissionDate)
			delete(rawMsg, key)
		case "submissionId":
			err = unpopulate(val, &s.SubmissionID)
			delete(rawMsg, key)
		case "submitter":
			err = unpopulate(val, &s.Submitter)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &s.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type TICheckRequirements.
func (t *TICheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: t.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TICheckRequirements.
func (t TICheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindThreatIntelligence
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TICheckRequirements.
func (t *TICheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type TIDataConnector.
func (t *TIDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       t.Kind,
		Etag:       t.Etag,
		ID:         t.ID,
		Name:       t.Name,
		Type:       t.Type,
		SystemData: t.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TIDataConnector.
func (t TIDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	objectMap["kind"] = DataConnectorKindThreatIntelligence
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TIDataConnector.
func (t *TIDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TIDataConnectorProperties.
func (t TIDataConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataTypes", t.DataTypes)
	populate(objectMap, "tenantId", t.TenantID)
	populateTimeRFC3339(objectMap, "tipLookbackPeriod", t.TipLookbackPeriod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TIDataConnectorProperties.
func (t *TIDataConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataTypes":
			err = unpopulate(val, &t.DataTypes)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &t.TenantID)
			delete(rawMsg, key)
		case "tipLookbackPeriod":
			err = unpopulateTimeRFC3339(val, &t.TipLookbackPeriod)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeamInformation.
func (t TeamInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "primaryChannelUrl", t.PrimaryChannelURL)
	populateTimeRFC3339(objectMap, "teamCreationTimeUtc", t.TeamCreationTimeUTC)
	populate(objectMap, "teamId", t.TeamID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeamInformation.
func (t *TeamInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "primaryChannelUrl":
			err = unpopulate(val, &t.PrimaryChannelURL)
			delete(rawMsg, key)
		case "teamCreationTimeUtc":
			err = unpopulateTimeRFC3339(val, &t.TeamCreationTimeUTC)
			delete(rawMsg, key)
		case "teamId":
			err = unpopulate(val, &t.TeamID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TeamProperties.
func (t TeamProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupIds", t.GroupIDs)
	populate(objectMap, "memberIds", t.MemberIDs)
	populate(objectMap, "teamDescription", t.TeamDescription)
	populate(objectMap, "teamName", t.TeamName)
	return json.Marshal(objectMap)
}

// GetAlertRule implements the AlertRuleClassification interface for type ThreatIntelligenceAlertRule.
func (t *ThreatIntelligenceAlertRule) GetAlertRule() *AlertRule {
	return &AlertRule{
		Kind:       t.Kind,
		Etag:       t.Etag,
		ID:         t.ID,
		Name:       t.Name,
		Type:       t.Type,
		SystemData: t.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceAlertRule.
func (t ThreatIntelligenceAlertRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	objectMap["kind"] = AlertRuleKindThreatIntelligence
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceAlertRule.
func (t *ThreatIntelligenceAlertRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceAlertRuleProperties.
func (t ThreatIntelligenceAlertRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRuleTemplateName", t.AlertRuleTemplateName)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "enabled", t.Enabled)
	populateTimeRFC3339(objectMap, "lastModifiedUtc", t.LastModifiedUTC)
	populate(objectMap, "severity", t.Severity)
	populate(objectMap, "tactics", t.Tactics)
	populate(objectMap, "techniques", t.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceAlertRuleProperties.
func (t *ThreatIntelligenceAlertRuleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRuleTemplateName":
			err = unpopulate(val, &t.AlertRuleTemplateName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &t.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &t.Enabled)
			delete(rawMsg, key)
		case "lastModifiedUtc":
			err = unpopulateTimeRFC3339(val, &t.LastModifiedUTC)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &t.Severity)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &t.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &t.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetAlertRuleTemplate implements the AlertRuleTemplateClassification interface for type ThreatIntelligenceAlertRuleTemplate.
func (t *ThreatIntelligenceAlertRuleTemplate) GetAlertRuleTemplate() *AlertRuleTemplate {
	return &AlertRuleTemplate{
		Kind:       t.Kind,
		ID:         t.ID,
		Name:       t.Name,
		Type:       t.Type,
		SystemData: t.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceAlertRuleTemplate.
func (t ThreatIntelligenceAlertRuleTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	objectMap["kind"] = AlertRuleKindThreatIntelligence
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceAlertRuleTemplate.
func (t *ThreatIntelligenceAlertRuleTemplate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceAlertRuleTemplateProperties.
func (t ThreatIntelligenceAlertRuleTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertRulesCreatedByTemplateCount", t.AlertRulesCreatedByTemplateCount)
	populateTimeRFC3339(objectMap, "createdDateUTC", t.CreatedDateUTC)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populateTimeRFC3339(objectMap, "lastUpdatedDateUTC", t.LastUpdatedDateUTC)
	populate(objectMap, "requiredDataConnectors", t.RequiredDataConnectors)
	populate(objectMap, "severity", t.Severity)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "tactics", t.Tactics)
	populate(objectMap, "techniques", t.Techniques)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceAlertRuleTemplateProperties.
func (t *ThreatIntelligenceAlertRuleTemplateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertRulesCreatedByTemplateCount":
			err = unpopulate(val, &t.AlertRulesCreatedByTemplateCount)
			delete(rawMsg, key)
		case "createdDateUTC":
			err = unpopulateTimeRFC3339(val, &t.CreatedDateUTC)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &t.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &t.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedDateUTC":
			err = unpopulateTimeRFC3339(val, &t.LastUpdatedDateUTC)
			delete(rawMsg, key)
		case "requiredDataConnectors":
			err = unpopulate(val, &t.RequiredDataConnectors)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &t.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &t.Status)
			delete(rawMsg, key)
		case "tactics":
			err = unpopulate(val, &t.Tactics)
			delete(rawMsg, key)
		case "techniques":
			err = unpopulate(val, &t.Techniques)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceAppendTags.
func (t ThreatIntelligenceAppendTags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "threatIntelligenceTags", t.ThreatIntelligenceTags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceExternalReference.
func (t ThreatIntelligenceExternalReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", t.Description)
	populate(objectMap, "externalId", t.ExternalID)
	populate(objectMap, "hashes", t.Hashes)
	populate(objectMap, "sourceName", t.SourceName)
	populate(objectMap, "url", t.URL)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceFilteringCriteria.
func (t ThreatIntelligenceFilteringCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ids", t.IDs)
	populate(objectMap, "includeDisabled", t.IncludeDisabled)
	populate(objectMap, "keywords", t.Keywords)
	populate(objectMap, "maxConfidence", t.MaxConfidence)
	populate(objectMap, "maxValidUntil", t.MaxValidUntil)
	populate(objectMap, "minConfidence", t.MinConfidence)
	populate(objectMap, "minValidUntil", t.MinValidUntil)
	populate(objectMap, "pageSize", t.PageSize)
	populate(objectMap, "patternTypes", t.PatternTypes)
	populate(objectMap, "skipToken", t.SkipToken)
	populate(objectMap, "sortBy", t.SortBy)
	populate(objectMap, "sources", t.Sources)
	populate(objectMap, "threatTypes", t.ThreatTypes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceGranularMarkingModel.
func (t ThreatIntelligenceGranularMarkingModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "language", t.Language)
	populate(objectMap, "markingRef", t.MarkingRef)
	populate(objectMap, "selectors", t.Selectors)
	return json.Marshal(objectMap)
}

// GetThreatIntelligenceInformation implements the ThreatIntelligenceInformationClassification interface for type ThreatIntelligenceIndicatorModel.
func (t *ThreatIntelligenceIndicatorModel) GetThreatIntelligenceInformation() *ThreatIntelligenceInformation {
	return &ThreatIntelligenceInformation{
		Kind:       t.Kind,
		Etag:       t.Etag,
		ID:         t.ID,
		Name:       t.Name,
		Type:       t.Type,
		SystemData: t.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceIndicatorModel.
func (t ThreatIntelligenceIndicatorModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	objectMap["kind"] = ThreatIntelligenceResourceKindEnumIndicator
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceIndicatorModel.
func (t *ThreatIntelligenceIndicatorModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceIndicatorProperties.
func (t ThreatIntelligenceIndicatorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", t.AdditionalData)
	populate(objectMap, "confidence", t.Confidence)
	populate(objectMap, "created", t.Created)
	populate(objectMap, "createdByRef", t.CreatedByRef)
	populate(objectMap, "defanged", t.Defanged)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "extensions", t.Extensions)
	populate(objectMap, "externalId", t.ExternalID)
	populate(objectMap, "externalLastUpdatedTimeUtc", t.ExternalLastUpdatedTimeUTC)
	populate(objectMap, "externalReferences", t.ExternalReferences)
	populate(objectMap, "friendlyName", t.FriendlyName)
	populate(objectMap, "granularMarkings", t.GranularMarkings)
	populate(objectMap, "indicatorTypes", t.IndicatorTypes)
	populate(objectMap, "killChainPhases", t.KillChainPhases)
	populate(objectMap, "labels", t.Labels)
	populate(objectMap, "language", t.Language)
	populate(objectMap, "lastUpdatedTimeUtc", t.LastUpdatedTimeUTC)
	populate(objectMap, "modified", t.Modified)
	populate(objectMap, "objectMarkingRefs", t.ObjectMarkingRefs)
	populate(objectMap, "parsedPattern", t.ParsedPattern)
	populate(objectMap, "pattern", t.Pattern)
	populate(objectMap, "patternType", t.PatternType)
	populate(objectMap, "patternVersion", t.PatternVersion)
	populate(objectMap, "revoked", t.Revoked)
	populate(objectMap, "source", t.Source)
	populate(objectMap, "threatIntelligenceTags", t.ThreatIntelligenceTags)
	populate(objectMap, "threatTypes", t.ThreatTypes)
	populate(objectMap, "validFrom", t.ValidFrom)
	populate(objectMap, "validUntil", t.ValidUntil)
	return json.Marshal(objectMap)
}

// GetThreatIntelligenceInformation implements the ThreatIntelligenceInformationClassification interface for type ThreatIntelligenceInformation.
func (t *ThreatIntelligenceInformation) GetThreatIntelligenceInformation() *ThreatIntelligenceInformation {
	return t
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceInformationList.
func (t ThreatIntelligenceInformationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ThreatIntelligenceInformationList.
func (t *ThreatIntelligenceInformationList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &t.NextLink)
			delete(rawMsg, key)
		case "value":
			t.Value, err = unmarshalThreatIntelligenceInformationClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceMetric.
func (t ThreatIntelligenceMetric) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "lastUpdatedTimeUtc", t.LastUpdatedTimeUTC)
	populate(objectMap, "patternTypeMetrics", t.PatternTypeMetrics)
	populate(objectMap, "sourceMetrics", t.SourceMetrics)
	populate(objectMap, "threatTypeMetrics", t.ThreatTypeMetrics)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceMetricsList.
func (t ThreatIntelligenceMetricsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ThreatIntelligenceParsedPattern.
func (t ThreatIntelligenceParsedPattern) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "patternTypeKey", t.PatternTypeKey)
	populate(objectMap, "patternTypeValues", t.PatternTypeValues)
	return json.Marshal(objectMap)
}

// GetDataConnectorsCheckRequirements implements the DataConnectorsCheckRequirementsClassification interface for type TiTaxiiCheckRequirements.
func (t *TiTaxiiCheckRequirements) GetDataConnectorsCheckRequirements() *DataConnectorsCheckRequirements {
	return &DataConnectorsCheckRequirements{
		Kind: t.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TiTaxiiCheckRequirements.
func (t TiTaxiiCheckRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = DataConnectorKindThreatIntelligenceTaxii
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TiTaxiiCheckRequirements.
func (t *TiTaxiiCheckRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetDataConnector implements the DataConnectorClassification interface for type TiTaxiiDataConnector.
func (t *TiTaxiiDataConnector) GetDataConnector() *DataConnector {
	return &DataConnector{
		Kind:       t.Kind,
		Etag:       t.Etag,
		ID:         t.ID,
		Name:       t.Name,
		Type:       t.Type,
		SystemData: t.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TiTaxiiDataConnector.
func (t TiTaxiiDataConnector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	objectMap["kind"] = DataConnectorKindThreatIntelligenceTaxii
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TiTaxiiDataConnector.
func (t *TiTaxiiDataConnector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &t.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &t.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &t.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &t.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TiTaxiiDataConnectorProperties.
func (t TiTaxiiDataConnectorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collectionId", t.CollectionID)
	populate(objectMap, "dataTypes", t.DataTypes)
	populate(objectMap, "friendlyName", t.FriendlyName)
	populate(objectMap, "password", t.Password)
	populate(objectMap, "pollingFrequency", t.PollingFrequency)
	populateTimeRFC3339(objectMap, "taxiiLookbackPeriod", t.TaxiiLookbackPeriod)
	populate(objectMap, "taxiiServer", t.TaxiiServer)
	populate(objectMap, "tenantId", t.TenantID)
	populate(objectMap, "userName", t.UserName)
	populate(objectMap, "workspaceId", t.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TiTaxiiDataConnectorProperties.
func (t *TiTaxiiDataConnectorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionId":
			err = unpopulate(val, &t.CollectionID)
			delete(rawMsg, key)
		case "dataTypes":
			err = unpopulate(val, &t.DataTypes)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &t.FriendlyName)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &t.Password)
			delete(rawMsg, key)
		case "pollingFrequency":
			err = unpopulate(val, &t.PollingFrequency)
			delete(rawMsg, key)
		case "taxiiLookbackPeriod":
			err = unpopulateTimeRFC3339(val, &t.TaxiiLookbackPeriod)
			delete(rawMsg, key)
		case "taxiiServer":
			err = unpopulate(val, &t.TaxiiServer)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &t.TenantID)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &t.UserName)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, &t.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TimelineResultsMetadata.
func (t TimelineResultsMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregations", t.Aggregations)
	populate(objectMap, "errors", t.Errors)
	populate(objectMap, "totalCount", t.TotalCount)
	return json.Marshal(objectMap)
}

// GetEntity implements the EntityClassification interface for type URLEntity.
func (u *URLEntity) GetEntity() *Entity {
	return &Entity{
		Kind:       u.Kind,
		ID:         u.ID,
		Name:       u.Name,
		Type:       u.Type,
		SystemData: u.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type URLEntity.
func (u URLEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", u.ID)
	objectMap["kind"] = EntityKindURL
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type URLEntity.
func (u *URLEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &u.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &u.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type URLEntityProperties.
func (u URLEntityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", u.AdditionalData)
	populate(objectMap, "friendlyName", u.FriendlyName)
	populate(objectMap, "url", u.URL)
	return json.Marshal(objectMap)
}

// GetSettings implements the SettingsClassification interface for type Ueba.
func (u *Ueba) GetSettings() *Settings {
	return &Settings{
		Kind:       u.Kind,
		Etag:       u.Etag,
		ID:         u.ID,
		Name:       u.Name,
		Type:       u.Type,
		SystemData: u.SystemData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Ueba.
func (u Ueba) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", u.Etag)
	populate(objectMap, "id", u.ID)
	objectMap["kind"] = SettingKindUeba
	populate(objectMap, "name", u.Name)
	populate(objectMap, "properties", u.Properties)
	populate(objectMap, "systemData", u.SystemData)
	populate(objectMap, "type", u.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Ueba.
func (u *Ueba) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &u.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &u.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &u.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &u.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &u.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &u.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UebaProperties.
func (u UebaProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSources", u.DataSources)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WatchlistItemList.
func (w WatchlistItemList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WatchlistItemProperties.
func (w WatchlistItemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "created", w.Created)
	populate(objectMap, "createdBy", w.CreatedBy)
	populate(objectMap, "entityMapping", w.EntityMapping)
	populate(objectMap, "isDeleted", w.IsDeleted)
	populate(objectMap, "itemsKeyValue", w.ItemsKeyValue)
	populate(objectMap, "tenantId", w.TenantID)
	populateTimeRFC3339(objectMap, "updated", w.Updated)
	populate(objectMap, "updatedBy", w.UpdatedBy)
	populate(objectMap, "watchlistItemId", w.WatchlistItemID)
	populate(objectMap, "watchlistItemType", w.WatchlistItemType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WatchlistItemProperties.
func (w *WatchlistItemProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeRFC3339(val, &w.Created)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &w.CreatedBy)
			delete(rawMsg, key)
		case "entityMapping":
			err = unpopulate(val, &w.EntityMapping)
			delete(rawMsg, key)
		case "isDeleted":
			err = unpopulate(val, &w.IsDeleted)
			delete(rawMsg, key)
		case "itemsKeyValue":
			err = unpopulate(val, &w.ItemsKeyValue)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &w.TenantID)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeRFC3339(val, &w.Updated)
			delete(rawMsg, key)
		case "updatedBy":
			err = unpopulate(val, &w.UpdatedBy)
			delete(rawMsg, key)
		case "watchlistItemId":
			err = unpopulate(val, &w.WatchlistItemID)
			delete(rawMsg, key)
		case "watchlistItemType":
			err = unpopulate(val, &w.WatchlistItemType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WatchlistList.
func (w WatchlistList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type WatchlistProperties.
func (w WatchlistProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", w.ContentType)
	populateTimeRFC3339(objectMap, "created", w.Created)
	populate(objectMap, "createdBy", w.CreatedBy)
	populate(objectMap, "defaultDuration", w.DefaultDuration)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "isDeleted", w.IsDeleted)
	populate(objectMap, "itemsSearchKey", w.ItemsSearchKey)
	populate(objectMap, "labels", w.Labels)
	populate(objectMap, "numberOfLinesToSkip", w.NumberOfLinesToSkip)
	populate(objectMap, "provider", w.Provider)
	populate(objectMap, "rawContent", w.RawContent)
	populate(objectMap, "source", w.Source)
	populate(objectMap, "sourceType", w.SourceType)
	populate(objectMap, "tenantId", w.TenantID)
	populateTimeRFC3339(objectMap, "updated", w.Updated)
	populate(objectMap, "updatedBy", w.UpdatedBy)
	populate(objectMap, "uploadStatus", w.UploadStatus)
	populate(objectMap, "watchlistAlias", w.WatchlistAlias)
	populate(objectMap, "watchlistId", w.WatchlistID)
	populate(objectMap, "watchlistType", w.WatchlistType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WatchlistProperties.
func (w *WatchlistProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentType":
			err = unpopulate(val, &w.ContentType)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &w.Created)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &w.CreatedBy)
			delete(rawMsg, key)
		case "defaultDuration":
			err = unpopulate(val, &w.DefaultDuration)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &w.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &w.DisplayName)
			delete(rawMsg, key)
		case "isDeleted":
			err = unpopulate(val, &w.IsDeleted)
			delete(rawMsg, key)
		case "itemsSearchKey":
			err = unpopulate(val, &w.ItemsSearchKey)
			delete(rawMsg, key)
		case "labels":
			err = unpopulate(val, &w.Labels)
			delete(rawMsg, key)
		case "numberOfLinesToSkip":
			err = unpopulate(val, &w.NumberOfLinesToSkip)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, &w.Provider)
			delete(rawMsg, key)
		case "rawContent":
			err = unpopulate(val, &w.RawContent)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &w.Source)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, &w.SourceType)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &w.TenantID)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeRFC3339(val, &w.Updated)
			delete(rawMsg, key)
		case "updatedBy":
			err = unpopulate(val, &w.UpdatedBy)
			delete(rawMsg, key)
		case "uploadStatus":
			err = unpopulate(val, &w.UploadStatus)
			delete(rawMsg, key)
		case "watchlistAlias":
			err = unpopulate(val, &w.WatchlistAlias)
			delete(rawMsg, key)
		case "watchlistId":
			err = unpopulate(val, &w.WatchlistID)
			delete(rawMsg, key)
		case "watchlistType":
			err = unpopulate(val, &w.WatchlistType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
