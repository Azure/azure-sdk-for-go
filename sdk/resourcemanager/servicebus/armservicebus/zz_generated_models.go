//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicebus

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccessKeys - Namespace/ServiceBus Connection String
type AccessKeys struct {
	// READ-ONLY; Primary connection string of the alias if GEO DR is enabled
	AliasPrimaryConnectionString *string `json:"aliasPrimaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; Secondary connection string of the alias if GEO DR is enabled
	AliasSecondaryConnectionString *string `json:"aliasSecondaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A string that describes the authorization rule.
	KeyName *string `json:"keyName,omitempty" azure:"ro"`

	// READ-ONLY; Primary connection string of the created namespace authorization rule.
	PrimaryConnectionString *string `json:"primaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A base64-encoded 256-bit primary key for signing and validating the SAS token.
	PrimaryKey *string `json:"primaryKey,omitempty" azure:"ro"`

	// READ-ONLY; Secondary connection string of the created namespace authorization rule.
	SecondaryConnectionString *string `json:"secondaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A base64-encoded 256-bit primary key for signing and validating the SAS token.
	SecondaryKey *string `json:"secondaryKey,omitempty" azure:"ro"`
}

// Action - Represents the filter actions which are allowed for the transformation of a message that have been matched by
// a filter expression.
type Action struct {
	// This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
	CompatibilityLevel *int32 `json:"compatibilityLevel,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// SQL expression. e.g. MyProperty='ABC'
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// ArmDisasterRecovery - Single item in List or Get Alias(Disaster Recovery configuration) operation
type ArmDisasterRecovery struct {
	// Properties required to the Create Or Update Alias(Disaster Recovery configurations)
	Properties *ArmDisasterRecoveryProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ArmDisasterRecoveryListResult - The result of the List Alias(Disaster Recovery configuration) operation.
type ArmDisasterRecoveryListResult struct {
	// List of Alias(Disaster Recovery configurations)
	Value []*ArmDisasterRecovery `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of Alias(Disaster Recovery configuration)
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmDisasterRecoveryListResult.
func (a ArmDisasterRecoveryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ArmDisasterRecoveryProperties - Properties required to the Create Or Update Alias(Disaster Recovery configurations)
type ArmDisasterRecoveryProperties struct {
	// Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
	AlternateName *string `json:"alternateName,omitempty"`

	// ARM Id of the Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
	PartnerNamespace *string `json:"partnerNamespace,omitempty"`

	// READ-ONLY; Number of entities pending to be replicated.
	PendingReplicationOperationsCount *int64 `json:"pendingReplicationOperationsCount,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the Alias(Disaster Recovery configuration) - possible values 'Accepted' or 'Succeeded'
	// or 'Failed'
	ProvisioningState *ProvisioningStateDR `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; role of namespace in GEO DR - possible values 'Primary' or 'PrimaryNotReplicating' or 'Secondary'
	Role *RoleDisasterRecovery `json:"role,omitempty" azure:"ro"`
}

// CheckNameAvailability - Description of a Check Name availability request properties.
type CheckNameAvailability struct {
	// REQUIRED; The Name to check the namespace name availability and The namespace name can contain only letters, numbers, and
	// hyphens. The namespace must start with a letter, and it must end with a letter or
	// number.
	Name *string `json:"name,omitempty"`
}

// CheckNameAvailabilityResult - Description of a Check Name availability request properties.
type CheckNameAvailabilityResult struct {
	// Value indicating namespace is availability, true if the namespace is available; otherwise, false.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason for unavailability of a namespace.
	Reason *UnavailableReason `json:"reason,omitempty"`

	// READ-ONLY; The detailed info regarding the reason associated with the namespace.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ConnectionState information.
type ConnectionState struct {
	// Description of the connection state.
	Description *string `json:"description,omitempty"`

	// Status of the connection.
	Status *PrivateLinkConnectionStatus `json:"status,omitempty"`
}

// CorrelationFilter - Represents the correlation filter expression.
type CorrelationFilter struct {
	// Content type of the message.
	ContentType *string `json:"contentType,omitempty"`

	// Identifier of the correlation.
	CorrelationID *string `json:"correlationId,omitempty"`

	// Application specific label.
	Label *string `json:"label,omitempty"`

	// Identifier of the message.
	MessageID *string `json:"messageId,omitempty"`

	// dictionary object for custom filters
	Properties map[string]*string `json:"properties,omitempty"`

	// Address of the queue to reply to.
	ReplyTo *string `json:"replyTo,omitempty"`

	// Session identifier to reply to.
	ReplyToSessionID *string `json:"replyToSessionId,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// Session identifier.
	SessionID *string `json:"sessionId,omitempty"`

	// Address to send to.
	To *string `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CorrelationFilter.
func (c CorrelationFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "correlationId", c.CorrelationID)
	populate(objectMap, "label", c.Label)
	populate(objectMap, "messageId", c.MessageID)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "replyTo", c.ReplyTo)
	populate(objectMap, "replyToSessionId", c.ReplyToSessionID)
	populate(objectMap, "requiresPreprocessing", c.RequiresPreprocessing)
	populate(objectMap, "sessionId", c.SessionID)
	populate(objectMap, "to", c.To)
	return json.Marshal(objectMap)
}

// DisasterRecoveryConfigsClientBreakPairingOptions contains the optional parameters for the DisasterRecoveryConfigsClient.BreakPairing
// method.
type DisasterRecoveryConfigsClientBreakPairingOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientCheckNameAvailabilityOptions contains the optional parameters for the DisasterRecoveryConfigsClient.CheckNameAvailability
// method.
type DisasterRecoveryConfigsClientCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientCreateOrUpdateOptions contains the optional parameters for the DisasterRecoveryConfigsClient.CreateOrUpdate
// method.
type DisasterRecoveryConfigsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientDeleteOptions contains the optional parameters for the DisasterRecoveryConfigsClient.Delete
// method.
type DisasterRecoveryConfigsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientFailOverOptions contains the optional parameters for the DisasterRecoveryConfigsClient.FailOver
// method.
type DisasterRecoveryConfigsClientFailOverOptions struct {
	// Parameters required to create an Alias(Disaster Recovery configuration)
	Parameters *FailoverProperties
}

// DisasterRecoveryConfigsClientGetAuthorizationRuleOptions contains the optional parameters for the DisasterRecoveryConfigsClient.GetAuthorizationRule
// method.
type DisasterRecoveryConfigsClientGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientGetOptions contains the optional parameters for the DisasterRecoveryConfigsClient.Get method.
type DisasterRecoveryConfigsClientGetOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientListAuthorizationRulesOptions contains the optional parameters for the DisasterRecoveryConfigsClient.ListAuthorizationRules
// method.
type DisasterRecoveryConfigsClientListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientListKeysOptions contains the optional parameters for the DisasterRecoveryConfigsClient.ListKeys
// method.
type DisasterRecoveryConfigsClientListKeysOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsClientListOptions contains the optional parameters for the DisasterRecoveryConfigsClient.List method.
type DisasterRecoveryConfigsClientListOptions struct {
	// placeholder for future optional parameters
}

// Encryption - Properties to configure Encryption
type Encryption struct {
	// Enumerates the possible value of keySource for Encryption
	KeySource *string `json:"keySource,omitempty"`

	// Properties of KeyVault
	KeyVaultProperties []*KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// Enable Infrastructure Encryption (Double Encryption)
	RequireInfrastructureEncryption *bool `json:"requireInfrastructureEncryption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Encryption.
func (e Encryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keySource", e.KeySource)
	populate(objectMap, "keyVaultProperties", e.KeyVaultProperties)
	populate(objectMap, "requireInfrastructureEncryption", e.RequireInfrastructureEncryption)
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorResponse - The resource management error response.
type ErrorResponse struct {
	// The error object.
	Error *ErrorResponseError `json:"error,omitempty"`
}

// ErrorResponseError - The error object.
type ErrorResponseError struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorResponse `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseError.
func (e ErrorResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// FailoverProperties - Safe failover is to indicate the service should wait for pending replication to finish before switching
// to the secondary.
type FailoverProperties struct {
	// Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
	Properties *FailoverPropertiesProperties `json:"properties,omitempty"`
}

// FailoverPropertiesProperties - Safe failover is to indicate the service should wait for pending replication to finish before
// switching to the secondary.
type FailoverPropertiesProperties struct {
	// Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
	IsSafeFailover *bool `json:"IsSafeFailover,omitempty"`
}

// Identity - Properties to configure User Assigned Identities for Bring your Own Keys
type Identity struct {
	// Type of managed service identity.
	Type *ManagedServiceIdentityType `json:"type,omitempty"`

	// Properties for User Assigned Identities
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; ObjectId from the KeyVault
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; TenantId from the KeyVault
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// KeyVaultProperties - Properties to configure keyVault Properties
type KeyVaultProperties struct {
	Identity *UserAssignedIdentityProperties `json:"identity,omitempty"`

	// Name of the Key from KeyVault
	KeyName *string `json:"keyName,omitempty"`

	// Uri of KeyVault
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`

	// Version of KeyVault
	KeyVersion *string `json:"keyVersion,omitempty"`
}

// MessageCountDetails - Message Count Details.
type MessageCountDetails struct {
	// READ-ONLY; Number of active messages in the queue, topic, or subscription.
	ActiveMessageCount *int64 `json:"activeMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages that are dead lettered.
	DeadLetterMessageCount *int64 `json:"deadLetterMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of scheduled messages.
	ScheduledMessageCount *int64 `json:"scheduledMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages transferred into dead letters.
	TransferDeadLetterMessageCount *int64 `json:"transferDeadLetterMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages transferred to another queue, topic, or subscription.
	TransferMessageCount *int64 `json:"transferMessageCount,omitempty" azure:"ro"`
}

// MigrationConfigListResult - The result of the List migrationConfigurations operation.
type MigrationConfigListResult struct {
	// List of Migration Configs
	Value []*MigrationConfigProperties `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of migrationConfigurations
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationConfigListResult.
func (m MigrationConfigListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MigrationConfigProperties - Single item in List or Get Migration Config operation
type MigrationConfigProperties struct {
	// Properties required to the Create Migration Configuration
	Properties *MigrationConfigPropertiesProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MigrationConfigPropertiesProperties - Properties required to the Create Migration Configuration
type MigrationConfigPropertiesProperties struct {
	// REQUIRED; Name to access Standard Namespace after migration
	PostMigrationName *string `json:"postMigrationName,omitempty"`

	// REQUIRED; Existing premium Namespace ARM Id name which has no entities, will be used for migration
	TargetNamespace *string `json:"targetNamespace,omitempty"`

	// READ-ONLY; State in which Standard to Premium Migration is, possible values : Unknown, Reverting, Completing, Initiating,
	// Syncing, Active
	MigrationState *string `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Number of entities pending to be replicated.
	PendingReplicationOperationsCount *int64 `json:"pendingReplicationOperationsCount,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of Migration Configuration
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MigrationConfigsClientBeginCreateAndStartMigrationOptions contains the optional parameters for the MigrationConfigsClient.BeginCreateAndStartMigration
// method.
type MigrationConfigsClientBeginCreateAndStartMigrationOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsClientCompleteMigrationOptions contains the optional parameters for the MigrationConfigsClient.CompleteMigration
// method.
type MigrationConfigsClientCompleteMigrationOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsClientDeleteOptions contains the optional parameters for the MigrationConfigsClient.Delete method.
type MigrationConfigsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsClientGetOptions contains the optional parameters for the MigrationConfigsClient.Get method.
type MigrationConfigsClientGetOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsClientListOptions contains the optional parameters for the MigrationConfigsClient.List method.
type MigrationConfigsClientListOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsClientRevertOptions contains the optional parameters for the MigrationConfigsClient.Revert method.
type MigrationConfigsClientRevertOptions struct {
	// placeholder for future optional parameters
}

// NWRuleSetIPRules - Description of NetWorkRuleSet - IpRules resource.
type NWRuleSetIPRules struct {
	// The IP Filter Action
	Action *NetworkRuleIPAction `json:"action,omitempty"`

	// IP Mask
	IPMask *string `json:"ipMask,omitempty"`
}

// NWRuleSetVirtualNetworkRules - Description of VirtualNetworkRules - NetworkRules resource.
type NWRuleSetVirtualNetworkRules struct {
	// Value that indicates whether to ignore missing VNet Service Endpoint
	IgnoreMissingVnetServiceEndpoint *bool `json:"ignoreMissingVnetServiceEndpoint,omitempty"`

	// Subnet properties
	Subnet *Subnet `json:"subnet,omitempty"`
}

// NamespacesClientBeginCreateOrUpdateOptions contains the optional parameters for the NamespacesClient.BeginCreateOrUpdate
// method.
type NamespacesClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientBeginDeleteOptions contains the optional parameters for the NamespacesClient.BeginDelete method.
type NamespacesClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientCheckNameAvailabilityOptions contains the optional parameters for the NamespacesClient.CheckNameAvailability
// method.
type NamespacesClientCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the NamespacesClient.CreateOrUpdateAuthorizationRule
// method.
type NamespacesClientCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientCreateOrUpdateNetworkRuleSetOptions contains the optional parameters for the NamespacesClient.CreateOrUpdateNetworkRuleSet
// method.
type NamespacesClientCreateOrUpdateNetworkRuleSetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientDeleteAuthorizationRuleOptions contains the optional parameters for the NamespacesClient.DeleteAuthorizationRule
// method.
type NamespacesClientDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientGetAuthorizationRuleOptions contains the optional parameters for the NamespacesClient.GetAuthorizationRule
// method.
type NamespacesClientGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientGetNetworkRuleSetOptions contains the optional parameters for the NamespacesClient.GetNetworkRuleSet method.
type NamespacesClientGetNetworkRuleSetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientGetOptions contains the optional parameters for the NamespacesClient.Get method.
type NamespacesClientGetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientListAuthorizationRulesOptions contains the optional parameters for the NamespacesClient.ListAuthorizationRules
// method.
type NamespacesClientListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientListByResourceGroupOptions contains the optional parameters for the NamespacesClient.ListByResourceGroup
// method.
type NamespacesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientListKeysOptions contains the optional parameters for the NamespacesClient.ListKeys method.
type NamespacesClientListKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientListNetworkRuleSetsOptions contains the optional parameters for the NamespacesClient.ListNetworkRuleSets
// method.
type NamespacesClientListNetworkRuleSetsOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientListOptions contains the optional parameters for the NamespacesClient.List method.
type NamespacesClientListOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientRegenerateKeysOptions contains the optional parameters for the NamespacesClient.RegenerateKeys method.
type NamespacesClientRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesClientUpdateOptions contains the optional parameters for the NamespacesClient.Update method.
type NamespacesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkRuleSet - Description of NetworkRuleSet resource.
type NetworkRuleSet struct {
	// NetworkRuleSet properties
	Properties *NetworkRuleSetProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// NetworkRuleSetListResult - The response of the List NetworkRuleSet operation.
type NetworkRuleSetListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of NetworkRuleSet.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List NetworkRuleSet operation.
	Value []*NetworkRuleSet `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSetListResult.
func (n NetworkRuleSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NetworkRuleSetProperties - NetworkRuleSet properties
type NetworkRuleSetProperties struct {
	// Default Action for Network Rule Set
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// List of IpRules
	IPRules []*NWRuleSetIPRules `json:"ipRules,omitempty"`

	// This determines if traffic is allowed over public network. By default it is enabled.
	PublicNetworkAccess *PublicNetworkAccessFlag `json:"publicNetworkAccess,omitempty"`

	// Value that indicates whether Trusted Service Access is Enabled or not.
	TrustedServiceAccessEnabled *bool `json:"trustedServiceAccessEnabled,omitempty"`

	// List VirtualNetwork Rules
	VirtualNetworkRules []*NWRuleSetVirtualNetworkRules `json:"virtualNetworkRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSetProperties.
func (n NetworkRuleSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", n.DefaultAction)
	populate(objectMap, "ipRules", n.IPRules)
	populate(objectMap, "publicNetworkAccess", n.PublicNetworkAccess)
	populate(objectMap, "trustedServiceAccessEnabled", n.TrustedServiceAccessEnabled)
	populate(objectMap, "virtualNetworkRules", n.VirtualNetworkRules)
	return json.Marshal(objectMap)
}

// Operation - A Service Bus REST API operation
type Operation struct {
	// Display of the operation
	Display *OperationDisplay `json:"display,omitempty"`

	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// Origin of the operation
	Origin *string `json:"origin,omitempty"`

	// Properties of the operation
	Properties map[string]interface{} `json:"properties,omitempty"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - Operation display payload
type OperationDisplay struct {
	// READ-ONLY; Localized friendly description for the operation
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Localized friendly name for the operation
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Resource provider of the operation
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource of the operation
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - Result of the request to list ServiceBus operations. It contains a list of operations and a URL link
// to get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of ServiceBus operations supported by the Microsoft.ServiceBus resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpoint information.
type PrivateEndpoint struct {
	// The ARM identifier for Private Endpoint.
	ID *string `json:"id,omitempty"`
}

// PrivateEndpointConnection - Properties of the PrivateEndpointConnection.
type PrivateEndpointConnection struct {
	// Properties of the PrivateEndpointConnection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionListResult - Result of the list of all private endpoint connections operation.
type PrivateEndpointConnectionListResult struct {
	// A link for the next page of private endpoint connection resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private endpoint connection resources.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the private endpoint connection resource.
type PrivateEndpointConnectionProperties struct {
	// The Private Endpoint resource for this Connection.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Details about the state of the connection.
	PrivateLinkServiceConnectionState *ConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// Provisioning state of the Private Endpoint Connection.
	ProvisioningState *EndPointProvisioningState `json:"provisioningState,omitempty"`
}

// PrivateEndpointConnectionsClientBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnectionsClient.BeginDelete
// method.
type PrivateEndpointConnectionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnectionsClient.CreateOrUpdate
// method.
type PrivateEndpointConnectionsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientGetOptions contains the optional parameters for the PrivateEndpointConnectionsClient.Get
// method.
type PrivateEndpointConnectionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsClientListOptions contains the optional parameters for the PrivateEndpointConnectionsClient.List
// method.
type PrivateEndpointConnectionsClientListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - Information of the private link resource.
type PrivateLinkResource struct {
	// Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty"`

	// Name of the resource
	Name *string `json:"name,omitempty"`

	// Properties of the private link resource.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// Type of the resource
	Type *string `json:"type,omitempty"`
}

// PrivateLinkResourceProperties - Properties of PrivateLinkResource
type PrivateLinkResourceProperties struct {
	GroupID *string `json:"groupId,omitempty"`

	// Required Members
	RequiredMembers []*string `json:"requiredMembers,omitempty"`

	// Required Zone Names
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesClientGetOptions contains the optional parameters for the PrivateLinkResourcesClient.Get method.
type PrivateLinkResourcesClientGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesListResult - Result of the List private link resources operation.
type PrivateLinkResourcesListResult struct {
	// A link for the next page of private link resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesListResult.
func (p PrivateLinkResourcesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProxyResource - Common fields that are returned in the response for all Azure Resource Manager resources
type ProxyResource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// QueuesClientCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the QueuesClient.CreateOrUpdateAuthorizationRule
// method.
type QueuesClientCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientCreateOrUpdateOptions contains the optional parameters for the QueuesClient.CreateOrUpdate method.
type QueuesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientDeleteAuthorizationRuleOptions contains the optional parameters for the QueuesClient.DeleteAuthorizationRule
// method.
type QueuesClientDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientDeleteOptions contains the optional parameters for the QueuesClient.Delete method.
type QueuesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientGetAuthorizationRuleOptions contains the optional parameters for the QueuesClient.GetAuthorizationRule method.
type QueuesClientGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientGetOptions contains the optional parameters for the QueuesClient.Get method.
type QueuesClientGetOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientListAuthorizationRulesOptions contains the optional parameters for the QueuesClient.ListAuthorizationRules
// method.
type QueuesClientListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientListByNamespaceOptions contains the optional parameters for the QueuesClient.ListByNamespace method.
type QueuesClientListByNamespaceOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skip parameter that specifies
	// a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// QueuesClientListKeysOptions contains the optional parameters for the QueuesClient.ListKeys method.
type QueuesClientListKeysOptions struct {
	// placeholder for future optional parameters
}

// QueuesClientRegenerateKeysOptions contains the optional parameters for the QueuesClient.RegenerateKeys method.
type QueuesClientRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// RegenerateAccessKeyParameters - Parameters supplied to the Regenerate Authorization Rule operation, specifies which key
// needs to be reset.
type RegenerateAccessKeyParameters struct {
	// REQUIRED; The access key to regenerate.
	KeyType *KeyType `json:"keyType,omitempty"`

	// Optional, if the key value provided, is reset for KeyType value or autogenerate Key value set for keyType
	Key *string `json:"key,omitempty"`
}

// Resource - The Resource definition for other than namespace.
type Resource struct {
	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ResourceNamespacePatch - The Resource definition.
type ResourceNamespacePatch struct {
	// Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceNamespacePatch.
func (r ResourceNamespacePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// Rule - Description of Rule Resource.
type Rule struct {
	// Properties of Rule resource
	Properties *Ruleproperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RuleListResult - The response of the List rule operation.
type RuleListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of rules
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Rules operation.
	Value []*Rule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleListResult.
func (r RuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// Ruleproperties - Description of Rule Resource.
type Ruleproperties struct {
	// Represents the filter actions which are allowed for the transformation of a message that have been matched by a filter
	// expression.
	Action *Action `json:"action,omitempty"`

	// Properties of correlationFilter
	CorrelationFilter *CorrelationFilter `json:"correlationFilter,omitempty"`

	// Filter type that is evaluated against a BrokeredMessage.
	FilterType *FilterType `json:"filterType,omitempty"`

	// Properties of sqlFilter
	SQLFilter *SQLFilter `json:"sqlFilter,omitempty"`
}

// RulesClientCreateOrUpdateOptions contains the optional parameters for the RulesClient.CreateOrUpdate method.
type RulesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RulesClientDeleteOptions contains the optional parameters for the RulesClient.Delete method.
type RulesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// RulesClientGetOptions contains the optional parameters for the RulesClient.Get method.
type RulesClientGetOptions struct {
	// placeholder for future optional parameters
}

// RulesClientListBySubscriptionsOptions contains the optional parameters for the RulesClient.ListBySubscriptions method.
type RulesClientListBySubscriptionsOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skip parameter that specifies
	// a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// SBAuthorizationRule - Description of a namespace authorization rule.
type SBAuthorizationRule struct {
	// AuthorizationRule properties.
	Properties *SBAuthorizationRuleProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SBAuthorizationRuleListResult - The response to the List Namespace operation.
type SBAuthorizationRuleListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of Authorization Rules.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Authorization Rules operation.
	Value []*SBAuthorizationRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBAuthorizationRuleListResult.
func (s SBAuthorizationRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBAuthorizationRuleProperties - AuthorizationRule properties.
type SBAuthorizationRuleProperties struct {
	// REQUIRED; The rights associated with the rule.
	Rights []*AccessRights `json:"rights,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBAuthorizationRuleProperties.
func (s SBAuthorizationRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rights", s.Rights)
	return json.Marshal(objectMap)
}

// SBClientAffineProperties - Properties specific to client affine subscriptions.
type SBClientAffineProperties struct {
	// Indicates the Client ID of the application that created the client-affine subscription.
	ClientID *string `json:"clientId,omitempty"`

	// For client-affine subscriptions, this value indicates whether the subscription is durable or not.
	IsDurable *bool `json:"isDurable,omitempty"`

	// For client-affine subscriptions, this value indicates whether the subscription is shared or not.
	IsShared *bool `json:"isShared,omitempty"`
}

// SBNamespace - Description of a namespace resource.
type SBNamespace struct {
	// REQUIRED; The Geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Properties of BYOK Identity description
	Identity *Identity `json:"identity,omitempty"`

	// Properties of the namespace.
	Properties *SBNamespaceProperties `json:"properties,omitempty"`

	// Properties of SKU
	SKU *SBSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespace.
func (s SBNamespace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SBNamespaceListResult - The response of the List Namespace operation.
type SBNamespaceListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of Namespaces.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Namespace operation.
	Value []*SBNamespace `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceListResult.
func (s SBNamespaceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBNamespaceProperties - Properties of the namespace.
type SBNamespaceProperties struct {
	// Alternate name for namespace
	AlternateName *string `json:"alternateName,omitempty"`

	// This property disables SAS authentication for the Service Bus namespace.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties of BYOK Encryption description
	Encryption *Encryption `json:"encryption,omitempty"`

	// List of private endpoint connections.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`

	// Enabling this property creates a Premium Service Bus Namespace in regions supported availability zones.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`

	// READ-ONLY; The time the namespace was created
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for Azure Insights metrics
	MetricID *string `json:"metricId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the namespace.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Endpoint you can use to perform Service Bus operations.
	ServiceBusEndpoint *string `json:"serviceBusEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Status of the namespace.
	Status *string `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceProperties.
func (s SBNamespaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateName", s.AlternateName)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "disableLocalAuth", s.DisableLocalAuth)
	populate(objectMap, "encryption", s.Encryption)
	populate(objectMap, "metricId", s.MetricID)
	populate(objectMap, "privateEndpointConnections", s.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "serviceBusEndpoint", s.ServiceBusEndpoint)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "updatedAt", s.UpdatedAt)
	populate(objectMap, "zoneRedundant", s.ZoneRedundant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBNamespaceProperties.
func (s *SBNamespaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateName":
			err = unpopulate(val, &s.AlternateName)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, &s.DisableLocalAuth)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &s.Encryption)
			delete(rawMsg, key)
		case "metricId":
			err = unpopulate(val, &s.MetricID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &s.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "serviceBusEndpoint":
			err = unpopulate(val, &s.ServiceBusEndpoint)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &s.UpdatedAt)
			delete(rawMsg, key)
		case "zoneRedundant":
			err = unpopulate(val, &s.ZoneRedundant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBNamespaceUpdateParameters - Description of a namespace resource.
type SBNamespaceUpdateParameters struct {
	// Properties of BYOK Identity description
	Identity *Identity `json:"identity,omitempty"`

	// Resource location
	Location *string `json:"location,omitempty"`

	// Properties of the namespace.
	Properties *SBNamespaceUpdateProperties `json:"properties,omitempty"`

	// Properties of SKU
	SKU *SBSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceUpdateParameters.
func (s SBNamespaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SBNamespaceUpdateProperties - Properties of the namespace.
type SBNamespaceUpdateProperties struct {
	// Alternate name for namespace
	AlternateName *string `json:"alternateName,omitempty"`

	// This property disables SAS authentication for the Service Bus namespace.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties of BYOK Encryption description
	Encryption *Encryption `json:"encryption,omitempty"`

	// List of private endpoint connections.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`

	// READ-ONLY; The time the namespace was created
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for Azure Insights metrics
	MetricID *string `json:"metricId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the namespace.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Endpoint you can use to perform Service Bus operations.
	ServiceBusEndpoint *string `json:"serviceBusEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Status of the namespace.
	Status *string `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceUpdateProperties.
func (s SBNamespaceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alternateName", s.AlternateName)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "disableLocalAuth", s.DisableLocalAuth)
	populate(objectMap, "encryption", s.Encryption)
	populate(objectMap, "metricId", s.MetricID)
	populate(objectMap, "privateEndpointConnections", s.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "serviceBusEndpoint", s.ServiceBusEndpoint)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "updatedAt", s.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBNamespaceUpdateProperties.
func (s *SBNamespaceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateName":
			err = unpopulate(val, &s.AlternateName)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "disableLocalAuth":
			err = unpopulate(val, &s.DisableLocalAuth)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &s.Encryption)
			delete(rawMsg, key)
		case "metricId":
			err = unpopulate(val, &s.MetricID)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, &s.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "serviceBusEndpoint":
			err = unpopulate(val, &s.ServiceBusEndpoint)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &s.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBQueue - Description of queue Resource.
type SBQueue struct {
	// Queue Properties
	Properties *SBQueueProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SBQueueListResult - The response to the List Queues operation.
type SBQueueListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of queues.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Queues operation.
	Value []*SBQueue `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBQueueListResult.
func (s SBQueueListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBQueueProperties - The Queue Properties definition.
type SBQueueProperties struct {
	// ISO 8061 timeSpan idle interval after which the queue is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// A value that indicates whether this queue has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when
	// the message is sent to Service Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// A value that indicates whether Express Entities are enabled. An express queue holds a message in memory temporarily before
	// writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// A value that indicates whether the queue is to be partitioned across multiple message brokers.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// Queue/Topic name to forward the Dead Letter message
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// Queue/Topic name to forward the messages
	ForwardTo *string `json:"forwardTo,omitempty"`

	// ISO 8601 timespan duration of a peek-lock; that is, the amount of time that the message is locked for other receivers.
	// The maximum value for LockDuration is 5 minutes; the default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// The maximum delivery count. A message is automatically deadlettered after this number of deliveries. default value is 10.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// Maximum size (in KB) of the message payload that can be accepted by the queue. This property is only used in Premium today
	// and default is 1024.
	MaxMessageSizeInKilobytes *int64 `json:"maxMessageSizeInKilobytes,omitempty"`

	// The maximum size of the queue in megabytes, which is the size of memory allocated for the queue. Default is 1024.
	MaxSizeInMegabytes *int32 `json:"maxSizeInMegabytes,omitempty"`

	// A value indicating if this queue requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// A value that indicates whether the queue supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// READ-ONLY; Last time a message was sent, or the last time there was a receive request to this queue.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message Count Details.
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; The number of messages in the queue.
	MessageCount *int64 `json:"messageCount,omitempty" azure:"ro"`

	// READ-ONLY; The size of the queue, in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBQueueProperties.
func (s SBQueueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "accessedAt", s.AccessedAt)
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "countDetails", s.CountDetails)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "deadLetteringOnMessageExpiration", s.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "enableExpress", s.EnableExpress)
	populate(objectMap, "enablePartitioning", s.EnablePartitioning)
	populate(objectMap, "forwardDeadLetteredMessagesTo", s.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", s.ForwardTo)
	populate(objectMap, "lockDuration", s.LockDuration)
	populate(objectMap, "maxDeliveryCount", s.MaxDeliveryCount)
	populate(objectMap, "maxMessageSizeInKilobytes", s.MaxMessageSizeInKilobytes)
	populate(objectMap, "maxSizeInMegabytes", s.MaxSizeInMegabytes)
	populate(objectMap, "messageCount", s.MessageCount)
	populate(objectMap, "requiresDuplicateDetection", s.RequiresDuplicateDetection)
	populate(objectMap, "requiresSession", s.RequiresSession)
	populate(objectMap, "sizeInBytes", s.SizeInBytes)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "updatedAt", s.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBQueueProperties.
func (s *SBQueueProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			err = unpopulateTimeRFC3339(val, &s.AccessedAt)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
			err = unpopulate(val, &s.DeadLetteringOnMessageExpiration)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "enableExpress":
			err = unpopulate(val, &s.EnableExpress)
			delete(rawMsg, key)
		case "enablePartitioning":
			err = unpopulate(val, &s.EnablePartitioning)
			delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
			err = unpopulate(val, &s.ForwardDeadLetteredMessagesTo)
			delete(rawMsg, key)
		case "forwardTo":
			err = unpopulate(val, &s.ForwardTo)
			delete(rawMsg, key)
		case "lockDuration":
			err = unpopulate(val, &s.LockDuration)
			delete(rawMsg, key)
		case "maxDeliveryCount":
			err = unpopulate(val, &s.MaxDeliveryCount)
			delete(rawMsg, key)
		case "maxMessageSizeInKilobytes":
			err = unpopulate(val, &s.MaxMessageSizeInKilobytes)
			delete(rawMsg, key)
		case "maxSizeInMegabytes":
			err = unpopulate(val, &s.MaxSizeInMegabytes)
			delete(rawMsg, key)
		case "messageCount":
			err = unpopulate(val, &s.MessageCount)
			delete(rawMsg, key)
		case "requiresDuplicateDetection":
			err = unpopulate(val, &s.RequiresDuplicateDetection)
			delete(rawMsg, key)
		case "requiresSession":
			err = unpopulate(val, &s.RequiresSession)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &s.SizeInBytes)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &s.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBSKU - SKU of the namespace.
type SBSKU struct {
	// REQUIRED; Name of this SKU.
	Name *SKUName `json:"name,omitempty"`

	// The specified messaging units for the tier. For Premium tier, capacity are 1,2 and 4.
	Capacity *int32 `json:"capacity,omitempty"`

	// The billing tier of this particular SKU.
	Tier *SKUTier `json:"tier,omitempty"`
}

// SBSubscription - Description of subscription resource.
type SBSubscription struct {
	// Properties of subscriptions resource.
	Properties *SBSubscriptionProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SBSubscriptionListResult - The response to the List Subscriptions operation.
type SBSubscriptionListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of subscriptions.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Subscriptions operation.
	Value []*SBSubscription `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBSubscriptionListResult.
func (s SBSubscriptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBSubscriptionProperties - Description of Subscription Resource.
type SBSubscriptionProperties struct {
	// ISO 8061 timeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// Properties specific to client affine subscriptions.
	ClientAffineProperties *SBClientAffineProperties `json:"clientAffineProperties,omitempty"`

	// Value that indicates whether a subscription has dead letter support on filter evaluation exceptions.
	DeadLetteringOnFilterEvaluationExceptions *bool `json:"deadLetteringOnFilterEvaluationExceptions,omitempty"`

	// Value that indicates whether a subscription has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8061 Default message timespan to live value. This is the duration after which the message expires, starting from when
	// the message is sent to Service Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// Queue/Topic name to forward the Dead Letter message
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// Queue/Topic name to forward the messages
	ForwardTo *string `json:"forwardTo,omitempty"`

	// Value that indicates whether the subscription has an affinity to the client id.
	IsClientAffine *bool `json:"isClientAffine,omitempty"`

	// ISO 8061 lock duration timespan for the subscription. The default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// Number of maximum deliveries.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// Value indicating if a subscription supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// READ-ONLY; Last time there was a receive request to this subscription.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message count details
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; Exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages.
	MessageCount *int64 `json:"messageCount,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBSubscriptionProperties.
func (s SBSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "accessedAt", s.AccessedAt)
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "clientAffineProperties", s.ClientAffineProperties)
	populate(objectMap, "countDetails", s.CountDetails)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "deadLetteringOnFilterEvaluationExceptions", s.DeadLetteringOnFilterEvaluationExceptions)
	populate(objectMap, "deadLetteringOnMessageExpiration", s.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "forwardDeadLetteredMessagesTo", s.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", s.ForwardTo)
	populate(objectMap, "isClientAffine", s.IsClientAffine)
	populate(objectMap, "lockDuration", s.LockDuration)
	populate(objectMap, "maxDeliveryCount", s.MaxDeliveryCount)
	populate(objectMap, "messageCount", s.MessageCount)
	populate(objectMap, "requiresSession", s.RequiresSession)
	populate(objectMap, "status", s.Status)
	populateTimeRFC3339(objectMap, "updatedAt", s.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBSubscriptionProperties.
func (s *SBSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			err = unpopulateTimeRFC3339(val, &s.AccessedAt)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "clientAffineProperties":
			err = unpopulate(val, &s.ClientAffineProperties)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "deadLetteringOnFilterEvaluationExceptions":
			err = unpopulate(val, &s.DeadLetteringOnFilterEvaluationExceptions)
			delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
			err = unpopulate(val, &s.DeadLetteringOnMessageExpiration)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
			err = unpopulate(val, &s.ForwardDeadLetteredMessagesTo)
			delete(rawMsg, key)
		case "forwardTo":
			err = unpopulate(val, &s.ForwardTo)
			delete(rawMsg, key)
		case "isClientAffine":
			err = unpopulate(val, &s.IsClientAffine)
			delete(rawMsg, key)
		case "lockDuration":
			err = unpopulate(val, &s.LockDuration)
			delete(rawMsg, key)
		case "maxDeliveryCount":
			err = unpopulate(val, &s.MaxDeliveryCount)
			delete(rawMsg, key)
		case "messageCount":
			err = unpopulate(val, &s.MessageCount)
			delete(rawMsg, key)
		case "requiresSession":
			err = unpopulate(val, &s.RequiresSession)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &s.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBTopic - Description of topic resource.
type SBTopic struct {
	// Properties of topic resource.
	Properties *SBTopicProperties `json:"properties,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system meta data relating to this resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SBTopicListResult - The response to the List Topics operation.
type SBTopicListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of topics.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Topics operation.
	Value []*SBTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBTopicListResult.
func (s SBTopicListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBTopicProperties - The Topic Properties definition.
type SBTopicProperties struct {
	// ISO 8601 timespan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// ISO 8601 Default message timespan to live value. This is the duration after which the message expires, starting from when
	// the message is sent to Service Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO8601 timespan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// Value that indicates whether Express Entities are enabled. An express topic holds a message in memory temporarily before
	// writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// Value that indicates whether the topic to be partitioned across multiple message brokers is enabled.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// Maximum size (in KB) of the message payload that can be accepted by the topic. This property is only used in Premium today
	// and default is 1024.
	MaxMessageSizeInKilobytes *int64 `json:"maxMessageSizeInKilobytes,omitempty"`

	// Maximum size of the topic in megabytes, which is the size of the memory allocated for the topic. Default is 1024.
	MaxSizeInMegabytes *int32 `json:"maxSizeInMegabytes,omitempty"`

	// Value indicating if this topic requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// Value that indicates whether the topic supports ordering.
	SupportOrdering *bool `json:"supportOrdering,omitempty"`

	// READ-ONLY; Last time the message was sent, or a request was received, for this topic.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message count details
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; Exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Size of the topic, in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; Number of subscriptions.
	SubscriptionCount *int32 `json:"subscriptionCount,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBTopicProperties.
func (s SBTopicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "accessedAt", s.AccessedAt)
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "countDetails", s.CountDetails)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "enableExpress", s.EnableExpress)
	populate(objectMap, "enablePartitioning", s.EnablePartitioning)
	populate(objectMap, "maxMessageSizeInKilobytes", s.MaxMessageSizeInKilobytes)
	populate(objectMap, "maxSizeInMegabytes", s.MaxSizeInMegabytes)
	populate(objectMap, "requiresDuplicateDetection", s.RequiresDuplicateDetection)
	populate(objectMap, "sizeInBytes", s.SizeInBytes)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "subscriptionCount", s.SubscriptionCount)
	populate(objectMap, "supportOrdering", s.SupportOrdering)
	populateTimeRFC3339(objectMap, "updatedAt", s.UpdatedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBTopicProperties.
func (s *SBTopicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			err = unpopulateTimeRFC3339(val, &s.AccessedAt)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "enableExpress":
			err = unpopulate(val, &s.EnableExpress)
			delete(rawMsg, key)
		case "enablePartitioning":
			err = unpopulate(val, &s.EnablePartitioning)
			delete(rawMsg, key)
		case "maxMessageSizeInKilobytes":
			err = unpopulate(val, &s.MaxMessageSizeInKilobytes)
			delete(rawMsg, key)
		case "maxSizeInMegabytes":
			err = unpopulate(val, &s.MaxSizeInMegabytes)
			delete(rawMsg, key)
		case "requiresDuplicateDetection":
			err = unpopulate(val, &s.RequiresDuplicateDetection)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &s.SizeInBytes)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "subscriptionCount":
			err = unpopulate(val, &s.SubscriptionCount)
			delete(rawMsg, key)
		case "supportOrdering":
			err = unpopulate(val, &s.SupportOrdering)
			delete(rawMsg, key)
		case "updatedAt":
			err = unpopulateTimeRFC3339(val, &s.UpdatedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLFilter - Represents a filter which is a composition of an expression and an action that is executed in the pub/sub pipeline.
type SQLFilter struct {
	// This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
	CompatibilityLevel *int32 `json:"compatibilityLevel,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// The SQL expression. e.g. MyProperty='ABC'
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// SQLRuleAction - Represents set of actions written in SQL language-based syntax that is performed against a ServiceBus.Messaging.BrokeredMessage
type SQLRuleAction struct {
	// This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
	CompatibilityLevel *int32 `json:"compatibilityLevel,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// SQL expression. e.g. MyProperty='ABC'
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// Subnet - Properties supplied for Subnet
type Subnet struct {
	// REQUIRED; Resource ID of Virtual Network Subnet
	ID *string `json:"id,omitempty"`
}

// SubscriptionsClientCreateOrUpdateOptions contains the optional parameters for the SubscriptionsClient.CreateOrUpdate method.
type SubscriptionsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsClientDeleteOptions contains the optional parameters for the SubscriptionsClient.Delete method.
type SubscriptionsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsClientGetOptions contains the optional parameters for the SubscriptionsClient.Get method.
type SubscriptionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsClientListByTopicOptions contains the optional parameters for the SubscriptionsClient.ListByTopic method.
type SubscriptionsClientListByTopicOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skip parameter that specifies
	// a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopicsClientCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the TopicsClient.CreateOrUpdateAuthorizationRule
// method.
type TopicsClientCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientCreateOrUpdateOptions contains the optional parameters for the TopicsClient.CreateOrUpdate method.
type TopicsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientDeleteAuthorizationRuleOptions contains the optional parameters for the TopicsClient.DeleteAuthorizationRule
// method.
type TopicsClientDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientDeleteOptions contains the optional parameters for the TopicsClient.Delete method.
type TopicsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientGetAuthorizationRuleOptions contains the optional parameters for the TopicsClient.GetAuthorizationRule method.
type TopicsClientGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientGetOptions contains the optional parameters for the TopicsClient.Get method.
type TopicsClientGetOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientListAuthorizationRulesOptions contains the optional parameters for the TopicsClient.ListAuthorizationRules
// method.
type TopicsClientListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientListByNamespaceOptions contains the optional parameters for the TopicsClient.ListByNamespace method.
type TopicsClientListByNamespaceOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element,
	// the value of the nextLink element will include a skip parameter that specifies
	// a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// TopicsClientListKeysOptions contains the optional parameters for the TopicsClient.ListKeys method.
type TopicsClientListKeysOptions struct {
	// placeholder for future optional parameters
}

// TopicsClientRegenerateKeysOptions contains the optional parameters for the TopicsClient.RegenerateKeys method.
type TopicsClientRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// TrackedResource - The Resource definition.
type TrackedResource struct {
	// REQUIRED; The Geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UserAssignedIdentity - Recognized Dictionary value.
type UserAssignedIdentity struct {
	// READ-ONLY; Client Id of user assigned identity
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; Principal Id of user assigned identity
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

type UserAssignedIdentityProperties struct {
	// ARM ID of user Identity selected for encryption
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
