//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicefabric

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ApplicationDeltaHealthPolicy - Defines a delta health policy used to evaluate the health of an application or one of its child entities when upgrading
// the cluster.
type ApplicationDeltaHealthPolicy struct {
	// The delta health policy used by default to evaluate the health of a service type when upgrading the cluster.
	DefaultServiceTypeDeltaHealthPolicy *ServiceTypeDeltaHealthPolicy `json:"defaultServiceTypeDeltaHealthPolicy,omitempty"`

	// The map with service type delta health policy per service type name. The map is empty by default.
	ServiceTypeDeltaHealthPolicies map[string]*ServiceTypeDeltaHealthPolicy `json:"serviceTypeDeltaHealthPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationDeltaHealthPolicy.
func (a ApplicationDeltaHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultServiceTypeDeltaHealthPolicy", a.DefaultServiceTypeDeltaHealthPolicy)
	populate(objectMap, "serviceTypeDeltaHealthPolicies", a.ServiceTypeDeltaHealthPolicies)
	return json.Marshal(objectMap)
}

// ApplicationHealthPolicy - Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicy struct {
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy `json:"defaultServiceTypeHealthPolicy,omitempty"`

	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicies map[string]*ServiceTypeHealthPolicy `json:"serviceTypeHealthPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationHealthPolicy.
func (a ApplicationHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultServiceTypeHealthPolicy", a.DefaultServiceTypeHealthPolicy)
	populate(objectMap, "serviceTypeHealthPolicies", a.ServiceTypeHealthPolicies)
	return json.Marshal(objectMap)
}

// ApplicationMetricDescription - Describes capacity information for a custom resource balancing metric. This can be used to limit the total consumption
// of this metric by the services of this application.
type ApplicationMetricDescription struct {
	// The maximum node capacity for Service Fabric application. This is the maximum Load for an instance of this application on a single node. Even if the
	// capacity of node is greater than this value,
	// Service Fabric will limit the total load of services within the application on each node to this value. If set to zero, capacity for this metric is unlimited
	// on each node. When creating a new
	// application with application capacity defined, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.
	// When updating existing application with
	// application capacity, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.
	MaximumCapacity *int64 `json:"maximumCapacity,omitempty"`

	// The name of the metric.
	Name *string `json:"name,omitempty"`

	// The node reservation capacity for Service Fabric application. This is the amount of load which is reserved on nodes which have instances of this application.
	// If MinimumNodes is specified, then the
	// product of these values will be the capacity reserved in the cluster for the application. If set to zero, no capacity is reserved for this metric. When
	// setting application capacity or when updating
	// application capacity; this value must be smaller than or equal to MaximumCapacity for each metric.
	ReservationCapacity *int64 `json:"reservationCapacity,omitempty"`

	// The total metric capacity for Service Fabric application. This is the total metric capacity for this application in the cluster. Service Fabric will
	// try to limit the sum of loads of services within
	// the application to this value. When creating a new application with application capacity defined, the product of MaximumNodes and MaximumCapacity must
	// always be smaller than or equal to this value.
	TotalApplicationCapacity *int64 `json:"totalApplicationCapacity,omitempty"`
}

// ApplicationResource - The application resource.
type ApplicationResource struct {
	ProxyResource
	// Describes the managed identities for an Azure resource.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// The application resource properties.
	Properties *ApplicationResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResource.
func (a ApplicationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResource.
func (a *ApplicationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &a.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplicationResourceList - The list of application resources.
type ApplicationResourceList struct {
	Value []*ApplicationResource `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of application list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceList.
func (a ApplicationResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationResourceProperties - The application resource properties.
type ApplicationResourceProperties struct {
	ApplicationResourceUpdateProperties
	// The application type name as defined in the application manifest.
	TypeName *string `json:"typeName,omitempty"`

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceProperties.
func (a ApplicationResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ApplicationResourceUpdateProperties.marshalInternal(objectMap)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "typeName", a.TypeName)
	return json.Marshal(objectMap)
}

// ApplicationResourceUpdate - The application resource for patch operations.
type ApplicationResourceUpdate struct {
	ProxyResource
	// The application resource properties for patch operations.
	Properties *ApplicationResourceUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceUpdate.
func (a ApplicationResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceUpdate.
func (a *ApplicationResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplicationResourceUpdateProperties - The application resource properties for patch operations.
type ApplicationResourceUpdateProperties struct {
	// List of user assigned identities for the application, each mapped to a friendly name.
	ManagedIdentities []*ApplicationUserAssignedIdentity `json:"managedIdentities,omitempty"`

	// The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application
	// will be placed on all of those nodes. By
	// default, the value of this property is zero and it means that the services can be placed on any node.
	MaximumNodes *int64 `json:"maximumNodes,omitempty"`

	// List of application capacity metric description.
	Metrics []*ApplicationMetricDescription `json:"metrics,omitempty"`

	// The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application
	// will be placed on all of those nodes. If
	// this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.
	MinimumNodes *int64 `json:"minimumNodes,omitempty"`

	// List of application parameters with overridden values from their default values specified in the application manifest.
	Parameters map[string]*string `json:"parameters,omitempty"`

	// Remove the current application capacity settings.
	RemoveApplicationCapacity *bool `json:"removeApplicationCapacity,omitempty"`

	// The version of the application type as defined in the application manifest.
	TypeVersion *string `json:"typeVersion,omitempty"`

	// Describes the policy for a monitored application upgrade.
	UpgradePolicy *ApplicationUpgradePolicy `json:"upgradePolicy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceUpdateProperties.
func (a ApplicationResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (a ApplicationResourceUpdateProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "managedIdentities", a.ManagedIdentities)
	populate(objectMap, "maximumNodes", a.MaximumNodes)
	populate(objectMap, "metrics", a.Metrics)
	populate(objectMap, "minimumNodes", a.MinimumNodes)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "removeApplicationCapacity", a.RemoveApplicationCapacity)
	populate(objectMap, "typeVersion", a.TypeVersion)
	populate(objectMap, "upgradePolicy", a.UpgradePolicy)
}

// ApplicationTypeResource - The application type name resource
type ApplicationTypeResource struct {
	ProxyResource
	// The application type name properties
	Properties *ApplicationTypeResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeResource.
func (a ApplicationTypeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeResource.
func (a *ApplicationTypeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplicationTypeResourceList - The list of application type names.
type ApplicationTypeResourceList struct {
	Value []*ApplicationTypeResource `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of application type list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeResourceList.
func (a ApplicationTypeResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationTypeResourceProperties - The application type name properties
type ApplicationTypeResourceProperties struct {
	// READ-ONLY; The current deployment or provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// ApplicationTypeVersionResource - An application type version resource for the specified application type name resource.
type ApplicationTypeVersionResource struct {
	ProxyResource
	// The properties of the application type version resource.
	Properties *ApplicationTypeVersionResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResource.
func (a ApplicationTypeVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionResource.
func (a *ApplicationTypeVersionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplicationTypeVersionResourceList - The list of application type version resources for the specified application type name resource.
type ApplicationTypeVersionResourceList struct {
	Value []*ApplicationTypeVersionResource `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of application type version list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResourceList.
func (a ApplicationTypeVersionResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationTypeVersionResourceProperties - The properties of the application type version resource.
type ApplicationTypeVersionResourceProperties struct {
	// REQUIRED; The URL to the application package
	AppPackageURL *string `json:"appPackageUrl,omitempty"`

	// READ-ONLY; List of application type parameters that can be overridden when creating or updating the application.
	DefaultParameterList map[string]*string `json:"defaultParameterList,omitempty" azure:"ro"`

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResourceProperties.
func (a ApplicationTypeVersionResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appPackageUrl", a.AppPackageURL)
	populate(objectMap, "defaultParameterList", a.DefaultParameterList)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// ApplicationTypeVersionsBeginCreateOrUpdateOptions contains the optional parameters for the ApplicationTypeVersions.BeginCreateOrUpdate method.
type ApplicationTypeVersionsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypeVersionsBeginDeleteOptions contains the optional parameters for the ApplicationTypeVersions.BeginDelete method.
type ApplicationTypeVersionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

type ApplicationTypeVersionsCleanupPolicy struct {
	// REQUIRED; Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep *int64 `json:"maxUnusedVersionsToKeep,omitempty"`
}

// ApplicationTypeVersionsGetOptions contains the optional parameters for the ApplicationTypeVersions.Get method.
type ApplicationTypeVersionsGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypeVersionsListOptions contains the optional parameters for the ApplicationTypeVersions.List method.
type ApplicationTypeVersionsListOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypesBeginDeleteOptions contains the optional parameters for the ApplicationTypes.BeginDelete method.
type ApplicationTypesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypesCreateOrUpdateOptions contains the optional parameters for the ApplicationTypes.CreateOrUpdate method.
type ApplicationTypesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypesGetOptions contains the optional parameters for the ApplicationTypes.Get method.
type ApplicationTypesGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationTypesListOptions contains the optional parameters for the ApplicationTypes.List method.
type ApplicationTypesListOptions struct {
	// placeholder for future optional parameters
}

// ApplicationUpgradePolicy - Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ArmApplicationHealthPolicy `json:"applicationHealthPolicy,omitempty"`

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or
	// data).
	ForceRestart *bool `json:"forceRestart,omitempty"`

	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed and it will
	// result in availability loss.
	RecreateApplication *bool `json:"recreateApplication,omitempty"`

	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *ArmRollingUpgradeMonitoringPolicy `json:"rollingUpgradeMonitoringPolicy,omitempty"`

	// The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and Monitored.
	UpgradeMode *RollingUpgradeMode `json:"upgradeMode,omitempty"`

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout
	// expires, processing of the upgrade domain will
	// proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925
	// inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *string `json:"upgradeReplicaSetCheckTimeout,omitempty"`
}

type ApplicationUserAssignedIdentity struct {
	// REQUIRED; The friendly name of user assigned identity.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
}

// ApplicationsBeginCreateOrUpdateOptions contains the optional parameters for the Applications.BeginCreateOrUpdate method.
type ApplicationsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsBeginDeleteOptions contains the optional parameters for the Applications.BeginDelete method.
type ApplicationsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsBeginUpdateOptions contains the optional parameters for the Applications.BeginUpdate method.
type ApplicationsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsGetOptions contains the optional parameters for the Applications.Get method.
type ApplicationsGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationsListOptions contains the optional parameters for the Applications.List method.
type ApplicationsListOptions struct {
	// placeholder for future optional parameters
}

// ArmApplicationHealthPolicy - Defines a health policy used to evaluate the health of an application or one of its children entities.
type ArmApplicationHealthPolicy struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError *bool `json:"considerWarningAsError,omitempty"`

	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ArmServiceTypeHealthPolicy `json:"defaultServiceTypeHealthPolicy,omitempty"`

	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100. The percentage represents the maximum
	// tolerated percentage of deployed applications
	// that can be unhealthy before the application is considered in error. This is calculated by dividing the number of unhealthy deployed applications over
	// the number of nodes where the application is
	// currently deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications *int32 `json:"maxPercentUnhealthyDeployedApplications,omitempty"`

	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]*ArmServiceTypeHealthPolicy `json:"serviceTypeHealthPolicyMap,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmApplicationHealthPolicy.
func (a ArmApplicationHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "considerWarningAsError", a.ConsiderWarningAsError)
	populate(objectMap, "defaultServiceTypeHealthPolicy", a.DefaultServiceTypeHealthPolicy)
	populate(objectMap, "maxPercentUnhealthyDeployedApplications", a.MaxPercentUnhealthyDeployedApplications)
	populate(objectMap, "serviceTypeHealthPolicyMap", a.ServiceTypeHealthPolicyMap)
	return json.Marshal(objectMap)
}

// ArmRollingUpgradeMonitoringPolicy - The policy used for monitoring the application upgrade
type ArmRollingUpgradeMonitoringPolicy struct {
	// The activation Mode of the service package
	FailureAction *ArmUpgradeFailureAction `json:"failureAction,omitempty"`

	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is first interpreted
	// as a string representing an ISO 8601 duration. If
	// that fails, then it is interpreted as a number representing the total number of milliseconds.
	HealthCheckRetryTimeout *string `json:"healthCheckRetryTimeout,omitempty"`

	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first interpreted
	// as a string representing an ISO 8601 duration. If
	// that fails, then it is interpreted as a number representing the total number of milliseconds.
	HealthCheckStableDuration *string `json:"healthCheckStableDuration,omitempty"`

	// The amount of time to wait after completing an upgrade domain before applying health policies. It is first interpreted as a string representing an ISO
	// 8601 duration. If that fails, then it is
	// interpreted as a number representing the total number of milliseconds.
	HealthCheckWaitDuration *string `json:"healthCheckWaitDuration,omitempty"`

	// The amount of time each upgrade domain has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
	// duration. If that fails, then it is interpreted as
	// a number representing the total number of milliseconds.
	UpgradeDomainTimeout *string `json:"upgradeDomainTimeout,omitempty"`

	// The amount of time the overall upgrade has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
	// duration. If that fails, then it is interpreted as
	// a number representing the total number of milliseconds.
	UpgradeTimeout *string `json:"upgradeTimeout,omitempty"`
}

// ArmServiceTypeHealthPolicy - Represents the health policy used to evaluate the health of services belonging to a service type.
type ArmServiceTypeHealthPolicy struct {
	// The maximum percentage of partitions per service allowed to be unhealthy before your application is considered in error.
	MaxPercentUnhealthyPartitionsPerService *int32 `json:"maxPercentUnhealthyPartitionsPerService,omitempty"`

	// The maximum percentage of replicas per partition allowed to be unhealthy before your application is considered in error.
	MaxPercentUnhealthyReplicasPerPartition *int32 `json:"maxPercentUnhealthyReplicasPerPartition,omitempty"`

	// The maximum percentage of services allowed to be unhealthy before your application is considered in error.
	MaxPercentUnhealthyServices *int32 `json:"maxPercentUnhealthyServices,omitempty"`
}

// AvailableOperationDisplay - Operation supported by the Service Fabric resource provider
type AvailableOperationDisplay struct {
	// Operation description
	Description *string `json:"description,omitempty"`

	// The operation that can be performed.
	Operation *string `json:"operation,omitempty"`

	// The name of the provider.
	Provider *string `json:"provider,omitempty"`

	// The resource on which the operation is performed
	Resource *string `json:"resource,omitempty"`
}

// AzureActiveDirectory - The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string `json:"clientApplication,omitempty"`

	// Azure active directory cluster application id.
	ClusterApplication *string `json:"clusterApplication,omitempty"`

	// Azure active directory tenant id.
	TenantID *string `json:"tenantId,omitempty"`
}

// CertificateDescription - Describes the certificate details.
type CertificateDescription struct {
	// REQUIRED; Thumbprint of the primary certificate.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// Thumbprint of the secondary certificate.
	ThumbprintSecondary *string `json:"thumbprintSecondary,omitempty"`

	// The local certificate store location.
	X509StoreName *StoreName `json:"x509StoreName,omitempty"`
}

// ClientCertificateCommonName - Describes the client certificate details using common name.
type ClientCertificateCommonName struct {
	// REQUIRED; The common name of the client certificate.
	CertificateCommonName *string `json:"certificateCommonName,omitempty"`

	// REQUIRED; The issuer thumbprint of the client certificate.
	CertificateIssuerThumbprint *string `json:"certificateIssuerThumbprint,omitempty"`

	// REQUIRED; Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin *bool `json:"isAdmin,omitempty"`
}

// ClientCertificateThumbprint - Describes the client certificate details using thumbprint.
type ClientCertificateThumbprint struct {
	// REQUIRED; The thumbprint of the client certificate.
	CertificateThumbprint *string `json:"certificateThumbprint,omitempty"`

	// REQUIRED; Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin *bool `json:"isAdmin,omitempty"`
}

// Cluster - The cluster resource
type Cluster struct {
	Resource
	// The cluster resource properties
	Properties *ClusterProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// ClusterCodeVersionsListResult - The list results of the Service Fabric runtime versions.
type ClusterCodeVersionsListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string                      `json:"nextLink,omitempty"`
	Value    []*ClusterCodeVersionsResult `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterCodeVersionsListResult.
func (c ClusterCodeVersionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ClusterCodeVersionsResult - The result of the Service Fabric runtime versions
type ClusterCodeVersionsResult struct {
	// The identification of the result
	ID *string `json:"id,omitempty"`

	// The name of the result
	Name *string `json:"name,omitempty"`

	// The detail of the Service Fabric runtime version result
	Properties *ClusterVersionDetails `json:"properties,omitempty"`

	// The result resource type
	Type *string `json:"type,omitempty"`
}

// ClusterHealthPolicy - Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicy struct {
	// Defines the application health policy map used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicies map[string]*ApplicationHealthPolicy `json:"applicationHealthPolicies,omitempty"`

	// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value
	// would be 10.
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error. If the percentage
	// is respected but there is at least one
	// unhealthy application, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy applications over the total number
	// of application instances in the cluster, excluding
	// applications of application types that are included in the ApplicationTypeHealthPolicyMap. The computation rounds up to tolerate one failure on small
	// numbers of applications. Default percentage is
	// zero.
	MaxPercentUnhealthyApplications *int32 `json:"maxPercentUnhealthyApplications,omitempty"`

	// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be
	// 10.
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error. If the percentage
	// is respected but there is at least one unhealthy
	// node, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the
	// cluster. The computation rounds up to tolerate
	// one failure on small numbers of nodes. Default percentage is zero.
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
	MaxPercentUnhealthyNodes *int32 `json:"maxPercentUnhealthyNodes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterHealthPolicy.
func (c ClusterHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationHealthPolicies", c.ApplicationHealthPolicies)
	populate(objectMap, "maxPercentUnhealthyApplications", c.MaxPercentUnhealthyApplications)
	populate(objectMap, "maxPercentUnhealthyNodes", c.MaxPercentUnhealthyNodes)
	return json.Marshal(objectMap)
}

// ClusterListResult - Cluster list results
type ClusterListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string    `json:"nextLink,omitempty"`
	Value    []*Cluster `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterListResult.
func (c ClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ClusterProperties - Describes the cluster resource properties.
type ClusterProperties struct {
	// REQUIRED; The http management endpoint of the cluster.
	ManagementEndpoint *string `json:"managementEndpoint,omitempty"`

	// REQUIRED; The list of node types in the cluster.
	NodeTypes []*NodeTypeDescription `json:"nodeTypes,omitempty"`

	// The list of add-on features to enable in the cluster.
	AddOnFeatures []*AddOnFeatures `json:"addOnFeatures,omitempty"`

	// The policy used to clean up unused versions.
	ApplicationTypeVersionsCleanupPolicy *ApplicationTypeVersionsCleanupPolicy `json:"applicationTypeVersionsCleanupPolicy,omitempty"`

	// The AAD authentication settings of the cluster.
	AzureActiveDirectory *AzureActiveDirectory `json:"azureActiveDirectory,omitempty"`

	// The certificate to use for securing the cluster. The certificate provided will be used for node to node security within the cluster, SSL certificate
	// for cluster management endpoint and default admin
	// client.
	Certificate *CertificateDescription `json:"certificate,omitempty"`

	// Describes a list of server certificates referenced by common name that are used to secure the cluster.
	CertificateCommonNames *ServerCertificateCommonNames `json:"certificateCommonNames,omitempty"`

	// The list of client certificates referenced by common name that are allowed to manage the cluster.
	ClientCertificateCommonNames []*ClientCertificateCommonName `json:"clientCertificateCommonNames,omitempty"`

	// The list of client certificates referenced by thumbprint that are allowed to manage the cluster.
	ClientCertificateThumbprints []*ClientCertificateThumbprint `json:"clientCertificateThumbprints,omitempty"`

	// The Service Fabric runtime version of the cluster. This property can only by set the user when upgradeMode is set to 'Manual'. To get list of available
	// Service Fabric versions for new clusters use
	// ClusterVersion API [./ClusterVersion.md]. To get the list of available version for existing clusters use availableClusterVersions.
	ClusterCodeVersion *string `json:"clusterCodeVersion,omitempty"`

	// The storage account information for storing Service Fabric diagnostic logs.
	DiagnosticsStorageAccountConfig *DiagnosticsStorageAccountConfig `json:"diagnosticsStorageAccountConfig,omitempty"`

	// Indicates if the event store service is enabled.
	EventStoreServiceEnabled *bool `json:"eventStoreServiceEnabled,omitempty"`

	// The list of custom fabric settings to configure the cluster.
	FabricSettings []*SettingsSectionDescription `json:"fabricSettings,omitempty"`

	// Indicates if infrastructure service manager is enabled.
	InfrastructureServiceManager *bool `json:"infrastructureServiceManager,omitempty"`

	// Indicates a list of notification channels for cluster events.
	Notifications []*Notification `json:"notifications,omitempty"`

	// The reliability level sets the replica set size of system services. Learn about ReliabilityLevel [https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity].
	// * None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
	// * Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
	// * Silver - Run the System services with a target replica set count of 5.
	// * Gold - Run the System services with a target replica set count of 7.
	// * Platinum - Run the System services with a target replica set count of 9.
	ReliabilityLevel *ReliabilityLevel `json:"reliabilityLevel,omitempty"`

	// The server certificate used by reverse proxy.
	ReverseProxyCertificate *CertificateDescription `json:"reverseProxyCertificate,omitempty"`

	// Describes a list of server certificates referenced by common name that are used to secure the cluster.
	ReverseProxyCertificateCommonNames *ServerCertificateCommonNames `json:"reverseProxyCertificateCommonNames,omitempty"`

	// This property controls the logical grouping of VMs in upgrade domains (UDs). This property can't be modified if a node type with multiple Availability
	// Zones is already present in the cluster.
	SfZonalUpgradeMode *SfZonalUpgradeMode `json:"sfZonalUpgradeMode,omitempty"`

	// The policy to use when upgrading the cluster.
	UpgradeDescription *ClusterUpgradePolicy `json:"upgradeDescription,omitempty"`

	// The upgrade mode of the cluster when new Service Fabric runtime version is available.
	UpgradeMode *UpgradeMode `json:"upgradeMode,omitempty"`

	// Indicates the end date and time to pause automatic runtime version upgrades on the cluster for an specific period of time on the cluster (UTC).
	UpgradePauseEndTimestampUTC *time.Time `json:"upgradePauseEndTimestampUtc,omitempty"`

	// Indicates the start date and time to pause automatic runtime version upgrades on the cluster for an specific period of time on the cluster (UTC).
	UpgradePauseStartTimestampUTC *time.Time `json:"upgradePauseStartTimestampUtc,omitempty"`

	// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when upgradeMode is set
	// to 'Automatic'.
	UpgradeWave *ClusterUpgradeCadence `json:"upgradeWave,omitempty"`

	// The VM image VMSS has been configured with. Generic names such as Windows or Linux can be used.
	VMImage *string `json:"vmImage,omitempty"`

	// This property defines the upgrade mode for the virtual machine scale set, it is mandatory if a node type with multiple Availability Zones is added.
	VmssZonalUpgradeMode *VmssZonalUpgradeMode `json:"vmssZonalUpgradeMode,omitempty"`

	// Boolean to pause automatic runtime version upgrades to the cluster.
	WaveUpgradePaused *bool `json:"waveUpgradePaused,omitempty"`

	// READ-ONLY; The Service Fabric runtime versions available for this cluster.
	AvailableClusterVersions []*ClusterVersionDetails `json:"availableClusterVersions,omitempty" azure:"ro"`

	// READ-ONLY; The Azure Resource Provider endpoint. A system service in the cluster connects to this endpoint.
	ClusterEndpoint *string `json:"clusterEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; A service generated unique identifier for the cluster resource.
	ClusterID *string `json:"clusterId,omitempty" azure:"ro"`

	// READ-ONLY; The current state of the cluster.
	// * WaitingForNodes - Indicates that the cluster resource is created and the resource provider is waiting for Service Fabric VM extension to boot up and
	// report to it.
	// * Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster resource will be in this state until the cluster boots
	// up and system services are up.
	// * BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster version. This upgrade is automatically initiated when the cluster
	// boots up for the first time.
	// * UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user provided configuration.
	// * UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user provided certificate.
	// * UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest Service Fabric runtime version. This happens only when the upgradeMode
	// is set to 'Automatic'.
	// * EnforcingClusterVersion - Indicates that cluster is on a different version than expected and the cluster is being upgraded to the expected version.
	// * UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer polling the Resource Provider. Clusters in this state cannot
	// be managed by the Resource Provider.
	// * AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
	// * Ready - Indicates that the cluster is in a stable state.
	ClusterState *ClusterState `json:"clusterState,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the cluster resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "addOnFeatures", c.AddOnFeatures)
	populate(objectMap, "applicationTypeVersionsCleanupPolicy", c.ApplicationTypeVersionsCleanupPolicy)
	populate(objectMap, "availableClusterVersions", c.AvailableClusterVersions)
	populate(objectMap, "azureActiveDirectory", c.AzureActiveDirectory)
	populate(objectMap, "certificate", c.Certificate)
	populate(objectMap, "certificateCommonNames", c.CertificateCommonNames)
	populate(objectMap, "clientCertificateCommonNames", c.ClientCertificateCommonNames)
	populate(objectMap, "clientCertificateThumbprints", c.ClientCertificateThumbprints)
	populate(objectMap, "clusterCodeVersion", c.ClusterCodeVersion)
	populate(objectMap, "clusterEndpoint", c.ClusterEndpoint)
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterState", c.ClusterState)
	populate(objectMap, "diagnosticsStorageAccountConfig", c.DiagnosticsStorageAccountConfig)
	populate(objectMap, "eventStoreServiceEnabled", c.EventStoreServiceEnabled)
	populate(objectMap, "fabricSettings", c.FabricSettings)
	populate(objectMap, "infrastructureServiceManager", c.InfrastructureServiceManager)
	populate(objectMap, "managementEndpoint", c.ManagementEndpoint)
	populate(objectMap, "nodeTypes", c.NodeTypes)
	populate(objectMap, "notifications", c.Notifications)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "reliabilityLevel", c.ReliabilityLevel)
	populate(objectMap, "reverseProxyCertificate", c.ReverseProxyCertificate)
	populate(objectMap, "reverseProxyCertificateCommonNames", c.ReverseProxyCertificateCommonNames)
	populate(objectMap, "sfZonalUpgradeMode", c.SfZonalUpgradeMode)
	populate(objectMap, "upgradeDescription", c.UpgradeDescription)
	populate(objectMap, "upgradeMode", c.UpgradeMode)
	populateTimeRFC3339(objectMap, "upgradePauseEndTimestampUtc", c.UpgradePauseEndTimestampUTC)
	populateTimeRFC3339(objectMap, "upgradePauseStartTimestampUtc", c.UpgradePauseStartTimestampUTC)
	populate(objectMap, "upgradeWave", c.UpgradeWave)
	populate(objectMap, "vmImage", c.VMImage)
	populate(objectMap, "vmssZonalUpgradeMode", c.VmssZonalUpgradeMode)
	populate(objectMap, "waveUpgradePaused", c.WaveUpgradePaused)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterProperties.
func (c *ClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addOnFeatures":
			err = unpopulate(val, &c.AddOnFeatures)
			delete(rawMsg, key)
		case "applicationTypeVersionsCleanupPolicy":
			err = unpopulate(val, &c.ApplicationTypeVersionsCleanupPolicy)
			delete(rawMsg, key)
		case "availableClusterVersions":
			err = unpopulate(val, &c.AvailableClusterVersions)
			delete(rawMsg, key)
		case "azureActiveDirectory":
			err = unpopulate(val, &c.AzureActiveDirectory)
			delete(rawMsg, key)
		case "certificate":
			err = unpopulate(val, &c.Certificate)
			delete(rawMsg, key)
		case "certificateCommonNames":
			err = unpopulate(val, &c.CertificateCommonNames)
			delete(rawMsg, key)
		case "clientCertificateCommonNames":
			err = unpopulate(val, &c.ClientCertificateCommonNames)
			delete(rawMsg, key)
		case "clientCertificateThumbprints":
			err = unpopulate(val, &c.ClientCertificateThumbprints)
			delete(rawMsg, key)
		case "clusterCodeVersion":
			err = unpopulate(val, &c.ClusterCodeVersion)
			delete(rawMsg, key)
		case "clusterEndpoint":
			err = unpopulate(val, &c.ClusterEndpoint)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, &c.ClusterID)
			delete(rawMsg, key)
		case "clusterState":
			err = unpopulate(val, &c.ClusterState)
			delete(rawMsg, key)
		case "diagnosticsStorageAccountConfig":
			err = unpopulate(val, &c.DiagnosticsStorageAccountConfig)
			delete(rawMsg, key)
		case "eventStoreServiceEnabled":
			err = unpopulate(val, &c.EventStoreServiceEnabled)
			delete(rawMsg, key)
		case "fabricSettings":
			err = unpopulate(val, &c.FabricSettings)
			delete(rawMsg, key)
		case "infrastructureServiceManager":
			err = unpopulate(val, &c.InfrastructureServiceManager)
			delete(rawMsg, key)
		case "managementEndpoint":
			err = unpopulate(val, &c.ManagementEndpoint)
			delete(rawMsg, key)
		case "nodeTypes":
			err = unpopulate(val, &c.NodeTypes)
			delete(rawMsg, key)
		case "notifications":
			err = unpopulate(val, &c.Notifications)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		case "reliabilityLevel":
			err = unpopulate(val, &c.ReliabilityLevel)
			delete(rawMsg, key)
		case "reverseProxyCertificate":
			err = unpopulate(val, &c.ReverseProxyCertificate)
			delete(rawMsg, key)
		case "reverseProxyCertificateCommonNames":
			err = unpopulate(val, &c.ReverseProxyCertificateCommonNames)
			delete(rawMsg, key)
		case "sfZonalUpgradeMode":
			err = unpopulate(val, &c.SfZonalUpgradeMode)
			delete(rawMsg, key)
		case "upgradeDescription":
			err = unpopulate(val, &c.UpgradeDescription)
			delete(rawMsg, key)
		case "upgradeMode":
			err = unpopulate(val, &c.UpgradeMode)
			delete(rawMsg, key)
		case "upgradePauseEndTimestampUtc":
			err = unpopulateTimeRFC3339(val, &c.UpgradePauseEndTimestampUTC)
			delete(rawMsg, key)
		case "upgradePauseStartTimestampUtc":
			err = unpopulateTimeRFC3339(val, &c.UpgradePauseStartTimestampUTC)
			delete(rawMsg, key)
		case "upgradeWave":
			err = unpopulate(val, &c.UpgradeWave)
			delete(rawMsg, key)
		case "vmImage":
			err = unpopulate(val, &c.VMImage)
			delete(rawMsg, key)
		case "vmssZonalUpgradeMode":
			err = unpopulate(val, &c.VmssZonalUpgradeMode)
			delete(rawMsg, key)
		case "waveUpgradePaused":
			err = unpopulate(val, &c.WaveUpgradePaused)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ClusterPropertiesUpdateParameters - Describes the cluster resource properties that can be updated during PATCH operation.
type ClusterPropertiesUpdateParameters struct {
	// The list of add-on features to enable in the cluster.
	AddOnFeatures []*AddOnFeatures `json:"addOnFeatures,omitempty"`

	// The policy used to clean up unused versions.
	ApplicationTypeVersionsCleanupPolicy *ApplicationTypeVersionsCleanupPolicy `json:"applicationTypeVersionsCleanupPolicy,omitempty"`

	// The certificate to use for securing the cluster. The certificate provided will be used for node to node security within the cluster, SSL certificate
	// for cluster management endpoint and default admin
	// client.
	Certificate *CertificateDescription `json:"certificate,omitempty"`

	// Describes a list of server certificates referenced by common name that are used to secure the cluster.
	CertificateCommonNames *ServerCertificateCommonNames `json:"certificateCommonNames,omitempty"`

	// The list of client certificates referenced by common name that are allowed to manage the cluster. This will overwrite the existing list.
	ClientCertificateCommonNames []*ClientCertificateCommonName `json:"clientCertificateCommonNames,omitempty"`

	// The list of client certificates referenced by thumbprint that are allowed to manage the cluster. This will overwrite the existing list.
	ClientCertificateThumbprints []*ClientCertificateThumbprint `json:"clientCertificateThumbprints,omitempty"`

	// The Service Fabric runtime version of the cluster. This property can only by set the user when upgradeMode is set to 'Manual'. To get list of available
	// Service Fabric versions for new clusters use
	// ClusterVersion API [./ClusterVersion.md]. To get the list of available version for existing clusters use availableClusterVersions.
	ClusterCodeVersion *string `json:"clusterCodeVersion,omitempty"`

	// Indicates if the event store service is enabled.
	EventStoreServiceEnabled *bool `json:"eventStoreServiceEnabled,omitempty"`

	// The list of custom fabric settings to configure the cluster. This will overwrite the existing list.
	FabricSettings []*SettingsSectionDescription `json:"fabricSettings,omitempty"`

	// Indicates if infrastructure service manager is enabled.
	InfrastructureServiceManager *bool `json:"infrastructureServiceManager,omitempty"`

	// The list of node types in the cluster. This will overwrite the existing list.
	NodeTypes []*NodeTypeDescription `json:"nodeTypes,omitempty"`

	// Indicates a list of notification channels for cluster events.
	Notifications []*Notification `json:"notifications,omitempty"`

	// The reliability level sets the replica set size of system services. Learn about ReliabilityLevel [https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity].
	// * None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
	// * Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
	// * Silver - Run the System services with a target replica set count of 5.
	// * Gold - Run the System services with a target replica set count of 7.
	// * Platinum - Run the System services with a target replica set count of 9.
	ReliabilityLevel *ReliabilityLevel `json:"reliabilityLevel,omitempty"`

	// The server certificate used by reverse proxy.
	ReverseProxyCertificate *CertificateDescription `json:"reverseProxyCertificate,omitempty"`

	// This property controls the logical grouping of VMs in upgrade domains (UDs). This property can't be modified if a node type with multiple Availability
	// Zones is already present in the cluster.
	SfZonalUpgradeMode *SfZonalUpgradeMode `json:"sfZonalUpgradeMode,omitempty"`

	// The policy to use when upgrading the cluster.
	UpgradeDescription *ClusterUpgradePolicy `json:"upgradeDescription,omitempty"`

	// The upgrade mode of the cluster when new Service Fabric runtime version is available.
	UpgradeMode *UpgradeMode `json:"upgradeMode,omitempty"`

	// The end timestamp of pause runtime version upgrades on the cluster (UTC).
	UpgradePauseEndTimestampUTC *time.Time `json:"upgradePauseEndTimestampUtc,omitempty"`

	// The start timestamp to pause runtime version upgrades on the cluster (UTC).
	UpgradePauseStartTimestampUTC *time.Time `json:"upgradePauseStartTimestampUtc,omitempty"`

	// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when upgradeMode is set
	// to 'Automatic'.
	UpgradeWave *ClusterUpgradeCadence `json:"upgradeWave,omitempty"`

	// This property defines the upgrade mode for the virtual machine scale set, it is mandatory if a node type with multiple Availability Zones is added.
	VmssZonalUpgradeMode *VmssZonalUpgradeMode `json:"vmssZonalUpgradeMode,omitempty"`

	// Boolean to pause automatic runtime version upgrades to the cluster.
	WaveUpgradePaused *bool `json:"waveUpgradePaused,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPropertiesUpdateParameters.
func (c ClusterPropertiesUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "addOnFeatures", c.AddOnFeatures)
	populate(objectMap, "applicationTypeVersionsCleanupPolicy", c.ApplicationTypeVersionsCleanupPolicy)
	populate(objectMap, "certificate", c.Certificate)
	populate(objectMap, "certificateCommonNames", c.CertificateCommonNames)
	populate(objectMap, "clientCertificateCommonNames", c.ClientCertificateCommonNames)
	populate(objectMap, "clientCertificateThumbprints", c.ClientCertificateThumbprints)
	populate(objectMap, "clusterCodeVersion", c.ClusterCodeVersion)
	populate(objectMap, "eventStoreServiceEnabled", c.EventStoreServiceEnabled)
	populate(objectMap, "fabricSettings", c.FabricSettings)
	populate(objectMap, "infrastructureServiceManager", c.InfrastructureServiceManager)
	populate(objectMap, "nodeTypes", c.NodeTypes)
	populate(objectMap, "notifications", c.Notifications)
	populate(objectMap, "reliabilityLevel", c.ReliabilityLevel)
	populate(objectMap, "reverseProxyCertificate", c.ReverseProxyCertificate)
	populate(objectMap, "sfZonalUpgradeMode", c.SfZonalUpgradeMode)
	populate(objectMap, "upgradeDescription", c.UpgradeDescription)
	populate(objectMap, "upgradeMode", c.UpgradeMode)
	populateTimeRFC3339(objectMap, "upgradePauseEndTimestampUtc", c.UpgradePauseEndTimestampUTC)
	populateTimeRFC3339(objectMap, "upgradePauseStartTimestampUtc", c.UpgradePauseStartTimestampUTC)
	populate(objectMap, "upgradeWave", c.UpgradeWave)
	populate(objectMap, "vmssZonalUpgradeMode", c.VmssZonalUpgradeMode)
	populate(objectMap, "waveUpgradePaused", c.WaveUpgradePaused)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterPropertiesUpdateParameters.
func (c *ClusterPropertiesUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addOnFeatures":
			err = unpopulate(val, &c.AddOnFeatures)
			delete(rawMsg, key)
		case "applicationTypeVersionsCleanupPolicy":
			err = unpopulate(val, &c.ApplicationTypeVersionsCleanupPolicy)
			delete(rawMsg, key)
		case "certificate":
			err = unpopulate(val, &c.Certificate)
			delete(rawMsg, key)
		case "certificateCommonNames":
			err = unpopulate(val, &c.CertificateCommonNames)
			delete(rawMsg, key)
		case "clientCertificateCommonNames":
			err = unpopulate(val, &c.ClientCertificateCommonNames)
			delete(rawMsg, key)
		case "clientCertificateThumbprints":
			err = unpopulate(val, &c.ClientCertificateThumbprints)
			delete(rawMsg, key)
		case "clusterCodeVersion":
			err = unpopulate(val, &c.ClusterCodeVersion)
			delete(rawMsg, key)
		case "eventStoreServiceEnabled":
			err = unpopulate(val, &c.EventStoreServiceEnabled)
			delete(rawMsg, key)
		case "fabricSettings":
			err = unpopulate(val, &c.FabricSettings)
			delete(rawMsg, key)
		case "infrastructureServiceManager":
			err = unpopulate(val, &c.InfrastructureServiceManager)
			delete(rawMsg, key)
		case "nodeTypes":
			err = unpopulate(val, &c.NodeTypes)
			delete(rawMsg, key)
		case "notifications":
			err = unpopulate(val, &c.Notifications)
			delete(rawMsg, key)
		case "reliabilityLevel":
			err = unpopulate(val, &c.ReliabilityLevel)
			delete(rawMsg, key)
		case "reverseProxyCertificate":
			err = unpopulate(val, &c.ReverseProxyCertificate)
			delete(rawMsg, key)
		case "sfZonalUpgradeMode":
			err = unpopulate(val, &c.SfZonalUpgradeMode)
			delete(rawMsg, key)
		case "upgradeDescription":
			err = unpopulate(val, &c.UpgradeDescription)
			delete(rawMsg, key)
		case "upgradeMode":
			err = unpopulate(val, &c.UpgradeMode)
			delete(rawMsg, key)
		case "upgradePauseEndTimestampUtc":
			err = unpopulateTimeRFC3339(val, &c.UpgradePauseEndTimestampUTC)
			delete(rawMsg, key)
		case "upgradePauseStartTimestampUtc":
			err = unpopulateTimeRFC3339(val, &c.UpgradePauseStartTimestampUTC)
			delete(rawMsg, key)
		case "upgradeWave":
			err = unpopulate(val, &c.UpgradeWave)
			delete(rawMsg, key)
		case "vmssZonalUpgradeMode":
			err = unpopulate(val, &c.VmssZonalUpgradeMode)
			delete(rawMsg, key)
		case "waveUpgradePaused":
			err = unpopulate(val, &c.WaveUpgradePaused)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ClusterUpdateParameters - Cluster update request
type ClusterUpdateParameters struct {
	// Describes the cluster resource properties that can be updated during PATCH operation.
	Properties *ClusterPropertiesUpdateParameters `json:"properties,omitempty"`

	// Cluster update parameters
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateParameters.
func (c ClusterUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// ClusterUpgradeDeltaHealthPolicy - Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of applications health degradation allowed during cluster upgrades. The delta is measured between the state
	// of the applications at the beginning of upgrade and the state
	// of the applications at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion to make sure the global
	// state of the cluster is within tolerated limits.
	// System services are not included in this.
	MaxPercentDeltaUnhealthyApplications *int32 `json:"maxPercentDeltaUnhealthyApplications,omitempty"`

	// REQUIRED; The maximum allowed percentage of nodes health degradation allowed during cluster upgrades. The delta is measured between the state of the
	// nodes at the beginning of upgrade and the state of the nodes
	// at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster
	// is within tolerated limits.
	MaxPercentDeltaUnhealthyNodes *int32 `json:"maxPercentDeltaUnhealthyNodes,omitempty"`

	// REQUIRED; The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades. The delta is measured between the
	// state of the upgrade domain nodes at the beginning of
	// upgrade and the state of the upgrade domain nodes at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion
	// for all completed upgrade domains to make
	// sure the state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes *int32 `json:"maxPercentUpgradeDomainDeltaUnhealthyNodes,omitempty"`

	// Defines the application delta health policy map used to evaluate the health of an application or one of its child entities when upgrading the cluster.
	ApplicationDeltaHealthPolicies map[string]*ApplicationDeltaHealthPolicy `json:"applicationDeltaHealthPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpgradeDeltaHealthPolicy.
func (c ClusterUpgradeDeltaHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationDeltaHealthPolicies", c.ApplicationDeltaHealthPolicies)
	populate(objectMap, "maxPercentDeltaUnhealthyApplications", c.MaxPercentDeltaUnhealthyApplications)
	populate(objectMap, "maxPercentDeltaUnhealthyNodes", c.MaxPercentDeltaUnhealthyNodes)
	populate(objectMap, "maxPercentUpgradeDomainDeltaUnhealthyNodes", c.MaxPercentUpgradeDomainDeltaUnhealthyNodes)
	return json.Marshal(objectMap)
}

// ClusterUpgradePolicy - Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicy struct {
	// REQUIRED; The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be
	// in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout *string `json:"healthCheckRetryTimeout,omitempty"`

	// REQUIRED; The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration
	// can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration *string `json:"healthCheckStableDuration,omitempty"`

	// REQUIRED; The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in
	// d.hh:mm:ss.ms format.
	HealthCheckWaitDuration *string `json:"healthCheckWaitDuration,omitempty"`

	// REQUIRED; The cluster health policy used when upgrading the cluster.
	HealthPolicy *ClusterHealthPolicy `json:"healthPolicy,omitempty"`

	// REQUIRED; The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
	// format.
	UpgradeDomainTimeout *string `json:"upgradeDomainTimeout,omitempty"`

	// REQUIRED; The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When
	// this timeout expires, processing of the upgrade domain will
	// proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in
	// d.hh:mm:ss.ms format.
	UpgradeReplicaSetCheckTimeout *string `json:"upgradeReplicaSetCheckTimeout,omitempty"`

	// REQUIRED; The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
	// format.
	UpgradeTimeout *string `json:"upgradeTimeout,omitempty"`

	// The cluster delta health policy used when upgrading the cluster.
	DeltaHealthPolicy *ClusterUpgradeDeltaHealthPolicy `json:"deltaHealthPolicy,omitempty"`

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or
	// data).
	ForceRestart *bool `json:"forceRestart,omitempty"`
}

// ClusterVersionDetails - The detail of the Service Fabric runtime version result
type ClusterVersionDetails struct {
	// The Service Fabric runtime version of the cluster.
	CodeVersion *string `json:"codeVersion,omitempty"`

	// Indicates if this version is for Windows or Linux operating system.
	Environment *ClusterEnvironment `json:"environment,omitempty"`

	// The date of expiry of support of the version.
	SupportExpiryUTC *string `json:"supportExpiryUtc,omitempty"`
}

// ClusterVersionsGetByEnvironmentOptions contains the optional parameters for the ClusterVersions.GetByEnvironment method.
type ClusterVersionsGetByEnvironmentOptions struct {
	// placeholder for future optional parameters
}

// ClusterVersionsGetOptions contains the optional parameters for the ClusterVersions.Get method.
type ClusterVersionsGetOptions struct {
	// placeholder for future optional parameters
}

// ClusterVersionsListByEnvironmentOptions contains the optional parameters for the ClusterVersions.ListByEnvironment method.
type ClusterVersionsListByEnvironmentOptions struct {
	// placeholder for future optional parameters
}

// ClusterVersionsListOptions contains the optional parameters for the ClusterVersions.List method.
type ClusterVersionsListOptions struct {
	// placeholder for future optional parameters
}

// ClustersBeginCreateOrUpdateOptions contains the optional parameters for the Clusters.BeginCreateOrUpdate method.
type ClustersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ClustersBeginUpdateOptions contains the optional parameters for the Clusters.BeginUpdate method.
type ClustersBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ClustersDeleteOptions contains the optional parameters for the Clusters.Delete method.
type ClustersDeleteOptions struct {
	// placeholder for future optional parameters
}

// ClustersGetOptions contains the optional parameters for the Clusters.Get method.
type ClustersGetOptions struct {
	// placeholder for future optional parameters
}

// ClustersListByResourceGroupOptions contains the optional parameters for the Clusters.ListByResourceGroup method.
type ClustersListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ClustersListOptions contains the optional parameters for the Clusters.List method.
type ClustersListOptions struct {
	// placeholder for future optional parameters
}

// ClustersListUpgradableVersionsOptions contains the optional parameters for the Clusters.ListUpgradableVersions method.
type ClustersListUpgradableVersionsOptions struct {
	// The upgrade path description with target version.
	VersionsDescription *UpgradableVersionsDescription
}

// DiagnosticsStorageAccountConfig - The storage account information for storing Service Fabric diagnostic logs.
type DiagnosticsStorageAccountConfig struct {
	// REQUIRED; The blob endpoint of the azure storage account.
	BlobEndpoint *string `json:"blobEndpoint,omitempty"`

	// REQUIRED; The protected diagnostics storage key name.
	ProtectedAccountKeyName *string `json:"protectedAccountKeyName,omitempty"`

	// REQUIRED; The queue endpoint of the azure storage account.
	QueueEndpoint *string `json:"queueEndpoint,omitempty"`

	// REQUIRED; The Azure storage account name.
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// REQUIRED; The table endpoint of the azure storage account.
	TableEndpoint *string `json:"tableEndpoint,omitempty"`

	// The secondary protected diagnostics storage key name. If one of the storage account keys is rotated the cluster will fallback to using the other.
	ProtectedAccountKeyName2 *string `json:"protectedAccountKeyName2,omitempty"`
}

// EndpointRangeDescription - Port range details
type EndpointRangeDescription struct {
	// REQUIRED; End port of a range of ports
	EndPort *int32 `json:"endPort,omitempty"`

	// REQUIRED; Starting port of a range of ports
	StartPort *int32 `json:"startPort,omitempty"`
}

// ErrorModel - The structure of the error.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorModel struct {
	raw string
	// The error details.
	InnerError *ErrorModelError `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorModel.
// The contents of the error text are not contractual and subject to change.
func (e ErrorModel) Error() string {
	return e.raw
}

// ErrorModelError - The error details.
type ErrorModelError struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`
}

// ManagedIdentity - Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType `json:"type,omitempty"`

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentity.
func (m ManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// NamedPartitionSchemeDescription - Describes the named partition scheme of the service.
type NamedPartitionSchemeDescription struct {
	PartitionSchemeDescription
	// REQUIRED; The number of partitions.
	Count *int32 `json:"count,omitempty"`

	// REQUIRED; Array of size specified by the count parameter, for the names of the partitions.
	Names []*string `json:"names,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NamedPartitionSchemeDescription.
func (n NamedPartitionSchemeDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.PartitionSchemeDescription.marshalInternal(objectMap, PartitionSchemeNamed)
	populate(objectMap, "count", n.Count)
	populate(objectMap, "names", n.Names)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NamedPartitionSchemeDescription.
func (n *NamedPartitionSchemeDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, &n.Count)
			delete(rawMsg, key)
		case "names":
			err = unpopulate(val, &n.Names)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.PartitionSchemeDescription.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NodeTypeDescription - Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
type NodeTypeDescription struct {
	// REQUIRED; The TCP cluster management endpoint port.
	ClientConnectionEndpointPort *int32 `json:"clientConnectionEndpointPort,omitempty"`

	// REQUIRED; The HTTP cluster management endpoint port.
	HTTPGatewayEndpointPort *int32 `json:"httpGatewayEndpointPort,omitempty"`

	// REQUIRED; The node type on which system services will run. Only one node type should be marked as primary. Primary node type cannot be deleted or changed
	// for existing clusters.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// REQUIRED; The name of the node type.
	Name *string `json:"name,omitempty"`

	// REQUIRED; VMInstanceCount should be 1 to n, where n indicates the number of VM instances corresponding to this nodeType. VMInstanceCount = 0 can be done
	// only in these scenarios: NodeType is a secondary
	// nodeType. Durability = Bronze or Durability >= Bronze and InfrastructureServiceManager = true. If VMInstanceCount = 0, implies the VMs for this nodeType
	// will not be used for the initial cluster size
	// computation.
	VMInstanceCount *int32 `json:"vmInstanceCount,omitempty"`

	// The range of ports from which cluster assigned port to Service Fabric applications.
	ApplicationPorts *EndpointRangeDescription `json:"applicationPorts,omitempty"`

	// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
	Capacities map[string]*string `json:"capacities,omitempty"`

	// The durability level of the node type. Learn about DurabilityLevel [https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity].
	// * Bronze - No privileges. This is the default.
	// * Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
	// * Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold durability can be enabled only on full node VM skus like D15_V2,
	// G5 etc.
	DurabilityLevel *DurabilityLevel `json:"durabilityLevel,omitempty"`

	// The range of ephemeral ports that nodes in this node type should be configured with.
	EphemeralPorts *EndpointRangeDescription `json:"ephemeralPorts,omitempty"`

	// Indicates if the node type can only host Stateless workloads.
	IsStateless *bool `json:"isStateless,omitempty"`

	// Indicates if the node type is enabled to support multiple zones.
	MultipleAvailabilityZones *bool `json:"multipleAvailabilityZones,omitempty"`

	// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
	PlacementProperties map[string]*string `json:"placementProperties,omitempty"`

	// The endpoint used by reverse proxy.
	ReverseProxyEndpointPort *int32 `json:"reverseProxyEndpointPort,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeDescription.
func (n NodeTypeDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationPorts", n.ApplicationPorts)
	populate(objectMap, "capacities", n.Capacities)
	populate(objectMap, "clientConnectionEndpointPort", n.ClientConnectionEndpointPort)
	populate(objectMap, "durabilityLevel", n.DurabilityLevel)
	populate(objectMap, "ephemeralPorts", n.EphemeralPorts)
	populate(objectMap, "httpGatewayEndpointPort", n.HTTPGatewayEndpointPort)
	populate(objectMap, "isPrimary", n.IsPrimary)
	populate(objectMap, "isStateless", n.IsStateless)
	populate(objectMap, "multipleAvailabilityZones", n.MultipleAvailabilityZones)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "placementProperties", n.PlacementProperties)
	populate(objectMap, "reverseProxyEndpointPort", n.ReverseProxyEndpointPort)
	populate(objectMap, "vmInstanceCount", n.VMInstanceCount)
	return json.Marshal(objectMap)
}

// Notification - Describes the notification channel for cluster events.
type Notification struct {
	// REQUIRED; Indicates if the notification is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// REQUIRED; The category of notification.
	NotificationCategory *NotificationCategory `json:"notificationCategory,omitempty"`

	// REQUIRED; The level of notification.
	NotificationLevel *NotificationLevel `json:"notificationLevel,omitempty"`

	// REQUIRED; List of targets that subscribe to the notification.
	NotificationTargets []*NotificationTarget `json:"notificationTargets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Notification.
func (n Notification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isEnabled", n.IsEnabled)
	populate(objectMap, "notificationCategory", n.NotificationCategory)
	populate(objectMap, "notificationLevel", n.NotificationLevel)
	populate(objectMap, "notificationTargets", n.NotificationTargets)
	return json.Marshal(objectMap)
}

// NotificationTarget - Describes the notification target properties.
type NotificationTarget struct {
	// REQUIRED; The notification channel indicates the type of receivers subscribed to the notification, either user or subscription.
	NotificationChannel *NotificationChannel `json:"notificationChannel,omitempty"`

	// REQUIRED; List of targets that subscribe to the notification.
	Receivers []*string `json:"receivers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotificationTarget.
func (n NotificationTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "notificationChannel", n.NotificationChannel)
	populate(objectMap, "receivers", n.Receivers)
	return json.Marshal(objectMap)
}

// OperationListResult - Describes the result of the request to list Service Fabric resource provider operations.
type OperationListResult struct {
	// List of operations supported by the Service Fabric resource provider.
	Value []*OperationResult `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationResult - Available operation list result
type OperationResult struct {
	// The object that represents the operation.
	Display *AvailableOperationDisplay `json:"display,omitempty"`

	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// The name of the operation.
	Name *string `json:"name,omitempty"`

	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Origin result
	Origin *string `json:"origin,omitempty"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PartitionSchemeDescriptionClassification provides polymorphic access to related types.
// Call the interface's GetPartitionSchemeDescription() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *NamedPartitionSchemeDescription, *PartitionSchemeDescription, *SingletonPartitionSchemeDescription, *UniformInt64RangePartitionSchemeDescription
type PartitionSchemeDescriptionClassification interface {
	// GetPartitionSchemeDescription returns the PartitionSchemeDescription content of the underlying type.
	GetPartitionSchemeDescription() *PartitionSchemeDescription
}

// PartitionSchemeDescription - Describes how the service is partitioned.
type PartitionSchemeDescription struct {
	// REQUIRED; Specifies how the service is partitioned.
	PartitionScheme *PartitionScheme `json:"partitionScheme,omitempty"`
}

// GetPartitionSchemeDescription implements the PartitionSchemeDescriptionClassification interface for type PartitionSchemeDescription.
func (p *PartitionSchemeDescription) GetPartitionSchemeDescription() *PartitionSchemeDescription {
	return p
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PartitionSchemeDescription.
func (p *PartitionSchemeDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return p.unmarshalInternal(rawMsg)
}

func (p PartitionSchemeDescription) marshalInternal(objectMap map[string]interface{}, discValue PartitionScheme) {
	p.PartitionScheme = &discValue
	objectMap["partitionScheme"] = p.PartitionScheme
}

func (p *PartitionSchemeDescription) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionScheme":
			err = unpopulate(val, &p.PartitionScheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProxyResource - The resource model definition for proxy-only resource.
type ProxyResource struct {
	// It will be deprecated in New API, resource location depends on the parent resource.
	Location *string `json:"location,omitempty"`

	// Azure resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Azure resource etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProxyResource.
func (p ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyResource.
func (p *ProxyResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return p.unmarshalInternal(rawMsg)
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
}

func (p *ProxyResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &p.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &p.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - The resource model definition.
type Resource struct {
	// REQUIRED; Azure resource location.
	Location *string `json:"location,omitempty"`

	// Azure resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Azure resource etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Azure resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// ServerCertificateCommonName - Describes the server certificate details using common name.
type ServerCertificateCommonName struct {
	// REQUIRED; The common name of the server certificate.
	CertificateCommonName *string `json:"certificateCommonName,omitempty"`

	// REQUIRED; The issuer thumbprint of the server certificate.
	CertificateIssuerThumbprint *string `json:"certificateIssuerThumbprint,omitempty"`
}

// ServerCertificateCommonNames - Describes a list of server certificates referenced by common name that are used to secure the cluster.
type ServerCertificateCommonNames struct {
	// The list of server certificates referenced by common name that are used to secure the cluster.
	CommonNames []*ServerCertificateCommonName `json:"commonNames,omitempty"`

	// The local certificate store location.
	X509StoreName *StoreName `json:"x509StoreName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerCertificateCommonNames.
func (s ServerCertificateCommonNames) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commonNames", s.CommonNames)
	populate(objectMap, "x509StoreName", s.X509StoreName)
	return json.Marshal(objectMap)
}

// ServiceCorrelationDescription - Creates a particular correlation between services.
type ServiceCorrelationDescription struct {
	// REQUIRED; The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme *ServiceCorrelationScheme `json:"scheme,omitempty"`

	// REQUIRED; The name of the service that the correlation relationship is established with.
	ServiceName *string `json:"serviceName,omitempty"`
}

// ServiceLoadMetricDescription - Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricDescription struct {
	// REQUIRED; The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified
	// in Name exactly. Note that metric names are case sensitive.
	Name *string `json:"name,omitempty"`

	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int32 `json:"defaultLoad,omitempty"`

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int32 `json:"primaryDefaultLoad,omitempty"`

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int32 `json:"secondaryDefaultLoad,omitempty"`

	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *ServiceLoadMetricWeight `json:"weight,omitempty"`
}

// ServicePlacementPolicyDescriptionClassification provides polymorphic access to related types.
// Call the interface's GetServicePlacementPolicyDescription() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ServicePlacementPolicyDescription
type ServicePlacementPolicyDescriptionClassification interface {
	// GetServicePlacementPolicyDescription returns the ServicePlacementPolicyDescription content of the underlying type.
	GetServicePlacementPolicyDescription() *ServicePlacementPolicyDescription
}

// ServicePlacementPolicyDescription - Describes the policy to be used for placement of a Service Fabric service.
type ServicePlacementPolicyDescription struct {
	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType `json:"type,omitempty"`
}

// GetServicePlacementPolicyDescription implements the ServicePlacementPolicyDescriptionClassification interface for type ServicePlacementPolicyDescription.
func (s *ServicePlacementPolicyDescription) GetServicePlacementPolicyDescription() *ServicePlacementPolicyDescription {
	return s
}

// ServiceResource - The service resource.
type ServiceResource struct {
	ProxyResource
	// The service resource properties.
	Properties ServiceResourcePropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResource.
func (s ServiceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResource.
func (s *ServiceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			s.Properties, err = unmarshalServiceResourcePropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceResourceList - The list of service resources.
type ServiceResourceList struct {
	Value []*ServiceResource `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of service list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResourceList.
func (s ServiceResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceResourcePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetServiceResourceProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ServiceResourceProperties, *StatefulServiceProperties, *StatelessServiceProperties
type ServiceResourcePropertiesClassification interface {
	// GetServiceResourceProperties returns the ServiceResourceProperties content of the underlying type.
	GetServiceResourceProperties() *ServiceResourceProperties
}

// ServiceResourceProperties - The service resource properties.
type ServiceResourceProperties struct {
	ServiceResourcePropertiesBase
	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind `json:"serviceKind,omitempty"`

	// Describes how the service is partitioned.
	PartitionDescription PartitionSchemeDescriptionClassification `json:"partitionDescription,omitempty"`

	// Dns name used for the service. If this is specified, then the service can be accessed via its DNS name instead of service name.
	ServiceDNSName *string `json:"serviceDnsName,omitempty"`

	// The activation Mode of the service package
	ServicePackageActivationMode *ArmServicePackageActivationMode `json:"servicePackageActivationMode,omitempty"`

	// The name of the service type
	ServiceTypeName *string `json:"serviceTypeName,omitempty"`

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type ServiceResourceProperties.
func (s *ServiceResourceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return s
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourceProperties.
func (s *ServiceResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s ServiceResourceProperties) marshalInternal(objectMap map[string]interface{}, discValue ServiceKind) {
	s.ServiceResourcePropertiesBase.marshalInternal(objectMap)
	populate(objectMap, "partitionDescription", s.PartitionDescription)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "serviceDnsName", s.ServiceDNSName)
	s.ServiceKind = &discValue
	objectMap["serviceKind"] = s.ServiceKind
	populate(objectMap, "servicePackageActivationMode", s.ServicePackageActivationMode)
	populate(objectMap, "serviceTypeName", s.ServiceTypeName)
}

func (s *ServiceResourceProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionDescription":
			s.PartitionDescription, err = unmarshalPartitionSchemeDescriptionClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "serviceDnsName":
			err = unpopulate(val, &s.ServiceDNSName)
			delete(rawMsg, key)
		case "serviceKind":
			err = unpopulate(val, &s.ServiceKind)
			delete(rawMsg, key)
		case "servicePackageActivationMode":
			err = unpopulate(val, &s.ServicePackageActivationMode)
			delete(rawMsg, key)
		case "serviceTypeName":
			err = unpopulate(val, &s.ServiceTypeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourcePropertiesBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceResourcePropertiesBase - The common service resource properties.
type ServiceResourcePropertiesBase struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelationDescription `json:"correlationScheme,omitempty"`

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost `json:"defaultMoveCost,omitempty"`

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular
	// nodes based on the service requirements. For
	// example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `json:"placementConstraints,omitempty"`

	// The service load metrics is given as an array of ServiceLoadMetricDescription objects.
	ServiceLoadMetrics []*ServiceLoadMetricDescription `json:"serviceLoadMetrics,omitempty"`

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyDescriptionClassification `json:"servicePlacementPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResourcePropertiesBase.
func (s ServiceResourcePropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourcePropertiesBase.
func (s *ServiceResourcePropertiesBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s ServiceResourcePropertiesBase) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "correlationScheme", s.CorrelationScheme)
	populate(objectMap, "defaultMoveCost", s.DefaultMoveCost)
	populate(objectMap, "placementConstraints", s.PlacementConstraints)
	populate(objectMap, "serviceLoadMetrics", s.ServiceLoadMetrics)
	populate(objectMap, "servicePlacementPolicies", s.ServicePlacementPolicies)
}

func (s *ServiceResourcePropertiesBase) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationScheme":
			err = unpopulate(val, &s.CorrelationScheme)
			delete(rawMsg, key)
		case "defaultMoveCost":
			err = unpopulate(val, &s.DefaultMoveCost)
			delete(rawMsg, key)
		case "placementConstraints":
			err = unpopulate(val, &s.PlacementConstraints)
			delete(rawMsg, key)
		case "serviceLoadMetrics":
			err = unpopulate(val, &s.ServiceLoadMetrics)
			delete(rawMsg, key)
		case "servicePlacementPolicies":
			s.ServicePlacementPolicies, err = unmarshalServicePlacementPolicyDescriptionClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceResourceUpdate - The service resource for patch operations.
type ServiceResourceUpdate struct {
	ProxyResource
	// The service resource properties for patch operations.
	Properties ServiceResourceUpdatePropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResourceUpdate.
func (s ServiceResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourceUpdate.
func (s *ServiceResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			s.Properties, err = unmarshalServiceResourceUpdatePropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceResourceUpdatePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetServiceResourceUpdateProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ServiceResourceUpdateProperties, *StatefulServiceUpdateProperties, *StatelessServiceUpdateProperties
type ServiceResourceUpdatePropertiesClassification interface {
	// GetServiceResourceUpdateProperties returns the ServiceResourceUpdateProperties content of the underlying type.
	GetServiceResourceUpdateProperties() *ServiceResourceUpdateProperties
}

// ServiceResourceUpdateProperties - The service resource properties for patch operations.
type ServiceResourceUpdateProperties struct {
	ServiceResourcePropertiesBase
	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind `json:"serviceKind,omitempty"`
}

// GetServiceResourceUpdateProperties implements the ServiceResourceUpdatePropertiesClassification interface for type ServiceResourceUpdateProperties.
func (s *ServiceResourceUpdateProperties) GetServiceResourceUpdateProperties() *ServiceResourceUpdateProperties {
	return s
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourceUpdateProperties.
func (s *ServiceResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s ServiceResourceUpdateProperties) marshalInternal(objectMap map[string]interface{}, discValue ServiceKind) {
	s.ServiceResourcePropertiesBase.marshalInternal(objectMap)
	s.ServiceKind = &discValue
	objectMap["serviceKind"] = s.ServiceKind
}

func (s *ServiceResourceUpdateProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "serviceKind":
			err = unpopulate(val, &s.ServiceKind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourcePropertiesBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServiceTypeDeltaHealthPolicy - Represents the delta health policy used to evaluate the health of services belonging to a service type when upgrading
// the cluster.
type ServiceTypeDeltaHealthPolicy struct {
	// The maximum allowed percentage of services health degradation allowed during cluster upgrades. The delta is measured between the state of the services
	// at the beginning of upgrade and the state of the
	// services at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion to make sure the global state of
	// the cluster is within tolerated limits.
	MaxPercentDeltaUnhealthyServices *int32 `json:"maxPercentDeltaUnhealthyServices,omitempty"`
}

// ServiceTypeHealthPolicy - Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// The maximum percentage of services allowed to be unhealthy before your application is considered in error.
	MaxPercentUnhealthyServices *int32 `json:"maxPercentUnhealthyServices,omitempty"`
}

// ServicesBeginCreateOrUpdateOptions contains the optional parameters for the Services.BeginCreateOrUpdate method.
type ServicesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginDeleteOptions contains the optional parameters for the Services.BeginDelete method.
type ServicesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginUpdateOptions contains the optional parameters for the Services.BeginUpdate method.
type ServicesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesGetOptions contains the optional parameters for the Services.Get method.
type ServicesGetOptions struct {
	// placeholder for future optional parameters
}

// ServicesListOptions contains the optional parameters for the Services.List method.
type ServicesListOptions struct {
	// placeholder for future optional parameters
}

// SettingsParameterDescription - Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// REQUIRED; The parameter name of fabric setting.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The parameter value of fabric setting.
	Value *string `json:"value,omitempty"`
}

// SettingsSectionDescription - Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// REQUIRED; The section name of the fabric settings.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The collection of parameters in the section.
	Parameters []*SettingsParameterDescription `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SettingsSectionDescription.
func (s SettingsSectionDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	return json.Marshal(objectMap)
}

// SingletonPartitionSchemeDescription
type SingletonPartitionSchemeDescription struct {
	PartitionSchemeDescription
}

// MarshalJSON implements the json.Marshaller interface for type SingletonPartitionSchemeDescription.
func (s SingletonPartitionSchemeDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.PartitionSchemeDescription.marshalInternal(objectMap, PartitionSchemeSingleton)
	return json.Marshal(objectMap)
}

// StatefulServiceProperties - The properties of a stateful service resource.
type StatefulServiceProperties struct {
	ServiceResourceProperties
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not
	// it is false.
	HasPersistedState *bool `json:"hasPersistedState,omitempty"`

	// The minimum replica set size as a number.
	MinReplicaSetSize *int32 `json:"minReplicaSetSize,omitempty"`

	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
	QuorumLossWaitDuration *time.Time `json:"quorumLossWaitDuration,omitempty"`

	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
	ReplicaRestartWaitDuration *time.Time `json:"replicaRestartWaitDuration,omitempty"`

	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
	StandByReplicaKeepDuration *time.Time `json:"standByReplicaKeepDuration,omitempty"`

	// The target replica set size as a number.
	TargetReplicaSetSize *int32 `json:"targetReplicaSetSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StatefulServiceProperties.
func (s StatefulServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceResourceProperties.marshalInternal(objectMap, ServiceKindStateful)
	populate(objectMap, "hasPersistedState", s.HasPersistedState)
	populate(objectMap, "minReplicaSetSize", s.MinReplicaSetSize)
	populateTimeRFC3339(objectMap, "quorumLossWaitDuration", s.QuorumLossWaitDuration)
	populateTimeRFC3339(objectMap, "replicaRestartWaitDuration", s.ReplicaRestartWaitDuration)
	populateTimeRFC3339(objectMap, "standByReplicaKeepDuration", s.StandByReplicaKeepDuration)
	populate(objectMap, "targetReplicaSetSize", s.TargetReplicaSetSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatefulServiceProperties.
func (s *StatefulServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hasPersistedState":
			err = unpopulate(val, &s.HasPersistedState)
			delete(rawMsg, key)
		case "minReplicaSetSize":
			err = unpopulate(val, &s.MinReplicaSetSize)
			delete(rawMsg, key)
		case "quorumLossWaitDuration":
			err = unpopulateTimeRFC3339(val, &s.QuorumLossWaitDuration)
			delete(rawMsg, key)
		case "replicaRestartWaitDuration":
			err = unpopulateTimeRFC3339(val, &s.ReplicaRestartWaitDuration)
			delete(rawMsg, key)
		case "standByReplicaKeepDuration":
			err = unpopulateTimeRFC3339(val, &s.StandByReplicaKeepDuration)
			delete(rawMsg, key)
		case "targetReplicaSetSize":
			err = unpopulate(val, &s.TargetReplicaSetSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StatefulServiceUpdateProperties - The properties of a stateful service resource for patch operations.
type StatefulServiceUpdateProperties struct {
	ServiceResourceUpdateProperties
	// The minimum replica set size as a number.
	MinReplicaSetSize *int32 `json:"minReplicaSetSize,omitempty"`

	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
	QuorumLossWaitDuration *time.Time `json:"quorumLossWaitDuration,omitempty"`

	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
	ReplicaRestartWaitDuration *time.Time `json:"replicaRestartWaitDuration,omitempty"`

	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
	StandByReplicaKeepDuration *time.Time `json:"standByReplicaKeepDuration,omitempty"`

	// The target replica set size as a number.
	TargetReplicaSetSize *int32 `json:"targetReplicaSetSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StatefulServiceUpdateProperties.
func (s StatefulServiceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceResourceUpdateProperties.marshalInternal(objectMap, ServiceKindStateful)
	populate(objectMap, "minReplicaSetSize", s.MinReplicaSetSize)
	populateTimeRFC3339(objectMap, "quorumLossWaitDuration", s.QuorumLossWaitDuration)
	populateTimeRFC3339(objectMap, "replicaRestartWaitDuration", s.ReplicaRestartWaitDuration)
	populateTimeRFC3339(objectMap, "standByReplicaKeepDuration", s.StandByReplicaKeepDuration)
	populate(objectMap, "targetReplicaSetSize", s.TargetReplicaSetSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatefulServiceUpdateProperties.
func (s *StatefulServiceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "minReplicaSetSize":
			err = unpopulate(val, &s.MinReplicaSetSize)
			delete(rawMsg, key)
		case "quorumLossWaitDuration":
			err = unpopulateTimeRFC3339(val, &s.QuorumLossWaitDuration)
			delete(rawMsg, key)
		case "replicaRestartWaitDuration":
			err = unpopulateTimeRFC3339(val, &s.ReplicaRestartWaitDuration)
			delete(rawMsg, key)
		case "standByReplicaKeepDuration":
			err = unpopulateTimeRFC3339(val, &s.StandByReplicaKeepDuration)
			delete(rawMsg, key)
		case "targetReplicaSetSize":
			err = unpopulate(val, &s.TargetReplicaSetSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourceUpdateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StatelessServiceProperties - The properties of a stateless service resource.
type StatelessServiceProperties struct {
	ServiceResourceProperties
	// Delay duration for RequestDrain feature to ensures that the endpoint advertised by the stateless instance is removed before the delay starts prior to
	// closing the instance. This delay enables existing
	// requests to drain gracefully before the instance actually goes down
	// (https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview).
	// It is first interpreted as
	// a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
	InstanceCloseDelayDuration *string `json:"instanceCloseDelayDuration,omitempty"`

	// The instance count.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StatelessServiceProperties.
func (s StatelessServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceResourceProperties.marshalInternal(objectMap, ServiceKindStateless)
	populate(objectMap, "instanceCloseDelayDuration", s.InstanceCloseDelayDuration)
	populate(objectMap, "instanceCount", s.InstanceCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatelessServiceProperties.
func (s *StatelessServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceCloseDelayDuration":
			err = unpopulate(val, &s.InstanceCloseDelayDuration)
			delete(rawMsg, key)
		case "instanceCount":
			err = unpopulate(val, &s.InstanceCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StatelessServiceUpdateProperties - The properties of a stateless service resource for patch operations.
type StatelessServiceUpdateProperties struct {
	ServiceResourceUpdateProperties
	// Delay duration for RequestDrain feature to ensures that the endpoint advertised by the stateless instance is removed before the delay starts prior to
	// closing the instance. This delay enables existing
	// requests to drain gracefully before the instance actually goes down
	// (https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview).
	// It is first interpreted as
	// a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
	InstanceCloseDelayDuration *string `json:"instanceCloseDelayDuration,omitempty"`

	// The instance count.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StatelessServiceUpdateProperties.
func (s StatelessServiceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ServiceResourceUpdateProperties.marshalInternal(objectMap, ServiceKindStateless)
	populate(objectMap, "instanceCloseDelayDuration", s.InstanceCloseDelayDuration)
	populate(objectMap, "instanceCount", s.InstanceCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatelessServiceUpdateProperties.
func (s *StatelessServiceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceCloseDelayDuration":
			err = unpopulate(val, &s.InstanceCloseDelayDuration)
			delete(rawMsg, key)
		case "instanceCount":
			err = unpopulate(val, &s.InstanceCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ServiceResourceUpdateProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *string `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC).
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *string `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UniformInt64RangePartitionSchemeDescription - Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeDescription struct {
	PartitionSchemeDescription
	// REQUIRED; The number of partitions.
	Count *int32 `json:"count,omitempty"`

	// REQUIRED; String indicating the upper bound of the partition key range that should be split between the partition count
	HighKey *string `json:"highKey,omitempty"`

	// REQUIRED; String indicating the lower bound of the partition key range that should be split between the partition count
	LowKey *string `json:"lowKey,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UniformInt64RangePartitionSchemeDescription.
func (u UniformInt64RangePartitionSchemeDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.PartitionSchemeDescription.marshalInternal(objectMap, PartitionSchemeUniformInt64Range)
	populate(objectMap, "count", u.Count)
	populate(objectMap, "highKey", u.HighKey)
	populate(objectMap, "lowKey", u.LowKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UniformInt64RangePartitionSchemeDescription.
func (u *UniformInt64RangePartitionSchemeDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, &u.Count)
			delete(rawMsg, key)
		case "highKey":
			err = unpopulate(val, &u.HighKey)
			delete(rawMsg, key)
		case "lowKey":
			err = unpopulate(val, &u.LowKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.PartitionSchemeDescription.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UpgradableVersionPathResult - The list of intermediate cluster code versions for an upgrade or downgrade. Or minimum and maximum upgradable version if
// no target was given
type UpgradableVersionPathResult struct {
	SupportedPath []*string `json:"supportedPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpgradableVersionPathResult.
func (u UpgradableVersionPathResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "supportedPath", u.SupportedPath)
	return json.Marshal(objectMap)
}

type UpgradableVersionsDescription struct {
	// REQUIRED; The target code version.
	TargetVersion *string `json:"targetVersion,omitempty"`
}

type UserAssignedIdentity struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
