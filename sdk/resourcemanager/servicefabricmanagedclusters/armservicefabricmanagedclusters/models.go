// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armservicefabricmanagedclusters

import "time"

// AddRemoveIncrementalNamedPartitionScalingMechanism - Represents a scaling mechanism for adding or removing named partitions
// of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanism struct {
	// CONSTANT; Specifies the mechanism associated with this scaling policy.
	// Field has constant value ServiceScalingMechanismKindAddRemoveIncrementalNamedPartition, any specified value is ignored.
	Kind *ServiceScalingMechanismKind

	// REQUIRED; Maximum number of named partitions of the service.
	MaxPartitionCount *int32

	// REQUIRED; Minimum number of named partitions of the service.
	MinPartitionCount *int32

	// REQUIRED; The number of instances to add or remove during a scaling operation.
	ScaleIncrement *int32
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type AddRemoveIncrementalNamedPartitionScalingMechanism.
func (a *AddRemoveIncrementalNamedPartitionScalingMechanism) GetScalingMechanism() *ScalingMechanism {
	return &ScalingMechanism{
		Kind: a.Kind,
	}
}

// AdditionalNetworkInterfaceConfiguration - Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfiguration struct {
	// REQUIRED; Specifies the IP configurations of the network interface.
	IPConfigurations []*IPConfiguration

	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies the DSCP configuration to apply to the network interface.
	DscpConfiguration *SubResource

	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool
}

// ApplicationFetchHealthRequest - Parameters for fetching the health of an application.
type ApplicationFetchHealthRequest struct {
	// Allows filtering of the deployed applications health state objects returned in the result of application health query based
	// on their health state.
	DeployedApplicationsHealthStateFilter *HealthFilter

	// Allows filtering of the health events returned in the response based on health state.
	EventsHealthStateFilter *HealthFilter

	// Indicates whether the health statistics should be returned as part of the query result. False by default. The statistics
	// show the number of children entities in health state Ok, Warning, and Error.
	ExcludeHealthStatistics *bool

	// Allows filtering of the services health state objects returned in the result of services health query based on their health
	// state.
	ServicesHealthStateFilter *HealthFilter

	// Request timeout for the health query in seconds. The default value is 60 seconds.
	Timeout *int64
}

// ApplicationHealthPolicy - Defines a health policy used to evaluate the health of an application or one of its children
// entities.
type ApplicationHealthPolicy struct {
	// REQUIRED; Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError *bool

	// REQUIRED; The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to
	// 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application
	// is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application
	// is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications *int32

	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy

	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]*ServiceTypeHealthPolicy
}

// ApplicationResource - The application resource.
type ApplicationResource struct {
	// Describes the managed identities for an Azure resource.
	Identity *ManagedIdentity

	// The geo-location where the resource lives
	Location *string

	// The application resource properties.
	Properties *ApplicationResourceProperties

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// ApplicationResourceList - The list of application resources.
type ApplicationResourceList struct {
	// REQUIRED; The ApplicationResource items on this page
	Value []*ApplicationResource

	// The link to the next page of items
	NextLink *string
}

// ApplicationResourceProperties - The application resource properties.
type ApplicationResourceProperties struct {
	// List of user assigned identities for the application, each mapped to a friendly name.
	ManagedIdentities []*ApplicationUserAssignedIdentity

	// List of application parameters with overridden values from their default values specified in the application manifest.
	Parameters map[string]*string

	// Describes the policy for a monitored application upgrade.
	UpgradePolicy *ApplicationUpgradePolicy

	// The version of the application type as defined in the application manifest.
	// This name must be the full Arm Resource ID for the referenced application type version.
	Version *string

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// ApplicationTypeResource - The application type name resource
type ApplicationTypeResource struct {
	// The geo-location where the resource lives
	Location *string

	// The application type name properties
	Properties *ApplicationTypeResourceProperties

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// ApplicationTypeResourceList - The list of application type names.
type ApplicationTypeResourceList struct {
	// REQUIRED; The ApplicationTypeResource items on this page
	Value []*ApplicationTypeResource

	// The link to the next page of items
	NextLink *string
}

// ApplicationTypeResourceProperties - The application type name properties
type ApplicationTypeResourceProperties struct {
	// READ-ONLY; The current deployment or provisioning state, which only appears in the response.
	ProvisioningState *string
}

// ApplicationTypeUpdateParameters - Application type update request
type ApplicationTypeUpdateParameters struct {
	// Application type update parameters
	Tags map[string]*string
}

// ApplicationTypeVersionResource - An application type version resource for the specified application type name resource.
type ApplicationTypeVersionResource struct {
	// The geo-location where the resource lives
	Location *string

	// The properties of the application type version resource.
	Properties *ApplicationTypeVersionResourceProperties

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// ApplicationTypeVersionResourceList - The list of application type version resources for the specified application type
// name resource.
type ApplicationTypeVersionResourceList struct {
	// REQUIRED; The ApplicationTypeVersionResource items on this page
	Value []*ApplicationTypeVersionResource

	// The link to the next page of items
	NextLink *string
}

// ApplicationTypeVersionResourceProperties - The properties of the application type version resource.
type ApplicationTypeVersionResourceProperties struct {
	// REQUIRED; The URL to the application package
	AppPackageURL *string

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// ApplicationTypeVersionUpdateParameters - Application type version update request
type ApplicationTypeVersionUpdateParameters struct {
	// Application type version update parameters
	Tags map[string]*string
}

// ApplicationTypeVersionsCleanupPolicy - The policy used to clean up unused versions. When the policy is not specified explicitly,
// the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicy struct {
	// REQUIRED; Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep *int32
}

// ApplicationUpdateParameters - Application update request.
type ApplicationUpdateParameters struct {
	// Application update parameters properties.
	Properties *ApplicationUpdateParametersProperties

	// Application update parameters
	Tags map[string]*string
}

// ApplicationUpdateParametersProperties - Properties for application update request.
type ApplicationUpdateParametersProperties struct {
	// List of application parameters with overridden values from their default values specified in the application manifest.
	Parameters map[string]*string
}

// ApplicationUpgradePolicy - Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicy

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade
	// only changes configuration or data).
	ForceRestart *bool

	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This
	// would be effective when the instance is closing during the application/cluster upgrade, only for those instances which
	// have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *int64

	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters
	// are not allowed.
	RecreateApplication *bool

	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicy

	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *RollingUpgradeMode

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected
	// issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
	// 32-bit integer). Unit is in seconds.
	UpgradeReplicaSetCheckTimeout *int64
}

// ApplicationUserAssignedIdentity - User assigned identity for the application.
type ApplicationUserAssignedIdentity struct {
	// REQUIRED; The friendly name of user assigned identity.
	Name *string

	// REQUIRED; The principal id of user assigned identity.
	PrincipalID *string
}

// AvailableOperationDisplay - Operation supported by the Service Fabric resource provider
type AvailableOperationDisplay struct {
	// Operation description
	Description *string

	// The operation that can be performed.
	Operation *string

	// The name of the provider.
	Provider *string

	// The resource on which the operation is performed
	Resource *string
}

// AveragePartitionLoadScalingTrigger - Represents a scaling trigger related to an average load of a metric/resource of a
// partition.
type AveragePartitionLoadScalingTrigger struct {
	// CONSTANT; Specifies the trigger associated with this scaling policy.
	// Field has constant value ServiceScalingTriggerKindAveragePartitionLoadTrigger, any specified value is ignored.
	Kind *ServiceScalingTriggerKind

	// REQUIRED; The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold *float64

	// REQUIRED; The name of the metric for which usage should be tracked.
	MetricName *string

	// REQUIRED; The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601
	// format "hh:mm:ss".
	ScaleInterval *string

	// REQUIRED; The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold *float64
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type AveragePartitionLoadScalingTrigger.
func (a *AveragePartitionLoadScalingTrigger) GetScalingTrigger() *ScalingTrigger {
	return &ScalingTrigger{
		Kind: a.Kind,
	}
}

// AverageServiceLoadScalingTrigger - Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTrigger struct {
	// CONSTANT; Specifies the trigger associated with this scaling policy.
	// Field has constant value ServiceScalingTriggerKindAverageServiceLoadTrigger, any specified value is ignored.
	Kind *ServiceScalingTriggerKind

	// REQUIRED; The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold *float64

	// REQUIRED; The name of the metric for which usage should be tracked.
	MetricName *string

	// REQUIRED; The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601
	// format "hh:mm:ss".
	ScaleInterval *string

	// REQUIRED; The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold *float64

	// REQUIRED; Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then
	// trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load
	// of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad *bool
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type AverageServiceLoadScalingTrigger.
func (a *AverageServiceLoadScalingTrigger) GetScalingTrigger() *ScalingTrigger {
	return &ScalingTrigger{
		Kind: a.Kind,
	}
}

// AzureActiveDirectory - The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string

	// Azure active directory cluster application id.
	ClusterApplication *string

	// Azure active directory tenant id.
	TenantID *string
}

// ClientCertificate - Client certificate definition.
type ClientCertificate struct {
	// REQUIRED; Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read
	// only operations on the cluster.
	IsAdmin *bool

	// Certificate common name.
	CommonName *string

	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string

	// Certificate thumbprint.
	Thumbprint *string
}

// ClusterHealthPolicy - Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10%
	// of applications to be unhealthy, this value would be 10.
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is
	// considered in error.
	// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the
	// cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
	// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
	MaxPercentUnhealthyApplications *int32

	// REQUIRED; The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes
	// to be unhealthy, this value would be 10.
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered
	// in error.
	// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate
	// that.
	MaxPercentUnhealthyNodes *int32
}

// ClusterMonitoringPolicy - Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicy struct {
	// REQUIRED; The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade
	// rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout *string

	// REQUIRED; The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next
	// upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration *string

	// REQUIRED; The length of time to wait after completing an upgrade domain before performing health checks. The duration can
	// be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckWaitDuration *string

	// REQUIRED; The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either
	// hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeDomainTimeout *string

	// REQUIRED; The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either
	// hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeTimeout *string
}

// ClusterUpgradeDeltaHealthPolicy - Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time
	// of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within
	// tolerated limits.
	MaxPercentDeltaUnhealthyNodes *int32

	// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications
	// at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within
	// tolerated limits. System services are not included in this.
	// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
	MaxPercentDeltaUnhealthyApplications *int32

	// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade
	// domain nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the
	// state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes *int32
}

// ClusterUpgradePolicy - Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicy struct {
	// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	DeltaHealthPolicy *ClusterUpgradeDeltaHealthPolicy

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade
	// only changes configuration or data).
	ForceRestart *bool

	// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	HealthPolicy *ClusterHealthPolicy

	// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
	MonitoringPolicy *ClusterMonitoringPolicy

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected
	// issues.
	// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
	UpgradeReplicaSetCheckTimeout *string
}

// EndpointRangeDescription - Port range details
type EndpointRangeDescription struct {
	// REQUIRED; End port of a range of ports
	EndPort *int32

	// REQUIRED; Starting port of a range of ports
	StartPort *int32
}

// ErrorModelError - The error details.
type ErrorModelError struct {
	// The error code.
	Code *string

	// The error message.
	Message *string
}

// FaultSimulation - Fault simulation object with status.
type FaultSimulation struct {
	// Fault simulation details
	Details *FaultSimulationDetails

	// The end time of the fault simulation.
	EndTime *time.Time

	// unique identifier for the fault simulation.
	SimulationID *string

	// The start time of the fault simulation.
	StartTime *time.Time

	// Fault simulation status
	Status *FaultSimulationStatus
}

// FaultSimulationConstraints - Constraints for Fault Simulation action.
type FaultSimulationConstraints struct {
	// The absolute expiration timestamp (UTC) after which this fault simulation should be stopped if it's still active.
	ExpirationTime *time.Time
}

// FaultSimulationContent - Parameters for Fault Simulation action.
type FaultSimulationContent struct {
	// REQUIRED; The kind of fault to be simulated.
	FaultKind *FaultKind

	// Constraints for Fault Simulation action.
	Constraints *FaultSimulationConstraints

	// Force the action to go through without any check on the cluster.
	Force *bool
}

// GetFaultSimulationContent implements the FaultSimulationContentClassification interface for type FaultSimulationContent.
func (f *FaultSimulationContent) GetFaultSimulationContent() *FaultSimulationContent { return f }

// FaultSimulationContentWrapper - Fault Simulation Request for Start action.
type FaultSimulationContentWrapper struct {
	// REQUIRED; Parameters for Fault Simulation start action.
	Parameters FaultSimulationContentClassification
}

// FaultSimulationDetails - Details for Fault Simulation.
type FaultSimulationDetails struct {
	// unique identifier for the cluster resource.
	ClusterID *string

	// List of node type simulations associated with the cluster fault simulation.
	NodeTypeFaultSimulation []*NodeTypeFaultSimulation

	// unique identifier for the operation associated with the fault simulation.
	OperationID *string

	// Fault simulation parameters.
	Parameters FaultSimulationContentClassification
}

// FaultSimulationIDContent - Parameters for Fault Simulation id.
type FaultSimulationIDContent struct {
	// REQUIRED; unique identifier for the fault simulation.
	SimulationID *string
}

// FaultSimulationListResult - Fault simulation list results
type FaultSimulationListResult struct {
	// REQUIRED; The FaultSimulation items on this page
	Value []*FaultSimulation

	// The link to the next page of items
	NextLink *string
}

// FrontendConfiguration - Describes the frontend configurations for the node type.
type FrontendConfiguration struct {
	// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/backendAddressPools/{backendAddressPoolName}'.
	ApplicationGatewayBackendAddressPoolID *string

	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IPAddressType *IPAddressType

	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The
	// format of the resource Id is '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}'.
	LoadBalancerBackendAddressPoolID *string

	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format
	// of the resource Id is '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatPools/{inboundNatPoolName}'.
	LoadBalancerInboundNatPoolID *string
}

// IPConfiguration - Specifies an IP configuration of the network interface.
type IPConfiguration struct {
	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address
	// pools of multiple application gateways. Multiple node types cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []*SubResource

	// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address
	// pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerBackendAddressPools []*SubResource

	// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools
	// of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerInboundNatPools []*SubResource

	// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *PrivateIPAddressVersion

	// The public IP address configuration of the network interface.
	PublicIPAddressConfiguration *IPConfigurationPublicIPAddressConfiguration

	// Specifies the subnet of the network interface.
	Subnet *SubResource
}

// IPConfigurationPublicIPAddressConfiguration - The public IP address configuration of the network interface.
type IPConfigurationPublicIPAddressConfiguration struct {
	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies the list of IP tags associated with the public IP address.
	IPTags []*IPTag

	// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
	PublicIPAddressVersion *PublicIPAddressVersion
}

// IPTag - The IP tag associated with the public IP address.
type IPTag struct {
	// REQUIRED; IP tag type. Example: FirstPartyUsage.
	IPTagType *string

	// REQUIRED; IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string
}

// LoadBalancingRule - Describes a load balancing rule.
type LoadBalancingRule struct {
	// REQUIRED; The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort *int32

	// REQUIRED; The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable
	// values are between 1 and 65534.
	FrontendPort *int32

	// REQUIRED; the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol *ProbeProtocol

	// REQUIRED; The reference to the transport protocol used by the load balancing rule.
	Protocol *Protocol

	// The load distribution policy for this rule.
	LoadDistribution *string

	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int32

	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string
}

// LongRunningOperationResult - Long running operation result.
type LongRunningOperationResult struct {
	// The end time of the operation.
	EndTime *time.Time

	// The operation error.
	Error *ErrorModelError

	// The name of the operation.
	Name *string

	// The completion percentage of the operation.
	PercentComplete *float64

	// The start time of the operation.
	StartTime *time.Time

	// The status of the operation.
	Status *string
}

// ManagedAzResiliencyStatus - Describes the result of the request to list Managed VM Sizes for Service Fabric Managed Clusters.
type ManagedAzResiliencyStatus struct {
	// List of Managed VM Sizes for Service Fabric Managed Clusters.
	BaseResourceStatus []*ResourceAzStatus

	// READ-ONLY; URL to get the next set of Managed VM Sizes if there are any.
	IsClusterZoneResilient *bool
}

// ManagedCluster - The managed cluster resource
type ManagedCluster struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string

	// REQUIRED; The sku of the managed cluster
	SKU *SKU

	// The managed cluster resource properties
	Properties *ManagedClusterProperties

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
	// Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in
	// the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header
	// fields.",
	Etag *string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// ManagedClusterCodeVersionResult - The result of the Service Fabric runtime versions
type ManagedClusterCodeVersionResult struct {
	// The identification of the result
	ID *string

	// The name of the result
	Name *string

	// The detail of the Service Fabric runtime version result
	Properties *ManagedClusterVersionDetails

	// The result resource type
	Type *string
}

// ManagedClusterListResult - The response of a ManagedCluster list operation.
type ManagedClusterListResult struct {
	// REQUIRED; The ManagedCluster items on this page
	Value []*ManagedCluster

	// The link to the next page of items
	NextLink *string
}

// ManagedClusterProperties - Describes the managed cluster resource properties.
type ManagedClusterProperties struct {
	// REQUIRED; VM admin user name.
	AdminUserName *string

	// REQUIRED; The cluster dns name.
	DNSName *string

	// List of add-on features to enable on the cluster.
	AddonFeatures []*ManagedClusterAddOnFeature

	// VM admin user password.
	AdminPassword *string

	// The number of outbound ports allocated for SNAT for each node in the backend pool of the default load balancer. The default
	// value is 0 which provides dynamic port allocation based on pool size.
	AllocatedOutboundPorts *int32

	// Setting this to true enables RDP access to the VM. The default NSG rule opens RDP port to Internet which can be overridden
	// with custom Network Security Rules. The default value for this setting is false.
	AllowRdpAccess *bool

	// The policy used to clean up unused versions.
	ApplicationTypeVersionsCleanupPolicy *ApplicationTypeVersionsCleanupPolicy

	// This property is the entry point to using a public CA cert for your cluster cert. It specifies the level of reuse allowed
	// for the custom FQDN created, matching the subject of the public CA cert.
	AutoGeneratedDomainNameLabelScope *AutoGeneratedDomainNameLabelScope

	// Auxiliary subnets for the cluster.
	AuxiliarySubnets []*Subnet

	// The AAD authentication settings of the cluster.
	AzureActiveDirectory *AzureActiveDirectory

	// The port used for client connections to the cluster.
	ClientConnectionPort *int32

	// Client certificates that are allowed to manage the cluster.
	Clients []*ClientCertificate

	// The Service Fabric runtime version of the cluster. This property is required when **clusterUpgradeMode** is set to 'Manual'.
	// To get list of available Service Fabric versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To get
	// the list of available version for existing clusters use **availableClusterVersions**.
	ClusterCodeVersion *string

	// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only
	// applies when **clusterUpgradeMode** is set to 'Automatic'.
	ClusterUpgradeCadence *ClusterUpgradeCadence

	// The upgrade mode of the cluster when new Service Fabric runtime version is available.
	ClusterUpgradeMode *ClusterUpgradeMode

	// Specify the resource id of a DDoS network protection plan that will be associated with the virtual network of the cluster.
	DdosProtectionPlanID *string

	// Enables automatic OS upgrade for node types created using OS images with version 'latest'. The default value for this setting
	// is false.
	EnableAutoOSUpgrade *bool

	// If true, token-based authentication is not allowed on the HttpGatewayEndpoint. This is required to support TLS versions
	// 1.3 and above. If token-based authentication is used, HttpGatewayTokenAuthConnectionPort must be defined.
	EnableHTTPGatewayExclusiveAuthMode *bool

	// Setting this to true creates IPv6 address space for the default VNet used by the cluster. This setting cannot be changed
	// once the cluster is created. The default value for this setting is false.
	EnableIPv6 *bool

	// Enable the creation of node types with only outbound traffic enabled. If set, a separate load balancer backend pool will
	// be created for node types with inbound traffic enabled. Can only be set at the time of cluster creation.
	EnableOutboundOnlyNodeTypes *bool

	// Setting this to true will link the IPv4 address as the ServicePublicIP of the IPv6 address. It can only be set to True
	// if IPv6 is enabled on the cluster.
	EnableServicePublicIP *bool

	// The list of custom fabric settings to configure the cluster.
	FabricSettings []*SettingsSectionDescription

	// The port used for HTTP connections to the cluster.
	HTTPGatewayConnectionPort *int32

	// The port used for token-auth based HTTPS connections to the cluster. Cannot be set to the same port as HttpGatewayEndpoint.
	HTTPGatewayTokenAuthConnectionPort *int32

	// The list of IP tags associated with the default public IP address of the cluster.
	IPTags []*IPTag

	// Load balancing rules that are applied to the public load balancer of the cluster.
	LoadBalancingRules []*LoadBalancingRule

	// Custom Network Security Rules that are applied to the Virtual Network of the cluster.
	NetworkSecurityRules []*NetworkSecurityRule

	// Specify the resource id of a public IPv4 prefix that the load balancer will allocate a public IPv4 address from. This setting
	// cannot be changed once the cluster is created.
	PublicIPPrefixID *string

	// Specify the resource id of a public IPv6 prefix that the load balancer will allocate a public IPv6 address from. This setting
	// cannot be changed once the cluster is created.
	PublicIPv6PrefixID *string

	// Service endpoints for subnets in the cluster.
	ServiceEndpoints []*ServiceEndpoint

	// If specified, the node types for the cluster are created in this subnet instead of the default VNet. The **networkSecurityRules**
	// specified for the cluster are also applied to this subnet. This setting cannot be changed once the cluster is created.
	SubnetID *string

	// The policy to use when upgrading the cluster.
	UpgradeDescription *ClusterUpgradePolicy

	// For new clusters, this parameter indicates that it uses Bring your own VNet, but the subnet is specified at node type level;
	// and for such clusters, the subnetId property is required for node types.
	UseCustomVnet *bool

	// The VM image the node types are configured with. This property controls the Service Fabric component packages to be used
	// for the cluster. Allowed values are: 'Windows'. The default value is 'Windows'.
	VMImage *string

	// Indicates if the cluster has zone resiliency.
	ZonalResiliency *bool

	// Indicates the update mode for Cross Az clusters.
	ZonalUpdateMode *ZonalUpdateMode

	// READ-ONLY; List of thumbprints of the cluster certificates.
	ClusterCertificateThumbprints []*string

	// READ-ONLY; A service generated unique identifier for the cluster resource.
	ClusterID *string

	// READ-ONLY; The current state of the cluster.
	ClusterState *ClusterState

	// READ-ONLY; The fully qualified domain name associated with the public load balancer of the cluster.
	Fqdn *string

	// READ-ONLY; The IPv4 address associated with the public load balancer of the cluster.
	IPv4Address *string

	// READ-ONLY; IPv6 address for the cluster if IPv6 is enabled.
	IPv6Address *string

	// READ-ONLY; The provisioning state of the managed cluster resource.
	ProvisioningState *ManagedResourceProvisioningState
}

// ManagedClusterUpdateParameters - Managed cluster update request
type ManagedClusterUpdateParameters struct {
	// Managed cluster update parameters
	Tags map[string]*string
}

// ManagedClusterVersionDetails - The detail of the Service Fabric runtime version result
type ManagedClusterVersionDetails struct {
	// The Service Fabric runtime version of the cluster.
	ClusterCodeVersion *string

	// Cluster operating system, the default will be Windows
	OSType *OsType

	// The date of expiry of support of the version.
	SupportExpiryUTC *time.Time
}

// ManagedIdentity - Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource
	// ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserAssignedIdentity

	// READ-ONLY; The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalID *string

	// READ-ONLY; The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantID *string
}

// ManagedMaintenanceWindowStatus - Describes the maintenance window status of the Service Fabric Managed Cluster.
type ManagedMaintenanceWindowStatus struct {
	// READ-ONLY; If updates can be applied.
	CanApplyUpdates *bool

	// READ-ONLY; Indicates if the region is ready to configure maintenance windows.
	IsRegionReady *bool

	// READ-ONLY; If maintenance window is active.
	IsWindowActive *bool

	// READ-ONLY; If maintenance window is enabled on this cluster.
	IsWindowEnabled *bool

	// READ-ONLY; Last window end time in UTC.
	LastWindowEndTimeUTC *time.Time

	// READ-ONLY; Last window start time in UTC.
	LastWindowStartTimeUTC *time.Time

	// READ-ONLY; Last window update time in UTC.
	LastWindowStatusUpdateAtUTC *time.Time
}

// ManagedVMSize - Describes a VM Sizes.
type ManagedVMSize struct {
	// READ-ONLY; VM Size id.
	ID *string

	// READ-ONLY; VM Size name.
	Name *string

	// READ-ONLY; VM Size properties.
	Properties *VMSize

	// READ-ONLY; VM Size type.
	Type *string
}

// ManagedVMSizesResult - Describes the result of the request to list Managed VM Sizes for Service Fabric Managed Clusters.
type ManagedVMSizesResult struct {
	// REQUIRED; The ManagedVMSize items on this page
	Value []*ManagedVMSize

	// The link to the next page of items
	NextLink *string
}

// NamedPartitionScheme - Describes the named partition scheme of the service.
type NamedPartitionScheme struct {
	// REQUIRED; Array for the names of the partitions.
	Names []*string

	// CONSTANT; Specifies how the service is partitioned.
	// Field has constant value PartitionSchemeNamed, any specified value is ignored.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type NamedPartitionScheme.
func (n *NamedPartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: n.PartitionScheme,
	}
}

// NetworkSecurityRule - Describes a network security rule.
type NetworkSecurityRule struct {
	// REQUIRED; The network traffic is allowed or denied.
	Access *Access

	// REQUIRED; Network security rule direction.
	Direction *Direction

	// REQUIRED; Network security rule name.
	Name *string

	// REQUIRED; The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved
	// for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection.
	// The lower the priority number, the higher the priority of the rule.
	Priority *int32

	// REQUIRED; Network protocol this rule applies to.
	Protocol *NsgProtocol

	// Network security rule description.
	Description *string

	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default
	// tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string

	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []*string

	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string

	// The destination port ranges.
	DestinationPortRanges []*string

	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork',
	// 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates
	// from.
	SourceAddressPrefix *string

	// The CIDR or source IP ranges.
	SourceAddressPrefixes []*string

	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string

	// The source port ranges.
	SourcePortRanges []*string
}

// NodeType - Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
type NodeType struct {
	// The node type properties
	Properties *NodeTypeProperties

	// The node type sku.
	SKU *NodeTypeSKU

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// NodeTypeActionParameters - Parameters for Node type action. If nodes are not specified on the parameters, the operation
// will be performed in all nodes of the node type one upgrade domain at a time.
type NodeTypeActionParameters struct {
	// Force the action to go through.
	Force *bool

	// List of node names from the node type.
	Nodes []*string

	// Specifies the way the operation will be performed.
	UpdateType *UpdateType
}

// NodeTypeAvailableSKU - Defines the type of sku available for a node type
type NodeTypeAvailableSKU struct {
	// READ-ONLY; Provides information about how the node count can be scaled.
	Capacity *NodeTypeSKUCapacity

	// READ-ONLY; The type of resource the sku applies to. Value: Microsoft.ServiceFabric/managedClusters/nodeTypes.
	ResourceType *string

	// READ-ONLY; The supported SKU for a for node type.
	SKU *NodeTypeSupportedSKU
}

// NodeTypeFaultSimulation - Node type fault simulation object with status.
type NodeTypeFaultSimulation struct {
	// Node type name.
	NodeTypeName *string

	// Current or latest asynchronous operation identifier on the node type.
	OperationID *string

	// Current or latest asynchronous operation status on the node type
	OperationStatus *SfmcOperationStatus

	// Fault simulation status
	Status *FaultSimulationStatus
}

// NodeTypeListResult - The response of a NodeType list operation.
type NodeTypeListResult struct {
	// REQUIRED; The NodeType items on this page
	Value []*NodeType

	// The link to the next page of items
	NextLink *string
}

// NodeTypeListSKUResult - Node type available sku list results
type NodeTypeListSKUResult struct {
	// REQUIRED; The NodeTypeAvailableSku items on this page
	Value []*NodeTypeAvailableSKU

	// The link to the next page of items
	NextLink *string
}

// NodeTypeNatConfig - Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfig struct {
	// The internal port for the NAT configuration.
	BackendPort *int32

	// The port range end for the external endpoint.
	FrontendPortRangeEnd *int32

	// The port range start for the external endpoint.
	FrontendPortRangeStart *int32
}

// NodeTypeProperties - Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
type NodeTypeProperties struct {
	// REQUIRED; Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot
	// be changed once the node type is created.
	IsPrimary *bool

	// REQUIRED; The number of nodes in the node type. **Values:** -1 - Use when auto scale rules are configured or sku.capacity
	// is defined 0 - Not supported >0 - Use for manual scale.
	VMInstanceCount *int32

	// Additional managed data disks.
	AdditionalDataDisks []*VmssDataDisk

	// Specifies the settings for any additional secondary network interfaces to attach to the node type.
	AdditionalNetworkInterfaceConfigurations []*AdditionalNetworkInterfaceConfiguration

	// The range of ports from which cluster assigned port to Service Fabric applications.
	ApplicationPorts *EndpointRangeDescription

	// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how
	// much resource a node has.
	Capacities map[string]*string

	// Specifies the computer name prefix. Limited to 9 characters. If specified, allows for a longer name to be specified for
	// the node type name.
	ComputerNamePrefix *string

	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DataDiskLetter *string

	// Disk size for the managed disk attached to the vms on the node type in GBs.
	DataDiskSizeGB *int32

	// Managed data disk type. Specifies the storage account type for the managed disk
	DataDiskType *DiskType

	// Specifies the resource id of the DSCP configuration to apply to the node type network interface.
	DscpConfigurationID *string

	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool

	// Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption for all
	// the disks including Resource/Temp disk at host itself. Default: The Encryption at host will be disabled unless this property
	// is set to true for the resource.
	EnableEncryptionAtHost *bool

	// Specifies whether each node is allocated its own public IPv4 address. This is only supported on secondary node types with
	// custom Load Balancers.
	EnableNodePublicIP *bool

	// Specifies whether each node is allocated its own public IPv6 address. This is only supported on secondary node types with
	// custom Load Balancers.
	EnableNodePublicIPv6 *bool

	// Specifies whether the node type should be overprovisioned. It is only allowed for stateless node types.
	EnableOverProvisioning *bool

	// The range of ephemeral ports that nodes in this node type should be configured with.
	EphemeralPorts *EndpointRangeDescription

	// Specifies the eviction policy for virtual machines in a SPOT node type. Default is Delete.
	EvictionPolicy *EvictionPolicyType

	// Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This setting can
	// only be specified for non-primary node types and can not be added or removed after the node type is created.
	FrontendConfigurations []*FrontendConfiguration

	// Specifies the full host group resource Id. This property is used for deploying on azure dedicated hosts.
	HostGroupID *string

	// Specifies the node type should be configured for only outbound traffic and not inbound traffic.
	IsOutboundOnly *bool

	// Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the VMs if there is capacity available
	// and the VMs can be evicted at any time.
	IsSpotVM *bool

	// Indicates if the node type can only host Stateless workloads.
	IsStateless *bool

	// Indicates if scale set associated with the node type can be composed of multiple placement groups.
	MultiplePlacementGroups *bool

	// Specifies the NAT configuration on default public Load Balancer for the node type. This is only supported for node types
	// use the default public Load Balancer.
	NatConfigurations []*NodeTypeNatConfig

	// Specifies the resource id of a NAT Gateway to attach to the subnet of this node type. Node type must use custom load balancer.
	NatGatewayID *string

	// The Network Security Rules for this node type. This setting can only be specified for node types that are configured with
	// frontend configurations.
	NetworkSecurityRules []*NetworkSecurityRule

	// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should
	// run.
	PlacementProperties map[string]*string

	// Specifies whether secure boot should be enabled on the nodeType. Can only be used with TrustedLaunch and ConfidentialVM
	// SecurityType.
	SecureBootEnabled *bool

	// Specifies the EncryptionType of the managed disk. It is set to DiskWithVMGuestState for encryption of the managed disk
	// along with VMGuestState blob and VMGuestStateOnly for encryption of just the VMGuestState blob. Note: It can be set for
	// only Confidential VMs.
	SecurityEncryptionType *SecurityEncryptionType

	// Specifies the security type of the nodeType. Supported values include Standard, TrustedLaunch and ConfidentialVM.
	SecurityType *SecurityType

	// Specifies the service artifact reference id used to set same image version for all virtual machines in the scale set when
	// using 'latest' image version.
	ServiceArtifactReferenceID *string

	// Indicates the time duration after which the platform will not try to restore the VMSS SPOT instances specified as ISO 8601.
	SpotRestoreTimeout *string

	// Indicates the resource id of the subnet for the node type.
	SubnetID *string

	// Specifies whether the use public load balancer. If not specified and the node type doesn't have its own frontend configuration,
	// it will be attached to the default load balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer
	// is true, then the frontend has to be an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer
	// is false or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
	UseDefaultPublicLoadBalancer *bool

	// Indicates whether to use ephemeral os disk. The sku selected on the vmSize property needs to support this feature.
	UseEphemeralOSDisk *bool

	// Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk will be
	// attached and the temporary disk will be used. It is only allowed for stateless node types.
	UseTempDataDisk *bool

	// Specifies the gallery applications that should be made available to the underlying VMSS.
	VMApplications []*VMApplication

	// Set of extensions that should be installed onto the virtual machines.
	VMExtensions []*VMSSExtension

	// The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer.
	VMImageOffer *string

	// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace
	// images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure
	// portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->.
	// Enter any required information and then click Save.
	VMImagePlan *VMImagePlan

	// The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer.
	VMImagePublisher *string

	// Indicates the resource id of the vm image. This parameter is used for custom vm image.
	VMImageResourceID *string

	// The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
	VMImageSKU *string

	// The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be specified to select the latest
	// version of an image. If omitted, the default is 'latest'.
	VMImageVersion *string

	// Identities to assign to the virtual machine scale set under the node type.
	VMManagedIdentity *VMManagedIdentity

	// The secrets to install in the virtual machines.
	VMSecrets []*VaultSecretGroup

	// Specifies the actions to be performed on the vms before bootstrapping the service fabric runtime.
	VMSetupActions []*VMSetupAction

	// Indicates the resource id of the vm shared galleries image. This parameter is used for custom vm image.
	VMSharedGalleryImageID *string

	// The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example, Standard_D3.
	VMSize *string

	// Setting this to true allows stateless node types to scale out without equal distribution across zones.
	ZoneBalance *bool

	// Specifies the availability zones where the node type would span across. If the cluster is not spanning across availability
	// zones, initiates az migration for the cluster.
	Zones []*string

	// READ-ONLY; The provisioning state of the node type resource.
	ProvisioningState *ManagedResourceProvisioningState
}

// NodeTypeSKU - Describes a node type sku.
type NodeTypeSKU struct {
	// REQUIRED; The number of nodes in the node type. If present in request it will override properties.vmInstanceCount.
	Capacity *int32

	// The sku name. Name is internally generated and is used in auto-scale scenarios. Property does not allow to be changed to
	// other values than generated. To avoid deployment errors please omit the property.
	Name *string

	// Specifies the tier of the node type. Possible Values: **Standard**
	Tier *string
}

// NodeTypeSKUCapacity - Provides information about how node type can be scaled.
type NodeTypeSKUCapacity struct {
	// READ-ONLY; Default node count in a node type.
	Default *int32

	// READ-ONLY; Highest permitted node count in a node type.
	Maximum *int32

	// READ-ONLY; Lowest permitted node count in a node type.
	Minimum *int32

	// READ-ONLY; Node type capacity scale type.
	ScaleType *NodeTypeSKUScaleType
}

// NodeTypeSupportedSKU - Describes a node type supported sku.
type NodeTypeSupportedSKU struct {
	// READ-ONLY; The sku name.
	Name *string

	// READ-ONLY; Specifies the tier of the node type. Possible Values: **Standard**
	Tier *string
}

// NodeTypeUpdateParameters - Node type update request
type NodeTypeUpdateParameters struct {
	// The node type sku.
	SKU *NodeTypeSKU

	// Node type update parameters
	Tags map[string]*string
}

// OperationListResult - Describes the result of the request to list Service Fabric resource provider operations.
type OperationListResult struct {
	// REQUIRED; The OperationResult items on this page
	Value []*OperationResult

	// The link to the next page of items
	NextLink *string
}

// OperationResult - Available operation list result
type OperationResult struct {
	// The object that represents the operation.
	Display *AvailableOperationDisplay

	// Indicates whether the operation is a data action
	IsDataAction *bool

	// The name of the operation.
	Name *string

	// The URL to use for getting the next set of results.
	NextLink *string

	// Origin result
	Origin *string
}

// Partition - Describes how the service is partitioned.
type Partition struct {
	// REQUIRED
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type Partition.
func (p *Partition) GetPartition() *Partition { return p }

// PartitionInstanceCountScaleMechanism - Represents a scaling mechanism for adding or removing instances of stateless service
// partition.
type PartitionInstanceCountScaleMechanism struct {
	// CONSTANT; Specifies the mechanism associated with this scaling policy.
	// Field has constant value ServiceScalingMechanismKindScalePartitionInstanceCount, any specified value is ignored.
	Kind *ServiceScalingMechanismKind

	// REQUIRED; Maximum number of instances of the partition.
	MaxInstanceCount *int32

	// REQUIRED; Minimum number of instances of the partition.
	MinInstanceCount *int32

	// REQUIRED; The number of instances to add or remove during a scaling operation.
	ScaleIncrement *int32
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type PartitionInstanceCountScaleMechanism.
func (p *PartitionInstanceCountScaleMechanism) GetScalingMechanism() *ScalingMechanism {
	return &ScalingMechanism{
		Kind: p.Kind,
	}
}

// ResourceAzStatus - Describes Az Resiliency status of Base resources
type ResourceAzStatus struct {
	// READ-ONLY; Zone resiliency status details for the resource.
	Details *string

	// READ-ONLY; VM Size name.
	IsZoneResilient *bool

	// READ-ONLY; VM Size properties.
	ResourceName *string

	// READ-ONLY; VM Size id.
	ResourceType *string
}

// RestartDeployedCodePackageRequest - Parameters for restarting a deployed code package.
type RestartDeployedCodePackageRequest struct {
	// REQUIRED; The instance ID for currently running entry point. For a code package setup entry point (if specified) runs first
	// and after it finishes main entry point is started. Each time entry point executable is run, its instance ID will change.
	// If 0 is passed in as the code package instance ID, the API will restart the code package with whatever instance ID it is
	// currently running. If an instance ID other than 0 is passed in, the API will restart the code package only if the current
	// Instance ID matches the passed in instance ID. Note, passing in the exact instance ID (not 0) in the API is safer, because
	// if ensures at most one restart of the code package.
	CodePackageInstanceID *string

	// REQUIRED; The name of the code package as specified in the service manifest.
	CodePackageName *string

	// REQUIRED; The name of the node where the code package needs to be restarted. Use '*' to restart on all nodes where the
	// code package is running.
	NodeName *string

	// REQUIRED; The name of the service manifest as specified in the code package.
	ServiceManifestName *string

	// The activation id of a deployed service package. If ServicePackageActivationMode specified at the time of creating the
	// service is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'), then value of ServicePackageActivationId
	// is always an empty string.
	ServicePackageActivationID *string
}

// RestartReplicaRequest - Request to restart a replica.
type RestartReplicaRequest struct {
	// REQUIRED; The ID of the partition.
	PartitionID *string

	// REQUIRED; The IDs of the replicas to be restarted.
	ReplicaIDs []*int64

	// REQUIRED; The kind of restart to perform.
	RestartKind *RestartKind

	// If true, the restart operation will be forced. Use this option with care, as it may cause data loss.
	ForceRestart *bool

	// The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is
	// willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
	Timeout *int64
}

// RollingUpgradeMonitoringPolicy - The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicy struct {
	// REQUIRED; The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations.
	// Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically.
	// Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction *FailureAction

	// REQUIRED; The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction
	// is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout *string

	// REQUIRED; The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next
	// upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration *string

	// REQUIRED; The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted
	// as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration *string

	// REQUIRED; The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than
	// 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout *string

	// REQUIRED; The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than
	// 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout *string
}

// RuntimeApplicationHealthPolicy - Cluster level definition for a health policy used to evaluate the health of an application
// or one of its children entities.
type RuntimeApplicationHealthPolicy struct {
	// REQUIRED; Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError *bool

	// REQUIRED; The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to
	// 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application
	// is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application
	// is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications *int32

	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *RuntimeServiceTypeHealthPolicy

	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]*RuntimeServiceTypeHealthPolicy
}

// RuntimeResumeApplicationUpgradeParameters - Parameters for Resume Upgrade action. The upgrade domain name must be specified.
type RuntimeResumeApplicationUpgradeParameters struct {
	// The upgrade domain name. Expected to be the next upgrade domain if the application is upgrading.
	UpgradeDomainName *string
}

// RuntimeRollingUpgradeUpdateMonitoringPolicy - Describes the parameters for updating a rolling upgrade of application or
// cluster.
type RuntimeRollingUpgradeUpdateMonitoringPolicy struct {
	// REQUIRED; The mode used to monitor health during a rolling upgrade.
	RollingUpgradeMode *RuntimeRollingUpgradeMode

	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid
	// indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual
	// indicates that the upgrade will switch to UnmonitoredManual upgrade mode
	FailureAction *RuntimeFailureAction

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade
	// only changes configuration or data).
	ForceRestart *bool

	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed.
	// It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number
	// representing the total number of milliseconds.
	HealthCheckRetryTimeoutInMilliseconds *string

	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade
	// domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as
	// a number representing the total number of milliseconds.
	HealthCheckStableDurationInMilliseconds *string

	// The amount of time to wait after completing an upgrade domain before applying health policies. It is first interpreted
	// as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
	// number of milliseconds.
	HealthCheckWaitDurationInMilliseconds *string

	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This
	// would be effective when the instance is closing during the application/cluster upgrade, only for those instances which
	// have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDurationInSeconds *int64

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected
	// issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
	// 32-bit integer).
	ReplicaSetCheckTimeoutInMilliseconds *int64

	// The amount of time each upgrade domain has to complete before FailureAction is executed. It is first interpreted as a string
	// representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
	UpgradeDomainTimeoutInMilliseconds *string

	// The amount of time the overall upgrade has to complete before FailureAction is executed. It is first interpreted as a string
	// representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
	UpgradeTimeoutInMilliseconds *string
}

// RuntimeServiceTypeHealthPolicy - Cluster level definition that represents the health policy used to evaluate the health
// of services belonging to a service type.
type RuntimeServiceTypeHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of unhealthy partitions per service.
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered
	// in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the
	// service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService *int32

	// REQUIRED; The maximum allowed percentage of unhealthy replicas per partition.
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered
	// in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition *int32

	// REQUIRED; The maximum allowed percentage of unhealthy services.
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is
	// considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services
	// of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices *int32
}

// RuntimeUpdateApplicationUpgradeParameters - Parameters for the Update Upgrade action.
type RuntimeUpdateApplicationUpgradeParameters struct {
	// REQUIRED; The name of the application, including the 'fabric:' URI scheme.
	Name *string

	// REQUIRED; The kind of the upgrade.
	UpgradeKind *RuntimeUpgradeKind

	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *RuntimeApplicationHealthPolicy

	// Describes the parameters for updating a rolling upgrade of application or cluster and a monitoring policy.
	UpdateDescription *RuntimeRollingUpgradeUpdateMonitoringPolicy
}

// SKU - Service Fabric managed cluster Sku definition
type SKU struct {
	// REQUIRED; Sku Name.
	Name *SKUName
}

// ScalingMechanism - Describes the mechanism for performing a scaling operation.
type ScalingMechanism struct {
	// REQUIRED
	Kind *ServiceScalingMechanismKind
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type ScalingMechanism.
func (s *ScalingMechanism) GetScalingMechanism() *ScalingMechanism { return s }

// ScalingPolicy - Specifies a metric to load balance a service during runtime.
type ScalingPolicy struct {
	// REQUIRED; Specifies the mechanism associated with this scaling policy
	ScalingMechanism ScalingMechanismClassification

	// REQUIRED; Specifies the trigger associated with this scaling policy.
	ScalingTrigger ScalingTriggerClassification
}

// ScalingTrigger - Describes the trigger for performing a scaling operation.
type ScalingTrigger struct {
	// REQUIRED
	Kind *ServiceScalingTriggerKind
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type ScalingTrigger.
func (s *ScalingTrigger) GetScalingTrigger() *ScalingTrigger { return s }

// ServiceCorrelation - Creates a particular correlation between services.
type ServiceCorrelation struct {
	// REQUIRED; The ServiceCorrelationScheme which describes the relationship between this service and the service specified
	// via ServiceName.
	Scheme *ServiceCorrelationScheme

	// REQUIRED; The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName *string
}

// ServiceEndpoint - The service endpoint properties.
type ServiceEndpoint struct {
	// REQUIRED; The type of the endpoint service.
	Service *string

	// A list of locations.
	Locations []*string

	// Specifies the resource id of the service endpoint to be used in the cluster.
	NetworkIdentifier *string
}

// ServiceLoadMetric - Specifies a metric to load balance a service during runtime.
type ServiceLoadMetric struct {
	// REQUIRED; The name of the metric. If the service chooses to report load during runtime, the load metric name should match
	// the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name *string

	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int32

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when
	// it is a Primary replica.
	PrimaryDefaultLoad *int32

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when
	// it is a Secondary replica.
	SecondaryDefaultLoad *int32

	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *ServiceLoadMetricWeight
}

// ServicePlacementInvalidDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where a
// particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicy struct {
	// REQUIRED; The name of the domain that should not be used for placement.
	DomainName *string

	// CONSTANT; The type of placement policy for a service fabric service. Following are the possible values.
	// Field has constant value ServicePlacementPolicyTypeInvalidDomain, any specified value is ignored.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementInvalidDomainPolicy.
func (s *ServicePlacementInvalidDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementNonPartiallyPlaceServicePolicy - The type of placement policy for a service fabric service. Following are
// the possible values.
type ServicePlacementNonPartiallyPlaceServicePolicy struct {
	// CONSTANT; Field has constant value ServicePlacementPolicyTypeNonPartiallyPlaceService, any specified value is ignored.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementNonPartiallyPlaceServicePolicy.
func (s *ServicePlacementNonPartiallyPlaceServicePolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementPolicy - Describes the policy to be used for placement of a Service Fabric service.
type ServicePlacementPolicy struct {
	// REQUIRED
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementPolicy.
func (s *ServicePlacementPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy { return s }

// ServicePlacementPreferPrimaryDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where
// the service's
// Primary replicas should optimally be placed in a particular domain.
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// CONSTANT; The type of placement policy for a service fabric service. Following are the possible values.
	// Field has constant value ServicePlacementPolicyTypePreferredPrimaryDomain, any specified value is ignored.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementPreferPrimaryDomainPolicy.
func (s *ServicePlacementPreferPrimaryDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementRequireDomainDistributionPolicy - Describes the policy to be used for placement of a Service Fabric service
// where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// CONSTANT; The type of placement policy for a service fabric service. Following are the possible values.
	// Field has constant value ServicePlacementPolicyTypeRequiredDomainDistribution, any specified value is ignored.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementRequireDomainDistributionPolicy.
func (s *ServicePlacementRequireDomainDistributionPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementRequiredDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where
// the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// CONSTANT; The type of placement policy for a service fabric service. Following are the possible values.
	// Field has constant value ServicePlacementPolicyTypeRequiredDomain, any specified value is ignored.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementRequiredDomainPolicy.
func (s *ServicePlacementRequiredDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServiceResource - The service resource.
type ServiceResource struct {
	// The geo-location where the resource lives
	Location *string

	// The service resource properties.
	Properties ServiceResourcePropertiesClassification

	// Resource tags.
	Tags map[string]*string

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string

	// READ-ONLY; The name of the resource
	Name *string

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string
}

// ServiceResourceList - The list of service resources.
type ServiceResourceList struct {
	// REQUIRED; The ServiceResource items on this page
	Value []*ServiceResource

	// The link to the next page of items
	NextLink *string
}

// ServiceResourceProperties - The service resource properties.
type ServiceResourceProperties struct {
	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType
	// is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type ServiceResourceProperties.
func (s *ServiceResourceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return s
}

// ServiceTypeHealthPolicy - Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of unhealthy partitions per service.
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered
	// in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the
	// service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService *int32

	// REQUIRED; The maximum allowed percentage of unhealthy replicas per partition.
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered
	// in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition *int32

	// REQUIRED; The maximum allowed percentage of unhealthy services.
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is
	// considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services
	// of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices *int32
}

// ServiceUpdateParameters - Service update request
type ServiceUpdateParameters struct {
	// Service update parameters
	Tags map[string]*string
}

// SettingsParameterDescription - Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// REQUIRED; The parameter name of fabric setting.
	Name *string

	// REQUIRED; The parameter value of fabric setting.
	Value *string
}

// SettingsSectionDescription - Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// REQUIRED; The section name of the fabric settings.
	Name *string

	// REQUIRED; The collection of parameters in the section.
	Parameters []*SettingsParameterDescription
}

// SingletonPartitionScheme - Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionScheme struct {
	// CONSTANT; Specifies how the service is partitioned.
	// Field has constant value PartitionSchemeSingleton, any specified value is ignored.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type SingletonPartitionScheme.
func (s *SingletonPartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: s.PartitionScheme,
	}
}

// StatefulServiceProperties - The properties of a stateful service resource.
type StatefulServiceProperties struct {
	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// CONSTANT; The kind of service (Stateless or Stateful).
	// Field has constant value ServiceKindStateful, any specified value is ignored.
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of
	// this property is true, if not it is false.
	HasPersistedState *bool

	// The minimum replica set size as a number.
	MinReplicaSetSize *int32

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType
	// is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string

	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string

	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string

	// The target replica set size as a number.
	TargetReplicaSetSize *int32

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type StatefulServiceProperties.
func (s *StatefulServiceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return &ServiceResourceProperties{
		CorrelationScheme:            s.CorrelationScheme,
		DefaultMoveCost:              s.DefaultMoveCost,
		PartitionDescription:         s.PartitionDescription,
		PlacementConstraints:         s.PlacementConstraints,
		ProvisioningState:            s.ProvisioningState,
		ScalingPolicies:              s.ScalingPolicies,
		ServiceDNSName:               s.ServiceDNSName,
		ServiceKind:                  s.ServiceKind,
		ServiceLoadMetrics:           s.ServiceLoadMetrics,
		ServicePackageActivationMode: s.ServicePackageActivationMode,
		ServicePlacementPolicies:     s.ServicePlacementPolicies,
		ServiceTypeName:              s.ServiceTypeName,
	}
}

// StatelessServiceProperties - The properties of a stateless service resource.
type StatelessServiceProperties struct {
	// REQUIRED; The instance count.
	InstanceCount *int32

	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// CONSTANT; The kind of service (Stateless or Stateful).
	// Field has constant value ServiceKindStateless, any specified value is ignored.
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during
	// operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0
	// * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into
	// the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int32

	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety
	// check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil(
	// MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation,
	// -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement
	// constraints on the service.
	MinInstancePercentage *int32

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType
	// is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type StatelessServiceProperties.
func (s *StatelessServiceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return &ServiceResourceProperties{
		CorrelationScheme:            s.CorrelationScheme,
		DefaultMoveCost:              s.DefaultMoveCost,
		PartitionDescription:         s.PartitionDescription,
		PlacementConstraints:         s.PlacementConstraints,
		ProvisioningState:            s.ProvisioningState,
		ScalingPolicies:              s.ScalingPolicies,
		ServiceDNSName:               s.ServiceDNSName,
		ServiceKind:                  s.ServiceKind,
		ServiceLoadMetrics:           s.ServiceLoadMetrics,
		ServicePackageActivationMode: s.ServicePackageActivationMode,
		ServicePlacementPolicies:     s.ServicePlacementPolicies,
		ServiceTypeName:              s.ServiceTypeName,
	}
}

// SubResource - Azure resource identifier.
type SubResource struct {
	// Azure resource identifier.
	ID *string
}

// Subnet - Describes a Subnet.
type Subnet struct {
	// REQUIRED; Subnet name.
	Name *string

	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIPv6 *bool

	// Full resource id for the network security group.
	NetworkSecurityGroupID *string

	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *PrivateEndpointNetworkPolicies

	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *PrivateLinkServiceNetworkPolicies
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time

	// The identity that created the resource.
	CreatedBy *string

	// The type of identity that created the resource.
	CreatedByType *CreatedByType

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time

	// The identity that last modified the resource.
	LastModifiedBy *string

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType
}

// UniformInt64RangePartitionScheme - Describes a partitioning scheme where an integer range is allocated evenly across a
// number of partitions.
type UniformInt64RangePartitionScheme struct {
	// REQUIRED; The number of partitions.
	Count *int32

	// REQUIRED; The upper bound of the partition key range that
	// should be split between the partition Count
	HighKey *int64

	// REQUIRED; The lower bound of the partition key range that
	// should be split between the partition Count
	LowKey *int64

	// CONSTANT; Specifies how the service is partitioned.
	// Field has constant value PartitionSchemeUniformInt64Range, any specified value is ignored.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type UniformInt64RangePartitionScheme.
func (u *UniformInt64RangePartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: u.PartitionScheme,
	}
}

// UserAssignedIdentity - User assigned identity.
type UserAssignedIdentity struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string
}

// VMApplication - Specifies the gallery application that should be made available to the underlying VMSS.
type VMApplication struct {
	// REQUIRED; Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
	PackageReferenceID *string

	// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
	ConfigurationReference *string

	// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the
	// underlying VMSS.
	EnableAutomaticUpgrade *bool

	// Optional, Specifies the order in which the packages have to be installed.
	Order *int32

	// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
	TreatFailureAsDeploymentFailure *bool

	// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
	VMGalleryTags *string
}

// VMImagePlan - Specifies information about the marketplace image used to create the virtual machine. This element is only
// used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic
// use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically,
// Get Started. Enter any required information and then click Save.
type VMImagePlan struct {
	// The plan ID.
	Name *string

	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product *string

	// The promotion code.
	PromotionCode *string

	// The publisher ID.
	Publisher *string
}

// VMManagedIdentity - Identities for the virtual machine scale set under the node type.
type VMManagedIdentity struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM
	// resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []*string
}

// VMSSExtension - Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtension struct {
	// REQUIRED; The name of the extension.
	Name *string

	// REQUIRED; Describes the properties of a Virtual Machine Scale Set Extension.
	Properties *VMSSExtensionProperties
}

// VMSSExtensionProperties - Describes the properties of a Virtual Machine Scale Set Extension.
type VMSSExtensionProperties struct {
	// REQUIRED; The name of the extension handler publisher.
	Publisher *string

	// REQUIRED; Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string

	// REQUIRED; Specifies the version of the script handler.
	TypeHandlerVersion *string

	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed,
	// however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool

	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension
	// available.
	EnableAutomaticUpgrade *bool

	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if
	// the extension configuration has not changed.
	ForceUpdateTag *string

	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings any

	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []*string

	// Json formatted public settings for the extension.
	Settings any

	// Indicates the setup order for the extension.
	SetupOrder []*VmssExtensionSetupOrder

	// READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string
}

// VMSize - VM Sizes properties.
type VMSize struct {
	// READ-ONLY; VM Size name.
	Size *string
}

// VaultCertificate - Describes a single certificate reference in a Key Vault, and where the certificate should reside on
// the VM.
type VaultCertificate struct {
	// REQUIRED; For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added.
	// The specified certificate store is implicitly in the LocalMachine account. For Linux VMs, the certificate file is placed
	// under the /var/lib/waagent directory, with the file name {UppercaseThumbprint}.crt for the X509 certificate file and {UppercaseThumbprint}.prv
	// for private key. Both of these files are .pem formatted.
	CertificateStore *string

	// REQUIRED; This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the
	// Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	CertificateURL *string
}

// VaultSecretGroup - Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroup struct {
	// REQUIRED; The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault *SubResource

	// REQUIRED; The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []*VaultCertificate
}

// VmssDataDisk - Managed data disk description.
type VmssDataDisk struct {
	// REQUIRED; Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter *string

	// REQUIRED; Disk size for each vm in the node type in GBs.
	DiskSizeGB *int32

	// REQUIRED; Managed data disk type. Specifies the storage account type for the managed disk
	DiskType *DiskType

	// REQUIRED; Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun *int32
}

// ZoneFaultSimulationContent - Parameters for Zone Fault Simulation action.
type ZoneFaultSimulationContent struct {
	// CONSTANT; The kind of fault simulation.
	// Field has constant value FaultKindZone, any specified value is ignored.
	FaultKind *FaultKind

	// Constraints for Fault Simulation action.
	Constraints *FaultSimulationConstraints

	// Force the action to go through without any check on the cluster.
	Force *bool

	// Indicates the zones of the fault simulation.
	Zones []*string
}

// GetFaultSimulationContent implements the FaultSimulationContentClassification interface for type ZoneFaultSimulationContent.
func (z *ZoneFaultSimulationContent) GetFaultSimulationContent() *FaultSimulationContent {
	return &FaultSimulationContent{
		Constraints: z.Constraints,
		FaultKind:   z.FaultKind,
		Force:       z.Force,
	}
}
