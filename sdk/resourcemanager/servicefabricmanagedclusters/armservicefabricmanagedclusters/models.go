//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicefabricmanagedclusters

import "time"

// AddRemoveIncrementalNamedPartitionScalingMechanism - Represents a scaling mechanism for adding or removing named partitions
// of a stateless service. Partition names are in the format '0','1'â€¦'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanism struct {
	// REQUIRED; Specifies the mechanism associated with this scaling policy.
	Kind *ServiceScalingMechanismKind

	// REQUIRED; Maximum number of named partitions of the service.
	MaxPartitionCount *int32

	// REQUIRED; Minimum number of named partitions of the service.
	MinPartitionCount *int32

	// REQUIRED; The number of instances to add or remove during a scaling operation.
	ScaleIncrement *int32
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type AddRemoveIncrementalNamedPartitionScalingMechanism.
func (a *AddRemoveIncrementalNamedPartitionScalingMechanism) GetScalingMechanism() *ScalingMechanism {
	return &ScalingMechanism{
		Kind: a.Kind,
	}
}

// AdditionalNetworkInterfaceConfiguration - Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfiguration struct {
	// REQUIRED; Specifies the IP configurations of the network interface.
	IPConfigurations []*IPConfiguration

	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies the DSCP configuration to apply to the network interface.
	DscpConfiguration *SubResource

	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool
}

// ApplicationHealthPolicy - Defines a health policy used to evaluate the health of an application or one of its children
// entities.
type ApplicationHealthPolicy struct {
	// REQUIRED; Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError *bool

	// REQUIRED; The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to
	// 100. The percentage represents the maximum tolerated percentage of deployed applications
	// that can be unhealthy before the application is considered in error. This is calculated by dividing the number of unhealthy
	// deployed applications over the number of nodes where the application is
	// currently deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default
	// percentage is zero.
	MaxPercentUnhealthyDeployedApplications *int32

	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy

	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]*ServiceTypeHealthPolicy
}

// ApplicationResource - The application resource.
type ApplicationResource struct {
	// Describes the managed identities for an Azure resource.
	Identity *ManagedIdentity

	// Resource location depends on the parent resource.
	Location *string

	// The application resource properties.
	Properties *ApplicationResourceProperties

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// ApplicationResourceList - The list of application resources.
type ApplicationResourceList struct {
	Value []*ApplicationResource

	// READ-ONLY; URL to get the next set of application list results if there are any.
	NextLink *string
}

// ApplicationResourceProperties - The application resource properties.
type ApplicationResourceProperties struct {
	// List of user assigned identities for the application, each mapped to a friendly name.
	ManagedIdentities []*ApplicationUserAssignedIdentity

	// List of application parameters with overridden values from their default values specified in the application manifest.
	Parameters map[string]*string

	// Describes the policy for a monitored application upgrade.
	UpgradePolicy *ApplicationUpgradePolicy

	// The version of the application type as defined in the application manifest. This name must be the full Arm Resource ID
	// for the referenced application type version.
	Version *string

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// ApplicationTypeResource - The application type name resource
type ApplicationTypeResource struct {
	// Resource location depends on the parent resource.
	Location *string

	// The application type name properties
	Properties *ApplicationTypeResourceProperties

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// ApplicationTypeResourceList - The list of application type names.
type ApplicationTypeResourceList struct {
	Value []*ApplicationTypeResource

	// READ-ONLY; URL to get the next set of application type list results if there are any.
	NextLink *string
}

// ApplicationTypeResourceProperties - The application type name properties
type ApplicationTypeResourceProperties struct {
	// READ-ONLY; The current deployment or provisioning state, which only appears in the response.
	ProvisioningState *string
}

// ApplicationTypeUpdateParameters - Application type update request
type ApplicationTypeUpdateParameters struct {
	// Application type update parameters
	Tags map[string]*string
}

// ApplicationTypeVersionResource - An application type version resource for the specified application type name resource.
type ApplicationTypeVersionResource struct {
	// Resource location depends on the parent resource.
	Location *string

	// The properties of the application type version resource.
	Properties *ApplicationTypeVersionResourceProperties

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// ApplicationTypeVersionResourceList - The list of application type version resources for the specified application type
// name resource.
type ApplicationTypeVersionResourceList struct {
	Value []*ApplicationTypeVersionResource

	// READ-ONLY; URL to get the next set of application type version list results if there are any.
	NextLink *string
}

// ApplicationTypeVersionResourceProperties - The properties of the application type version resource.
type ApplicationTypeVersionResourceProperties struct {
	// REQUIRED; The URL to the application package
	AppPackageURL *string

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// ApplicationTypeVersionUpdateParameters - Application type version update request
type ApplicationTypeVersionUpdateParameters struct {
	// Application type version update parameters
	Tags map[string]*string
}

// ApplicationTypeVersionsCleanupPolicy - The policy used to clean up unused versions. When the policy is not specified explicitly,
// the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicy struct {
	// REQUIRED; Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep *int32
}

// ApplicationUpdateParameters - Application update request
type ApplicationUpdateParameters struct {
	// Application update parameters
	Tags map[string]*string
}

// ApplicationUpgradePolicy - Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicy

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade
	// only changes configuration or data).
	ForceRestart *bool

	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This
	// would be effective when the instance is closing during the
	// application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *int64

	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters
	// are not allowed.
	RecreateApplication *bool

	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicy

	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *RollingUpgradeMode

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected
	// issues. When this timeout expires, processing of the upgrade domain will
	// proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values
	// are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *int64
}

type ApplicationUserAssignedIdentity struct {
	// REQUIRED; The friendly name of user assigned identity.
	Name *string

	// REQUIRED; The principal id of user assigned identity.
	PrincipalID *string
}

// AvailableOperationDisplay - Operation supported by the Service Fabric resource provider
type AvailableOperationDisplay struct {
	// Operation description
	Description *string

	// The operation that can be performed.
	Operation *string

	// The name of the provider.
	Provider *string

	// The resource on which the operation is performed
	Resource *string
}

// AveragePartitionLoadScalingTrigger - Represents a scaling trigger related to an average load of a metric/resource of a
// partition.
type AveragePartitionLoadScalingTrigger struct {
	// REQUIRED; Specifies the trigger associated with this scaling policy.
	Kind *ServiceScalingTriggerKind

	// REQUIRED; The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold *float64

	// REQUIRED; The name of the metric for which usage should be tracked.
	MetricName *string

	// REQUIRED; The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601
	// format "hh:mm:ss".
	ScaleInterval *string

	// REQUIRED; The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold *float64
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type AveragePartitionLoadScalingTrigger.
func (a *AveragePartitionLoadScalingTrigger) GetScalingTrigger() *ScalingTrigger {
	return &ScalingTrigger{
		Kind: a.Kind,
	}
}

// AverageServiceLoadScalingTrigger - Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTrigger struct {
	// REQUIRED; Specifies the trigger associated with this scaling policy.
	Kind *ServiceScalingTriggerKind

	// REQUIRED; The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold *float64

	// REQUIRED; The name of the metric for which usage should be tracked.
	MetricName *string

	// REQUIRED; The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601
	// format "hh:mm:ss".
	ScaleInterval *string

	// REQUIRED; The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold *float64

	// REQUIRED; Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then
	// trigger will only consider the load of primary replicas of stateful service. If set to
	// false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad *bool
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type AverageServiceLoadScalingTrigger.
func (a *AverageServiceLoadScalingTrigger) GetScalingTrigger() *ScalingTrigger {
	return &ScalingTrigger{
		Kind: a.Kind,
	}
}

// AzureActiveDirectory - The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string

	// Azure active directory cluster application id.
	ClusterApplication *string

	// Azure active directory tenant id.
	TenantID *string
}

// ClientCertificate - Client certificate definition.
type ClientCertificate struct {
	// REQUIRED; Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read
	// only operations on the cluster.
	IsAdmin *bool

	// Certificate common name.
	CommonName *string

	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string

	// Certificate thumbprint.
	Thumbprint *string
}

// ClusterHealthPolicy - Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10%
	// of applications to be unhealthy, this value would be 10.
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is
	// considered in error. If the percentage is respected but there is at least one
	// unhealthy application, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy applications
	// over the total number of application instances in the cluster, excluding
	// applications of application types that are included in the ApplicationTypeHealthPolicyMap. The computation rounds up to
	// tolerate one failure on small numbers of applications. Default percentage is
	// zero.
	MaxPercentUnhealthyApplications *int32

	// REQUIRED; The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes
	// to be unhealthy, this value would be 10.
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered
	// in error. If the percentage is respected but there is at least one unhealthy
	// node, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy nodes over the
	// total number of nodes in the cluster. The computation rounds up to tolerate
	// one failure on small numbers of nodes. Default percentage is zero.
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate
	// that.
	MaxPercentUnhealthyNodes *int32
}

// ClusterMonitoringPolicy - Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicy struct {
	// REQUIRED; The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade
	// rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout *string

	// REQUIRED; The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next
	// upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration *string

	// REQUIRED; The length of time to wait after completing an upgrade domain before performing health checks. The duration can
	// be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckWaitDuration *string

	// REQUIRED; The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either
	// hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeDomainTimeout *string

	// REQUIRED; The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either
	// hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeTimeout *string
}

// ClusterUpgradeDeltaHealthPolicy - Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of nodes health degradation allowed during cluster upgrades. The delta is measured
	// between the state of the nodes at the beginning of upgrade and the state of the nodes
	// at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion to make sure
	// the global state of the cluster is within tolerated limits.
	MaxPercentDeltaUnhealthyNodes *int32

	// The maximum allowed percentage of applications health degradation allowed during cluster upgrades. The delta is measured
	// between the state of the applications at the beginning of upgrade and the state
	// of the applications at the time of the health evaluation. The check is performed after every upgrade domain upgrade completion
	// to make sure the global state of the cluster is within tolerated limits.
	// System services are not included in this. NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
	MaxPercentDeltaUnhealthyApplications *int32

	// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades. The delta is
	// measured between the state of the upgrade domain nodes at the beginning of
	// upgrade and the state of the upgrade domain nodes at the time of the health evaluation. The check is performed after every
	// upgrade domain upgrade completion for all completed upgrade domains to make
	// sure the state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes *int32
}

// ClusterUpgradePolicy - Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicy struct {
	// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	DeltaHealthPolicy *ClusterUpgradeDeltaHealthPolicy

	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade
	// only changes configuration or data).
	ForceRestart *bool

	// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	HealthPolicy *ClusterHealthPolicy

	// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
	MonitoringPolicy *ClusterMonitoringPolicy

	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected
	// issues. When this timeout expires, processing of the upgrade domain will
	// proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. The timeout can
	// be in either hh:mm:ss or in d.hh:mm:ss.ms format. This value must be between
	// 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
	UpgradeReplicaSetCheckTimeout *string
}

// EndpointRangeDescription - Port range details
type EndpointRangeDescription struct {
	// REQUIRED; End port of a range of ports
	EndPort *int32

	// REQUIRED; Starting port of a range of ports
	StartPort *int32
}

// ErrorModelError - The error details.
type ErrorModelError struct {
	// The error code.
	Code *string

	// The error message.
	Message *string
}

// FrontendConfiguration - Describes the frontend configurations for the node type.
type FrontendConfiguration struct {
	// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions//resourceGroups//providers/Microsoft.Network/applicationGateways//backendAddressPools/'.
	ApplicationGatewayBackendAddressPoolID *string

	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IPAddressType *IPAddressType

	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The
	// format of the resource Id is '/subscriptions//resourceGroups/
	// /providers/Microsoft.Network/loadBalancers//backendAddressPools/'.
	LoadBalancerBackendAddressPoolID *string

	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format
	// of the resource Id is '/subscriptions//resourceGroups/
	// /providers/Microsoft.Network/loadBalancers//inboundNatPools/'.
	LoadBalancerInboundNatPoolID *string
}

// IPConfiguration - Specifies an IP configuration of the network interface.
type IPConfiguration struct {
	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address
	// pools of multiple application gateways. Multiple node types cannot use the
	// same application gateway.
	ApplicationGatewayBackendAddressPools []*SubResource

	// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address
	// pools of one public and one internal load balancer. Multiple node types cannot
	// use the same basic sku load balancer.
	LoadBalancerBackendAddressPools []*SubResource

	// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools
	// of one public and one internal load balancer. Multiple node types cannot use
	// the same basic sku load balancer.
	LoadBalancerInboundNatPools []*SubResource

	// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *PrivateIPAddressVersion

	// The public IP address configuration of the network interface.
	PublicIPAddressConfiguration *IPConfigurationPublicIPAddressConfiguration

	// Specifies the subnet of the network interface.
	Subnet *SubResource
}

// IPConfigurationPublicIPAddressConfiguration - The public IP address configuration of the network interface.
type IPConfigurationPublicIPAddressConfiguration struct {
	// REQUIRED; Name of the network interface.
	Name *string

	// Specifies the list of IP tags associated with the public IP address.
	IPTags []*IPTag

	// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
	PublicIPAddressVersion *PublicIPAddressVersion
}

// IPTag - The IP tag associated with the public IP address.
type IPTag struct {
	// REQUIRED; IP tag type. Example: FirstPartyUsage.
	IPTagType *string

	// REQUIRED; IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string
}

// LoadBalancingRule - Describes a load balancing rule.
type LoadBalancingRule struct {
	// REQUIRED; The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort *int32

	// REQUIRED; The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable
	// values are between 1 and 65534.
	FrontendPort *int32

	// REQUIRED; the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol *ProbeProtocol

	// REQUIRED; The reference to the transport protocol used by the load balancing rule.
	Protocol *Protocol

	// The load distribution policy for this rule.
	LoadDistribution *string

	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int32

	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string
}

// LongRunningOperationResult - Long running operation result.
type LongRunningOperationResult struct {
	// The end time of the operation.
	EndTime *time.Time

	// The operation error.
	Error *ErrorModelError

	// The name of the operation.
	Name *string

	// The completion percentage of the operation.
	PercentComplete *float64

	// The start time of the operation.
	StartTime *time.Time

	// The status of the operation.
	Status *string
}

// ManagedAzResiliencyStatus - Describes the result of the request to list Managed VM Sizes for Service Fabric Managed Clusters.
type ManagedAzResiliencyStatus struct {
	// List of Managed VM Sizes for Service Fabric Managed Clusters.
	BaseResourceStatus []*ResourceAzStatus

	// READ-ONLY; URL to get the next set of Managed VM Sizes if there are any.
	IsClusterZoneResilient *bool
}

// ManagedCluster - The managed cluster resource
type ManagedCluster struct {
	// REQUIRED; Azure resource location.
	Location *string

	// REQUIRED; The sku of the managed cluster
	SKU *SKU

	// The managed cluster resource properties
	Properties *ManagedClusterProperties

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource etag.
	Etag *string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// ManagedClusterCodeVersionResult - The result of the Service Fabric runtime versions
type ManagedClusterCodeVersionResult struct {
	// The identification of the result
	ID *string

	// The name of the result
	Name *string

	// The detail of the Service Fabric runtime version result
	Properties *ManagedClusterVersionDetails

	// The result resource type
	Type *string
}

// ManagedClusterListResult - Managed Cluster list results
type ManagedClusterListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string
	Value    []*ManagedCluster
}

// ManagedClusterProperties - Describes the managed cluster resource properties.
type ManagedClusterProperties struct {
	// REQUIRED; VM admin user name.
	AdminUserName *string

	// REQUIRED; The cluster dns name.
	DNSName *string

	// List of add-on features to enable on the cluster.
	AddonFeatures []*ManagedClusterAddOnFeature

	// VM admin user password.
	AdminPassword *string

	// Setting this to true enables RDP access to the VM. The default NSG rule opens RDP port to Internet which can be overridden
	// with custom Network Security Rules. The default value for this setting is
	// false.
	AllowRdpAccess *bool

	// The policy used to clean up unused versions.
	ApplicationTypeVersionsCleanupPolicy *ApplicationTypeVersionsCleanupPolicy

	// Auxiliary subnets for the cluster.
	AuxiliarySubnets []*Subnet

	// The AAD authentication settings of the cluster.
	AzureActiveDirectory *AzureActiveDirectory

	// The port used for client connections to the cluster.
	ClientConnectionPort *int32

	// Client certificates that are allowed to manage the cluster.
	Clients []*ClientCertificate

	// The Service Fabric runtime version of the cluster. This property is required when clusterUpgradeMode is set to 'Manual'.
	// To get list of available Service Fabric versions for new clusters use
	// ClusterVersion API [./ClusterVersion.md]. To get the list of available version for existing clusters use availableClusterVersions.
	ClusterCodeVersion *string

	// Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only
	// applies when clusterUpgradeMode is set to 'Automatic'.
	ClusterUpgradeCadence *ClusterUpgradeCadence

	// The upgrade mode of the cluster when new Service Fabric runtime version is available.
	ClusterUpgradeMode *ClusterUpgradeMode

	// Specify the resource id of a DDoS network protection plan that will be associated with the virtual network of the cluster.
	DdosProtectionPlanID *string

	// Setting this to true enables automatic OS upgrade for the node types that are created using any platform OS image with
	// version 'latest'. The default value for this setting is false.
	EnableAutoOSUpgrade *bool

	// If true, token-based authentication is not allowed on the HttpGatewayEndpoint. This is required to support TLS versions
	// 1.3 and above. If token-based authentication is used,
	// HttpGatewayTokenAuthConnectionPort must be defined.
	EnableHTTPGatewayExclusiveAuthMode *bool

	// Setting this to true creates IPv6 address space for the default VNet used by the cluster. This setting cannot be changed
	// once the cluster is created. The default value for this setting is false.
	EnableIPv6 *bool

	// Setting this to true will link the IPv4 address as the ServicePublicIP of the IPv6 address. It can only be set to True
	// if IPv6 is enabled on the cluster.
	EnableServicePublicIP *bool

	// The list of custom fabric settings to configure the cluster.
	FabricSettings []*SettingsSectionDescription

	// The port used for HTTP connections to the cluster.
	HTTPGatewayConnectionPort *int32

	// The port used for token-auth based HTTPS connections to the cluster. Cannot be set to the same port as HttpGatewayEndpoint.
	HTTPGatewayTokenAuthConnectionPort *int32

	// The list of IP tags associated with the default public IP address of the cluster.
	IPTags []*IPTag

	// Load balancing rules that are applied to the public load balancer of the cluster.
	LoadBalancingRules []*LoadBalancingRule

	// Custom Network Security Rules that are applied to the Virtual Network of the cluster.
	NetworkSecurityRules []*NetworkSecurityRule

	// Specify the resource id of a public IPv4 prefix that the load balancer will allocate a public IPv4 address from. This setting
	// cannot be changed once the cluster is created.
	PublicIPPrefixID *string

	// Specify the resource id of a public IPv6 prefix that the load balancer will allocate a public IPv6 address from. This setting
	// cannot be changed once the cluster is created.
	PublicIPv6PrefixID *string

	// Service endpoints for subnets in the cluster.
	ServiceEndpoints []*ServiceEndpoint

	// If specified, the node types for the cluster are created in this subnet instead of the default VNet. The networkSecurityRules
	// specified for the cluster are also applied to this subnet. This setting
	// cannot be changed once the cluster is created.
	SubnetID *string

	// The policy to use when upgrading the cluster.
	UpgradeDescription *ClusterUpgradePolicy

	// For new clusters, this parameter indicates that it uses Bring your own VNet, but the subnet is specified at node type level;
	// and for such clusters, the subnetId property is required for node types.
	UseCustomVnet *bool

	// Indicates if the cluster has zone resiliency.
	ZonalResiliency *bool

	// Indicates the update mode for Cross Az clusters.
	ZonalUpdateMode *ZonalUpdateMode

	// READ-ONLY; List of thumbprints of the cluster certificates.
	ClusterCertificateThumbprints []*string

	// READ-ONLY; A service generated unique identifier for the cluster resource.
	ClusterID *string

	// READ-ONLY; The current state of the cluster.
	ClusterState *ClusterState

	// READ-ONLY; The fully qualified domain name associated with the public load balancer of the cluster.
	Fqdn *string

	// READ-ONLY; The IPv4 address associated with the public load balancer of the cluster.
	IPv4Address *string

	// READ-ONLY; IPv6 address for the cluster if IPv6 is enabled.
	IPv6Address *string

	// READ-ONLY; The provisioning state of the managed cluster resource.
	ProvisioningState *ManagedResourceProvisioningState
}

// ManagedClusterUpdateParameters - Managed cluster update request
type ManagedClusterUpdateParameters struct {
	// Managed cluster update parameters
	Tags map[string]*string
}

// ManagedClusterVersionDetails - The detail of the Service Fabric runtime version result
type ManagedClusterVersionDetails struct {
	// The Service Fabric runtime version of the cluster.
	ClusterCodeVersion *string

	// Cluster operating system, the default will be Windows
	OSType *OsType

	// The date of expiry of support of the version.
	SupportExpiryUTC *string
}

// ManagedIdentity - Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType

	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource
	// ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserAssignedIdentity

	// READ-ONLY; The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalID *string

	// READ-ONLY; The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantID *string
}

// ManagedMaintenanceWindowStatus - Describes the maintenance window status of the Service Fabric Managed Cluster.
type ManagedMaintenanceWindowStatus struct {
	// READ-ONLY; If updates can be applied.
	CanApplyUpdates *bool

	// READ-ONLY; Indicates if the region is ready to configure maintenance windows.
	IsRegionReady *bool

	// READ-ONLY; If maintenance window is active.
	IsWindowActive *bool

	// READ-ONLY; If maintenance window is enabled on this cluster.
	IsWindowEnabled *bool

	// READ-ONLY; Last window end time in UTC.
	LastWindowEndTimeUTC *time.Time

	// READ-ONLY; Last window start time in UTC.
	LastWindowStartTimeUTC *time.Time

	// READ-ONLY; Last window update time in UTC.
	LastWindowStatusUpdateAtUTC *time.Time
}

// ManagedVMSize - Describes a VM Sizes.
type ManagedVMSize struct {
	// READ-ONLY; VM Size id.
	ID *string

	// READ-ONLY; VM Size name.
	Name *string

	// READ-ONLY; VM Size properties.
	Properties *VMSize

	// READ-ONLY; VM Size type.
	Type *string
}

// ManagedVMSizesResult - Describes the result of the request to list Managed VM Sizes for Service Fabric Managed Clusters.
type ManagedVMSizesResult struct {
	// List of Managed VM Sizes for Service Fabric Managed Clusters.
	Value []*ManagedVMSize

	// READ-ONLY; URL to get the next set of Managed VM Sizes if there are any.
	NextLink *string
}

// NamedPartitionScheme - Describes the named partition scheme of the service.
type NamedPartitionScheme struct {
	// REQUIRED; Array for the names of the partitions.
	Names []*string

	// REQUIRED; Specifies how the service is partitioned.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type NamedPartitionScheme.
func (n *NamedPartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: n.PartitionScheme,
	}
}

// NetworkSecurityRule - Describes a network security rule.
type NetworkSecurityRule struct {
	// REQUIRED; The network traffic is allowed or denied.
	Access *Access

	// REQUIRED; Network security rule direction.
	Direction *Direction

	// REQUIRED; Network security rule name.
	Name *string

	// REQUIRED; The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved
	// for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for
	// each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority *int32

	// REQUIRED; Network protocol this rule applies to.
	Protocol *NsgProtocol

	// Network security rule description.
	Description *string

	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default
	// tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also
	// be used.
	DestinationAddressPrefix *string

	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []*string

	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string

	// The destination port ranges.
	DestinationPortRanges []*string

	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork',
	// 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress
	// rule, specifies where network traffic originates from.
	SourceAddressPrefix *string

	// The CIDR or source IP ranges.
	SourceAddressPrefixes []*string

	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string

	// The source port ranges.
	SourcePortRanges []*string
}

// NodeType - Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
type NodeType struct {
	// The node type properties
	Properties *NodeTypeProperties

	// The node type sku.
	SKU *NodeTypeSKU

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// NodeTypeActionParameters - Parameters for Node type action. If nodes are not specified on the parameters, the operation
// will be performed in all nodes of the node type one upgrade domain at a time.
type NodeTypeActionParameters struct {
	// Force the action to go through.
	Force *bool

	// List of node names from the node type.
	Nodes []*string

	// Specifies the way the operation will be performed.
	UpdateType *UpdateType
}

// NodeTypeAvailableSKU - Defines the type of sku available for a node type
type NodeTypeAvailableSKU struct {
	// READ-ONLY; Provides information about how the node count can be scaled.
	Capacity *NodeTypeSKUCapacity

	// READ-ONLY; The type of resource the sku applies to.
	// Value: Microsoft.ServiceFabric/managedClusters/nodeTypes.
	ResourceType *string

	// READ-ONLY; The supported SKU for a for node type.
	SKU *NodeTypeSupportedSKU
}

// NodeTypeListResult - Node type list results
type NodeTypeListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string

	// The list of node types.
	Value []*NodeType
}

// NodeTypeListSKUResult - Node type available sku list results
type NodeTypeListSKUResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string

	// The list of available node type SKUs.
	Value []*NodeTypeAvailableSKU
}

// NodeTypeNatConfig - Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfig struct {
	// The internal port for the NAT configuration.
	BackendPort *int32

	// The port range end for the external endpoint.
	FrontendPortRangeEnd *int32

	// The port range start for the external endpoint.
	FrontendPortRangeStart *int32
}

// NodeTypeProperties - Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
type NodeTypeProperties struct {
	// REQUIRED; Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot
	// be changed once the node type is created.
	IsPrimary *bool

	// REQUIRED; The number of nodes in the node type.
	// Values:
	// -1 - Use when auto scale rules are configured or sku.capacity is defined
	// 0 - Not supported
	// >0 - Use for manual scale.
	VMInstanceCount *int32

	// Additional managed data disks.
	AdditionalDataDisks []*VmssDataDisk

	// Specifies the settings for any additional secondary network interfaces to attach to the node type.
	AdditionalNetworkInterfaceConfigurations []*AdditionalNetworkInterfaceConfiguration

	// The range of ports from which cluster assigned port to Service Fabric applications.
	ApplicationPorts *EndpointRangeDescription

	// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how
	// much resource a node has.
	Capacities map[string]*string

	// Specifies the computer name prefix. Limited to 9 characters. If specified, allows for a longer name to be specified for
	// the node type name.
	ComputerNamePrefix *string

	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DataDiskLetter *string

	// Disk size for the managed disk attached to the vms on the node type in GBs.
	DataDiskSizeGB *int32

	// Managed data disk type. Specifies the storage account type for the managed disk
	DataDiskType *DiskType

	// Specifies the resource id of the DSCP configuration to apply to the node type network interface.
	DscpConfigurationID *string

	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool

	// Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption for all
	// the disks including Resource/Temp disk at host itself. Default: The Encryption
	// at host will be disabled unless this property is set to true for the resource.
	EnableEncryptionAtHost *bool

	// Specifies whether each node is allocated its own public IPv4 address. This is only supported on secondary node types with
	// custom Load Balancers.
	EnableNodePublicIP *bool

	// Specifies whether each node is allocated its own public IPv6 address. This is only supported on secondary node types with
	// custom Load Balancers.
	EnableNodePublicIPv6 *bool

	// Specifies whether the node type should be overprovisioned. It is only allowed for stateless node types.
	EnableOverProvisioning *bool

	// The range of ephemeral ports that nodes in this node type should be configured with.
	EphemeralPorts *EndpointRangeDescription

	// Specifies the eviction policy for virtual machines in a SPOT node type. Default is Delete.
	EvictionPolicy *EvictionPolicyType

	// Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This setting can
	// only be specified for non-primary node types and can not be added or removed
	// after the node type is created.
	FrontendConfigurations []*FrontendConfiguration

	// Specifies the full host group resource Id. This property is used for deploying on azure dedicated hosts.
	HostGroupID *string

	// Indicates whether the node type will be Spot Virtual Machines. Azure will allocate the VMs if there is capacity available
	// and the VMs can be evicted at any time.
	IsSpotVM *bool

	// Indicates if the node type can only host Stateless workloads.
	IsStateless *bool

	// Indicates if scale set associated with the node type can be composed of multiple placement groups.
	MultiplePlacementGroups *bool

	// Specifies the NAT configuration on default public Load Balancer for the node type. This is only supported for node types
	// use the default public Load Balancer.
	NatConfigurations []*NodeTypeNatConfig

	// Specifies the resource id of a NAT Gateway to attach to the subnet of this node type. Node type must use custom load balancer.
	NatGatewayID *string

	// The Network Security Rules for this node type. This setting can only be specified for node types that are configured with
	// frontend configurations.
	NetworkSecurityRules []*NetworkSecurityRule

	// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should
	// run.
	PlacementProperties map[string]*string

	// Specifies whether secure boot should be enabled on the nodeType. Can only be used with TrustedLaunch SecurityType
	SecureBootEnabled *bool

	// Specifies the security type of the nodeType. Only Standard and TrustedLaunch are currently supported
	SecurityType *SecurityType

	// Specifies the service artifact reference id used to set same image version for all virtual machines in the scale set when
	// using 'latest' image version.
	ServiceArtifactReferenceID *string

	// Indicates the time duration after which the platform will not try to restore the VMSS SPOT instances specified as ISO 8601.
	SpotRestoreTimeout *string

	// Indicates the resource id of the subnet for the node type.
	SubnetID *string

	// Specifies whether the use public load balancer. If not specified and the node type doesn't have its own frontend configuration,
	// it will be attached to the default load balancer. If the node type uses
	// its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be an Internal Load Balancer.
	// If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is
	// false or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity.
	UseDefaultPublicLoadBalancer *bool

	// Indicates whether to use ephemeral os disk. The sku selected on the vmSize property needs to support this feature.
	UseEphemeralOSDisk *bool

	// Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk will be
	// attached and the temporary disk will be used. It is only allowed for stateless
	// node types.
	UseTempDataDisk *bool

	// Set of extensions that should be installed onto the virtual machines.
	VMExtensions []*VMSSExtension

	// The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer.
	VMImageOffer *string

	// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace
	// images. Before you can use a marketplace image from an API, you must
	// enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click
	// Want to deploy programmatically, Get Started ->. Enter any required
	// information and then click Save.
	VMImagePlan *VMImagePlan

	// The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer.
	VMImagePublisher *string

	// Indicates the resource id of the vm image. This parameter is used for custom vm image.
	VMImageResourceID *string

	// The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter.
	VMImageSKU *string

	// The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be specified to select the latest
	// version of an image. If omitted, the default is 'latest'.
	VMImageVersion *string

	// Identities to assign to the virtual machine scale set under the node type.
	VMManagedIdentity *VMManagedIdentity

	// The secrets to install in the virtual machines.
	VMSecrets []*VaultSecretGroup

	// Specifies the actions to be performed on the vms before bootstrapping the service fabric runtime.
	VMSetupActions []*VMSetupAction

	// Indicates the resource id of the vm shared galleries image. This parameter is used for custom vm image.
	VMSharedGalleryImageID *string

	// The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example, Standard_D3.
	VMSize *string

	// Specifies the availability zones where the node type would span across. If the cluster is not spanning across availability
	// zones, initiates az migration for the cluster.
	Zones []*string

	// READ-ONLY; The provisioning state of the node type resource.
	ProvisioningState *ManagedResourceProvisioningState
}

// NodeTypeSKU - Describes a node type sku.
type NodeTypeSKU struct {
	// REQUIRED; The number of nodes in the node type.
	// If present in request it will override properties.vmInstanceCount.
	Capacity *int32

	// The sku name.
	// Name is internally generated and is used in auto-scale scenarios.
	// Property does not allow to be changed to other values than generated.
	// To avoid deployment errors please omit the property.
	Name *string

	// Specifies the tier of the node type.
	// Possible Values:
	// Standard
	Tier *string
}

// NodeTypeSKUCapacity - Provides information about how node type can be scaled.
type NodeTypeSKUCapacity struct {
	// READ-ONLY; Default node count in a node type.
	Default *int32

	// READ-ONLY; Highest permitted node count in a node type.
	Maximum *int32

	// READ-ONLY; Lowest permitted node count in a node type.
	Minimum *int32

	// READ-ONLY; Node type capacity scale type.
	ScaleType *NodeTypeSKUScaleType
}

// NodeTypeSupportedSKU - Describes a node type supported sku.
type NodeTypeSupportedSKU struct {
	// READ-ONLY; The sku name.
	Name *string

	// READ-ONLY; Specifies the tier of the node type.
	// Possible Values:
	// Standard
	Tier *string
}

// NodeTypeUpdateParameters - Node type update request
type NodeTypeUpdateParameters struct {
	// The node type sku.
	SKU *NodeTypeSKU

	// Node type update parameters
	Tags map[string]*string
}

// OperationListResult - Describes the result of the request to list Service Fabric resource provider operations.
type OperationListResult struct {
	// List of operations supported by the Service Fabric resource provider.
	Value []*OperationResult

	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string
}

// OperationResult - Available operation list result
type OperationResult struct {
	// The object that represents the operation.
	Display *AvailableOperationDisplay

	// Indicates whether the operation is a data action
	IsDataAction *bool

	// The name of the operation.
	Name *string

	// The URL to use for getting the next set of results.
	NextLink *string

	// Origin result
	Origin *string
}

// Partition - Describes how the service is partitioned.
type Partition struct {
	// REQUIRED; Specifies how the service is partitioned.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type Partition.
func (p *Partition) GetPartition() *Partition { return p }

// PartitionInstanceCountScaleMechanism - Represents a scaling mechanism for adding or removing instances of stateless service
// partition.
type PartitionInstanceCountScaleMechanism struct {
	// REQUIRED; Specifies the mechanism associated with this scaling policy.
	Kind *ServiceScalingMechanismKind

	// REQUIRED; Maximum number of instances of the partition.
	MaxInstanceCount *int32

	// REQUIRED; Minimum number of instances of the partition.
	MinInstanceCount *int32

	// REQUIRED; The number of instances to add or remove during a scaling operation.
	ScaleIncrement *int32
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type PartitionInstanceCountScaleMechanism.
func (p *PartitionInstanceCountScaleMechanism) GetScalingMechanism() *ScalingMechanism {
	return &ScalingMechanism{
		Kind: p.Kind,
	}
}

// ResourceAzStatus - Describes Az Resiliency status of Base resources
type ResourceAzStatus struct {
	// READ-ONLY; Zone resiliency status details for the resource.
	Details *string

	// READ-ONLY; VM Size name.
	IsZoneResilient *bool

	// READ-ONLY; VM Size properties.
	ResourceName *string

	// READ-ONLY; VM Size id.
	ResourceType *string
}

// RollingUpgradeMonitoringPolicy - The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicy struct {
	// REQUIRED; The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations.
	// Invalid indicates the failure action is invalid. Rollback specifies that the
	// upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
	// mode.
	FailureAction *FailureAction

	// REQUIRED; The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction
	// is executed. It is interpreted as a string representing an ISO 8601 duration with
	// following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout *string

	// REQUIRED; The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next
	// upgrade domain. It is interpreted as a string representing an ISO 8601 duration with
	// following format "hh:mm:ss.fff".
	HealthCheckStableDuration *string

	// REQUIRED; The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted
	// as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration *string

	// REQUIRED; The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than
	// 12 hours. It is interpreted as a string representing an ISO 8601 duration with following
	// format "hh:mm:ss.fff".
	UpgradeDomainTimeout *string

	// REQUIRED; The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than
	// 12 hours. It is interpreted as a string representing an ISO 8601 duration with following
	// format "hh:mm:ss.fff".
	UpgradeTimeout *string
}

// RuntimeResumeApplicationUpgradeParameters - Parameters for Resume Upgrade action. The upgrade domain name must be specified.
type RuntimeResumeApplicationUpgradeParameters struct {
	// The upgrade domain name. Expected to be the next upgrade domain if the application is upgrading.
	UpgradeDomainName *string
}

// SKU - Service Fabric managed cluster Sku definition
type SKU struct {
	// REQUIRED; Sku Name.
	Name *SKUName
}

// ScalingMechanism - Describes the mechanism for performing a scaling operation.
type ScalingMechanism struct {
	// REQUIRED; Specifies the mechanism associated with this scaling policy.
	Kind *ServiceScalingMechanismKind
}

// GetScalingMechanism implements the ScalingMechanismClassification interface for type ScalingMechanism.
func (s *ScalingMechanism) GetScalingMechanism() *ScalingMechanism { return s }

// ScalingPolicy - Specifies a metric to load balance a service during runtime.
type ScalingPolicy struct {
	// REQUIRED; Specifies the mechanism associated with this scaling policy
	ScalingMechanism ScalingMechanismClassification

	// REQUIRED; Specifies the trigger associated with this scaling policy.
	ScalingTrigger ScalingTriggerClassification
}

// ScalingTrigger - Describes the trigger for performing a scaling operation.
type ScalingTrigger struct {
	// REQUIRED; Specifies the trigger associated with this scaling policy.
	Kind *ServiceScalingTriggerKind
}

// GetScalingTrigger implements the ScalingTriggerClassification interface for type ScalingTrigger.
func (s *ScalingTrigger) GetScalingTrigger() *ScalingTrigger { return s }

// ServiceCorrelation - Creates a particular correlation between services.
type ServiceCorrelation struct {
	// REQUIRED; The ServiceCorrelationScheme which describes the relationship between this service and the service specified
	// via ServiceName.
	Scheme *ServiceCorrelationScheme

	// REQUIRED; The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName *string
}

// ServiceEndpoint - The service endpoint properties.
type ServiceEndpoint struct {
	// REQUIRED; The type of the endpoint service.
	Service *string

	// A list of locations.
	Locations []*string
}

// ServiceLoadMetric - Specifies a metric to load balance a service during runtime.
type ServiceLoadMetric struct {
	// REQUIRED; The name of the metric. If the service chooses to report load during runtime, the load metric name should match
	// the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name *string

	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int32

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when
	// it is a Primary replica.
	PrimaryDefaultLoad *int32

	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when
	// it is a Secondary replica.
	SecondaryDefaultLoad *int32

	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *ServiceLoadMetricWeight
}

// ServicePlacementInvalidDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where a
// particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicy struct {
	// REQUIRED; The name of the domain that should not be used for placement.
	DomainName *string

	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementInvalidDomainPolicy.
func (s *ServicePlacementInvalidDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementNonPartiallyPlaceServicePolicy
type ServicePlacementNonPartiallyPlaceServicePolicy struct {
	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementNonPartiallyPlaceServicePolicy.
func (s *ServicePlacementNonPartiallyPlaceServicePolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementPolicy - Describes the policy to be used for placement of a Service Fabric service.
type ServicePlacementPolicy struct {
	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementPolicy.
func (s *ServicePlacementPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy { return s }

// ServicePlacementPreferPrimaryDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where
// the service's Primary replicas should optimally be placed in a particular domain.
// This placement policy is usually used with fault domains in scenarios where the Service Fabric cluster is geographically
// distributed in order to indicate that a service's primary replica should be
// located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional or datacenter boundaries.
// Note that since this is an optimization it is possible that the Primary
// replica may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementPreferPrimaryDomainPolicy.
func (s *ServicePlacementPreferPrimaryDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementRequireDomainDistributionPolicy - Describes the policy to be used for placement of a Service Fabric service
// where two replicas from the same partition should never be placed in the same fault or upgrade domain.
// While this is not common it can expose the service to an increased risk of concurrent failures due to unplanned outages
// or other cases of subsequent/concurrent failures. As an example, consider a case
// where replicas are deployed across different data center, with one replica per location. In the event that one of the datacenters
// goes offline, normally the replica that was placed in that datacenter
// will be packed into one of the remaining datacenters. If this is not desirable then this policy should be set.
type ServicePlacementRequireDomainDistributionPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementRequireDomainDistributionPolicy.
func (s *ServicePlacementRequireDomainDistributionPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServicePlacementRequiredDomainPolicy - Describes the policy to be used for placement of a Service Fabric service where
// the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicy struct {
	// REQUIRED; The name of the domain that should used for placement as per this policy.
	DomainName *string

	// REQUIRED; The type of placement policy for a service fabric service. Following are the possible values.
	Type *ServicePlacementPolicyType
}

// GetServicePlacementPolicy implements the ServicePlacementPolicyClassification interface for type ServicePlacementRequiredDomainPolicy.
func (s *ServicePlacementRequiredDomainPolicy) GetServicePlacementPolicy() *ServicePlacementPolicy {
	return &ServicePlacementPolicy{
		Type: s.Type,
	}
}

// ServiceResource - The service resource.
type ServiceResource struct {
	// Resource location depends on the parent resource.
	Location *string

	// The service resource properties.
	Properties ServiceResourcePropertiesClassification

	// Azure resource tags.
	Tags map[string]*string

	// READ-ONLY; Azure resource identifier.
	ID *string

	// READ-ONLY; Azure resource name.
	Name *string

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData

	// READ-ONLY; Azure resource type.
	Type *string
}

// ServiceResourceList - The list of service resources.
type ServiceResourceList struct {
	Value []*ServiceResource

	// READ-ONLY; URL to get the next set of service list results if there are any.
	NextLink *string
}

// ServiceResourceProperties - The service resource properties.
type ServiceResourceProperties struct {
	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For
	// example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP). When updating
	// serviceDnsName, old name may be temporarily resolvable. However, rely on new name. When removing serviceDnsName, removed
	// name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type ServiceResourceProperties.
func (s *ServiceResourceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return s
}

// ServiceTypeHealthPolicy - Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// REQUIRED; The maximum allowed percentage of unhealthy partitions per service.
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered
	// in error. If the percentage is respected but there is at least one
	// unhealthy partition, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy
	// partitions over the total number of partitions in the service. The computation
	// rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService *int32

	// REQUIRED; The maximum allowed percentage of unhealthy replicas per partition.
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered
	// in error. If the percentage is respected but there is at least one
	// unhealthy replica, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy
	// replicas over the total number of replicas in the partition. The computation
	// rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition *int32

	// REQUIRED; The maximum allowed percentage of unhealthy services.
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is
	// considered in error. If the percentage is respected but there is at least one
	// unhealthy service, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy services
	// of the specific service type over the total number of services of the specific
	// service type. The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices *int32
}

// ServiceUpdateParameters - Service update request
type ServiceUpdateParameters struct {
	// Service update parameters
	Tags map[string]*string
}

// SettingsParameterDescription - Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// REQUIRED; The parameter name of fabric setting.
	Name *string

	// REQUIRED; The parameter value of fabric setting.
	Value *string
}

// SettingsSectionDescription - Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// REQUIRED; The section name of the fabric settings.
	Name *string

	// REQUIRED; The collection of parameters in the section.
	Parameters []*SettingsParameterDescription
}

// SingletonPartitionScheme
type SingletonPartitionScheme struct {
	// REQUIRED; Specifies how the service is partitioned.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type SingletonPartitionScheme.
func (s *SingletonPartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: s.PartitionScheme,
	}
}

// StatefulServiceProperties - The properties of a stateful service resource.
type StatefulServiceProperties struct {
	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of
	// this property is true, if not it is false.
	HasPersistedState *bool

	// The minimum replica set size as a number.
	MinReplicaSetSize *int32

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For
	// example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string

	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP). When updating
	// serviceDnsName, old name may be temporarily resolvable. However, rely on new name. When removing serviceDnsName, removed
	// name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string

	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string

	// The target replica set size as a number.
	TargetReplicaSetSize *int32

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type StatefulServiceProperties.
func (s *StatefulServiceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return &ServiceResourceProperties{
		CorrelationScheme:            s.CorrelationScheme,
		DefaultMoveCost:              s.DefaultMoveCost,
		PartitionDescription:         s.PartitionDescription,
		PlacementConstraints:         s.PlacementConstraints,
		ProvisioningState:            s.ProvisioningState,
		ScalingPolicies:              s.ScalingPolicies,
		ServiceDNSName:               s.ServiceDNSName,
		ServiceKind:                  s.ServiceKind,
		ServiceLoadMetrics:           s.ServiceLoadMetrics,
		ServicePackageActivationMode: s.ServicePackageActivationMode,
		ServicePlacementPolicies:     s.ServicePlacementPolicies,
		ServiceTypeName:              s.ServiceTypeName,
	}
}

// StatelessServiceProperties - The properties of a stateless service resource.
type StatelessServiceProperties struct {
	// REQUIRED; The instance count.
	InstanceCount *int32

	// REQUIRED; Describes how the service is partitioned.
	PartitionDescription PartitionClassification

	// REQUIRED; The kind of service (Stateless or Stateful).
	ServiceKind *ServiceKind

	// REQUIRED; The name of the service type
	ServiceTypeName *string

	// A list that describes the correlation of the service with other services.
	CorrelationScheme []*ServiceCorrelation

	// Specifies the move cost for the service.
	DefaultMoveCost *MoveCost

	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during
	// operations like upgrade or deactivate node. The actual number that is used is
	// max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during
	// MinInstanceCount computation -1 is first converted into the number of nodes on
	// which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int32

	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety
	// check during operations like upgrade or deactivate node. The actual number that
	// is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to
	// -1, during MinInstancePercentage computation, -1 is first converted into the
	// number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int32

	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting
	// a service to particular nodes based on the service requirements. For
	// example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string

	// Scaling policies for this service.
	ScalingPolicies []*ScalingPolicy

	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service
	// endpoints for application layer protocols (e.g., HTTP). When updating
	// serviceDnsName, old name may be temporarily resolvable. However, rely on new name. When removing serviceDnsName, removed
	// name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDNSName *string

	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []*ServiceLoadMetric

	// The activation Mode of the service package
	ServicePackageActivationMode *ServicePackageActivationMode

	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []ServicePlacementPolicyClassification

	// READ-ONLY; The current deployment or provisioning state, which only appears in the response
	ProvisioningState *string
}

// GetServiceResourceProperties implements the ServiceResourcePropertiesClassification interface for type StatelessServiceProperties.
func (s *StatelessServiceProperties) GetServiceResourceProperties() *ServiceResourceProperties {
	return &ServiceResourceProperties{
		CorrelationScheme:            s.CorrelationScheme,
		DefaultMoveCost:              s.DefaultMoveCost,
		PartitionDescription:         s.PartitionDescription,
		PlacementConstraints:         s.PlacementConstraints,
		ProvisioningState:            s.ProvisioningState,
		ScalingPolicies:              s.ScalingPolicies,
		ServiceDNSName:               s.ServiceDNSName,
		ServiceKind:                  s.ServiceKind,
		ServiceLoadMetrics:           s.ServiceLoadMetrics,
		ServicePackageActivationMode: s.ServicePackageActivationMode,
		ServicePlacementPolicies:     s.ServicePlacementPolicies,
		ServiceTypeName:              s.ServiceTypeName,
	}
}

// SubResource - Azure resource identifier.
type SubResource struct {
	// Azure resource identifier.
	ID *string
}

// Subnet - Describes a Subnet.
type Subnet struct {
	// REQUIRED; Subnet name.
	Name *string

	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIPv6 *bool

	// Full resource id for the network security group.
	NetworkSecurityGroupID *string

	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *PrivateEndpointNetworkPolicies

	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *PrivateLinkServiceNetworkPolicies
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time

	// The identity that created the resource.
	CreatedBy *string

	// The type of identity that created the resource.
	CreatedByType *string

	// The timestamp of resource last modification (UTC).
	LastModifiedAt *time.Time

	// The identity that last modified the resource.
	LastModifiedBy *string

	// The type of identity that last modified the resource.
	LastModifiedByType *string
}

// UniformInt64RangePartitionScheme - Describes a partitioning scheme where an integer range is allocated evenly across a
// number of partitions.
type UniformInt64RangePartitionScheme struct {
	// REQUIRED; The number of partitions.
	Count *int32

	// REQUIRED; The upper bound of the partition key range that should be split between the partition â€˜Countâ€™
	HighKey *int64

	// REQUIRED; The lower bound of the partition key range that should be split between the partition â€˜Countâ€™
	LowKey *int64

	// REQUIRED; Specifies how the service is partitioned.
	PartitionScheme *PartitionScheme
}

// GetPartition implements the PartitionClassification interface for type UniformInt64RangePartitionScheme.
func (u *UniformInt64RangePartitionScheme) GetPartition() *Partition {
	return &Partition{
		PartitionScheme: u.PartitionScheme,
	}
}

type UserAssignedIdentity struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string
}

// VMImagePlan - Specifies information about the marketplace image used to create the virtual machine. This element is only
// used for marketplace images. Before you can use a marketplace image from an API, you must
// enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click
// Want to deploy programmatically, Get Started ->. Enter any required
// information and then click Save.
type VMImagePlan struct {
	// The plan ID.
	Name *string

	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product *string

	// The promotion code.
	PromotionCode *string

	// The publisher ID.
	Publisher *string
}

// VMManagedIdentity - Identities for the virtual machine scale set under the node type.
type VMManagedIdentity struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM
	// resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []*string
}

// VMSSExtension - Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtension struct {
	// REQUIRED; The name of the extension.
	Name *string

	// REQUIRED; Describes the properties of a Virtual Machine Scale Set Extension.
	Properties *VMSSExtensionProperties
}

// VMSSExtensionProperties - Describes the properties of a Virtual Machine Scale Set Extension.
type VMSSExtensionProperties struct {
	// REQUIRED; The name of the extension handler publisher.
	Publisher *string

	// REQUIRED; Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string

	// REQUIRED; Specifies the version of the script handler.
	TypeHandlerVersion *string

	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed,
	// however, the extension will not upgrade minor versions unless redeployed, even
	// with this property set to true.
	AutoUpgradeMinorVersion *bool

	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension
	// available.
	EnableAutomaticUpgrade *bool

	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if
	// the extension configuration has not changed.
	ForceUpdateTag *string

	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings any

	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []*string

	// Json formatted public settings for the extension.
	Settings any

	// Indicates the setup order for the extension.
	SetupOrder []*VmssExtensionSetupOrder

	// READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string
}

// VMSize - VM Sizes properties.
type VMSize struct {
	// READ-ONLY; VM Size name.
	Size *string
}

// VaultCertificate - Describes a single certificate reference in a Key Vault, and where the certificate should reside on
// the VM.
type VaultCertificate struct {
	// REQUIRED; For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added.
	// The specified certificate store is implicitly in the LocalMachine account.
	// For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name .crt for the X509
	// certificate file and .prv for private key. Both of these files are .pem
	// formatted.
	CertificateStore *string

	// REQUIRED; This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the
	// Key Vault, see Add a key or secret to the key vault
	// [https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add]. In this case, your certificate needs to be It
	// is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"",
	// "dataType":"pfx",
	// "password":""
	// }
	CertificateURL *string
}

// VaultSecretGroup - Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroup struct {
	// REQUIRED; The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault *SubResource

	// REQUIRED; The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []*VaultCertificate
}

// VmssDataDisk - Managed data disk description.
type VmssDataDisk struct {
	// REQUIRED; Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter *string

	// REQUIRED; Disk size for each vm in the node type in GBs.
	DiskSizeGB *int32

	// REQUIRED; Managed data disk type. Specifies the storage account type for the managed disk
	DiskType *DiskType

	// REQUIRED; Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the
	// service fabric data disk.
	Lun *int32
}
