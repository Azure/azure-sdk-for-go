// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armservicefabricmanagedclusters

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime/datetime"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AddRemoveIncrementalNamedPartitionScalingMechanism.
func (a AddRemoveIncrementalNamedPartitionScalingMechanism) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ServiceScalingMechanismKindAddRemoveIncrementalNamedPartition
	populate(objectMap, "maxPartitionCount", a.MaxPartitionCount)
	populate(objectMap, "minPartitionCount", a.MinPartitionCount)
	populate(objectMap, "scaleIncrement", a.ScaleIncrement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddRemoveIncrementalNamedPartitionScalingMechanism.
func (a *AddRemoveIncrementalNamedPartitionScalingMechanism) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "maxPartitionCount":
			err = unpopulate(val, "MaxPartitionCount", &a.MaxPartitionCount)
			delete(rawMsg, key)
		case "minPartitionCount":
			err = unpopulate(val, "MinPartitionCount", &a.MinPartitionCount)
			delete(rawMsg, key)
		case "scaleIncrement":
			err = unpopulate(val, "ScaleIncrement", &a.ScaleIncrement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdditionalNetworkInterfaceConfiguration.
func (a AdditionalNetworkInterfaceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dscpConfiguration", a.DscpConfiguration)
	populate(objectMap, "enableAcceleratedNetworking", a.EnableAcceleratedNetworking)
	populate(objectMap, "ipConfigurations", a.IPConfigurations)
	populate(objectMap, "name", a.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdditionalNetworkInterfaceConfiguration.
func (a *AdditionalNetworkInterfaceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dscpConfiguration":
			err = unpopulate(val, "DscpConfiguration", &a.DscpConfiguration)
			delete(rawMsg, key)
		case "enableAcceleratedNetworking":
			err = unpopulate(val, "EnableAcceleratedNetworking", &a.EnableAcceleratedNetworking)
			delete(rawMsg, key)
		case "ipConfigurations":
			err = unpopulate(val, "IPConfigurations", &a.IPConfigurations)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationFetchHealthRequest.
func (a ApplicationFetchHealthRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deployedApplicationsHealthStateFilter", a.DeployedApplicationsHealthStateFilter)
	populate(objectMap, "eventsHealthStateFilter", a.EventsHealthStateFilter)
	populate(objectMap, "excludeHealthStatistics", a.ExcludeHealthStatistics)
	populate(objectMap, "servicesHealthStateFilter", a.ServicesHealthStateFilter)
	populate(objectMap, "timeout", a.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationFetchHealthRequest.
func (a *ApplicationFetchHealthRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deployedApplicationsHealthStateFilter":
			err = unpopulate(val, "DeployedApplicationsHealthStateFilter", &a.DeployedApplicationsHealthStateFilter)
			delete(rawMsg, key)
		case "eventsHealthStateFilter":
			err = unpopulate(val, "EventsHealthStateFilter", &a.EventsHealthStateFilter)
			delete(rawMsg, key)
		case "excludeHealthStatistics":
			err = unpopulate(val, "ExcludeHealthStatistics", &a.ExcludeHealthStatistics)
			delete(rawMsg, key)
		case "servicesHealthStateFilter":
			err = unpopulate(val, "ServicesHealthStateFilter", &a.ServicesHealthStateFilter)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &a.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationHealthPolicy.
func (a ApplicationHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "considerWarningAsError", a.ConsiderWarningAsError)
	populate(objectMap, "defaultServiceTypeHealthPolicy", a.DefaultServiceTypeHealthPolicy)
	populate(objectMap, "maxPercentUnhealthyDeployedApplications", a.MaxPercentUnhealthyDeployedApplications)
	populate(objectMap, "serviceTypeHealthPolicyMap", a.ServiceTypeHealthPolicyMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationHealthPolicy.
func (a *ApplicationHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "considerWarningAsError":
			err = unpopulate(val, "ConsiderWarningAsError", &a.ConsiderWarningAsError)
			delete(rawMsg, key)
		case "defaultServiceTypeHealthPolicy":
			err = unpopulate(val, "DefaultServiceTypeHealthPolicy", &a.DefaultServiceTypeHealthPolicy)
			delete(rawMsg, key)
		case "maxPercentUnhealthyDeployedApplications":
			err = unpopulate(val, "MaxPercentUnhealthyDeployedApplications", &a.MaxPercentUnhealthyDeployedApplications)
			delete(rawMsg, key)
		case "serviceTypeHealthPolicyMap":
			err = unpopulate(val, "ServiceTypeHealthPolicyMap", &a.ServiceTypeHealthPolicyMap)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResource.
func (a ApplicationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResource.
func (a *ApplicationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &a.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceList.
func (a ApplicationResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceList.
func (a *ApplicationResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceProperties.
func (a ApplicationResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "managedIdentities", a.ManagedIdentities)
	populate(objectMap, "parameters", a.Parameters)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "upgradePolicy", a.UpgradePolicy)
	populate(objectMap, "version", a.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceProperties.
func (a *ApplicationResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managedIdentities":
			err = unpopulate(val, "ManagedIdentities", &a.ManagedIdentities)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "upgradePolicy":
			err = unpopulate(val, "UpgradePolicy", &a.UpgradePolicy)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &a.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeResource.
func (a ApplicationTypeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeResource.
func (a *ApplicationTypeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeResourceList.
func (a ApplicationTypeResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeResourceList.
func (a *ApplicationTypeResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeResourceProperties.
func (a ApplicationTypeResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeResourceProperties.
func (a *ApplicationTypeResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeUpdateParameters.
func (a ApplicationTypeUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeUpdateParameters.
func (a *ApplicationTypeUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResource.
func (a ApplicationTypeVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionResource.
func (a *ApplicationTypeVersionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResourceList.
func (a ApplicationTypeVersionResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionResourceList.
func (a *ApplicationTypeVersionResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionResourceProperties.
func (a ApplicationTypeVersionResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appPackageUrl", a.AppPackageURL)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionResourceProperties.
func (a *ApplicationTypeVersionResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appPackageUrl":
			err = unpopulate(val, "AppPackageURL", &a.AppPackageURL)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionUpdateParameters.
func (a ApplicationTypeVersionUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionUpdateParameters.
func (a *ApplicationTypeVersionUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationTypeVersionsCleanupPolicy.
func (a ApplicationTypeVersionsCleanupPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxUnusedVersionsToKeep", a.MaxUnusedVersionsToKeep)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationTypeVersionsCleanupPolicy.
func (a *ApplicationTypeVersionsCleanupPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxUnusedVersionsToKeep":
			err = unpopulate(val, "MaxUnusedVersionsToKeep", &a.MaxUnusedVersionsToKeep)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationUpdateParameters.
func (a ApplicationUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationUpdateParameters.
func (a *ApplicationUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationUpdateParametersProperties.
func (a ApplicationUpdateParametersProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", a.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationUpdateParametersProperties.
func (a *ApplicationUpdateParametersProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			err = unpopulate(val, "Parameters", &a.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationUpgradePolicy.
func (a ApplicationUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationHealthPolicy", a.ApplicationHealthPolicy)
	populate(objectMap, "forceRestart", a.ForceRestart)
	populate(objectMap, "instanceCloseDelayDuration", a.InstanceCloseDelayDuration)
	populate(objectMap, "recreateApplication", a.RecreateApplication)
	populate(objectMap, "rollingUpgradeMonitoringPolicy", a.RollingUpgradeMonitoringPolicy)
	populate(objectMap, "upgradeMode", a.UpgradeMode)
	populate(objectMap, "upgradeReplicaSetCheckTimeout", a.UpgradeReplicaSetCheckTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationUpgradePolicy.
func (a *ApplicationUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationHealthPolicy":
			err = unpopulate(val, "ApplicationHealthPolicy", &a.ApplicationHealthPolicy)
			delete(rawMsg, key)
		case "forceRestart":
			err = unpopulate(val, "ForceRestart", &a.ForceRestart)
			delete(rawMsg, key)
		case "instanceCloseDelayDuration":
			err = unpopulate(val, "InstanceCloseDelayDuration", &a.InstanceCloseDelayDuration)
			delete(rawMsg, key)
		case "recreateApplication":
			err = unpopulate(val, "RecreateApplication", &a.RecreateApplication)
			delete(rawMsg, key)
		case "rollingUpgradeMonitoringPolicy":
			err = unpopulate(val, "RollingUpgradeMonitoringPolicy", &a.RollingUpgradeMonitoringPolicy)
			delete(rawMsg, key)
		case "upgradeMode":
			err = unpopulate(val, "UpgradeMode", &a.UpgradeMode)
			delete(rawMsg, key)
		case "upgradeReplicaSetCheckTimeout":
			err = unpopulate(val, "UpgradeReplicaSetCheckTimeout", &a.UpgradeReplicaSetCheckTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationUserAssignedIdentity.
func (a ApplicationUserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "principalId", a.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationUserAssignedIdentity.
func (a *ApplicationUserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &a.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOperationDisplay.
func (a AvailableOperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "operation", a.Operation)
	populate(objectMap, "provider", a.Provider)
	populate(objectMap, "resource", a.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailableOperationDisplay.
func (a *AvailableOperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &a.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &a.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &a.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AveragePartitionLoadScalingTrigger.
func (a AveragePartitionLoadScalingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ServiceScalingTriggerKindAveragePartitionLoadTrigger
	populate(objectMap, "lowerLoadThreshold", a.LowerLoadThreshold)
	populate(objectMap, "metricName", a.MetricName)
	populate(objectMap, "scaleInterval", a.ScaleInterval)
	populate(objectMap, "upperLoadThreshold", a.UpperLoadThreshold)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AveragePartitionLoadScalingTrigger.
func (a *AveragePartitionLoadScalingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "lowerLoadThreshold":
			err = unpopulate(val, "LowerLoadThreshold", &a.LowerLoadThreshold)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, "MetricName", &a.MetricName)
			delete(rawMsg, key)
		case "scaleInterval":
			err = unpopulate(val, "ScaleInterval", &a.ScaleInterval)
			delete(rawMsg, key)
		case "upperLoadThreshold":
			err = unpopulate(val, "UpperLoadThreshold", &a.UpperLoadThreshold)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AverageServiceLoadScalingTrigger.
func (a AverageServiceLoadScalingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ServiceScalingTriggerKindAverageServiceLoadTrigger
	populate(objectMap, "lowerLoadThreshold", a.LowerLoadThreshold)
	populate(objectMap, "metricName", a.MetricName)
	populate(objectMap, "scaleInterval", a.ScaleInterval)
	populate(objectMap, "upperLoadThreshold", a.UpperLoadThreshold)
	populate(objectMap, "useOnlyPrimaryLoad", a.UseOnlyPrimaryLoad)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AverageServiceLoadScalingTrigger.
func (a *AverageServiceLoadScalingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "lowerLoadThreshold":
			err = unpopulate(val, "LowerLoadThreshold", &a.LowerLoadThreshold)
			delete(rawMsg, key)
		case "metricName":
			err = unpopulate(val, "MetricName", &a.MetricName)
			delete(rawMsg, key)
		case "scaleInterval":
			err = unpopulate(val, "ScaleInterval", &a.ScaleInterval)
			delete(rawMsg, key)
		case "upperLoadThreshold":
			err = unpopulate(val, "UpperLoadThreshold", &a.UpperLoadThreshold)
			delete(rawMsg, key)
		case "useOnlyPrimaryLoad":
			err = unpopulate(val, "UseOnlyPrimaryLoad", &a.UseOnlyPrimaryLoad)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureActiveDirectory.
func (a AzureActiveDirectory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientApplication", a.ClientApplication)
	populate(objectMap, "clusterApplication", a.ClusterApplication)
	populate(objectMap, "tenantId", a.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureActiveDirectory.
func (a *AzureActiveDirectory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientApplication":
			err = unpopulate(val, "ClientApplication", &a.ClientApplication)
			delete(rawMsg, key)
		case "clusterApplication":
			err = unpopulate(val, "ClusterApplication", &a.ClusterApplication)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &a.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClientCertificate.
func (c ClientCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commonName", c.CommonName)
	populate(objectMap, "isAdmin", c.IsAdmin)
	populate(objectMap, "issuerThumbprint", c.IssuerThumbprint)
	populate(objectMap, "thumbprint", c.Thumbprint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientCertificate.
func (c *ClientCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonName":
			err = unpopulate(val, "CommonName", &c.CommonName)
			delete(rawMsg, key)
		case "isAdmin":
			err = unpopulate(val, "IsAdmin", &c.IsAdmin)
			delete(rawMsg, key)
		case "issuerThumbprint":
			err = unpopulate(val, "IssuerThumbprint", &c.IssuerThumbprint)
			delete(rawMsg, key)
		case "thumbprint":
			err = unpopulate(val, "Thumbprint", &c.Thumbprint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterHealthPolicy.
func (c ClusterHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxPercentUnhealthyApplications", c.MaxPercentUnhealthyApplications)
	populate(objectMap, "maxPercentUnhealthyNodes", c.MaxPercentUnhealthyNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterHealthPolicy.
func (c *ClusterHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxPercentUnhealthyApplications":
			err = unpopulate(val, "MaxPercentUnhealthyApplications", &c.MaxPercentUnhealthyApplications)
			delete(rawMsg, key)
		case "maxPercentUnhealthyNodes":
			err = unpopulate(val, "MaxPercentUnhealthyNodes", &c.MaxPercentUnhealthyNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterMonitoringPolicy.
func (c ClusterMonitoringPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "healthCheckRetryTimeout", c.HealthCheckRetryTimeout)
	populate(objectMap, "healthCheckStableDuration", c.HealthCheckStableDuration)
	populate(objectMap, "healthCheckWaitDuration", c.HealthCheckWaitDuration)
	populate(objectMap, "upgradeDomainTimeout", c.UpgradeDomainTimeout)
	populate(objectMap, "upgradeTimeout", c.UpgradeTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterMonitoringPolicy.
func (c *ClusterMonitoringPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "healthCheckRetryTimeout":
			err = unpopulate(val, "HealthCheckRetryTimeout", &c.HealthCheckRetryTimeout)
			delete(rawMsg, key)
		case "healthCheckStableDuration":
			err = unpopulate(val, "HealthCheckStableDuration", &c.HealthCheckStableDuration)
			delete(rawMsg, key)
		case "healthCheckWaitDuration":
			err = unpopulate(val, "HealthCheckWaitDuration", &c.HealthCheckWaitDuration)
			delete(rawMsg, key)
		case "upgradeDomainTimeout":
			err = unpopulate(val, "UpgradeDomainTimeout", &c.UpgradeDomainTimeout)
			delete(rawMsg, key)
		case "upgradeTimeout":
			err = unpopulate(val, "UpgradeTimeout", &c.UpgradeTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpgradeDeltaHealthPolicy.
func (c ClusterUpgradeDeltaHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxPercentDeltaUnhealthyApplications", c.MaxPercentDeltaUnhealthyApplications)
	populate(objectMap, "maxPercentDeltaUnhealthyNodes", c.MaxPercentDeltaUnhealthyNodes)
	populate(objectMap, "maxPercentUpgradeDomainDeltaUnhealthyNodes", c.MaxPercentUpgradeDomainDeltaUnhealthyNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterUpgradeDeltaHealthPolicy.
func (c *ClusterUpgradeDeltaHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxPercentDeltaUnhealthyApplications":
			err = unpopulate(val, "MaxPercentDeltaUnhealthyApplications", &c.MaxPercentDeltaUnhealthyApplications)
			delete(rawMsg, key)
		case "maxPercentDeltaUnhealthyNodes":
			err = unpopulate(val, "MaxPercentDeltaUnhealthyNodes", &c.MaxPercentDeltaUnhealthyNodes)
			delete(rawMsg, key)
		case "maxPercentUpgradeDomainDeltaUnhealthyNodes":
			err = unpopulate(val, "MaxPercentUpgradeDomainDeltaUnhealthyNodes", &c.MaxPercentUpgradeDomainDeltaUnhealthyNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpgradePolicy.
func (c ClusterUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "deltaHealthPolicy", c.DeltaHealthPolicy)
	populate(objectMap, "forceRestart", c.ForceRestart)
	populate(objectMap, "healthPolicy", c.HealthPolicy)
	populate(objectMap, "monitoringPolicy", c.MonitoringPolicy)
	populate(objectMap, "upgradeReplicaSetCheckTimeout", c.UpgradeReplicaSetCheckTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterUpgradePolicy.
func (c *ClusterUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deltaHealthPolicy":
			err = unpopulate(val, "DeltaHealthPolicy", &c.DeltaHealthPolicy)
			delete(rawMsg, key)
		case "forceRestart":
			err = unpopulate(val, "ForceRestart", &c.ForceRestart)
			delete(rawMsg, key)
		case "healthPolicy":
			err = unpopulate(val, "HealthPolicy", &c.HealthPolicy)
			delete(rawMsg, key)
		case "monitoringPolicy":
			err = unpopulate(val, "MonitoringPolicy", &c.MonitoringPolicy)
			delete(rawMsg, key)
		case "upgradeReplicaSetCheckTimeout":
			err = unpopulate(val, "UpgradeReplicaSetCheckTimeout", &c.UpgradeReplicaSetCheckTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EndpointRangeDescription.
func (e EndpointRangeDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endPort", e.EndPort)
	populate(objectMap, "startPort", e.StartPort)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EndpointRangeDescription.
func (e *EndpointRangeDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endPort":
			err = unpopulate(val, "EndPort", &e.EndPort)
			delete(rawMsg, key)
		case "startPort":
			err = unpopulate(val, "StartPort", &e.StartPort)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorModelError.
func (e ErrorModelError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorModelError.
func (e *ErrorModelError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulation.
func (f FaultSimulation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", f.Details)
	populateTime[datetime.RFC3339](objectMap, "endTime", f.EndTime)
	populate(objectMap, "simulationId", f.SimulationID)
	populateTime[datetime.RFC3339](objectMap, "startTime", f.StartTime)
	populate(objectMap, "status", f.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulation.
func (f *FaultSimulation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
			err = unpopulate(val, "Details", &f.Details)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTime[datetime.RFC3339](val, "EndTime", &f.EndTime)
			delete(rawMsg, key)
		case "simulationId":
			err = unpopulate(val, "SimulationID", &f.SimulationID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTime[datetime.RFC3339](val, "StartTime", &f.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &f.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationConstraints.
func (f FaultSimulationConstraints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "expirationTime", f.ExpirationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationConstraints.
func (f *FaultSimulationConstraints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expirationTime":
			err = unpopulateTime[datetime.RFC3339](val, "ExpirationTime", &f.ExpirationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationContent.
func (f FaultSimulationContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "constraints", f.Constraints)
	populate(objectMap, "faultKind", f.FaultKind)
	populate(objectMap, "force", f.Force)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationContent.
func (f *FaultSimulationContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "constraints":
			err = unpopulate(val, "Constraints", &f.Constraints)
			delete(rawMsg, key)
		case "faultKind":
			err = unpopulate(val, "FaultKind", &f.FaultKind)
			delete(rawMsg, key)
		case "force":
			err = unpopulate(val, "Force", &f.Force)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationContentWrapper.
func (f FaultSimulationContentWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", f.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationContentWrapper.
func (f *FaultSimulationContentWrapper) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
			f.Parameters, err = unmarshalFaultSimulationContentClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationDetails.
func (f FaultSimulationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterId", f.ClusterID)
	populate(objectMap, "nodeTypeFaultSimulation", f.NodeTypeFaultSimulation)
	populate(objectMap, "operationId", f.OperationID)
	populate(objectMap, "parameters", f.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationDetails.
func (f *FaultSimulationDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterId":
			err = unpopulate(val, "ClusterID", &f.ClusterID)
			delete(rawMsg, key)
		case "nodeTypeFaultSimulation":
			err = unpopulate(val, "NodeTypeFaultSimulation", &f.NodeTypeFaultSimulation)
			delete(rawMsg, key)
		case "operationId":
			err = unpopulate(val, "OperationID", &f.OperationID)
			delete(rawMsg, key)
		case "parameters":
			f.Parameters, err = unmarshalFaultSimulationContentClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationIDContent.
func (f FaultSimulationIDContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "simulationId", f.SimulationID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationIDContent.
func (f *FaultSimulationIDContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "simulationId":
			err = unpopulate(val, "SimulationID", &f.SimulationID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FaultSimulationListResult.
func (f FaultSimulationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FaultSimulationListResult.
func (f *FaultSimulationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &f.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FrontendConfiguration.
func (f FrontendConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationGatewayBackendAddressPoolId", f.ApplicationGatewayBackendAddressPoolID)
	populate(objectMap, "ipAddressType", f.IPAddressType)
	populate(objectMap, "loadBalancerBackendAddressPoolId", f.LoadBalancerBackendAddressPoolID)
	populate(objectMap, "loadBalancerInboundNatPoolId", f.LoadBalancerInboundNatPoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FrontendConfiguration.
func (f *FrontendConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationGatewayBackendAddressPoolId":
			err = unpopulate(val, "ApplicationGatewayBackendAddressPoolID", &f.ApplicationGatewayBackendAddressPoolID)
			delete(rawMsg, key)
		case "ipAddressType":
			err = unpopulate(val, "IPAddressType", &f.IPAddressType)
			delete(rawMsg, key)
		case "loadBalancerBackendAddressPoolId":
			err = unpopulate(val, "LoadBalancerBackendAddressPoolID", &f.LoadBalancerBackendAddressPoolID)
			delete(rawMsg, key)
		case "loadBalancerInboundNatPoolId":
			err = unpopulate(val, "LoadBalancerInboundNatPoolID", &f.LoadBalancerInboundNatPoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPConfiguration.
func (i IPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationGatewayBackendAddressPools", i.ApplicationGatewayBackendAddressPools)
	populate(objectMap, "loadBalancerBackendAddressPools", i.LoadBalancerBackendAddressPools)
	populate(objectMap, "loadBalancerInboundNatPools", i.LoadBalancerInboundNatPools)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "privateIPAddressVersion", i.PrivateIPAddressVersion)
	populate(objectMap, "publicIPAddressConfiguration", i.PublicIPAddressConfiguration)
	populate(objectMap, "subnet", i.Subnet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPConfiguration.
func (i *IPConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationGatewayBackendAddressPools":
			err = unpopulate(val, "ApplicationGatewayBackendAddressPools", &i.ApplicationGatewayBackendAddressPools)
			delete(rawMsg, key)
		case "loadBalancerBackendAddressPools":
			err = unpopulate(val, "LoadBalancerBackendAddressPools", &i.LoadBalancerBackendAddressPools)
			delete(rawMsg, key)
		case "loadBalancerInboundNatPools":
			err = unpopulate(val, "LoadBalancerInboundNatPools", &i.LoadBalancerInboundNatPools)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "privateIPAddressVersion":
			err = unpopulate(val, "PrivateIPAddressVersion", &i.PrivateIPAddressVersion)
			delete(rawMsg, key)
		case "publicIPAddressConfiguration":
			err = unpopulate(val, "PublicIPAddressConfiguration", &i.PublicIPAddressConfiguration)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, "Subnet", &i.Subnet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPConfigurationPublicIPAddressConfiguration.
func (i IPConfigurationPublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipTags", i.IPTags)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "publicIPAddressVersion", i.PublicIPAddressVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPConfigurationPublicIPAddressConfiguration.
func (i *IPConfigurationPublicIPAddressConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipTags":
			err = unpopulate(val, "IPTags", &i.IPTags)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "publicIPAddressVersion":
			err = unpopulate(val, "PublicIPAddressVersion", &i.PublicIPAddressVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPTag.
func (i IPTag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipTagType", i.IPTagType)
	populate(objectMap, "tag", i.Tag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPTag.
func (i *IPTag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipTagType":
			err = unpopulate(val, "IPTagType", &i.IPTagType)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &i.Tag)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LoadBalancingRule.
func (l LoadBalancingRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", l.BackendPort)
	populate(objectMap, "frontendPort", l.FrontendPort)
	populate(objectMap, "loadDistribution", l.LoadDistribution)
	populate(objectMap, "probePort", l.ProbePort)
	populate(objectMap, "probeProtocol", l.ProbeProtocol)
	populate(objectMap, "probeRequestPath", l.ProbeRequestPath)
	populate(objectMap, "protocol", l.Protocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LoadBalancingRule.
func (l *LoadBalancingRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
			err = unpopulate(val, "BackendPort", &l.BackendPort)
			delete(rawMsg, key)
		case "frontendPort":
			err = unpopulate(val, "FrontendPort", &l.FrontendPort)
			delete(rawMsg, key)
		case "loadDistribution":
			err = unpopulate(val, "LoadDistribution", &l.LoadDistribution)
			delete(rawMsg, key)
		case "probePort":
			err = unpopulate(val, "ProbePort", &l.ProbePort)
			delete(rawMsg, key)
		case "probeProtocol":
			err = unpopulate(val, "ProbeProtocol", &l.ProbeProtocol)
			delete(rawMsg, key)
		case "probeRequestPath":
			err = unpopulate(val, "ProbeRequestPath", &l.ProbeRequestPath)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &l.Protocol)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongRunningOperationResult.
func (l LongRunningOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "endTime", l.EndTime)
	populate(objectMap, "error", l.Error)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "percentComplete", l.PercentComplete)
	populateTime[datetime.RFC3339](objectMap, "startTime", l.StartTime)
	populate(objectMap, "status", l.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongRunningOperationResult.
func (l *LongRunningOperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTime[datetime.RFC3339](val, "EndTime", &l.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &l.Error)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &l.PercentComplete)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTime[datetime.RFC3339](val, "StartTime", &l.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &l.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedAzResiliencyStatus.
func (m ManagedAzResiliencyStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseResourceStatus", m.BaseResourceStatus)
	populate(objectMap, "isClusterZoneResilient", m.IsClusterZoneResilient)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedAzResiliencyStatus.
func (m *ManagedAzResiliencyStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseResourceStatus":
			err = unpopulate(val, "BaseResourceStatus", &m.BaseResourceStatus)
			delete(rawMsg, key)
		case "isClusterZoneResilient":
			err = unpopulate(val, "IsClusterZoneResilient", &m.IsClusterZoneResilient)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedCluster.
func (m ManagedCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "sku", m.SKU)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedCluster.
func (m *ManagedCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, "Etag", &m.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &m.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &m.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &m.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedClusterCodeVersionResult.
func (m ManagedClusterCodeVersionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedClusterCodeVersionResult.
func (m *ManagedClusterCodeVersionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedClusterListResult.
func (m ManagedClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedClusterListResult.
func (m *ManagedClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedClusterProperties.
func (m ManagedClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addonFeatures", m.AddonFeatures)
	populate(objectMap, "adminPassword", m.AdminPassword)
	populate(objectMap, "adminUserName", m.AdminUserName)
	populate(objectMap, "allocatedOutboundPorts", m.AllocatedOutboundPorts)
	populate(objectMap, "allowRdpAccess", m.AllowRdpAccess)
	populate(objectMap, "applicationTypeVersionsCleanupPolicy", m.ApplicationTypeVersionsCleanupPolicy)
	populate(objectMap, "autoGeneratedDomainNameLabelScope", m.AutoGeneratedDomainNameLabelScope)
	populate(objectMap, "auxiliarySubnets", m.AuxiliarySubnets)
	populate(objectMap, "azureActiveDirectory", m.AzureActiveDirectory)
	populate(objectMap, "clientConnectionPort", m.ClientConnectionPort)
	populate(objectMap, "clients", m.Clients)
	populate(objectMap, "clusterCertificateThumbprints", m.ClusterCertificateThumbprints)
	populate(objectMap, "clusterCodeVersion", m.ClusterCodeVersion)
	populate(objectMap, "clusterId", m.ClusterID)
	populate(objectMap, "clusterState", m.ClusterState)
	populate(objectMap, "clusterUpgradeCadence", m.ClusterUpgradeCadence)
	populate(objectMap, "clusterUpgradeMode", m.ClusterUpgradeMode)
	populate(objectMap, "dnsName", m.DNSName)
	populate(objectMap, "ddosProtectionPlanId", m.DdosProtectionPlanID)
	populate(objectMap, "enableAutoOSUpgrade", m.EnableAutoOSUpgrade)
	populate(objectMap, "enableHttpGatewayExclusiveAuthMode", m.EnableHTTPGatewayExclusiveAuthMode)
	populate(objectMap, "enableIpv6", m.EnableIPv6)
	populate(objectMap, "enableOutboundOnlyNodeTypes", m.EnableOutboundOnlyNodeTypes)
	populate(objectMap, "enableServicePublicIP", m.EnableServicePublicIP)
	populate(objectMap, "fabricSettings", m.FabricSettings)
	populate(objectMap, "fqdn", m.Fqdn)
	populate(objectMap, "httpGatewayConnectionPort", m.HTTPGatewayConnectionPort)
	populate(objectMap, "httpGatewayTokenAuthConnectionPort", m.HTTPGatewayTokenAuthConnectionPort)
	populate(objectMap, "ipTags", m.IPTags)
	populate(objectMap, "ipv4Address", m.IPv4Address)
	populate(objectMap, "ipv6Address", m.IPv6Address)
	populate(objectMap, "loadBalancingRules", m.LoadBalancingRules)
	populate(objectMap, "networkSecurityRules", m.NetworkSecurityRules)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "publicIPPrefixId", m.PublicIPPrefixID)
	populate(objectMap, "publicIPv6PrefixId", m.PublicIPv6PrefixID)
	populate(objectMap, "serviceEndpoints", m.ServiceEndpoints)
	populate(objectMap, "subnetId", m.SubnetID)
	populate(objectMap, "upgradeDescription", m.UpgradeDescription)
	populate(objectMap, "useCustomVnet", m.UseCustomVnet)
	populate(objectMap, "VMImage", m.VMImage)
	populate(objectMap, "zonalResiliency", m.ZonalResiliency)
	populate(objectMap, "zonalUpdateMode", m.ZonalUpdateMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedClusterProperties.
func (m *ManagedClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonFeatures":
			err = unpopulate(val, "AddonFeatures", &m.AddonFeatures)
			delete(rawMsg, key)
		case "adminPassword":
			err = unpopulate(val, "AdminPassword", &m.AdminPassword)
			delete(rawMsg, key)
		case "adminUserName":
			err = unpopulate(val, "AdminUserName", &m.AdminUserName)
			delete(rawMsg, key)
		case "allocatedOutboundPorts":
			err = unpopulate(val, "AllocatedOutboundPorts", &m.AllocatedOutboundPorts)
			delete(rawMsg, key)
		case "allowRdpAccess":
			err = unpopulate(val, "AllowRdpAccess", &m.AllowRdpAccess)
			delete(rawMsg, key)
		case "applicationTypeVersionsCleanupPolicy":
			err = unpopulate(val, "ApplicationTypeVersionsCleanupPolicy", &m.ApplicationTypeVersionsCleanupPolicy)
			delete(rawMsg, key)
		case "autoGeneratedDomainNameLabelScope":
			err = unpopulate(val, "AutoGeneratedDomainNameLabelScope", &m.AutoGeneratedDomainNameLabelScope)
			delete(rawMsg, key)
		case "auxiliarySubnets":
			err = unpopulate(val, "AuxiliarySubnets", &m.AuxiliarySubnets)
			delete(rawMsg, key)
		case "azureActiveDirectory":
			err = unpopulate(val, "AzureActiveDirectory", &m.AzureActiveDirectory)
			delete(rawMsg, key)
		case "clientConnectionPort":
			err = unpopulate(val, "ClientConnectionPort", &m.ClientConnectionPort)
			delete(rawMsg, key)
		case "clients":
			err = unpopulate(val, "Clients", &m.Clients)
			delete(rawMsg, key)
		case "clusterCertificateThumbprints":
			err = unpopulate(val, "ClusterCertificateThumbprints", &m.ClusterCertificateThumbprints)
			delete(rawMsg, key)
		case "clusterCodeVersion":
			err = unpopulate(val, "ClusterCodeVersion", &m.ClusterCodeVersion)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, "ClusterID", &m.ClusterID)
			delete(rawMsg, key)
		case "clusterState":
			err = unpopulate(val, "ClusterState", &m.ClusterState)
			delete(rawMsg, key)
		case "clusterUpgradeCadence":
			err = unpopulate(val, "ClusterUpgradeCadence", &m.ClusterUpgradeCadence)
			delete(rawMsg, key)
		case "clusterUpgradeMode":
			err = unpopulate(val, "ClusterUpgradeMode", &m.ClusterUpgradeMode)
			delete(rawMsg, key)
		case "dnsName":
			err = unpopulate(val, "DNSName", &m.DNSName)
			delete(rawMsg, key)
		case "ddosProtectionPlanId":
			err = unpopulate(val, "DdosProtectionPlanID", &m.DdosProtectionPlanID)
			delete(rawMsg, key)
		case "enableAutoOSUpgrade":
			err = unpopulate(val, "EnableAutoOSUpgrade", &m.EnableAutoOSUpgrade)
			delete(rawMsg, key)
		case "enableHttpGatewayExclusiveAuthMode":
			err = unpopulate(val, "EnableHTTPGatewayExclusiveAuthMode", &m.EnableHTTPGatewayExclusiveAuthMode)
			delete(rawMsg, key)
		case "enableIpv6":
			err = unpopulate(val, "EnableIPv6", &m.EnableIPv6)
			delete(rawMsg, key)
		case "enableOutboundOnlyNodeTypes":
			err = unpopulate(val, "EnableOutboundOnlyNodeTypes", &m.EnableOutboundOnlyNodeTypes)
			delete(rawMsg, key)
		case "enableServicePublicIP":
			err = unpopulate(val, "EnableServicePublicIP", &m.EnableServicePublicIP)
			delete(rawMsg, key)
		case "fabricSettings":
			err = unpopulate(val, "FabricSettings", &m.FabricSettings)
			delete(rawMsg, key)
		case "fqdn":
			err = unpopulate(val, "Fqdn", &m.Fqdn)
			delete(rawMsg, key)
		case "httpGatewayConnectionPort":
			err = unpopulate(val, "HTTPGatewayConnectionPort", &m.HTTPGatewayConnectionPort)
			delete(rawMsg, key)
		case "httpGatewayTokenAuthConnectionPort":
			err = unpopulate(val, "HTTPGatewayTokenAuthConnectionPort", &m.HTTPGatewayTokenAuthConnectionPort)
			delete(rawMsg, key)
		case "ipTags":
			err = unpopulate(val, "IPTags", &m.IPTags)
			delete(rawMsg, key)
		case "ipv4Address":
			err = unpopulate(val, "IPv4Address", &m.IPv4Address)
			delete(rawMsg, key)
		case "ipv6Address":
			err = unpopulate(val, "IPv6Address", &m.IPv6Address)
			delete(rawMsg, key)
		case "loadBalancingRules":
			err = unpopulate(val, "LoadBalancingRules", &m.LoadBalancingRules)
			delete(rawMsg, key)
		case "networkSecurityRules":
			err = unpopulate(val, "NetworkSecurityRules", &m.NetworkSecurityRules)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		case "publicIPPrefixId":
			err = unpopulate(val, "PublicIPPrefixID", &m.PublicIPPrefixID)
			delete(rawMsg, key)
		case "publicIPv6PrefixId":
			err = unpopulate(val, "PublicIPv6PrefixID", &m.PublicIPv6PrefixID)
			delete(rawMsg, key)
		case "serviceEndpoints":
			err = unpopulate(val, "ServiceEndpoints", &m.ServiceEndpoints)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &m.SubnetID)
			delete(rawMsg, key)
		case "upgradeDescription":
			err = unpopulate(val, "UpgradeDescription", &m.UpgradeDescription)
			delete(rawMsg, key)
		case "useCustomVnet":
			err = unpopulate(val, "UseCustomVnet", &m.UseCustomVnet)
			delete(rawMsg, key)
		case "VMImage":
			err = unpopulate(val, "VMImage", &m.VMImage)
			delete(rawMsg, key)
		case "zonalResiliency":
			err = unpopulate(val, "ZonalResiliency", &m.ZonalResiliency)
			delete(rawMsg, key)
		case "zonalUpdateMode":
			err = unpopulate(val, "ZonalUpdateMode", &m.ZonalUpdateMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedClusterUpdateParameters.
func (m ManagedClusterUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedClusterUpdateParameters.
func (m *ManagedClusterUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &m.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedClusterVersionDetails.
func (m ManagedClusterVersionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterCodeVersion", m.ClusterCodeVersion)
	populate(objectMap, "osType", m.OSType)
	populateTime[datetime.RFC3339](objectMap, "supportExpiryUtc", m.SupportExpiryUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedClusterVersionDetails.
func (m *ManagedClusterVersionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterCodeVersion":
			err = unpopulate(val, "ClusterCodeVersion", &m.ClusterCodeVersion)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, "OSType", &m.OSType)
			delete(rawMsg, key)
		case "supportExpiryUtc":
			err = unpopulateTime[datetime.RFC3339](val, "SupportExpiryUTC", &m.SupportExpiryUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentity.
func (m ManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentity.
func (m *ManagedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
			err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedMaintenanceWindowStatus.
func (m ManagedMaintenanceWindowStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "canApplyUpdates", m.CanApplyUpdates)
	populate(objectMap, "isRegionReady", m.IsRegionReady)
	populate(objectMap, "isWindowActive", m.IsWindowActive)
	populate(objectMap, "isWindowEnabled", m.IsWindowEnabled)
	populateTime[datetime.RFC3339](objectMap, "lastWindowEndTimeUTC", m.LastWindowEndTimeUTC)
	populateTime[datetime.RFC3339](objectMap, "lastWindowStartTimeUTC", m.LastWindowStartTimeUTC)
	populateTime[datetime.RFC3339](objectMap, "lastWindowStatusUpdateAtUTC", m.LastWindowStatusUpdateAtUTC)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedMaintenanceWindowStatus.
func (m *ManagedMaintenanceWindowStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "canApplyUpdates":
			err = unpopulate(val, "CanApplyUpdates", &m.CanApplyUpdates)
			delete(rawMsg, key)
		case "isRegionReady":
			err = unpopulate(val, "IsRegionReady", &m.IsRegionReady)
			delete(rawMsg, key)
		case "isWindowActive":
			err = unpopulate(val, "IsWindowActive", &m.IsWindowActive)
			delete(rawMsg, key)
		case "isWindowEnabled":
			err = unpopulate(val, "IsWindowEnabled", &m.IsWindowEnabled)
			delete(rawMsg, key)
		case "lastWindowEndTimeUTC":
			err = unpopulateTime[datetime.RFC3339](val, "LastWindowEndTimeUTC", &m.LastWindowEndTimeUTC)
			delete(rawMsg, key)
		case "lastWindowStartTimeUTC":
			err = unpopulateTime[datetime.RFC3339](val, "LastWindowStartTimeUTC", &m.LastWindowStartTimeUTC)
			delete(rawMsg, key)
		case "lastWindowStatusUpdateAtUTC":
			err = unpopulateTime[datetime.RFC3339](val, "LastWindowStatusUpdateAtUTC", &m.LastWindowStatusUpdateAtUTC)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVMSize.
func (m ManagedVMSize) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVMSize.
func (m *ManagedVMSize) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVMSizesResult.
func (m ManagedVMSizesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedVMSizesResult.
func (m *ManagedVMSizesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &m.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NamedPartitionScheme.
func (n NamedPartitionScheme) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "names", n.Names)
	objectMap["partitionScheme"] = PartitionSchemeNamed
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NamedPartitionScheme.
func (n *NamedPartitionScheme) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "names":
			err = unpopulate(val, "Names", &n.Names)
			delete(rawMsg, key)
		case "partitionScheme":
			err = unpopulate(val, "PartitionScheme", &n.PartitionScheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSecurityRule.
func (n NetworkSecurityRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access", n.Access)
	populate(objectMap, "description", n.Description)
	populate(objectMap, "destinationAddressPrefix", n.DestinationAddressPrefix)
	populate(objectMap, "destinationAddressPrefixes", n.DestinationAddressPrefixes)
	populate(objectMap, "destinationPortRange", n.DestinationPortRange)
	populate(objectMap, "destinationPortRanges", n.DestinationPortRanges)
	populate(objectMap, "direction", n.Direction)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "priority", n.Priority)
	populate(objectMap, "protocol", n.Protocol)
	populate(objectMap, "sourceAddressPrefix", n.SourceAddressPrefix)
	populate(objectMap, "sourceAddressPrefixes", n.SourceAddressPrefixes)
	populate(objectMap, "sourcePortRange", n.SourcePortRange)
	populate(objectMap, "sourcePortRanges", n.SourcePortRanges)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSecurityRule.
func (n *NetworkSecurityRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access":
			err = unpopulate(val, "Access", &n.Access)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &n.Description)
			delete(rawMsg, key)
		case "destinationAddressPrefix":
			err = unpopulate(val, "DestinationAddressPrefix", &n.DestinationAddressPrefix)
			delete(rawMsg, key)
		case "destinationAddressPrefixes":
			err = unpopulate(val, "DestinationAddressPrefixes", &n.DestinationAddressPrefixes)
			delete(rawMsg, key)
		case "destinationPortRange":
			err = unpopulate(val, "DestinationPortRange", &n.DestinationPortRange)
			delete(rawMsg, key)
		case "destinationPortRanges":
			err = unpopulate(val, "DestinationPortRanges", &n.DestinationPortRanges)
			delete(rawMsg, key)
		case "direction":
			err = unpopulate(val, "Direction", &n.Direction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, "Priority", &n.Priority)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, "Protocol", &n.Protocol)
			delete(rawMsg, key)
		case "sourceAddressPrefix":
			err = unpopulate(val, "SourceAddressPrefix", &n.SourceAddressPrefix)
			delete(rawMsg, key)
		case "sourceAddressPrefixes":
			err = unpopulate(val, "SourceAddressPrefixes", &n.SourceAddressPrefixes)
			delete(rawMsg, key)
		case "sourcePortRange":
			err = unpopulate(val, "SourcePortRange", &n.SourcePortRange)
			delete(rawMsg, key)
		case "sourcePortRanges":
			err = unpopulate(val, "SourcePortRanges", &n.SourcePortRanges)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeType.
func (n NodeType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "sku", n.SKU)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeType.
func (n *NodeType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &n.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &n.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeActionParameters.
func (n NodeTypeActionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "force", n.Force)
	populate(objectMap, "nodes", n.Nodes)
	populate(objectMap, "updateType", n.UpdateType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeActionParameters.
func (n *NodeTypeActionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "force":
			err = unpopulate(val, "Force", &n.Force)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, "Nodes", &n.Nodes)
			delete(rawMsg, key)
		case "updateType":
			err = unpopulate(val, "UpdateType", &n.UpdateType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeAvailableSKU.
func (n NodeTypeAvailableSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacity", n.Capacity)
	populate(objectMap, "resourceType", n.ResourceType)
	populate(objectMap, "sku", n.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeAvailableSKU.
func (n *NodeTypeAvailableSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacity":
			err = unpopulate(val, "Capacity", &n.Capacity)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &n.ResourceType)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &n.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeFaultSimulation.
func (n NodeTypeFaultSimulation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeTypeName", n.NodeTypeName)
	populate(objectMap, "operationId", n.OperationID)
	populate(objectMap, "operationStatus", n.OperationStatus)
	populate(objectMap, "status", n.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeFaultSimulation.
func (n *NodeTypeFaultSimulation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeTypeName":
			err = unpopulate(val, "NodeTypeName", &n.NodeTypeName)
			delete(rawMsg, key)
		case "operationId":
			err = unpopulate(val, "OperationID", &n.OperationID)
			delete(rawMsg, key)
		case "operationStatus":
			err = unpopulate(val, "OperationStatus", &n.OperationStatus)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &n.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeListResult.
func (n NodeTypeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeListResult.
func (n *NodeTypeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeListSKUResult.
func (n NodeTypeListSKUResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeListSKUResult.
func (n *NodeTypeListSKUResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &n.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeNatConfig.
func (n NodeTypeNatConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", n.BackendPort)
	populate(objectMap, "frontendPortRangeEnd", n.FrontendPortRangeEnd)
	populate(objectMap, "frontendPortRangeStart", n.FrontendPortRangeStart)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeNatConfig.
func (n *NodeTypeNatConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
			err = unpopulate(val, "BackendPort", &n.BackendPort)
			delete(rawMsg, key)
		case "frontendPortRangeEnd":
			err = unpopulate(val, "FrontendPortRangeEnd", &n.FrontendPortRangeEnd)
			delete(rawMsg, key)
		case "frontendPortRangeStart":
			err = unpopulate(val, "FrontendPortRangeStart", &n.FrontendPortRangeStart)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeProperties.
func (n NodeTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalDataDisks", n.AdditionalDataDisks)
	populate(objectMap, "additionalNetworkInterfaceConfigurations", n.AdditionalNetworkInterfaceConfigurations)
	populate(objectMap, "applicationPorts", n.ApplicationPorts)
	populate(objectMap, "capacities", n.Capacities)
	populate(objectMap, "computerNamePrefix", n.ComputerNamePrefix)
	populate(objectMap, "dataDiskLetter", n.DataDiskLetter)
	populate(objectMap, "dataDiskSizeGB", n.DataDiskSizeGB)
	populate(objectMap, "dataDiskType", n.DataDiskType)
	populate(objectMap, "dscpConfigurationId", n.DscpConfigurationID)
	populate(objectMap, "enableAcceleratedNetworking", n.EnableAcceleratedNetworking)
	populate(objectMap, "enableEncryptionAtHost", n.EnableEncryptionAtHost)
	populate(objectMap, "enableNodePublicIP", n.EnableNodePublicIP)
	populate(objectMap, "enableNodePublicIPv6", n.EnableNodePublicIPv6)
	populate(objectMap, "enableOverProvisioning", n.EnableOverProvisioning)
	populate(objectMap, "ephemeralPorts", n.EphemeralPorts)
	populate(objectMap, "evictionPolicy", n.EvictionPolicy)
	populate(objectMap, "frontendConfigurations", n.FrontendConfigurations)
	populate(objectMap, "hostGroupId", n.HostGroupID)
	populate(objectMap, "isOutboundOnly", n.IsOutboundOnly)
	populate(objectMap, "isPrimary", n.IsPrimary)
	populate(objectMap, "isSpotVM", n.IsSpotVM)
	populate(objectMap, "isStateless", n.IsStateless)
	populate(objectMap, "multiplePlacementGroups", n.MultiplePlacementGroups)
	populate(objectMap, "natConfigurations", n.NatConfigurations)
	populate(objectMap, "natGatewayId", n.NatGatewayID)
	populate(objectMap, "networkSecurityRules", n.NetworkSecurityRules)
	populate(objectMap, "placementProperties", n.PlacementProperties)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "secureBootEnabled", n.SecureBootEnabled)
	populate(objectMap, "securityEncryptionType", n.SecurityEncryptionType)
	populate(objectMap, "securityType", n.SecurityType)
	populate(objectMap, "serviceArtifactReferenceId", n.ServiceArtifactReferenceID)
	populate(objectMap, "spotRestoreTimeout", n.SpotRestoreTimeout)
	populate(objectMap, "subnetId", n.SubnetID)
	populate(objectMap, "useDefaultPublicLoadBalancer", n.UseDefaultPublicLoadBalancer)
	populate(objectMap, "useEphemeralOSDisk", n.UseEphemeralOSDisk)
	populate(objectMap, "useTempDataDisk", n.UseTempDataDisk)
	populate(objectMap, "vmApplications", n.VMApplications)
	populate(objectMap, "vmExtensions", n.VMExtensions)
	populate(objectMap, "vmImageOffer", n.VMImageOffer)
	populate(objectMap, "vmImagePlan", n.VMImagePlan)
	populate(objectMap, "vmImagePublisher", n.VMImagePublisher)
	populate(objectMap, "vmImageResourceId", n.VMImageResourceID)
	populate(objectMap, "vmImageSku", n.VMImageSKU)
	populate(objectMap, "vmImageVersion", n.VMImageVersion)
	populate(objectMap, "vmInstanceCount", n.VMInstanceCount)
	populate(objectMap, "vmManagedIdentity", n.VMManagedIdentity)
	populate(objectMap, "vmSecrets", n.VMSecrets)
	populate(objectMap, "vmSetupActions", n.VMSetupActions)
	populate(objectMap, "vmSharedGalleryImageId", n.VMSharedGalleryImageID)
	populate(objectMap, "vmSize", n.VMSize)
	populate(objectMap, "zoneBalance", n.ZoneBalance)
	populate(objectMap, "zones", n.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeProperties.
func (n *NodeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalDataDisks":
			err = unpopulate(val, "AdditionalDataDisks", &n.AdditionalDataDisks)
			delete(rawMsg, key)
		case "additionalNetworkInterfaceConfigurations":
			err = unpopulate(val, "AdditionalNetworkInterfaceConfigurations", &n.AdditionalNetworkInterfaceConfigurations)
			delete(rawMsg, key)
		case "applicationPorts":
			err = unpopulate(val, "ApplicationPorts", &n.ApplicationPorts)
			delete(rawMsg, key)
		case "capacities":
			err = unpopulate(val, "Capacities", &n.Capacities)
			delete(rawMsg, key)
		case "computerNamePrefix":
			err = unpopulate(val, "ComputerNamePrefix", &n.ComputerNamePrefix)
			delete(rawMsg, key)
		case "dataDiskLetter":
			err = unpopulate(val, "DataDiskLetter", &n.DataDiskLetter)
			delete(rawMsg, key)
		case "dataDiskSizeGB":
			err = unpopulate(val, "DataDiskSizeGB", &n.DataDiskSizeGB)
			delete(rawMsg, key)
		case "dataDiskType":
			err = unpopulate(val, "DataDiskType", &n.DataDiskType)
			delete(rawMsg, key)
		case "dscpConfigurationId":
			err = unpopulate(val, "DscpConfigurationID", &n.DscpConfigurationID)
			delete(rawMsg, key)
		case "enableAcceleratedNetworking":
			err = unpopulate(val, "EnableAcceleratedNetworking", &n.EnableAcceleratedNetworking)
			delete(rawMsg, key)
		case "enableEncryptionAtHost":
			err = unpopulate(val, "EnableEncryptionAtHost", &n.EnableEncryptionAtHost)
			delete(rawMsg, key)
		case "enableNodePublicIP":
			err = unpopulate(val, "EnableNodePublicIP", &n.EnableNodePublicIP)
			delete(rawMsg, key)
		case "enableNodePublicIPv6":
			err = unpopulate(val, "EnableNodePublicIPv6", &n.EnableNodePublicIPv6)
			delete(rawMsg, key)
		case "enableOverProvisioning":
			err = unpopulate(val, "EnableOverProvisioning", &n.EnableOverProvisioning)
			delete(rawMsg, key)
		case "ephemeralPorts":
			err = unpopulate(val, "EphemeralPorts", &n.EphemeralPorts)
			delete(rawMsg, key)
		case "evictionPolicy":
			err = unpopulate(val, "EvictionPolicy", &n.EvictionPolicy)
			delete(rawMsg, key)
		case "frontendConfigurations":
			err = unpopulate(val, "FrontendConfigurations", &n.FrontendConfigurations)
			delete(rawMsg, key)
		case "hostGroupId":
			err = unpopulate(val, "HostGroupID", &n.HostGroupID)
			delete(rawMsg, key)
		case "isOutboundOnly":
			err = unpopulate(val, "IsOutboundOnly", &n.IsOutboundOnly)
			delete(rawMsg, key)
		case "isPrimary":
			err = unpopulate(val, "IsPrimary", &n.IsPrimary)
			delete(rawMsg, key)
		case "isSpotVM":
			err = unpopulate(val, "IsSpotVM", &n.IsSpotVM)
			delete(rawMsg, key)
		case "isStateless":
			err = unpopulate(val, "IsStateless", &n.IsStateless)
			delete(rawMsg, key)
		case "multiplePlacementGroups":
			err = unpopulate(val, "MultiplePlacementGroups", &n.MultiplePlacementGroups)
			delete(rawMsg, key)
		case "natConfigurations":
			err = unpopulate(val, "NatConfigurations", &n.NatConfigurations)
			delete(rawMsg, key)
		case "natGatewayId":
			err = unpopulate(val, "NatGatewayID", &n.NatGatewayID)
			delete(rawMsg, key)
		case "networkSecurityRules":
			err = unpopulate(val, "NetworkSecurityRules", &n.NetworkSecurityRules)
			delete(rawMsg, key)
		case "placementProperties":
			err = unpopulate(val, "PlacementProperties", &n.PlacementProperties)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "secureBootEnabled":
			err = unpopulate(val, "SecureBootEnabled", &n.SecureBootEnabled)
			delete(rawMsg, key)
		case "securityEncryptionType":
			err = unpopulate(val, "SecurityEncryptionType", &n.SecurityEncryptionType)
			delete(rawMsg, key)
		case "securityType":
			err = unpopulate(val, "SecurityType", &n.SecurityType)
			delete(rawMsg, key)
		case "serviceArtifactReferenceId":
			err = unpopulate(val, "ServiceArtifactReferenceID", &n.ServiceArtifactReferenceID)
			delete(rawMsg, key)
		case "spotRestoreTimeout":
			err = unpopulate(val, "SpotRestoreTimeout", &n.SpotRestoreTimeout)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, "SubnetID", &n.SubnetID)
			delete(rawMsg, key)
		case "useDefaultPublicLoadBalancer":
			err = unpopulate(val, "UseDefaultPublicLoadBalancer", &n.UseDefaultPublicLoadBalancer)
			delete(rawMsg, key)
		case "useEphemeralOSDisk":
			err = unpopulate(val, "UseEphemeralOSDisk", &n.UseEphemeralOSDisk)
			delete(rawMsg, key)
		case "useTempDataDisk":
			err = unpopulate(val, "UseTempDataDisk", &n.UseTempDataDisk)
			delete(rawMsg, key)
		case "vmApplications":
			err = unpopulate(val, "VMApplications", &n.VMApplications)
			delete(rawMsg, key)
		case "vmExtensions":
			err = unpopulate(val, "VMExtensions", &n.VMExtensions)
			delete(rawMsg, key)
		case "vmImageOffer":
			err = unpopulate(val, "VMImageOffer", &n.VMImageOffer)
			delete(rawMsg, key)
		case "vmImagePlan":
			err = unpopulate(val, "VMImagePlan", &n.VMImagePlan)
			delete(rawMsg, key)
		case "vmImagePublisher":
			err = unpopulate(val, "VMImagePublisher", &n.VMImagePublisher)
			delete(rawMsg, key)
		case "vmImageResourceId":
			err = unpopulate(val, "VMImageResourceID", &n.VMImageResourceID)
			delete(rawMsg, key)
		case "vmImageSku":
			err = unpopulate(val, "VMImageSKU", &n.VMImageSKU)
			delete(rawMsg, key)
		case "vmImageVersion":
			err = unpopulate(val, "VMImageVersion", &n.VMImageVersion)
			delete(rawMsg, key)
		case "vmInstanceCount":
			err = unpopulate(val, "VMInstanceCount", &n.VMInstanceCount)
			delete(rawMsg, key)
		case "vmManagedIdentity":
			err = unpopulate(val, "VMManagedIdentity", &n.VMManagedIdentity)
			delete(rawMsg, key)
		case "vmSecrets":
			err = unpopulate(val, "VMSecrets", &n.VMSecrets)
			delete(rawMsg, key)
		case "vmSetupActions":
			err = unpopulate(val, "VMSetupActions", &n.VMSetupActions)
			delete(rawMsg, key)
		case "vmSharedGalleryImageId":
			err = unpopulate(val, "VMSharedGalleryImageID", &n.VMSharedGalleryImageID)
			delete(rawMsg, key)
		case "vmSize":
			err = unpopulate(val, "VMSize", &n.VMSize)
			delete(rawMsg, key)
		case "zoneBalance":
			err = unpopulate(val, "ZoneBalance", &n.ZoneBalance)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &n.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeSKU.
func (n NodeTypeSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacity", n.Capacity)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "tier", n.Tier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeSKU.
func (n *NodeTypeSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacity":
			err = unpopulate(val, "Capacity", &n.Capacity)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "tier":
			err = unpopulate(val, "Tier", &n.Tier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeSKUCapacity.
func (n NodeTypeSKUCapacity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "default", n.Default)
	populate(objectMap, "maximum", n.Maximum)
	populate(objectMap, "minimum", n.Minimum)
	populate(objectMap, "scaleType", n.ScaleType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeSKUCapacity.
func (n *NodeTypeSKUCapacity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "default":
			err = unpopulate(val, "Default", &n.Default)
			delete(rawMsg, key)
		case "maximum":
			err = unpopulate(val, "Maximum", &n.Maximum)
			delete(rawMsg, key)
		case "minimum":
			err = unpopulate(val, "Minimum", &n.Minimum)
			delete(rawMsg, key)
		case "scaleType":
			err = unpopulate(val, "ScaleType", &n.ScaleType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeSupportedSKU.
func (n NodeTypeSupportedSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "tier", n.Tier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeSupportedSKU.
func (n *NodeTypeSupportedSKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "tier":
			err = unpopulate(val, "Tier", &n.Tier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodeTypeUpdateParameters.
func (n NodeTypeUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sku", n.SKU)
	populate(objectMap, "tags", n.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodeTypeUpdateParameters.
func (n *NodeTypeUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sku":
			err = unpopulate(val, "SKU", &n.SKU)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &n.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationResult.
func (o OperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationResult.
func (o *OperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Partition.
func (p Partition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "partitionScheme", p.PartitionScheme)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Partition.
func (p *Partition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionScheme":
			err = unpopulate(val, "PartitionScheme", &p.PartitionScheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PartitionInstanceCountScaleMechanism.
func (p PartitionInstanceCountScaleMechanism) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ServiceScalingMechanismKindScalePartitionInstanceCount
	populate(objectMap, "maxInstanceCount", p.MaxInstanceCount)
	populate(objectMap, "minInstanceCount", p.MinInstanceCount)
	populate(objectMap, "scaleIncrement", p.ScaleIncrement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PartitionInstanceCountScaleMechanism.
func (p *PartitionInstanceCountScaleMechanism) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &p.Kind)
			delete(rawMsg, key)
		case "maxInstanceCount":
			err = unpopulate(val, "MaxInstanceCount", &p.MaxInstanceCount)
			delete(rawMsg, key)
		case "minInstanceCount":
			err = unpopulate(val, "MinInstanceCount", &p.MinInstanceCount)
			delete(rawMsg, key)
		case "scaleIncrement":
			err = unpopulate(val, "ScaleIncrement", &p.ScaleIncrement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceAzStatus.
func (r ResourceAzStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", r.Details)
	populate(objectMap, "isZoneResilient", r.IsZoneResilient)
	populate(objectMap, "resourceName", r.ResourceName)
	populate(objectMap, "resourceType", r.ResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceAzStatus.
func (r *ResourceAzStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
			err = unpopulate(val, "Details", &r.Details)
			delete(rawMsg, key)
		case "isZoneResilient":
			err = unpopulate(val, "IsZoneResilient", &r.IsZoneResilient)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, "ResourceName", &r.ResourceName)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &r.ResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestartDeployedCodePackageRequest.
func (r RestartDeployedCodePackageRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "codePackageInstanceId", r.CodePackageInstanceID)
	populate(objectMap, "codePackageName", r.CodePackageName)
	populate(objectMap, "nodeName", r.NodeName)
	populate(objectMap, "serviceManifestName", r.ServiceManifestName)
	populate(objectMap, "servicePackageActivationId", r.ServicePackageActivationID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestartDeployedCodePackageRequest.
func (r *RestartDeployedCodePackageRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codePackageInstanceId":
			err = unpopulate(val, "CodePackageInstanceID", &r.CodePackageInstanceID)
			delete(rawMsg, key)
		case "codePackageName":
			err = unpopulate(val, "CodePackageName", &r.CodePackageName)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, "NodeName", &r.NodeName)
			delete(rawMsg, key)
		case "serviceManifestName":
			err = unpopulate(val, "ServiceManifestName", &r.ServiceManifestName)
			delete(rawMsg, key)
		case "servicePackageActivationId":
			err = unpopulate(val, "ServicePackageActivationID", &r.ServicePackageActivationID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestartReplicaRequest.
func (r RestartReplicaRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "forceRestart", r.ForceRestart)
	populate(objectMap, "partitionId", r.PartitionID)
	populate(objectMap, "replicaIds", r.ReplicaIDs)
	populate(objectMap, "restartKind", r.RestartKind)
	populate(objectMap, "timeout", r.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestartReplicaRequest.
func (r *RestartReplicaRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "forceRestart":
			err = unpopulate(val, "ForceRestart", &r.ForceRestart)
			delete(rawMsg, key)
		case "partitionId":
			err = unpopulate(val, "PartitionID", &r.PartitionID)
			delete(rawMsg, key)
		case "replicaIds":
			err = unpopulate(val, "ReplicaIDs", &r.ReplicaIDs)
			delete(rawMsg, key)
		case "restartKind":
			err = unpopulate(val, "RestartKind", &r.RestartKind)
			delete(rawMsg, key)
		case "timeout":
			err = unpopulate(val, "Timeout", &r.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RollingUpgradeMonitoringPolicy.
func (r RollingUpgradeMonitoringPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "failureAction", r.FailureAction)
	populate(objectMap, "healthCheckRetryTimeout", r.HealthCheckRetryTimeout)
	populate(objectMap, "healthCheckStableDuration", r.HealthCheckStableDuration)
	populate(objectMap, "healthCheckWaitDuration", r.HealthCheckWaitDuration)
	populate(objectMap, "upgradeDomainTimeout", r.UpgradeDomainTimeout)
	populate(objectMap, "upgradeTimeout", r.UpgradeTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RollingUpgradeMonitoringPolicy.
func (r *RollingUpgradeMonitoringPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureAction":
			err = unpopulate(val, "FailureAction", &r.FailureAction)
			delete(rawMsg, key)
		case "healthCheckRetryTimeout":
			err = unpopulate(val, "HealthCheckRetryTimeout", &r.HealthCheckRetryTimeout)
			delete(rawMsg, key)
		case "healthCheckStableDuration":
			err = unpopulate(val, "HealthCheckStableDuration", &r.HealthCheckStableDuration)
			delete(rawMsg, key)
		case "healthCheckWaitDuration":
			err = unpopulate(val, "HealthCheckWaitDuration", &r.HealthCheckWaitDuration)
			delete(rawMsg, key)
		case "upgradeDomainTimeout":
			err = unpopulate(val, "UpgradeDomainTimeout", &r.UpgradeDomainTimeout)
			delete(rawMsg, key)
		case "upgradeTimeout":
			err = unpopulate(val, "UpgradeTimeout", &r.UpgradeTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimeApplicationHealthPolicy.
func (r RuntimeApplicationHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "considerWarningAsError", r.ConsiderWarningAsError)
	populate(objectMap, "defaultServiceTypeHealthPolicy", r.DefaultServiceTypeHealthPolicy)
	populate(objectMap, "maxPercentUnhealthyDeployedApplications", r.MaxPercentUnhealthyDeployedApplications)
	populate(objectMap, "serviceTypeHealthPolicyMap", r.ServiceTypeHealthPolicyMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimeApplicationHealthPolicy.
func (r *RuntimeApplicationHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "considerWarningAsError":
			err = unpopulate(val, "ConsiderWarningAsError", &r.ConsiderWarningAsError)
			delete(rawMsg, key)
		case "defaultServiceTypeHealthPolicy":
			err = unpopulate(val, "DefaultServiceTypeHealthPolicy", &r.DefaultServiceTypeHealthPolicy)
			delete(rawMsg, key)
		case "maxPercentUnhealthyDeployedApplications":
			err = unpopulate(val, "MaxPercentUnhealthyDeployedApplications", &r.MaxPercentUnhealthyDeployedApplications)
			delete(rawMsg, key)
		case "serviceTypeHealthPolicyMap":
			err = unpopulate(val, "ServiceTypeHealthPolicyMap", &r.ServiceTypeHealthPolicyMap)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimeResumeApplicationUpgradeParameters.
func (r RuntimeResumeApplicationUpgradeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "upgradeDomainName", r.UpgradeDomainName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimeResumeApplicationUpgradeParameters.
func (r *RuntimeResumeApplicationUpgradeParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "upgradeDomainName":
			err = unpopulate(val, "UpgradeDomainName", &r.UpgradeDomainName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimeRollingUpgradeUpdateMonitoringPolicy.
func (r RuntimeRollingUpgradeUpdateMonitoringPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "failureAction", r.FailureAction)
	populate(objectMap, "forceRestart", r.ForceRestart)
	populate(objectMap, "healthCheckRetryTimeoutInMilliseconds", r.HealthCheckRetryTimeoutInMilliseconds)
	populate(objectMap, "healthCheckStableDurationInMilliseconds", r.HealthCheckStableDurationInMilliseconds)
	populate(objectMap, "healthCheckWaitDurationInMilliseconds", r.HealthCheckWaitDurationInMilliseconds)
	populate(objectMap, "instanceCloseDelayDurationInSeconds", r.InstanceCloseDelayDurationInSeconds)
	populate(objectMap, "replicaSetCheckTimeoutInMilliseconds", r.ReplicaSetCheckTimeoutInMilliseconds)
	populate(objectMap, "rollingUpgradeMode", r.RollingUpgradeMode)
	populate(objectMap, "upgradeDomainTimeoutInMilliseconds", r.UpgradeDomainTimeoutInMilliseconds)
	populate(objectMap, "upgradeTimeoutInMilliseconds", r.UpgradeTimeoutInMilliseconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimeRollingUpgradeUpdateMonitoringPolicy.
func (r *RuntimeRollingUpgradeUpdateMonitoringPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureAction":
			err = unpopulate(val, "FailureAction", &r.FailureAction)
			delete(rawMsg, key)
		case "forceRestart":
			err = unpopulate(val, "ForceRestart", &r.ForceRestart)
			delete(rawMsg, key)
		case "healthCheckRetryTimeoutInMilliseconds":
			err = unpopulate(val, "HealthCheckRetryTimeoutInMilliseconds", &r.HealthCheckRetryTimeoutInMilliseconds)
			delete(rawMsg, key)
		case "healthCheckStableDurationInMilliseconds":
			err = unpopulate(val, "HealthCheckStableDurationInMilliseconds", &r.HealthCheckStableDurationInMilliseconds)
			delete(rawMsg, key)
		case "healthCheckWaitDurationInMilliseconds":
			err = unpopulate(val, "HealthCheckWaitDurationInMilliseconds", &r.HealthCheckWaitDurationInMilliseconds)
			delete(rawMsg, key)
		case "instanceCloseDelayDurationInSeconds":
			err = unpopulate(val, "InstanceCloseDelayDurationInSeconds", &r.InstanceCloseDelayDurationInSeconds)
			delete(rawMsg, key)
		case "replicaSetCheckTimeoutInMilliseconds":
			err = unpopulate(val, "ReplicaSetCheckTimeoutInMilliseconds", &r.ReplicaSetCheckTimeoutInMilliseconds)
			delete(rawMsg, key)
		case "rollingUpgradeMode":
			err = unpopulate(val, "RollingUpgradeMode", &r.RollingUpgradeMode)
			delete(rawMsg, key)
		case "upgradeDomainTimeoutInMilliseconds":
			err = unpopulate(val, "UpgradeDomainTimeoutInMilliseconds", &r.UpgradeDomainTimeoutInMilliseconds)
			delete(rawMsg, key)
		case "upgradeTimeoutInMilliseconds":
			err = unpopulate(val, "UpgradeTimeoutInMilliseconds", &r.UpgradeTimeoutInMilliseconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimeServiceTypeHealthPolicy.
func (r RuntimeServiceTypeHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxPercentUnhealthyPartitionsPerService", r.MaxPercentUnhealthyPartitionsPerService)
	populate(objectMap, "maxPercentUnhealthyReplicasPerPartition", r.MaxPercentUnhealthyReplicasPerPartition)
	populate(objectMap, "maxPercentUnhealthyServices", r.MaxPercentUnhealthyServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimeServiceTypeHealthPolicy.
func (r *RuntimeServiceTypeHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxPercentUnhealthyPartitionsPerService":
			err = unpopulate(val, "MaxPercentUnhealthyPartitionsPerService", &r.MaxPercentUnhealthyPartitionsPerService)
			delete(rawMsg, key)
		case "maxPercentUnhealthyReplicasPerPartition":
			err = unpopulate(val, "MaxPercentUnhealthyReplicasPerPartition", &r.MaxPercentUnhealthyReplicasPerPartition)
			delete(rawMsg, key)
		case "maxPercentUnhealthyServices":
			err = unpopulate(val, "MaxPercentUnhealthyServices", &r.MaxPercentUnhealthyServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimeUpdateApplicationUpgradeParameters.
func (r RuntimeUpdateApplicationUpgradeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationHealthPolicy", r.ApplicationHealthPolicy)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "updateDescription", r.UpdateDescription)
	populate(objectMap, "upgradeKind", r.UpgradeKind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimeUpdateApplicationUpgradeParameters.
func (r *RuntimeUpdateApplicationUpgradeParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationHealthPolicy":
			err = unpopulate(val, "ApplicationHealthPolicy", &r.ApplicationHealthPolicy)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "updateDescription":
			err = unpopulate(val, "UpdateDescription", &r.UpdateDescription)
			delete(rawMsg, key)
		case "upgradeKind":
			err = unpopulate(val, "UpgradeKind", &r.UpgradeKind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SKU.
func (s SKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SKU.
func (s *SKU) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScalingMechanism.
func (s ScalingMechanism) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", s.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalingMechanism.
func (s *ScalingMechanism) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScalingPolicy.
func (s ScalingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scalingMechanism", s.ScalingMechanism)
	populate(objectMap, "scalingTrigger", s.ScalingTrigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalingPolicy.
func (s *ScalingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scalingMechanism":
			s.ScalingMechanism, err = unmarshalScalingMechanismClassification(val)
			delete(rawMsg, key)
		case "scalingTrigger":
			s.ScalingTrigger, err = unmarshalScalingTriggerClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScalingTrigger.
func (s ScalingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", s.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalingTrigger.
func (s *ScalingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceCorrelation.
func (s ServiceCorrelation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scheme", s.Scheme)
	populate(objectMap, "serviceName", s.ServiceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceCorrelation.
func (s *ServiceCorrelation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheme":
			err = unpopulate(val, "Scheme", &s.Scheme)
			delete(rawMsg, key)
		case "serviceName":
			err = unpopulate(val, "ServiceName", &s.ServiceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceEndpoint.
func (s ServiceEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "locations", s.Locations)
	populate(objectMap, "networkIdentifier", s.NetworkIdentifier)
	populate(objectMap, "service", s.Service)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceEndpoint.
func (s *ServiceEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "locations":
			err = unpopulate(val, "Locations", &s.Locations)
			delete(rawMsg, key)
		case "networkIdentifier":
			err = unpopulate(val, "NetworkIdentifier", &s.NetworkIdentifier)
			delete(rawMsg, key)
		case "service":
			err = unpopulate(val, "Service", &s.Service)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceLoadMetric.
func (s ServiceLoadMetric) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "defaultLoad", s.DefaultLoad)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "primaryDefaultLoad", s.PrimaryDefaultLoad)
	populate(objectMap, "secondaryDefaultLoad", s.SecondaryDefaultLoad)
	populate(objectMap, "weight", s.Weight)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceLoadMetric.
func (s *ServiceLoadMetric) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultLoad":
			err = unpopulate(val, "DefaultLoad", &s.DefaultLoad)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "primaryDefaultLoad":
			err = unpopulate(val, "PrimaryDefaultLoad", &s.PrimaryDefaultLoad)
			delete(rawMsg, key)
		case "secondaryDefaultLoad":
			err = unpopulate(val, "SecondaryDefaultLoad", &s.SecondaryDefaultLoad)
			delete(rawMsg, key)
		case "weight":
			err = unpopulate(val, "Weight", &s.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementInvalidDomainPolicy.
func (s ServicePlacementInvalidDomainPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainName", s.DomainName)
	objectMap["type"] = ServicePlacementPolicyTypeInvalidDomain
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementInvalidDomainPolicy.
func (s *ServicePlacementInvalidDomainPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainName":
			err = unpopulate(val, "DomainName", &s.DomainName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementNonPartiallyPlaceServicePolicy.
func (s ServicePlacementNonPartiallyPlaceServicePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = ServicePlacementPolicyTypeNonPartiallyPlaceService
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementNonPartiallyPlaceServicePolicy.
func (s *ServicePlacementNonPartiallyPlaceServicePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementPolicy.
func (s ServicePlacementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementPolicy.
func (s *ServicePlacementPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementPreferPrimaryDomainPolicy.
func (s ServicePlacementPreferPrimaryDomainPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainName", s.DomainName)
	objectMap["type"] = ServicePlacementPolicyTypePreferredPrimaryDomain
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementPreferPrimaryDomainPolicy.
func (s *ServicePlacementPreferPrimaryDomainPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainName":
			err = unpopulate(val, "DomainName", &s.DomainName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementRequireDomainDistributionPolicy.
func (s ServicePlacementRequireDomainDistributionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainName", s.DomainName)
	objectMap["type"] = ServicePlacementPolicyTypeRequiredDomainDistribution
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementRequireDomainDistributionPolicy.
func (s *ServicePlacementRequireDomainDistributionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainName":
			err = unpopulate(val, "DomainName", &s.DomainName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePlacementRequiredDomainPolicy.
func (s ServicePlacementRequiredDomainPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domainName", s.DomainName)
	objectMap["type"] = ServicePlacementPolicyTypeRequiredDomain
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePlacementRequiredDomainPolicy.
func (s *ServicePlacementRequiredDomainPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domainName":
			err = unpopulate(val, "DomainName", &s.DomainName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResource.
func (s ServiceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResource.
func (s *ServiceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &s.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
			s.Properties, err = unmarshalServiceResourcePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &s.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResourceList.
func (s ServiceResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourceList.
func (s *ServiceResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceResourceProperties.
func (s ServiceResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationScheme", s.CorrelationScheme)
	populate(objectMap, "defaultMoveCost", s.DefaultMoveCost)
	populate(objectMap, "partitionDescription", s.PartitionDescription)
	populate(objectMap, "placementConstraints", s.PlacementConstraints)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "scalingPolicies", s.ScalingPolicies)
	populate(objectMap, "serviceDnsName", s.ServiceDNSName)
	populate(objectMap, "serviceKind", s.ServiceKind)
	populate(objectMap, "serviceLoadMetrics", s.ServiceLoadMetrics)
	populate(objectMap, "servicePackageActivationMode", s.ServicePackageActivationMode)
	populate(objectMap, "servicePlacementPolicies", s.ServicePlacementPolicies)
	populate(objectMap, "serviceTypeName", s.ServiceTypeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceResourceProperties.
func (s *ServiceResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationScheme":
			err = unpopulate(val, "CorrelationScheme", &s.CorrelationScheme)
			delete(rawMsg, key)
		case "defaultMoveCost":
			err = unpopulate(val, "DefaultMoveCost", &s.DefaultMoveCost)
			delete(rawMsg, key)
		case "partitionDescription":
			s.PartitionDescription, err = unmarshalPartitionClassification(val)
			delete(rawMsg, key)
		case "placementConstraints":
			err = unpopulate(val, "PlacementConstraints", &s.PlacementConstraints)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "scalingPolicies":
			err = unpopulate(val, "ScalingPolicies", &s.ScalingPolicies)
			delete(rawMsg, key)
		case "serviceDnsName":
			err = unpopulate(val, "ServiceDNSName", &s.ServiceDNSName)
			delete(rawMsg, key)
		case "serviceKind":
			err = unpopulate(val, "ServiceKind", &s.ServiceKind)
			delete(rawMsg, key)
		case "serviceLoadMetrics":
			err = unpopulate(val, "ServiceLoadMetrics", &s.ServiceLoadMetrics)
			delete(rawMsg, key)
		case "servicePackageActivationMode":
			err = unpopulate(val, "ServicePackageActivationMode", &s.ServicePackageActivationMode)
			delete(rawMsg, key)
		case "servicePlacementPolicies":
			s.ServicePlacementPolicies, err = unmarshalServicePlacementPolicyClassificationArray(val)
			delete(rawMsg, key)
		case "serviceTypeName":
			err = unpopulate(val, "ServiceTypeName", &s.ServiceTypeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceTypeHealthPolicy.
func (s ServiceTypeHealthPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxPercentUnhealthyPartitionsPerService", s.MaxPercentUnhealthyPartitionsPerService)
	populate(objectMap, "maxPercentUnhealthyReplicasPerPartition", s.MaxPercentUnhealthyReplicasPerPartition)
	populate(objectMap, "maxPercentUnhealthyServices", s.MaxPercentUnhealthyServices)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceTypeHealthPolicy.
func (s *ServiceTypeHealthPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxPercentUnhealthyPartitionsPerService":
			err = unpopulate(val, "MaxPercentUnhealthyPartitionsPerService", &s.MaxPercentUnhealthyPartitionsPerService)
			delete(rawMsg, key)
		case "maxPercentUnhealthyReplicasPerPartition":
			err = unpopulate(val, "MaxPercentUnhealthyReplicasPerPartition", &s.MaxPercentUnhealthyReplicasPerPartition)
			delete(rawMsg, key)
		case "maxPercentUnhealthyServices":
			err = unpopulate(val, "MaxPercentUnhealthyServices", &s.MaxPercentUnhealthyServices)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceUpdateParameters.
func (s ServiceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceUpdateParameters.
func (s *ServiceUpdateParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &s.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SettingsParameterDescription.
func (s SettingsParameterDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SettingsParameterDescription.
func (s *SettingsParameterDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SettingsSectionDescription.
func (s SettingsSectionDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "parameters", s.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SettingsSectionDescription.
func (s *SettingsSectionDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SingletonPartitionScheme.
func (s SingletonPartitionScheme) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["partitionScheme"] = PartitionSchemeSingleton
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SingletonPartitionScheme.
func (s *SingletonPartitionScheme) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionScheme":
			err = unpopulate(val, "PartitionScheme", &s.PartitionScheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StatefulServiceProperties.
func (s StatefulServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationScheme", s.CorrelationScheme)
	populate(objectMap, "defaultMoveCost", s.DefaultMoveCost)
	populate(objectMap, "hasPersistedState", s.HasPersistedState)
	populate(objectMap, "minReplicaSetSize", s.MinReplicaSetSize)
	populate(objectMap, "partitionDescription", s.PartitionDescription)
	populate(objectMap, "placementConstraints", s.PlacementConstraints)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "quorumLossWaitDuration", s.QuorumLossWaitDuration)
	populate(objectMap, "replicaRestartWaitDuration", s.ReplicaRestartWaitDuration)
	populate(objectMap, "scalingPolicies", s.ScalingPolicies)
	populate(objectMap, "serviceDnsName", s.ServiceDNSName)
	objectMap["serviceKind"] = ServiceKindStateful
	populate(objectMap, "serviceLoadMetrics", s.ServiceLoadMetrics)
	populate(objectMap, "servicePackageActivationMode", s.ServicePackageActivationMode)
	populate(objectMap, "servicePlacementPolicies", s.ServicePlacementPolicies)
	populate(objectMap, "servicePlacementTimeLimit", s.ServicePlacementTimeLimit)
	populate(objectMap, "serviceTypeName", s.ServiceTypeName)
	populate(objectMap, "standByReplicaKeepDuration", s.StandByReplicaKeepDuration)
	populate(objectMap, "targetReplicaSetSize", s.TargetReplicaSetSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatefulServiceProperties.
func (s *StatefulServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationScheme":
			err = unpopulate(val, "CorrelationScheme", &s.CorrelationScheme)
			delete(rawMsg, key)
		case "defaultMoveCost":
			err = unpopulate(val, "DefaultMoveCost", &s.DefaultMoveCost)
			delete(rawMsg, key)
		case "hasPersistedState":
			err = unpopulate(val, "HasPersistedState", &s.HasPersistedState)
			delete(rawMsg, key)
		case "minReplicaSetSize":
			err = unpopulate(val, "MinReplicaSetSize", &s.MinReplicaSetSize)
			delete(rawMsg, key)
		case "partitionDescription":
			s.PartitionDescription, err = unmarshalPartitionClassification(val)
			delete(rawMsg, key)
		case "placementConstraints":
			err = unpopulate(val, "PlacementConstraints", &s.PlacementConstraints)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "quorumLossWaitDuration":
			err = unpopulate(val, "QuorumLossWaitDuration", &s.QuorumLossWaitDuration)
			delete(rawMsg, key)
		case "replicaRestartWaitDuration":
			err = unpopulate(val, "ReplicaRestartWaitDuration", &s.ReplicaRestartWaitDuration)
			delete(rawMsg, key)
		case "scalingPolicies":
			err = unpopulate(val, "ScalingPolicies", &s.ScalingPolicies)
			delete(rawMsg, key)
		case "serviceDnsName":
			err = unpopulate(val, "ServiceDNSName", &s.ServiceDNSName)
			delete(rawMsg, key)
		case "serviceKind":
			err = unpopulate(val, "ServiceKind", &s.ServiceKind)
			delete(rawMsg, key)
		case "serviceLoadMetrics":
			err = unpopulate(val, "ServiceLoadMetrics", &s.ServiceLoadMetrics)
			delete(rawMsg, key)
		case "servicePackageActivationMode":
			err = unpopulate(val, "ServicePackageActivationMode", &s.ServicePackageActivationMode)
			delete(rawMsg, key)
		case "servicePlacementPolicies":
			s.ServicePlacementPolicies, err = unmarshalServicePlacementPolicyClassificationArray(val)
			delete(rawMsg, key)
		case "servicePlacementTimeLimit":
			err = unpopulate(val, "ServicePlacementTimeLimit", &s.ServicePlacementTimeLimit)
			delete(rawMsg, key)
		case "serviceTypeName":
			err = unpopulate(val, "ServiceTypeName", &s.ServiceTypeName)
			delete(rawMsg, key)
		case "standByReplicaKeepDuration":
			err = unpopulate(val, "StandByReplicaKeepDuration", &s.StandByReplicaKeepDuration)
			delete(rawMsg, key)
		case "targetReplicaSetSize":
			err = unpopulate(val, "TargetReplicaSetSize", &s.TargetReplicaSetSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StatelessServiceProperties.
func (s StatelessServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correlationScheme", s.CorrelationScheme)
	populate(objectMap, "defaultMoveCost", s.DefaultMoveCost)
	populate(objectMap, "instanceCount", s.InstanceCount)
	populate(objectMap, "minInstanceCount", s.MinInstanceCount)
	populate(objectMap, "minInstancePercentage", s.MinInstancePercentage)
	populate(objectMap, "partitionDescription", s.PartitionDescription)
	populate(objectMap, "placementConstraints", s.PlacementConstraints)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "scalingPolicies", s.ScalingPolicies)
	populate(objectMap, "serviceDnsName", s.ServiceDNSName)
	objectMap["serviceKind"] = ServiceKindStateless
	populate(objectMap, "serviceLoadMetrics", s.ServiceLoadMetrics)
	populate(objectMap, "servicePackageActivationMode", s.ServicePackageActivationMode)
	populate(objectMap, "servicePlacementPolicies", s.ServicePlacementPolicies)
	populate(objectMap, "serviceTypeName", s.ServiceTypeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StatelessServiceProperties.
func (s *StatelessServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correlationScheme":
			err = unpopulate(val, "CorrelationScheme", &s.CorrelationScheme)
			delete(rawMsg, key)
		case "defaultMoveCost":
			err = unpopulate(val, "DefaultMoveCost", &s.DefaultMoveCost)
			delete(rawMsg, key)
		case "instanceCount":
			err = unpopulate(val, "InstanceCount", &s.InstanceCount)
			delete(rawMsg, key)
		case "minInstanceCount":
			err = unpopulate(val, "MinInstanceCount", &s.MinInstanceCount)
			delete(rawMsg, key)
		case "minInstancePercentage":
			err = unpopulate(val, "MinInstancePercentage", &s.MinInstancePercentage)
			delete(rawMsg, key)
		case "partitionDescription":
			s.PartitionDescription, err = unmarshalPartitionClassification(val)
			delete(rawMsg, key)
		case "placementConstraints":
			err = unpopulate(val, "PlacementConstraints", &s.PlacementConstraints)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "scalingPolicies":
			err = unpopulate(val, "ScalingPolicies", &s.ScalingPolicies)
			delete(rawMsg, key)
		case "serviceDnsName":
			err = unpopulate(val, "ServiceDNSName", &s.ServiceDNSName)
			delete(rawMsg, key)
		case "serviceKind":
			err = unpopulate(val, "ServiceKind", &s.ServiceKind)
			delete(rawMsg, key)
		case "serviceLoadMetrics":
			err = unpopulate(val, "ServiceLoadMetrics", &s.ServiceLoadMetrics)
			delete(rawMsg, key)
		case "servicePackageActivationMode":
			err = unpopulate(val, "ServicePackageActivationMode", &s.ServicePackageActivationMode)
			delete(rawMsg, key)
		case "servicePlacementPolicies":
			s.ServicePlacementPolicies, err = unmarshalServicePlacementPolicyClassificationArray(val)
			delete(rawMsg, key)
		case "serviceTypeName":
			err = unpopulate(val, "ServiceTypeName", &s.ServiceTypeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubResource.
func (s SubResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubResource.
func (s *SubResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Subnet.
func (s Subnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableIpv6", s.EnableIPv6)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "networkSecurityGroupId", s.NetworkSecurityGroupID)
	populate(objectMap, "privateEndpointNetworkPolicies", s.PrivateEndpointNetworkPolicies)
	populate(objectMap, "privateLinkServiceNetworkPolicies", s.PrivateLinkServiceNetworkPolicies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Subnet.
func (s *Subnet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableIpv6":
			err = unpopulate(val, "EnableIPv6", &s.EnableIPv6)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "networkSecurityGroupId":
			err = unpopulate(val, "NetworkSecurityGroupID", &s.NetworkSecurityGroupID)
			delete(rawMsg, key)
		case "privateEndpointNetworkPolicies":
			err = unpopulate(val, "PrivateEndpointNetworkPolicies", &s.PrivateEndpointNetworkPolicies)
			delete(rawMsg, key)
		case "privateLinkServiceNetworkPolicies":
			err = unpopulate(val, "PrivateLinkServiceNetworkPolicies", &s.PrivateLinkServiceNetworkPolicies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTime[datetime.RFC3339](objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTime[datetime.RFC3339](objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTime[datetime.RFC3339](val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTime[datetime.RFC3339](val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UniformInt64RangePartitionScheme.
func (u UniformInt64RangePartitionScheme) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", u.Count)
	populate(objectMap, "highKey", u.HighKey)
	populate(objectMap, "lowKey", u.LowKey)
	objectMap["partitionScheme"] = PartitionSchemeUniformInt64Range
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UniformInt64RangePartitionScheme.
func (u *UniformInt64RangePartitionScheme) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &u.Count)
			delete(rawMsg, key)
		case "highKey":
			err = unpopulate(val, "HighKey", &u.HighKey)
			delete(rawMsg, key)
		case "lowKey":
			err = unpopulate(val, "LowKey", &u.LowKey)
			delete(rawMsg, key)
		case "partitionScheme":
			err = unpopulate(val, "PartitionScheme", &u.PartitionScheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMApplication.
func (v VMApplication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configurationReference", v.ConfigurationReference)
	populate(objectMap, "enableAutomaticUpgrade", v.EnableAutomaticUpgrade)
	populate(objectMap, "order", v.Order)
	populate(objectMap, "packageReferenceId", v.PackageReferenceID)
	populate(objectMap, "treatFailureAsDeploymentFailure", v.TreatFailureAsDeploymentFailure)
	populate(objectMap, "vmGalleryTags", v.VMGalleryTags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMApplication.
func (v *VMApplication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurationReference":
			err = unpopulate(val, "ConfigurationReference", &v.ConfigurationReference)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &v.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, "Order", &v.Order)
			delete(rawMsg, key)
		case "packageReferenceId":
			err = unpopulate(val, "PackageReferenceID", &v.PackageReferenceID)
			delete(rawMsg, key)
		case "treatFailureAsDeploymentFailure":
			err = unpopulate(val, "TreatFailureAsDeploymentFailure", &v.TreatFailureAsDeploymentFailure)
			delete(rawMsg, key)
		case "vmGalleryTags":
			err = unpopulate(val, "VMGalleryTags", &v.VMGalleryTags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMImagePlan.
func (v VMImagePlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "product", v.Product)
	populate(objectMap, "promotionCode", v.PromotionCode)
	populate(objectMap, "publisher", v.Publisher)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMImagePlan.
func (v *VMImagePlan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "product":
			err = unpopulate(val, "Product", &v.Product)
			delete(rawMsg, key)
		case "promotionCode":
			err = unpopulate(val, "PromotionCode", &v.PromotionCode)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &v.Publisher)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMManagedIdentity.
func (v VMManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "userAssignedIdentities", v.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMManagedIdentity.
func (v *VMManagedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &v.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMSSExtension.
func (v VMSSExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMSSExtension.
func (v *VMSSExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMSSExtensionProperties.
func (v VMSSExtensionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpgradeMinorVersion", v.AutoUpgradeMinorVersion)
	populate(objectMap, "enableAutomaticUpgrade", v.EnableAutomaticUpgrade)
	populate(objectMap, "forceUpdateTag", v.ForceUpdateTag)
	populateAny(objectMap, "protectedSettings", v.ProtectedSettings)
	populate(objectMap, "provisionAfterExtensions", v.ProvisionAfterExtensions)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "publisher", v.Publisher)
	populateAny(objectMap, "settings", v.Settings)
	populate(objectMap, "setupOrder", v.SetupOrder)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "typeHandlerVersion", v.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMSSExtensionProperties.
func (v *VMSSExtensionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpgradeMinorVersion":
			err = unpopulate(val, "AutoUpgradeMinorVersion", &v.AutoUpgradeMinorVersion)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
			err = unpopulate(val, "EnableAutomaticUpgrade", &v.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "forceUpdateTag":
			err = unpopulate(val, "ForceUpdateTag", &v.ForceUpdateTag)
			delete(rawMsg, key)
		case "protectedSettings":
			err = unpopulate(val, "ProtectedSettings", &v.ProtectedSettings)
			delete(rawMsg, key)
		case "provisionAfterExtensions":
			err = unpopulate(val, "ProvisionAfterExtensions", &v.ProvisionAfterExtensions)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "publisher":
			err = unpopulate(val, "Publisher", &v.Publisher)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &v.Settings)
			delete(rawMsg, key)
		case "setupOrder":
			err = unpopulate(val, "SetupOrder", &v.SetupOrder)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeHandlerVersion":
			err = unpopulate(val, "TypeHandlerVersion", &v.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMSize.
func (v VMSize) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "size", v.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMSize.
func (v *VMSize) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "size":
			err = unpopulate(val, "Size", &v.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultCertificate.
func (v VaultCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certificateStore", v.CertificateStore)
	populate(objectMap, "certificateUrl", v.CertificateURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultCertificate.
func (v *VaultCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateStore":
			err = unpopulate(val, "CertificateStore", &v.CertificateStore)
			delete(rawMsg, key)
		case "certificateUrl":
			err = unpopulate(val, "CertificateURL", &v.CertificateURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VaultSecretGroup.
func (v VaultSecretGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sourceVault", v.SourceVault)
	populate(objectMap, "vaultCertificates", v.VaultCertificates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VaultSecretGroup.
func (v *VaultSecretGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sourceVault":
			err = unpopulate(val, "SourceVault", &v.SourceVault)
			delete(rawMsg, key)
		case "vaultCertificates":
			err = unpopulate(val, "VaultCertificates", &v.VaultCertificates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VmssDataDisk.
func (v VmssDataDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskLetter", v.DiskLetter)
	populate(objectMap, "diskSizeGB", v.DiskSizeGB)
	populate(objectMap, "diskType", v.DiskType)
	populate(objectMap, "lun", v.Lun)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VmssDataDisk.
func (v *VmssDataDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskLetter":
			err = unpopulate(val, "DiskLetter", &v.DiskLetter)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, "DiskSizeGB", &v.DiskSizeGB)
			delete(rawMsg, key)
		case "diskType":
			err = unpopulate(val, "DiskType", &v.DiskType)
			delete(rawMsg, key)
		case "lun":
			err = unpopulate(val, "Lun", &v.Lun)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ZoneFaultSimulationContent.
func (z ZoneFaultSimulationContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "constraints", z.Constraints)
	objectMap["faultKind"] = FaultKindZone
	populate(objectMap, "force", z.Force)
	populate(objectMap, "zones", z.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZoneFaultSimulationContent.
func (z *ZoneFaultSimulationContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", z, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "constraints":
			err = unpopulate(val, "Constraints", &z.Constraints)
			delete(rawMsg, key)
		case "faultKind":
			err = unpopulate(val, "FaultKind", &z.FaultKind)
			delete(rawMsg, key)
		case "force":
			err = unpopulate(val, "Force", &z.Force)
			delete(rawMsg, key)
		case "zones":
			err = unpopulate(val, "Zones", &z.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", z, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateTime[T dateTimeConstraints](m map[string]any, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
	} else if !reflect.ValueOf(t).IsNil() {
		newTime := T(*t)
		m[k] = (*T)(&newTime)
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

func unpopulateTime[T dateTimeConstraints](data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	var aux T
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	newTime := time.Time(aux)
	*t = &newTime
	return nil
}

type dateTimeConstraints interface {
	datetime.PlainDate | datetime.PlainTime | datetime.RFC1123 | datetime.RFC3339 | datetime.Unix
}
