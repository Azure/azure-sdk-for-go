//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicelinker

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// LinkerClientCreateOrUpdatePollerResponse contains the response from method LinkerClient.CreateOrUpdate.
type LinkerClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkerClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LinkerClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkerClientCreateOrUpdateResponse, error) {
	respType := LinkerClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LinkerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkerClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LinkerClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LinkerClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LinkerClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LinkerClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkerClientCreateOrUpdateResponse contains the response from method LinkerClient.CreateOrUpdate.
type LinkerClientCreateOrUpdateResponse struct {
	LinkerClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientCreateOrUpdateResult contains the result from method LinkerClient.CreateOrUpdate.
type LinkerClientCreateOrUpdateResult struct {
	LinkerResource
}

// LinkerClientDeletePollerResponse contains the response from method LinkerClient.Delete.
type LinkerClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkerClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LinkerClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkerClientDeleteResponse, error) {
	respType := LinkerClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkerClientDeletePollerResponse from the provided client and resume token.
func (l *LinkerClientDeletePollerResponse) Resume(ctx context.Context, client *LinkerClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LinkerClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LinkerClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkerClientDeleteResponse contains the response from method LinkerClient.Delete.
type LinkerClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientGetResponse contains the response from method LinkerClient.Get.
type LinkerClientGetResponse struct {
	LinkerClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientGetResult contains the result from method LinkerClient.Get.
type LinkerClientGetResult struct {
	LinkerResource
}

// LinkerClientListConfigurationsResponse contains the response from method LinkerClient.ListConfigurations.
type LinkerClientListConfigurationsResponse struct {
	LinkerClientListConfigurationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientListConfigurationsResult contains the result from method LinkerClient.ListConfigurations.
type LinkerClientListConfigurationsResult struct {
	SourceConfigurationResult
}

// LinkerClientListResponse contains the response from method LinkerClient.List.
type LinkerClientListResponse struct {
	LinkerClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientListResult contains the result from method LinkerClient.List.
type LinkerClientListResult struct {
	LinkerList
}

// LinkerClientUpdatePollerResponse contains the response from method LinkerClient.Update.
type LinkerClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkerClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LinkerClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkerClientUpdateResponse, error) {
	respType := LinkerClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LinkerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkerClientUpdatePollerResponse from the provided client and resume token.
func (l *LinkerClientUpdatePollerResponse) Resume(ctx context.Context, client *LinkerClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LinkerClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LinkerClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkerClientUpdateResponse contains the response from method LinkerClient.Update.
type LinkerClientUpdateResponse struct {
	LinkerClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientUpdateResult contains the result from method LinkerClient.Update.
type LinkerClientUpdateResult struct {
	LinkerResource
}

// LinkerClientValidatePollerResponse contains the response from method LinkerClient.Validate.
type LinkerClientValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkerClientValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LinkerClientValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkerClientValidateResponse, error) {
	respType := LinkerClientValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ValidateResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkerClientValidatePollerResponse from the provided client and resume token.
func (l *LinkerClientValidatePollerResponse) Resume(ctx context.Context, client *LinkerClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LinkerClient.Validate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LinkerClientValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkerClientValidateResponse contains the response from method LinkerClient.Validate.
type LinkerClientValidateResponse struct {
	LinkerClientValidateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkerClientValidateResult contains the result from method LinkerClient.Validate.
type LinkerClientValidateResult struct {
	ValidateResult
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}
