//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armmanagedapplications

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationClientListOperationsResponse contains the response from method ApplicationClient.ListOperations.
type ApplicationClientListOperationsResponse struct {
	ApplicationClientListOperationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationClientListOperationsResult contains the result from method ApplicationClient.ListOperations.
type ApplicationClientListOperationsResult struct {
	OperationListResult
}

// ApplicationDefinitionsCreateOrUpdatePollerResponse contains the response from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsCreateOrUpdateResponse, error) {
	respType := ApplicationDefinitionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsCreateOrUpdateResponse contains the response from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdateResponse struct {
	ApplicationDefinitionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsCreateOrUpdateResult contains the result from method ApplicationDefinitions.CreateOrUpdate.
type ApplicationDefinitionsCreateOrUpdateResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsDeletePollerResponse contains the response from method ApplicationDefinitions.Delete.
type ApplicationDefinitionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDefinitionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationDefinitionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDefinitionsDeleteResponse, error) {
	respType := ApplicationDefinitionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDefinitionsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationDefinitionsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationDefinitionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDefinitionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDefinitionsDeleteResponse contains the response from method ApplicationDefinitions.Delete.
type ApplicationDefinitionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsGetResponse contains the response from method ApplicationDefinitions.Get.
type ApplicationDefinitionsGetResponse struct {
	ApplicationDefinitionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsGetResult contains the result from method ApplicationDefinitions.Get.
type ApplicationDefinitionsGetResult struct {
	ApplicationDefinition
}

// ApplicationDefinitionsListByResourceGroupResponse contains the response from method ApplicationDefinitions.ListByResourceGroup.
type ApplicationDefinitionsListByResourceGroupResponse struct {
	ApplicationDefinitionsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsListByResourceGroupResult contains the result from method ApplicationDefinitions.ListByResourceGroup.
type ApplicationDefinitionsListByResourceGroupResult struct {
	ApplicationDefinitionListResult
}

// ApplicationDefinitionsListBySubscriptionResponse contains the response from method ApplicationDefinitions.ListBySubscription.
type ApplicationDefinitionsListBySubscriptionResponse struct {
	ApplicationDefinitionsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsListBySubscriptionResult contains the result from method ApplicationDefinitions.ListBySubscription.
type ApplicationDefinitionsListBySubscriptionResult struct {
	ApplicationDefinitionListResult
}

// ApplicationDefinitionsUpdateResponse contains the response from method ApplicationDefinitions.Update.
type ApplicationDefinitionsUpdateResponse struct {
	ApplicationDefinitionsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationDefinitionsUpdateResult contains the result from method ApplicationDefinitions.Update.
type ApplicationDefinitionsUpdateResult struct {
	ApplicationDefinition
}

// ApplicationsCreateOrUpdatePollerResponse contains the response from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsCreateOrUpdateResponse, error) {
	respType := ApplicationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Application)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsCreateOrUpdateResponse contains the response from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdateResponse struct {
	ApplicationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsCreateOrUpdateResult contains the result from method Applications.CreateOrUpdate.
type ApplicationsCreateOrUpdateResult struct {
	Application
}

// ApplicationsDeletePollerResponse contains the response from method Applications.Delete.
type ApplicationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsDeleteResponse, error) {
	respType := ApplicationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsDeletePollerResponse from the provided client and resume token.
func (l *ApplicationsDeletePollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsDeleteResponse contains the response from method Applications.Delete.
type ApplicationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsGetResponse contains the response from method Applications.Get.
type ApplicationsGetResponse struct {
	ApplicationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsGetResult contains the result from method Applications.Get.
type ApplicationsGetResult struct {
	Application
}

// ApplicationsListAllowedUpgradePlansResponse contains the response from method Applications.ListAllowedUpgradePlans.
type ApplicationsListAllowedUpgradePlansResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsListByResourceGroupResponse contains the response from method Applications.ListByResourceGroup.
type ApplicationsListByResourceGroupResponse struct {
	ApplicationsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsListByResourceGroupResult contains the result from method Applications.ListByResourceGroup.
type ApplicationsListByResourceGroupResult struct {
	ApplicationListResult
}

// ApplicationsListBySubscriptionResponse contains the response from method Applications.ListBySubscription.
type ApplicationsListBySubscriptionResponse struct {
	ApplicationsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsListBySubscriptionResult contains the result from method Applications.ListBySubscription.
type ApplicationsListBySubscriptionResult struct {
	ApplicationListResult
}

// ApplicationsRefreshPermissionsPollerResponse contains the response from method Applications.RefreshPermissions.
type ApplicationsRefreshPermissionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationsRefreshPermissionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationsRefreshPermissionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationsRefreshPermissionsResponse, error) {
	respType := ApplicationsRefreshPermissionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationsRefreshPermissionsPollerResponse from the provided client and resume token.
func (l *ApplicationsRefreshPermissionsPollerResponse) Resume(ctx context.Context, client *ApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationsClient.RefreshPermissions", token, client.pl, client.refreshPermissionsHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationsRefreshPermissionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationsRefreshPermissionsResponse contains the response from method Applications.RefreshPermissions.
type ApplicationsRefreshPermissionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsUpdateResponse contains the response from method Applications.Update.
type ApplicationsUpdateResponse struct {
	ApplicationsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationsUpdateResult contains the result from method Applications.Update.
type ApplicationsUpdateResult struct {
	Application
}

// JitRequestsCreateOrUpdatePollerResponse contains the response from method JitRequests.CreateOrUpdate.
type JitRequestsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JitRequestsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JitRequestsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JitRequestsCreateOrUpdateResponse, error) {
	respType := JitRequestsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JitRequestDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JitRequestsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *JitRequestsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *JitRequestsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JitRequestsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &JitRequestsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JitRequestsCreateOrUpdateResponse contains the response from method JitRequests.CreateOrUpdate.
type JitRequestsCreateOrUpdateResponse struct {
	JitRequestsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsCreateOrUpdateResult contains the result from method JitRequests.CreateOrUpdate.
type JitRequestsCreateOrUpdateResult struct {
	JitRequestDefinition
}

// JitRequestsDeleteResponse contains the response from method JitRequests.Delete.
type JitRequestsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsGetResponse contains the response from method JitRequests.Get.
type JitRequestsGetResponse struct {
	JitRequestsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsGetResult contains the result from method JitRequests.Get.
type JitRequestsGetResult struct {
	JitRequestDefinition
}

// JitRequestsListByResourceGroupResponse contains the response from method JitRequests.ListByResourceGroup.
type JitRequestsListByResourceGroupResponse struct {
	JitRequestsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsListByResourceGroupResult contains the result from method JitRequests.ListByResourceGroup.
type JitRequestsListByResourceGroupResult struct {
	JitRequestDefinitionListResult
}

// JitRequestsListBySubscriptionResponse contains the response from method JitRequests.ListBySubscription.
type JitRequestsListBySubscriptionResponse struct {
	JitRequestsListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsListBySubscriptionResult contains the result from method JitRequests.ListBySubscription.
type JitRequestsListBySubscriptionResult struct {
	JitRequestDefinitionListResult
}

// JitRequestsUpdateResponse contains the response from method JitRequests.Update.
type JitRequestsUpdateResponse struct {
	JitRequestsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JitRequestsUpdateResult contains the result from method JitRequests.Update.
type JitRequestsUpdateResult struct {
	JitRequestDefinition
}
