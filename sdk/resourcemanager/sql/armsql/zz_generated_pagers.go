//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// BackupShortTermRetentionPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type BackupShortTermRetentionPoliciesClientListByDatabasePager struct {
	client    *BackupShortTermRetentionPoliciesClient
	current   BackupShortTermRetentionPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupShortTermRetentionPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BackupShortTermRetentionPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BackupShortTermRetentionPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.BackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BackupShortTermRetentionPoliciesClientListByDatabaseResponse page.
func (p *BackupShortTermRetentionPoliciesClientListByDatabasePager) PageResponse() BackupShortTermRetentionPoliciesClientListByDatabaseResponse {
	return p.current
}

// DataWarehouseUserActivitiesClientListByDatabasePager provides operations for iterating over paged responses.
type DataWarehouseUserActivitiesClientListByDatabasePager struct {
	client    *DataWarehouseUserActivitiesClient
	current   DataWarehouseUserActivitiesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataWarehouseUserActivitiesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataWarehouseUserActivitiesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataWarehouseUserActivitiesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataWarehouseUserActivitiesListResult.NextLink == nil || len(*p.current.DataWarehouseUserActivitiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataWarehouseUserActivitiesClientListByDatabaseResponse page.
func (p *DataWarehouseUserActivitiesClientListByDatabasePager) PageResponse() DataWarehouseUserActivitiesClientListByDatabaseResponse {
	return p.current
}

// DatabaseBlobAuditingPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseBlobAuditingPoliciesClientListByDatabasePager struct {
	client    *DatabaseBlobAuditingPoliciesClient
	current   DatabaseBlobAuditingPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseBlobAuditingPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseBlobAuditingPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseBlobAuditingPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.DatabaseBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseBlobAuditingPoliciesClientListByDatabaseResponse page.
func (p *DatabaseBlobAuditingPoliciesClientListByDatabasePager) PageResponse() DatabaseBlobAuditingPoliciesClientListByDatabaseResponse {
	return p.current
}

// DatabaseColumnsClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseColumnsClientListByDatabasePager struct {
	client    *DatabaseColumnsClient
	current   DatabaseColumnsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseColumnsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseColumnsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseColumnsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseColumnsClientListByDatabaseResponse page.
func (p *DatabaseColumnsClientListByDatabasePager) PageResponse() DatabaseColumnsClientListByDatabaseResponse {
	return p.current
}

// DatabaseColumnsClientListByTablePager provides operations for iterating over paged responses.
type DatabaseColumnsClientListByTablePager struct {
	client    *DatabaseColumnsClient
	current   DatabaseColumnsClientListByTableResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseColumnsClientListByTableResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseColumnsClientListByTablePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseColumnsClientListByTablePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTableHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseColumnsClientListByTableResponse page.
func (p *DatabaseColumnsClientListByTablePager) PageResponse() DatabaseColumnsClientListByTableResponse {
	return p.current
}

// DatabaseExtensionsClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseExtensionsClientListByDatabasePager struct {
	client    *DatabaseExtensionsClient
	current   DatabaseExtensionsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseExtensionsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseExtensionsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseExtensionsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImportExportExtensionsOperationListResult.NextLink == nil || len(*p.current.ImportExportExtensionsOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseExtensionsClientListByDatabaseResponse page.
func (p *DatabaseExtensionsClientListByDatabasePager) PageResponse() DatabaseExtensionsClientListByDatabaseResponse {
	return p.current
}

// DatabaseOperationsClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseOperationsClientListByDatabasePager struct {
	client    *DatabaseOperationsClient
	current   DatabaseOperationsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseOperationsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseOperationsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseOperationsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseOperationListResult.NextLink == nil || len(*p.current.DatabaseOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseOperationsClientListByDatabaseResponse page.
func (p *DatabaseOperationsClientListByDatabasePager) PageResponse() DatabaseOperationsClientListByDatabaseResponse {
	return p.current
}

// DatabaseSchemasClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseSchemasClientListByDatabasePager struct {
	client    *DatabaseSchemasClient
	current   DatabaseSchemasClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseSchemasClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseSchemasClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseSchemasClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSchemaListResult.NextLink == nil || len(*p.current.DatabaseSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseSchemasClientListByDatabaseResponse page.
func (p *DatabaseSchemasClientListByDatabasePager) PageResponse() DatabaseSchemasClientListByDatabaseResponse {
	return p.current
}

// DatabaseSecurityAlertPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseSecurityAlertPoliciesClientListByDatabasePager struct {
	client    *DatabaseSecurityAlertPoliciesClient
	current   DatabaseSecurityAlertPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseSecurityAlertPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseSecurityAlertPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseSecurityAlertPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSecurityAlertListResult.NextLink == nil || len(*p.current.DatabaseSecurityAlertListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseSecurityAlertPoliciesClientListByDatabaseResponse page.
func (p *DatabaseSecurityAlertPoliciesClientListByDatabasePager) PageResponse() DatabaseSecurityAlertPoliciesClientListByDatabaseResponse {
	return p.current
}

// DatabaseTablesClientListBySchemaPager provides operations for iterating over paged responses.
type DatabaseTablesClientListBySchemaPager struct {
	client    *DatabaseTablesClient
	current   DatabaseTablesClientListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseTablesClientListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseTablesClientListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseTablesClientListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseTableListResult.NextLink == nil || len(*p.current.DatabaseTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseTablesClientListBySchemaResponse page.
func (p *DatabaseTablesClientListBySchemaPager) PageResponse() DatabaseTablesClientListBySchemaResponse {
	return p.current
}

// DatabaseUsagesClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseUsagesClientListByDatabasePager struct {
	client    *DatabaseUsagesClient
	current   DatabaseUsagesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseUsagesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseUsagesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseUsagesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseUsageListResult.NextLink == nil || len(*p.current.DatabaseUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseUsagesClientListByDatabaseResponse page.
func (p *DatabaseUsagesClientListByDatabasePager) PageResponse() DatabaseUsagesClientListByDatabaseResponse {
	return p.current
}

// DatabaseVulnerabilityAssessmentScansClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseVulnerabilityAssessmentScansClientListByDatabasePager struct {
	client    *DatabaseVulnerabilityAssessmentScansClient
	current   DatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseVulnerabilityAssessmentScansClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseVulnerabilityAssessmentScansClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse page.
func (p *DatabaseVulnerabilityAssessmentScansClientListByDatabasePager) PageResponse() DatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse {
	return p.current
}

// DatabaseVulnerabilityAssessmentsClientListByDatabasePager provides operations for iterating over paged responses.
type DatabaseVulnerabilityAssessmentsClientListByDatabasePager struct {
	client    *DatabaseVulnerabilityAssessmentsClient
	current   DatabaseVulnerabilityAssessmentsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseVulnerabilityAssessmentsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseVulnerabilityAssessmentsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseVulnerabilityAssessmentsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.DatabaseVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseVulnerabilityAssessmentsClientListByDatabaseResponse page.
func (p *DatabaseVulnerabilityAssessmentsClientListByDatabasePager) PageResponse() DatabaseVulnerabilityAssessmentsClientListByDatabaseResponse {
	return p.current
}

// DatabasesClientListByElasticPoolPager provides operations for iterating over paged responses.
type DatabasesClientListByElasticPoolPager struct {
	client    *DatabasesClient
	current   DatabasesClientListByElasticPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesClientListByElasticPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesClientListByElasticPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesClientListByElasticPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByElasticPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesClientListByElasticPoolResponse page.
func (p *DatabasesClientListByElasticPoolPager) PageResponse() DatabasesClientListByElasticPoolResponse {
	return p.current
}

// DatabasesClientListByServerPager provides operations for iterating over paged responses.
type DatabasesClientListByServerPager struct {
	client    *DatabasesClient
	current   DatabasesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesClientListByServerResponse page.
func (p *DatabasesClientListByServerPager) PageResponse() DatabasesClientListByServerResponse {
	return p.current
}

// DatabasesClientListInaccessibleByServerPager provides operations for iterating over paged responses.
type DatabasesClientListInaccessibleByServerPager struct {
	client    *DatabasesClient
	current   DatabasesClientListInaccessibleByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesClientListInaccessibleByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesClientListInaccessibleByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesClientListInaccessibleByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInaccessibleByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesClientListInaccessibleByServerResponse page.
func (p *DatabasesClientListInaccessibleByServerPager) PageResponse() DatabasesClientListInaccessibleByServerResponse {
	return p.current
}

// DeletedServersClientListByLocationPager provides operations for iterating over paged responses.
type DeletedServersClientListByLocationPager struct {
	client    *DeletedServersClient
	current   DeletedServersClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServersClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServersClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServersClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServerListResult.NextLink == nil || len(*p.current.DeletedServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServersClientListByLocationResponse page.
func (p *DeletedServersClientListByLocationPager) PageResponse() DeletedServersClientListByLocationResponse {
	return p.current
}

// DeletedServersClientListPager provides operations for iterating over paged responses.
type DeletedServersClientListPager struct {
	client    *DeletedServersClient
	current   DeletedServersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServerListResult.NextLink == nil || len(*p.current.DeletedServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServersClientListResponse page.
func (p *DeletedServersClientListPager) PageResponse() DeletedServersClientListResponse {
	return p.current
}

// ElasticPoolOperationsClientListByElasticPoolPager provides operations for iterating over paged responses.
type ElasticPoolOperationsClientListByElasticPoolPager struct {
	client    *ElasticPoolOperationsClient
	current   ElasticPoolOperationsClientListByElasticPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ElasticPoolOperationsClientListByElasticPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ElasticPoolOperationsClientListByElasticPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ElasticPoolOperationsClientListByElasticPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ElasticPoolOperationListResult.NextLink == nil || len(*p.current.ElasticPoolOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByElasticPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ElasticPoolOperationsClientListByElasticPoolResponse page.
func (p *ElasticPoolOperationsClientListByElasticPoolPager) PageResponse() ElasticPoolOperationsClientListByElasticPoolResponse {
	return p.current
}

// ElasticPoolsClientListByServerPager provides operations for iterating over paged responses.
type ElasticPoolsClientListByServerPager struct {
	client    *ElasticPoolsClient
	current   ElasticPoolsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ElasticPoolsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ElasticPoolsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ElasticPoolsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ElasticPoolListResult.NextLink == nil || len(*p.current.ElasticPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ElasticPoolsClientListByServerResponse page.
func (p *ElasticPoolsClientListByServerPager) PageResponse() ElasticPoolsClientListByServerResponse {
	return p.current
}

// EncryptionProtectorsClientListByServerPager provides operations for iterating over paged responses.
type EncryptionProtectorsClientListByServerPager struct {
	client    *EncryptionProtectorsClient
	current   EncryptionProtectorsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EncryptionProtectorsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EncryptionProtectorsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EncryptionProtectorsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EncryptionProtectorListResult.NextLink == nil || len(*p.current.EncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EncryptionProtectorsClientListByServerResponse page.
func (p *EncryptionProtectorsClientListByServerPager) PageResponse() EncryptionProtectorsClientListByServerResponse {
	return p.current
}

// ExtendedDatabaseBlobAuditingPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type ExtendedDatabaseBlobAuditingPoliciesClientListByDatabasePager struct {
	client    *ExtendedDatabaseBlobAuditingPoliciesClient
	current   ExtendedDatabaseBlobAuditingPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedDatabaseBlobAuditingPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedDatabaseBlobAuditingPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedDatabaseBlobAuditingPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedDatabaseBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedDatabaseBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedDatabaseBlobAuditingPoliciesClientListByDatabaseResponse page.
func (p *ExtendedDatabaseBlobAuditingPoliciesClientListByDatabasePager) PageResponse() ExtendedDatabaseBlobAuditingPoliciesClientListByDatabaseResponse {
	return p.current
}

// ExtendedServerBlobAuditingPoliciesClientListByServerPager provides operations for iterating over paged responses.
type ExtendedServerBlobAuditingPoliciesClientListByServerPager struct {
	client    *ExtendedServerBlobAuditingPoliciesClient
	current   ExtendedServerBlobAuditingPoliciesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedServerBlobAuditingPoliciesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedServerBlobAuditingPoliciesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedServerBlobAuditingPoliciesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedServerBlobAuditingPoliciesClientListByServerResponse page.
func (p *ExtendedServerBlobAuditingPoliciesClientListByServerPager) PageResponse() ExtendedServerBlobAuditingPoliciesClientListByServerResponse {
	return p.current
}

// FailoverGroupsClientListByServerPager provides operations for iterating over paged responses.
type FailoverGroupsClientListByServerPager struct {
	client    *FailoverGroupsClient
	current   FailoverGroupsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FailoverGroupsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FailoverGroupsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FailoverGroupsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FailoverGroupListResult.NextLink == nil || len(*p.current.FailoverGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FailoverGroupsClientListByServerResponse page.
func (p *FailoverGroupsClientListByServerPager) PageResponse() FailoverGroupsClientListByServerResponse {
	return p.current
}

// FirewallRulesClientListByServerPager provides operations for iterating over paged responses.
type FirewallRulesClientListByServerPager struct {
	client    *FirewallRulesClient
	current   FirewallRulesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallRulesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallRulesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallRulesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallRuleListResult.NextLink == nil || len(*p.current.FirewallRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallRulesClientListByServerResponse page.
func (p *FirewallRulesClientListByServerPager) PageResponse() FirewallRulesClientListByServerResponse {
	return p.current
}

// InstanceFailoverGroupsClientListByLocationPager provides operations for iterating over paged responses.
type InstanceFailoverGroupsClientListByLocationPager struct {
	client    *InstanceFailoverGroupsClient
	current   InstanceFailoverGroupsClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstanceFailoverGroupsClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstanceFailoverGroupsClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstanceFailoverGroupsClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstanceFailoverGroupListResult.NextLink == nil || len(*p.current.InstanceFailoverGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstanceFailoverGroupsClientListByLocationResponse page.
func (p *InstanceFailoverGroupsClientListByLocationPager) PageResponse() InstanceFailoverGroupsClientListByLocationResponse {
	return p.current
}

// InstancePoolsClientListByResourceGroupPager provides operations for iterating over paged responses.
type InstancePoolsClientListByResourceGroupPager struct {
	client    *InstancePoolsClient
	current   InstancePoolsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstancePoolsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstancePoolsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstancePoolsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstancePoolListResult.NextLink == nil || len(*p.current.InstancePoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstancePoolsClientListByResourceGroupResponse page.
func (p *InstancePoolsClientListByResourceGroupPager) PageResponse() InstancePoolsClientListByResourceGroupResponse {
	return p.current
}

// InstancePoolsClientListPager provides operations for iterating over paged responses.
type InstancePoolsClientListPager struct {
	client    *InstancePoolsClient
	current   InstancePoolsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstancePoolsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstancePoolsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstancePoolsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstancePoolListResult.NextLink == nil || len(*p.current.InstancePoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstancePoolsClientListResponse page.
func (p *InstancePoolsClientListPager) PageResponse() InstancePoolsClientListResponse {
	return p.current
}

// JobAgentsClientListByServerPager provides operations for iterating over paged responses.
type JobAgentsClientListByServerPager struct {
	client    *JobAgentsClient
	current   JobAgentsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobAgentsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobAgentsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobAgentsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobAgentListResult.NextLink == nil || len(*p.current.JobAgentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobAgentsClientListByServerResponse page.
func (p *JobAgentsClientListByServerPager) PageResponse() JobAgentsClientListByServerResponse {
	return p.current
}

// JobCredentialsClientListByAgentPager provides operations for iterating over paged responses.
type JobCredentialsClientListByAgentPager struct {
	client    *JobCredentialsClient
	current   JobCredentialsClientListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobCredentialsClientListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobCredentialsClientListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobCredentialsClientListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobCredentialListResult.NextLink == nil || len(*p.current.JobCredentialListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobCredentialsClientListByAgentResponse page.
func (p *JobCredentialsClientListByAgentPager) PageResponse() JobCredentialsClientListByAgentResponse {
	return p.current
}

// JobExecutionsClientListByAgentPager provides operations for iterating over paged responses.
type JobExecutionsClientListByAgentPager struct {
	client    *JobExecutionsClient
	current   JobExecutionsClientListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobExecutionsClientListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobExecutionsClientListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobExecutionsClientListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobExecutionsClientListByAgentResponse page.
func (p *JobExecutionsClientListByAgentPager) PageResponse() JobExecutionsClientListByAgentResponse {
	return p.current
}

// JobExecutionsClientListByJobPager provides operations for iterating over paged responses.
type JobExecutionsClientListByJobPager struct {
	client    *JobExecutionsClient
	current   JobExecutionsClientListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobExecutionsClientListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobExecutionsClientListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobExecutionsClientListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobExecutionsClientListByJobResponse page.
func (p *JobExecutionsClientListByJobPager) PageResponse() JobExecutionsClientListByJobResponse {
	return p.current
}

// JobStepExecutionsClientListByJobExecutionPager provides operations for iterating over paged responses.
type JobStepExecutionsClientListByJobExecutionPager struct {
	client    *JobStepExecutionsClient
	current   JobStepExecutionsClientListByJobExecutionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepExecutionsClientListByJobExecutionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepExecutionsClientListByJobExecutionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepExecutionsClientListByJobExecutionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobExecutionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepExecutionsClientListByJobExecutionResponse page.
func (p *JobStepExecutionsClientListByJobExecutionPager) PageResponse() JobStepExecutionsClientListByJobExecutionResponse {
	return p.current
}

// JobStepsClientListByJobPager provides operations for iterating over paged responses.
type JobStepsClientListByJobPager struct {
	client    *JobStepsClient
	current   JobStepsClientListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepsClientListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepsClientListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepsClientListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStepListResult.NextLink == nil || len(*p.current.JobStepListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepsClientListByJobResponse page.
func (p *JobStepsClientListByJobPager) PageResponse() JobStepsClientListByJobResponse {
	return p.current
}

// JobStepsClientListByVersionPager provides operations for iterating over paged responses.
type JobStepsClientListByVersionPager struct {
	client    *JobStepsClient
	current   JobStepsClientListByVersionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepsClientListByVersionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepsClientListByVersionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepsClientListByVersionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStepListResult.NextLink == nil || len(*p.current.JobStepListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByVersionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepsClientListByVersionResponse page.
func (p *JobStepsClientListByVersionPager) PageResponse() JobStepsClientListByVersionResponse {
	return p.current
}

// JobTargetExecutionsClientListByJobExecutionPager provides operations for iterating over paged responses.
type JobTargetExecutionsClientListByJobExecutionPager struct {
	client    *JobTargetExecutionsClient
	current   JobTargetExecutionsClientListByJobExecutionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetExecutionsClientListByJobExecutionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetExecutionsClientListByJobExecutionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetExecutionsClientListByJobExecutionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobExecutionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetExecutionsClientListByJobExecutionResponse page.
func (p *JobTargetExecutionsClientListByJobExecutionPager) PageResponse() JobTargetExecutionsClientListByJobExecutionResponse {
	return p.current
}

// JobTargetExecutionsClientListByStepPager provides operations for iterating over paged responses.
type JobTargetExecutionsClientListByStepPager struct {
	client    *JobTargetExecutionsClient
	current   JobTargetExecutionsClientListByStepResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetExecutionsClientListByStepResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetExecutionsClientListByStepPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetExecutionsClientListByStepPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByStepHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetExecutionsClientListByStepResponse page.
func (p *JobTargetExecutionsClientListByStepPager) PageResponse() JobTargetExecutionsClientListByStepResponse {
	return p.current
}

// JobTargetGroupsClientListByAgentPager provides operations for iterating over paged responses.
type JobTargetGroupsClientListByAgentPager struct {
	client    *JobTargetGroupsClient
	current   JobTargetGroupsClientListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetGroupsClientListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetGroupsClientListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetGroupsClientListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobTargetGroupListResult.NextLink == nil || len(*p.current.JobTargetGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetGroupsClientListByAgentResponse page.
func (p *JobTargetGroupsClientListByAgentPager) PageResponse() JobTargetGroupsClientListByAgentResponse {
	return p.current
}

// JobVersionsClientListByJobPager provides operations for iterating over paged responses.
type JobVersionsClientListByJobPager struct {
	client    *JobVersionsClient
	current   JobVersionsClientListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobVersionsClientListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobVersionsClientListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobVersionsClientListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobVersionListResult.NextLink == nil || len(*p.current.JobVersionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobVersionsClientListByJobResponse page.
func (p *JobVersionsClientListByJobPager) PageResponse() JobVersionsClientListByJobResponse {
	return p.current
}

// JobsClientListByAgentPager provides operations for iterating over paged responses.
type JobsClientListByAgentPager struct {
	client    *JobsClient
	current   JobsClientListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsClientListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobsClientListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobsClientListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobListResult.NextLink == nil || len(*p.current.JobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobsClientListByAgentResponse page.
func (p *JobsClientListByAgentPager) PageResponse() JobsClientListByAgentResponse {
	return p.current
}

// LedgerDigestUploadsClientListByDatabasePager provides operations for iterating over paged responses.
type LedgerDigestUploadsClientListByDatabasePager struct {
	client    *LedgerDigestUploadsClient
	current   LedgerDigestUploadsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LedgerDigestUploadsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LedgerDigestUploadsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LedgerDigestUploadsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LedgerDigestUploadsListResult.NextLink == nil || len(*p.current.LedgerDigestUploadsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LedgerDigestUploadsClientListByDatabaseResponse page.
func (p *LedgerDigestUploadsClientListByDatabasePager) PageResponse() LedgerDigestUploadsClientListByDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByDatabasePager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByDatabaseResponse page.
func (p *LongTermRetentionBackupsClientListByDatabasePager) PageResponse() LongTermRetentionBackupsClientListByDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByLocationPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByLocationPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByLocationResponse page.
func (p *LongTermRetentionBackupsClientListByLocationPager) PageResponse() LongTermRetentionBackupsClientListByLocationResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByResourceGroupDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByResourceGroupDatabasePager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByResourceGroupDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByResourceGroupDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByResourceGroupDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByResourceGroupDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByResourceGroupDatabaseResponse page.
func (p *LongTermRetentionBackupsClientListByResourceGroupDatabasePager) PageResponse() LongTermRetentionBackupsClientListByResourceGroupDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByResourceGroupLocationPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByResourceGroupLocationPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByResourceGroupLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByResourceGroupLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByResourceGroupLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByResourceGroupLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByResourceGroupLocationResponse page.
func (p *LongTermRetentionBackupsClientListByResourceGroupLocationPager) PageResponse() LongTermRetentionBackupsClientListByResourceGroupLocationResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByResourceGroupServerPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByResourceGroupServerPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByResourceGroupServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByResourceGroupServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByResourceGroupServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByResourceGroupServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByResourceGroupServerResponse page.
func (p *LongTermRetentionBackupsClientListByResourceGroupServerPager) PageResponse() LongTermRetentionBackupsClientListByResourceGroupServerResponse {
	return p.current
}

// LongTermRetentionBackupsClientListByServerPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsClientListByServerPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsClientListByServerResponse page.
func (p *LongTermRetentionBackupsClientListByServerPager) PageResponse() LongTermRetentionBackupsClientListByServerResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByDatabasePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByDatabaseResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByDatabasePager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByDatabaseResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByInstancePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByInstancePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByInstanceResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByInstancePager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByInstanceResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByLocationPager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByLocationPager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByLocationResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByLocationPager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByLocationResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabasePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabaseResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabasePager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByResourceGroupDatabaseResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstancePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstancePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstanceResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstancePager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByResourceGroupInstanceResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationPager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationPager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationResponse page.
func (p *LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationPager) PageResponse() LongTermRetentionManagedInstanceBackupsClientListByResourceGroupLocationResponse {
	return p.current
}

// LongTermRetentionPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionPoliciesClientListByDatabasePager struct {
	client    *LongTermRetentionPoliciesClient
	current   LongTermRetentionPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionPolicyListResult.NextLink == nil || len(*p.current.LongTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionPoliciesClientListByDatabaseResponse page.
func (p *LongTermRetentionPoliciesClientListByDatabasePager) PageResponse() LongTermRetentionPoliciesClientListByDatabaseResponse {
	return p.current
}

// ManagedBackupShortTermRetentionPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedBackupShortTermRetentionPoliciesClientListByDatabasePager struct {
	client    *ManagedBackupShortTermRetentionPoliciesClient
	current   ManagedBackupShortTermRetentionPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedBackupShortTermRetentionPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedBackupShortTermRetentionPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedBackupShortTermRetentionPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedBackupShortTermRetentionPoliciesClientListByDatabaseResponse page.
func (p *ManagedBackupShortTermRetentionPoliciesClientListByDatabasePager) PageResponse() ManagedBackupShortTermRetentionPoliciesClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseColumnsClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseColumnsClientListByDatabasePager struct {
	client    *ManagedDatabaseColumnsClient
	current   ManagedDatabaseColumnsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseColumnsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseColumnsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseColumnsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseColumnsClientListByDatabaseResponse page.
func (p *ManagedDatabaseColumnsClientListByDatabasePager) PageResponse() ManagedDatabaseColumnsClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseColumnsClientListByTablePager provides operations for iterating over paged responses.
type ManagedDatabaseColumnsClientListByTablePager struct {
	client    *ManagedDatabaseColumnsClient
	current   ManagedDatabaseColumnsClientListByTableResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseColumnsClientListByTableResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseColumnsClientListByTablePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseColumnsClientListByTablePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTableHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseColumnsClientListByTableResponse page.
func (p *ManagedDatabaseColumnsClientListByTablePager) PageResponse() ManagedDatabaseColumnsClientListByTableResponse {
	return p.current
}

// ManagedDatabaseQueriesClientListByQueryPager provides operations for iterating over paged responses.
type ManagedDatabaseQueriesClientListByQueryPager struct {
	client    *ManagedDatabaseQueriesClient
	current   ManagedDatabaseQueriesClientListByQueryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseQueriesClientListByQueryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseQueriesClientListByQueryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseQueriesClientListByQueryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceQueryStatistics.NextLink == nil || len(*p.current.ManagedInstanceQueryStatistics.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByQueryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseQueriesClientListByQueryResponse page.
func (p *ManagedDatabaseQueriesClientListByQueryPager) PageResponse() ManagedDatabaseQueriesClientListByQueryResponse {
	return p.current
}

// ManagedDatabaseSchemasClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSchemasClientListByDatabasePager struct {
	client    *ManagedDatabaseSchemasClient
	current   ManagedDatabaseSchemasClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSchemasClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSchemasClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSchemasClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSchemaListResult.NextLink == nil || len(*p.current.DatabaseSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSchemasClientListByDatabaseResponse page.
func (p *ManagedDatabaseSchemasClientListByDatabasePager) PageResponse() ManagedDatabaseSchemasClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSecurityAlertPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSecurityAlertPoliciesClientListByDatabasePager struct {
	client    *ManagedDatabaseSecurityAlertPoliciesClient
	current   ManagedDatabaseSecurityAlertPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSecurityAlertPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSecurityAlertPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSecurityAlertPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ManagedDatabaseSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSecurityAlertPoliciesClientListByDatabaseResponse page.
func (p *ManagedDatabaseSecurityAlertPoliciesClientListByDatabasePager) PageResponse() ManagedDatabaseSecurityAlertPoliciesClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSecurityEventsClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSecurityEventsClientListByDatabasePager struct {
	client    *ManagedDatabaseSecurityEventsClient
	current   ManagedDatabaseSecurityEventsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSecurityEventsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSecurityEventsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSecurityEventsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityEventCollection.NextLink == nil || len(*p.current.SecurityEventCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSecurityEventsClientListByDatabaseResponse page.
func (p *ManagedDatabaseSecurityEventsClientListByDatabasePager) PageResponse() ManagedDatabaseSecurityEventsClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSensitivityLabelsClientListCurrentByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSensitivityLabelsClientListCurrentByDatabasePager struct {
	client    *ManagedDatabaseSensitivityLabelsClient
	current   ManagedDatabaseSensitivityLabelsClientListCurrentByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSensitivityLabelsClientListCurrentByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSensitivityLabelsClientListCurrentByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSensitivityLabelsClientListCurrentByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCurrentByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSensitivityLabelsClientListCurrentByDatabaseResponse page.
func (p *ManagedDatabaseSensitivityLabelsClientListCurrentByDatabasePager) PageResponse() ManagedDatabaseSensitivityLabelsClientListCurrentByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabasePager struct {
	client    *ManagedDatabaseSensitivityLabelsClient
	current   ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendedByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabaseResponse page.
func (p *ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabasePager) PageResponse() ManagedDatabaseSensitivityLabelsClientListRecommendedByDatabaseResponse {
	return p.current
}

// ManagedDatabaseTablesClientListBySchemaPager provides operations for iterating over paged responses.
type ManagedDatabaseTablesClientListBySchemaPager struct {
	client    *ManagedDatabaseTablesClient
	current   ManagedDatabaseTablesClientListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseTablesClientListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseTablesClientListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseTablesClientListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseTableListResult.NextLink == nil || len(*p.current.DatabaseTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseTablesClientListBySchemaResponse page.
func (p *ManagedDatabaseTablesClientListBySchemaPager) PageResponse() ManagedDatabaseTablesClientListBySchemaResponse {
	return p.current
}

// ManagedDatabaseTransparentDataEncryptionClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseTransparentDataEncryptionClientListByDatabasePager struct {
	client    *ManagedDatabaseTransparentDataEncryptionClient
	current   ManagedDatabaseTransparentDataEncryptionClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseTransparentDataEncryptionClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseTransparentDataEncryptionClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseTransparentDataEncryptionClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedTransparentDataEncryptionListResult.NextLink == nil || len(*p.current.ManagedTransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseTransparentDataEncryptionClientListByDatabaseResponse page.
func (p *ManagedDatabaseTransparentDataEncryptionClientListByDatabasePager) PageResponse() ManagedDatabaseTransparentDataEncryptionClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabasePager struct {
	client    *ManagedDatabaseVulnerabilityAssessmentScansClient
	current   ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse page.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabasePager) PageResponse() ManagedDatabaseVulnerabilityAssessmentScansClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseVulnerabilityAssessmentsClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseVulnerabilityAssessmentsClientListByDatabasePager struct {
	client    *ManagedDatabaseVulnerabilityAssessmentsClient
	current   ManagedDatabaseVulnerabilityAssessmentsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseVulnerabilityAssessmentsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseVulnerabilityAssessmentsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseVulnerabilityAssessmentsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.DatabaseVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseVulnerabilityAssessmentsClientListByDatabaseResponse page.
func (p *ManagedDatabaseVulnerabilityAssessmentsClientListByDatabasePager) PageResponse() ManagedDatabaseVulnerabilityAssessmentsClientListByDatabaseResponse {
	return p.current
}

// ManagedDatabasesClientListByInstancePager provides operations for iterating over paged responses.
type ManagedDatabasesClientListByInstancePager struct {
	client    *ManagedDatabasesClient
	current   ManagedDatabasesClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabasesClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabasesClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabasesClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseListResult.NextLink == nil || len(*p.current.ManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabasesClientListByInstanceResponse page.
func (p *ManagedDatabasesClientListByInstancePager) PageResponse() ManagedDatabasesClientListByInstanceResponse {
	return p.current
}

// ManagedDatabasesClientListInaccessibleByInstancePager provides operations for iterating over paged responses.
type ManagedDatabasesClientListInaccessibleByInstancePager struct {
	client    *ManagedDatabasesClient
	current   ManagedDatabasesClientListInaccessibleByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabasesClientListInaccessibleByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabasesClientListInaccessibleByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabasesClientListInaccessibleByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseListResult.NextLink == nil || len(*p.current.ManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listInaccessibleByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabasesClientListInaccessibleByInstanceResponse page.
func (p *ManagedDatabasesClientListInaccessibleByInstancePager) PageResponse() ManagedDatabasesClientListInaccessibleByInstanceResponse {
	return p.current
}

// ManagedInstanceAdministratorsClientListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceAdministratorsClientListByInstancePager struct {
	client    *ManagedInstanceAdministratorsClient
	current   ManagedInstanceAdministratorsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceAdministratorsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceAdministratorsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceAdministratorsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceAdministratorListResult.NextLink == nil || len(*p.current.ManagedInstanceAdministratorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceAdministratorsClientListByInstanceResponse page.
func (p *ManagedInstanceAdministratorsClientListByInstancePager) PageResponse() ManagedInstanceAdministratorsClientListByInstanceResponse {
	return p.current
}

// ManagedInstanceAzureADOnlyAuthenticationsClientListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceAzureADOnlyAuthenticationsClientListByInstancePager struct {
	client    *ManagedInstanceAzureADOnlyAuthenticationsClient
	current   ManagedInstanceAzureADOnlyAuthenticationsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceAzureADOnlyAuthenticationsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceAzureADOnlyAuthListResult.NextLink == nil || len(*p.current.ManagedInstanceAzureADOnlyAuthListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceAzureADOnlyAuthenticationsClientListByInstanceResponse page.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientListByInstancePager) PageResponse() ManagedInstanceAzureADOnlyAuthenticationsClientListByInstanceResponse {
	return p.current
}

// ManagedInstanceEncryptionProtectorsClientListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceEncryptionProtectorsClientListByInstancePager struct {
	client    *ManagedInstanceEncryptionProtectorsClient
	current   ManagedInstanceEncryptionProtectorsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceEncryptionProtectorsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceEncryptionProtectorsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceEncryptionProtectorsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceEncryptionProtectorListResult.NextLink == nil || len(*p.current.ManagedInstanceEncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceEncryptionProtectorsClientListByInstanceResponse page.
func (p *ManagedInstanceEncryptionProtectorsClientListByInstancePager) PageResponse() ManagedInstanceEncryptionProtectorsClientListByInstanceResponse {
	return p.current
}

// ManagedInstanceKeysClientListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceKeysClientListByInstancePager struct {
	client    *ManagedInstanceKeysClient
	current   ManagedInstanceKeysClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceKeysClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceKeysClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceKeysClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceKeyListResult.NextLink == nil || len(*p.current.ManagedInstanceKeyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceKeysClientListByInstanceResponse page.
func (p *ManagedInstanceKeysClientListByInstancePager) PageResponse() ManagedInstanceKeysClientListByInstanceResponse {
	return p.current
}

// ManagedInstanceLongTermRetentionPoliciesClientListByDatabasePager provides operations for iterating over paged responses.
type ManagedInstanceLongTermRetentionPoliciesClientListByDatabasePager struct {
	client    *ManagedInstanceLongTermRetentionPoliciesClient
	current   ManagedInstanceLongTermRetentionPoliciesClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceLongTermRetentionPoliciesClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceLongTermRetentionPoliciesClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceLongTermRetentionPoliciesClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceLongTermRetentionPoliciesClientListByDatabaseResponse page.
func (p *ManagedInstanceLongTermRetentionPoliciesClientListByDatabasePager) PageResponse() ManagedInstanceLongTermRetentionPoliciesClientListByDatabaseResponse {
	return p.current
}

// ManagedInstanceOperationsClientListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstanceOperationsClientListByManagedInstancePager struct {
	client    *ManagedInstanceOperationsClient
	current   ManagedInstanceOperationsClientListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceOperationsClientListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceOperationsClientListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceOperationsClientListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceOperationListResult.NextLink == nil || len(*p.current.ManagedInstanceOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceOperationsClientListByManagedInstanceResponse page.
func (p *ManagedInstanceOperationsClientListByManagedInstancePager) PageResponse() ManagedInstanceOperationsClientListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancePrivateEndpointConnectionsClientListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancePrivateEndpointConnectionsClientListByManagedInstancePager struct {
	client    *ManagedInstancePrivateEndpointConnectionsClient
	current   ManagedInstancePrivateEndpointConnectionsClientListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancePrivateEndpointConnectionsClientListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancePrivateEndpointConnectionsClientListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancePrivateEndpointConnectionsClientListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstancePrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.ManagedInstancePrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancePrivateEndpointConnectionsClientListByManagedInstanceResponse page.
func (p *ManagedInstancePrivateEndpointConnectionsClientListByManagedInstancePager) PageResponse() ManagedInstancePrivateEndpointConnectionsClientListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancePrivateLinkResourcesClientListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancePrivateLinkResourcesClientListByManagedInstancePager struct {
	client    *ManagedInstancePrivateLinkResourcesClient
	current   ManagedInstancePrivateLinkResourcesClientListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancePrivateLinkResourcesClientListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancePrivateLinkResourcesClientListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancePrivateLinkResourcesClientListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstancePrivateLinkListResult.NextLink == nil || len(*p.current.ManagedInstancePrivateLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancePrivateLinkResourcesClientListByManagedInstanceResponse page.
func (p *ManagedInstancePrivateLinkResourcesClientListByManagedInstancePager) PageResponse() ManagedInstancePrivateLinkResourcesClientListByManagedInstanceResponse {
	return p.current
}

// ManagedInstanceVulnerabilityAssessmentsClientListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceVulnerabilityAssessmentsClientListByInstancePager struct {
	client    *ManagedInstanceVulnerabilityAssessmentsClient
	current   ManagedInstanceVulnerabilityAssessmentsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceVulnerabilityAssessmentsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceVulnerabilityAssessmentsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceVulnerabilityAssessmentsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ManagedInstanceVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceVulnerabilityAssessmentsClientListByInstanceResponse page.
func (p *ManagedInstanceVulnerabilityAssessmentsClientListByInstancePager) PageResponse() ManagedInstanceVulnerabilityAssessmentsClientListByInstanceResponse {
	return p.current
}

// ManagedInstancesClientListByInstancePoolPager provides operations for iterating over paged responses.
type ManagedInstancesClientListByInstancePoolPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesClientListByInstancePoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesClientListByInstancePoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesClientListByInstancePoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesClientListByInstancePoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstancePoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesClientListByInstancePoolResponse page.
func (p *ManagedInstancesClientListByInstancePoolPager) PageResponse() ManagedInstancesClientListByInstancePoolResponse {
	return p.current
}

// ManagedInstancesClientListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancesClientListByManagedInstancePager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesClientListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesClientListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesClientListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesClientListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopQueriesListResult.NextLink == nil || len(*p.current.TopQueriesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesClientListByManagedInstanceResponse page.
func (p *ManagedInstancesClientListByManagedInstancePager) PageResponse() ManagedInstancesClientListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ManagedInstancesClientListByResourceGroupPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesClientListByResourceGroupResponse page.
func (p *ManagedInstancesClientListByResourceGroupPager) PageResponse() ManagedInstancesClientListByResourceGroupResponse {
	return p.current
}

// ManagedInstancesClientListPager provides operations for iterating over paged responses.
type ManagedInstancesClientListPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesClientListResponse page.
func (p *ManagedInstancesClientListPager) PageResponse() ManagedInstancesClientListResponse {
	return p.current
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabasePager provides operations for iterating over paged responses.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabasePager struct {
	client    *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient
	current   ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByRestorableDroppedDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabaseResponse page.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabasePager) PageResponse() ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientListByRestorableDroppedDatabaseResponse {
	return p.current
}

// ManagedServerSecurityAlertPoliciesClientListByInstancePager provides operations for iterating over paged responses.
type ManagedServerSecurityAlertPoliciesClientListByInstancePager struct {
	client    *ManagedServerSecurityAlertPoliciesClient
	current   ManagedServerSecurityAlertPoliciesClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedServerSecurityAlertPoliciesClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedServerSecurityAlertPoliciesClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedServerSecurityAlertPoliciesClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ManagedServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedServerSecurityAlertPoliciesClientListByInstanceResponse page.
func (p *ManagedServerSecurityAlertPoliciesClientListByInstancePager) PageResponse() ManagedServerSecurityAlertPoliciesClientListByInstanceResponse {
	return p.current
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsClientListResponse page.
func (p *OperationsClientListPager) PageResponse() OperationsClientListResponse {
	return p.current
}

// OutboundFirewallRulesClientListByServerPager provides operations for iterating over paged responses.
type OutboundFirewallRulesClientListByServerPager struct {
	client    *OutboundFirewallRulesClient
	current   OutboundFirewallRulesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OutboundFirewallRulesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OutboundFirewallRulesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OutboundFirewallRulesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OutboundFirewallRuleListResult.NextLink == nil || len(*p.current.OutboundFirewallRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OutboundFirewallRulesClientListByServerResponse page.
func (p *OutboundFirewallRulesClientListByServerPager) PageResponse() OutboundFirewallRulesClientListByServerResponse {
	return p.current
}

// PrivateEndpointConnectionsClientListByServerPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsClientListByServerPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsClientListByServerResponse page.
func (p *PrivateEndpointConnectionsClientListByServerPager) PageResponse() PrivateEndpointConnectionsClientListByServerResponse {
	return p.current
}

// PrivateLinkResourcesClientListByServerPager provides operations for iterating over paged responses.
type PrivateLinkResourcesClientListByServerPager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkResourcesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkResourcesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkResourcesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkResourcesClientListByServerResponse page.
func (p *PrivateLinkResourcesClientListByServerPager) PageResponse() PrivateLinkResourcesClientListByServerResponse {
	return p.current
}

// RecoverableManagedDatabasesClientListByInstancePager provides operations for iterating over paged responses.
type RecoverableManagedDatabasesClientListByInstancePager struct {
	client    *RecoverableManagedDatabasesClient
	current   RecoverableManagedDatabasesClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecoverableManagedDatabasesClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecoverableManagedDatabasesClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecoverableManagedDatabasesClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoverableManagedDatabaseListResult.NextLink == nil || len(*p.current.RecoverableManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecoverableManagedDatabasesClientListByInstanceResponse page.
func (p *RecoverableManagedDatabasesClientListByInstancePager) PageResponse() RecoverableManagedDatabasesClientListByInstanceResponse {
	return p.current
}

// ReplicationLinksClientListByDatabasePager provides operations for iterating over paged responses.
type ReplicationLinksClientListByDatabasePager struct {
	client    *ReplicationLinksClient
	current   ReplicationLinksClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReplicationLinksClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReplicationLinksClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReplicationLinksClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReplicationLinksClientListByDatabaseResponse page.
func (p *ReplicationLinksClientListByDatabasePager) PageResponse() ReplicationLinksClientListByDatabaseResponse {
	return p.current
}

// ReplicationLinksClientListByServerPager provides operations for iterating over paged responses.
type ReplicationLinksClientListByServerPager struct {
	client    *ReplicationLinksClient
	current   ReplicationLinksClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReplicationLinksClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReplicationLinksClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReplicationLinksClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReplicationLinksClientListByServerResponse page.
func (p *ReplicationLinksClientListByServerPager) PageResponse() ReplicationLinksClientListByServerResponse {
	return p.current
}

// RestorableDroppedDatabasesClientListByServerPager provides operations for iterating over paged responses.
type RestorableDroppedDatabasesClientListByServerPager struct {
	client    *RestorableDroppedDatabasesClient
	current   RestorableDroppedDatabasesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorableDroppedDatabasesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorableDroppedDatabasesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorableDroppedDatabasesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorableDroppedDatabaseListResult.NextLink == nil || len(*p.current.RestorableDroppedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorableDroppedDatabasesClientListByServerResponse page.
func (p *RestorableDroppedDatabasesClientListByServerPager) PageResponse() RestorableDroppedDatabasesClientListByServerResponse {
	return p.current
}

// RestorableDroppedManagedDatabasesClientListByInstancePager provides operations for iterating over paged responses.
type RestorableDroppedManagedDatabasesClientListByInstancePager struct {
	client    *RestorableDroppedManagedDatabasesClient
	current   RestorableDroppedManagedDatabasesClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorableDroppedManagedDatabasesClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorableDroppedManagedDatabasesClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorableDroppedManagedDatabasesClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorableDroppedManagedDatabaseListResult.NextLink == nil || len(*p.current.RestorableDroppedManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorableDroppedManagedDatabasesClientListByInstanceResponse page.
func (p *RestorableDroppedManagedDatabasesClientListByInstancePager) PageResponse() RestorableDroppedManagedDatabasesClientListByInstanceResponse {
	return p.current
}

// RestorePointsClientListByDatabasePager provides operations for iterating over paged responses.
type RestorePointsClientListByDatabasePager struct {
	client    *RestorePointsClient
	current   RestorePointsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorePointsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorePointsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointListResult.NextLink == nil || len(*p.current.RestorePointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorePointsClientListByDatabaseResponse page.
func (p *RestorePointsClientListByDatabasePager) PageResponse() RestorePointsClientListByDatabaseResponse {
	return p.current
}

// SensitivityLabelsClientListCurrentByDatabasePager provides operations for iterating over paged responses.
type SensitivityLabelsClientListCurrentByDatabasePager struct {
	client    *SensitivityLabelsClient
	current   SensitivityLabelsClientListCurrentByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SensitivityLabelsClientListCurrentByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SensitivityLabelsClientListCurrentByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SensitivityLabelsClientListCurrentByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCurrentByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SensitivityLabelsClientListCurrentByDatabaseResponse page.
func (p *SensitivityLabelsClientListCurrentByDatabasePager) PageResponse() SensitivityLabelsClientListCurrentByDatabaseResponse {
	return p.current
}

// SensitivityLabelsClientListRecommendedByDatabasePager provides operations for iterating over paged responses.
type SensitivityLabelsClientListRecommendedByDatabasePager struct {
	client    *SensitivityLabelsClient
	current   SensitivityLabelsClientListRecommendedByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SensitivityLabelsClientListRecommendedByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SensitivityLabelsClientListRecommendedByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SensitivityLabelsClientListRecommendedByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendedByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SensitivityLabelsClientListRecommendedByDatabaseResponse page.
func (p *SensitivityLabelsClientListRecommendedByDatabasePager) PageResponse() SensitivityLabelsClientListRecommendedByDatabaseResponse {
	return p.current
}

// ServerAzureADAdministratorsClientListByServerPager provides operations for iterating over paged responses.
type ServerAzureADAdministratorsClientListByServerPager struct {
	client    *ServerAzureADAdministratorsClient
	current   ServerAzureADAdministratorsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerAzureADAdministratorsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerAzureADAdministratorsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerAzureADAdministratorsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AdministratorListResult.NextLink == nil || len(*p.current.AdministratorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerAzureADAdministratorsClientListByServerResponse page.
func (p *ServerAzureADAdministratorsClientListByServerPager) PageResponse() ServerAzureADAdministratorsClientListByServerResponse {
	return p.current
}

// ServerAzureADOnlyAuthenticationsClientListByServerPager provides operations for iterating over paged responses.
type ServerAzureADOnlyAuthenticationsClientListByServerPager struct {
	client    *ServerAzureADOnlyAuthenticationsClient
	current   ServerAzureADOnlyAuthenticationsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerAzureADOnlyAuthenticationsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerAzureADOnlyAuthenticationsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerAzureADOnlyAuthenticationsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureADOnlyAuthListResult.NextLink == nil || len(*p.current.AzureADOnlyAuthListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerAzureADOnlyAuthenticationsClientListByServerResponse page.
func (p *ServerAzureADOnlyAuthenticationsClientListByServerPager) PageResponse() ServerAzureADOnlyAuthenticationsClientListByServerResponse {
	return p.current
}

// ServerBlobAuditingPoliciesClientListByServerPager provides operations for iterating over paged responses.
type ServerBlobAuditingPoliciesClientListByServerPager struct {
	client    *ServerBlobAuditingPoliciesClient
	current   ServerBlobAuditingPoliciesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerBlobAuditingPoliciesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerBlobAuditingPoliciesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerBlobAuditingPoliciesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerBlobAuditingPoliciesClientListByServerResponse page.
func (p *ServerBlobAuditingPoliciesClientListByServerPager) PageResponse() ServerBlobAuditingPoliciesClientListByServerResponse {
	return p.current
}

// ServerConnectionPoliciesClientListByServerPager provides operations for iterating over paged responses.
type ServerConnectionPoliciesClientListByServerPager struct {
	client    *ServerConnectionPoliciesClient
	current   ServerConnectionPoliciesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerConnectionPoliciesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerConnectionPoliciesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerConnectionPoliciesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerConnectionPolicyListResult.NextLink == nil || len(*p.current.ServerConnectionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerConnectionPoliciesClientListByServerResponse page.
func (p *ServerConnectionPoliciesClientListByServerPager) PageResponse() ServerConnectionPoliciesClientListByServerResponse {
	return p.current
}

// ServerDNSAliasesClientListByServerPager provides operations for iterating over paged responses.
type ServerDNSAliasesClientListByServerPager struct {
	client    *ServerDNSAliasesClient
	current   ServerDNSAliasesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerDNSAliasesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerDNSAliasesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerDNSAliasesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerDNSAliasListResult.NextLink == nil || len(*p.current.ServerDNSAliasListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerDNSAliasesClientListByServerResponse page.
func (p *ServerDNSAliasesClientListByServerPager) PageResponse() ServerDNSAliasesClientListByServerResponse {
	return p.current
}

// ServerDevOpsAuditSettingsClientListByServerPager provides operations for iterating over paged responses.
type ServerDevOpsAuditSettingsClientListByServerPager struct {
	client    *ServerDevOpsAuditSettingsClient
	current   ServerDevOpsAuditSettingsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerDevOpsAuditSettingsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerDevOpsAuditSettingsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerDevOpsAuditSettingsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerDevOpsAuditSettingsListResult.NextLink == nil || len(*p.current.ServerDevOpsAuditSettingsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerDevOpsAuditSettingsClientListByServerResponse page.
func (p *ServerDevOpsAuditSettingsClientListByServerPager) PageResponse() ServerDevOpsAuditSettingsClientListByServerResponse {
	return p.current
}

// ServerKeysClientListByServerPager provides operations for iterating over paged responses.
type ServerKeysClientListByServerPager struct {
	client    *ServerKeysClient
	current   ServerKeysClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerKeysClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerKeysClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerKeysClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerKeyListResult.NextLink == nil || len(*p.current.ServerKeyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerKeysClientListByServerResponse page.
func (p *ServerKeysClientListByServerPager) PageResponse() ServerKeysClientListByServerResponse {
	return p.current
}

// ServerOperationsClientListByServerPager provides operations for iterating over paged responses.
type ServerOperationsClientListByServerPager struct {
	client    *ServerOperationsClient
	current   ServerOperationsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerOperationsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerOperationsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerOperationsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerOperationListResult.NextLink == nil || len(*p.current.ServerOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerOperationsClientListByServerResponse page.
func (p *ServerOperationsClientListByServerPager) PageResponse() ServerOperationsClientListByServerResponse {
	return p.current
}

// ServerSecurityAlertPoliciesClientListByServerPager provides operations for iterating over paged responses.
type ServerSecurityAlertPoliciesClientListByServerPager struct {
	client    *ServerSecurityAlertPoliciesClient
	current   ServerSecurityAlertPoliciesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerSecurityAlertPoliciesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerSecurityAlertPoliciesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerSecurityAlertPoliciesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LogicalServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.LogicalServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerSecurityAlertPoliciesClientListByServerResponse page.
func (p *ServerSecurityAlertPoliciesClientListByServerPager) PageResponse() ServerSecurityAlertPoliciesClientListByServerResponse {
	return p.current
}

// ServerTrustGroupsClientListByInstancePager provides operations for iterating over paged responses.
type ServerTrustGroupsClientListByInstancePager struct {
	client    *ServerTrustGroupsClient
	current   ServerTrustGroupsClientListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerTrustGroupsClientListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerTrustGroupsClientListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerTrustGroupsClientListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerTrustGroupListResult.NextLink == nil || len(*p.current.ServerTrustGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerTrustGroupsClientListByInstanceResponse page.
func (p *ServerTrustGroupsClientListByInstancePager) PageResponse() ServerTrustGroupsClientListByInstanceResponse {
	return p.current
}

// ServerTrustGroupsClientListByLocationPager provides operations for iterating over paged responses.
type ServerTrustGroupsClientListByLocationPager struct {
	client    *ServerTrustGroupsClient
	current   ServerTrustGroupsClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerTrustGroupsClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerTrustGroupsClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerTrustGroupsClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerTrustGroupListResult.NextLink == nil || len(*p.current.ServerTrustGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerTrustGroupsClientListByLocationResponse page.
func (p *ServerTrustGroupsClientListByLocationPager) PageResponse() ServerTrustGroupsClientListByLocationResponse {
	return p.current
}

// ServerVulnerabilityAssessmentsClientListByServerPager provides operations for iterating over paged responses.
type ServerVulnerabilityAssessmentsClientListByServerPager struct {
	client    *ServerVulnerabilityAssessmentsClient
	current   ServerVulnerabilityAssessmentsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerVulnerabilityAssessmentsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerVulnerabilityAssessmentsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerVulnerabilityAssessmentsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ServerVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerVulnerabilityAssessmentsClientListByServerResponse page.
func (p *ServerVulnerabilityAssessmentsClientListByServerPager) PageResponse() ServerVulnerabilityAssessmentsClientListByServerResponse {
	return p.current
}

// ServersClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServersClientListByResourceGroupPager struct {
	client    *ServersClient
	current   ServersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerListResult.NextLink == nil || len(*p.current.ServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServersClientListByResourceGroupResponse page.
func (p *ServersClientListByResourceGroupPager) PageResponse() ServersClientListByResourceGroupResponse {
	return p.current
}

// ServersClientListPager provides operations for iterating over paged responses.
type ServersClientListPager struct {
	client    *ServersClient
	current   ServersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerListResult.NextLink == nil || len(*p.current.ServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServersClientListResponse page.
func (p *ServersClientListPager) PageResponse() ServersClientListResponse {
	return p.current
}

// SubscriptionUsagesClientListByLocationPager provides operations for iterating over paged responses.
type SubscriptionUsagesClientListByLocationPager struct {
	client    *SubscriptionUsagesClient
	current   SubscriptionUsagesClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionUsagesClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionUsagesClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionUsagesClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionUsageListResult.NextLink == nil || len(*p.current.SubscriptionUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionUsagesClientListByLocationResponse page.
func (p *SubscriptionUsagesClientListByLocationPager) PageResponse() SubscriptionUsagesClientListByLocationResponse {
	return p.current
}

// SyncAgentsClientListByServerPager provides operations for iterating over paged responses.
type SyncAgentsClientListByServerPager struct {
	client    *SyncAgentsClient
	current   SyncAgentsClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncAgentsClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncAgentsClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncAgentsClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncAgentListResult.NextLink == nil || len(*p.current.SyncAgentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncAgentsClientListByServerResponse page.
func (p *SyncAgentsClientListByServerPager) PageResponse() SyncAgentsClientListByServerResponse {
	return p.current
}

// SyncAgentsClientListLinkedDatabasesPager provides operations for iterating over paged responses.
type SyncAgentsClientListLinkedDatabasesPager struct {
	client    *SyncAgentsClient
	current   SyncAgentsClientListLinkedDatabasesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncAgentsClientListLinkedDatabasesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncAgentsClientListLinkedDatabasesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncAgentsClientListLinkedDatabasesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncAgentLinkedDatabaseListResult.NextLink == nil || len(*p.current.SyncAgentLinkedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listLinkedDatabasesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncAgentsClientListLinkedDatabasesResponse page.
func (p *SyncAgentsClientListLinkedDatabasesPager) PageResponse() SyncAgentsClientListLinkedDatabasesResponse {
	return p.current
}

// SyncGroupsClientListByDatabasePager provides operations for iterating over paged responses.
type SyncGroupsClientListByDatabasePager struct {
	client    *SyncGroupsClient
	current   SyncGroupsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncGroupListResult.NextLink == nil || len(*p.current.SyncGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsClientListByDatabaseResponse page.
func (p *SyncGroupsClientListByDatabasePager) PageResponse() SyncGroupsClientListByDatabaseResponse {
	return p.current
}

// SyncGroupsClientListHubSchemasPager provides operations for iterating over paged responses.
type SyncGroupsClientListHubSchemasPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsClientListHubSchemasResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsClientListHubSchemasResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsClientListHubSchemasPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsClientListHubSchemasPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncFullSchemaPropertiesListResult.NextLink == nil || len(*p.current.SyncFullSchemaPropertiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHubSchemasHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsClientListHubSchemasResponse page.
func (p *SyncGroupsClientListHubSchemasPager) PageResponse() SyncGroupsClientListHubSchemasResponse {
	return p.current
}

// SyncGroupsClientListLogsPager provides operations for iterating over paged responses.
type SyncGroupsClientListLogsPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsClientListLogsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsClientListLogsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsClientListLogsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsClientListLogsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncGroupLogListResult.NextLink == nil || len(*p.current.SyncGroupLogListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listLogsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsClientListLogsResponse page.
func (p *SyncGroupsClientListLogsPager) PageResponse() SyncGroupsClientListLogsResponse {
	return p.current
}

// SyncGroupsClientListSyncDatabaseIDsPager provides operations for iterating over paged responses.
type SyncGroupsClientListSyncDatabaseIDsPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsClientListSyncDatabaseIDsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsClientListSyncDatabaseIDsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsClientListSyncDatabaseIDsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsClientListSyncDatabaseIDsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncDatabaseIDListResult.NextLink == nil || len(*p.current.SyncDatabaseIDListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listSyncDatabaseIDsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsClientListSyncDatabaseIDsResponse page.
func (p *SyncGroupsClientListSyncDatabaseIDsPager) PageResponse() SyncGroupsClientListSyncDatabaseIDsResponse {
	return p.current
}

// SyncMembersClientListBySyncGroupPager provides operations for iterating over paged responses.
type SyncMembersClientListBySyncGroupPager struct {
	client    *SyncMembersClient
	current   SyncMembersClientListBySyncGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncMembersClientListBySyncGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncMembersClientListBySyncGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncMembersClientListBySyncGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncMemberListResult.NextLink == nil || len(*p.current.SyncMemberListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySyncGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncMembersClientListBySyncGroupResponse page.
func (p *SyncMembersClientListBySyncGroupPager) PageResponse() SyncMembersClientListBySyncGroupResponse {
	return p.current
}

// SyncMembersClientListMemberSchemasPager provides operations for iterating over paged responses.
type SyncMembersClientListMemberSchemasPager struct {
	client    *SyncMembersClient
	current   SyncMembersClientListMemberSchemasResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncMembersClientListMemberSchemasResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncMembersClientListMemberSchemasPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncMembersClientListMemberSchemasPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncFullSchemaPropertiesListResult.NextLink == nil || len(*p.current.SyncFullSchemaPropertiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listMemberSchemasHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncMembersClientListMemberSchemasResponse page.
func (p *SyncMembersClientListMemberSchemasPager) PageResponse() SyncMembersClientListMemberSchemasResponse {
	return p.current
}

// TimeZonesClientListByLocationPager provides operations for iterating over paged responses.
type TimeZonesClientListByLocationPager struct {
	client    *TimeZonesClient
	current   TimeZonesClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TimeZonesClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TimeZonesClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TimeZonesClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TimeZoneListResult.NextLink == nil || len(*p.current.TimeZoneListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TimeZonesClientListByLocationResponse page.
func (p *TimeZonesClientListByLocationPager) PageResponse() TimeZonesClientListByLocationResponse {
	return p.current
}

// TransparentDataEncryptionsClientListByDatabasePager provides operations for iterating over paged responses.
type TransparentDataEncryptionsClientListByDatabasePager struct {
	client    *TransparentDataEncryptionsClient
	current   TransparentDataEncryptionsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TransparentDataEncryptionsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TransparentDataEncryptionsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TransparentDataEncryptionsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LogicalDatabaseTransparentDataEncryptionListResult.NextLink == nil || len(*p.current.LogicalDatabaseTransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TransparentDataEncryptionsClientListByDatabaseResponse page.
func (p *TransparentDataEncryptionsClientListByDatabasePager) PageResponse() TransparentDataEncryptionsClientListByDatabaseResponse {
	return p.current
}

// UsagesClientListByInstancePoolPager provides operations for iterating over paged responses.
type UsagesClientListByInstancePoolPager struct {
	client    *UsagesClient
	current   UsagesClientListByInstancePoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsagesClientListByInstancePoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsagesClientListByInstancePoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsagesClientListByInstancePoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageListResult.NextLink == nil || len(*p.current.UsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByInstancePoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsagesClientListByInstancePoolResponse page.
func (p *UsagesClientListByInstancePoolPager) PageResponse() UsagesClientListByInstancePoolResponse {
	return p.current
}

// VirtualClustersClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualClustersClientListByResourceGroupPager struct {
	client    *VirtualClustersClient
	current   VirtualClustersClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualClustersClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualClustersClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualClustersClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualClusterListResult.NextLink == nil || len(*p.current.VirtualClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualClustersClientListByResourceGroupResponse page.
func (p *VirtualClustersClientListByResourceGroupPager) PageResponse() VirtualClustersClientListByResourceGroupResponse {
	return p.current
}

// VirtualClustersClientListPager provides operations for iterating over paged responses.
type VirtualClustersClientListPager struct {
	client    *VirtualClustersClient
	current   VirtualClustersClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualClustersClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualClustersClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualClustersClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualClusterListResult.NextLink == nil || len(*p.current.VirtualClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualClustersClientListResponse page.
func (p *VirtualClustersClientListPager) PageResponse() VirtualClustersClientListResponse {
	return p.current
}

// VirtualNetworkRulesClientListByServerPager provides operations for iterating over paged responses.
type VirtualNetworkRulesClientListByServerPager struct {
	client    *VirtualNetworkRulesClient
	current   VirtualNetworkRulesClientListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkRulesClientListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkRulesClientListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkRulesClientListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkRuleListResult.NextLink == nil || len(*p.current.VirtualNetworkRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkRulesClientListByServerResponse page.
func (p *VirtualNetworkRulesClientListByServerPager) PageResponse() VirtualNetworkRulesClientListByServerResponse {
	return p.current
}

// WorkloadClassifiersClientListByWorkloadGroupPager provides operations for iterating over paged responses.
type WorkloadClassifiersClientListByWorkloadGroupPager struct {
	client    *WorkloadClassifiersClient
	current   WorkloadClassifiersClientListByWorkloadGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadClassifiersClientListByWorkloadGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkloadClassifiersClientListByWorkloadGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkloadClassifiersClientListByWorkloadGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadClassifierListResult.NextLink == nil || len(*p.current.WorkloadClassifierListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkloadGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkloadClassifiersClientListByWorkloadGroupResponse page.
func (p *WorkloadClassifiersClientListByWorkloadGroupPager) PageResponse() WorkloadClassifiersClientListByWorkloadGroupResponse {
	return p.current
}

// WorkloadGroupsClientListByDatabasePager provides operations for iterating over paged responses.
type WorkloadGroupsClientListByDatabasePager struct {
	client    *WorkloadGroupsClient
	current   WorkloadGroupsClientListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadGroupsClientListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkloadGroupsClientListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkloadGroupsClientListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadGroupListResult.NextLink == nil || len(*p.current.WorkloadGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkloadGroupsClientListByDatabaseResponse page.
func (p *WorkloadGroupsClientListByDatabasePager) PageResponse() WorkloadGroupsClientListByDatabaseResponse {
	return p.current
}
