//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// BackupShortTermRetentionPoliciesListByDatabasePager provides operations for iterating over paged responses.
type BackupShortTermRetentionPoliciesListByDatabasePager struct {
	client    *BackupShortTermRetentionPoliciesClient
	current   BackupShortTermRetentionPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupShortTermRetentionPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BackupShortTermRetentionPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BackupShortTermRetentionPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.BackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BackupShortTermRetentionPoliciesListByDatabaseResponse page.
func (p *BackupShortTermRetentionPoliciesListByDatabasePager) PageResponse() BackupShortTermRetentionPoliciesListByDatabaseResponse {
	return p.current
}

// DataWarehouseUserActivitiesListByDatabasePager provides operations for iterating over paged responses.
type DataWarehouseUserActivitiesListByDatabasePager struct {
	client    *DataWarehouseUserActivitiesClient
	current   DataWarehouseUserActivitiesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataWarehouseUserActivitiesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DataWarehouseUserActivitiesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DataWarehouseUserActivitiesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataWarehouseUserActivitiesListResult.NextLink == nil || len(*p.current.DataWarehouseUserActivitiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DataWarehouseUserActivitiesListByDatabaseResponse page.
func (p *DataWarehouseUserActivitiesListByDatabasePager) PageResponse() DataWarehouseUserActivitiesListByDatabaseResponse {
	return p.current
}

// DatabaseBlobAuditingPoliciesListByDatabasePager provides operations for iterating over paged responses.
type DatabaseBlobAuditingPoliciesListByDatabasePager struct {
	client    *DatabaseBlobAuditingPoliciesClient
	current   DatabaseBlobAuditingPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseBlobAuditingPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseBlobAuditingPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseBlobAuditingPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.DatabaseBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseBlobAuditingPoliciesListByDatabaseResponse page.
func (p *DatabaseBlobAuditingPoliciesListByDatabasePager) PageResponse() DatabaseBlobAuditingPoliciesListByDatabaseResponse {
	return p.current
}

// DatabaseColumnsListByDatabasePager provides operations for iterating over paged responses.
type DatabaseColumnsListByDatabasePager struct {
	client    *DatabaseColumnsClient
	current   DatabaseColumnsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseColumnsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseColumnsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseColumnsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseColumnsListByDatabaseResponse page.
func (p *DatabaseColumnsListByDatabasePager) PageResponse() DatabaseColumnsListByDatabaseResponse {
	return p.current
}

// DatabaseColumnsListByTablePager provides operations for iterating over paged responses.
type DatabaseColumnsListByTablePager struct {
	client    *DatabaseColumnsClient
	current   DatabaseColumnsListByTableResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseColumnsListByTableResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseColumnsListByTablePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseColumnsListByTablePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTableHandleError(resp)
		return false
	}
	result, err := p.client.listByTableHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseColumnsListByTableResponse page.
func (p *DatabaseColumnsListByTablePager) PageResponse() DatabaseColumnsListByTableResponse {
	return p.current
}

// DatabaseExtensionsListByDatabasePager provides operations for iterating over paged responses.
type DatabaseExtensionsListByDatabasePager struct {
	client    *DatabaseExtensionsClient
	current   DatabaseExtensionsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseExtensionsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseExtensionsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseExtensionsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImportExportExtensionsOperationListResult.NextLink == nil || len(*p.current.ImportExportExtensionsOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseExtensionsListByDatabaseResponse page.
func (p *DatabaseExtensionsListByDatabasePager) PageResponse() DatabaseExtensionsListByDatabaseResponse {
	return p.current
}

// DatabaseOperationsListByDatabasePager provides operations for iterating over paged responses.
type DatabaseOperationsListByDatabasePager struct {
	client    *DatabaseOperationsClient
	current   DatabaseOperationsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseOperationsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseOperationsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseOperationsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseOperationListResult.NextLink == nil || len(*p.current.DatabaseOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseOperationsListByDatabaseResponse page.
func (p *DatabaseOperationsListByDatabasePager) PageResponse() DatabaseOperationsListByDatabaseResponse {
	return p.current
}

// DatabaseSchemasListByDatabasePager provides operations for iterating over paged responses.
type DatabaseSchemasListByDatabasePager struct {
	client    *DatabaseSchemasClient
	current   DatabaseSchemasListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseSchemasListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseSchemasListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseSchemasListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSchemaListResult.NextLink == nil || len(*p.current.DatabaseSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseSchemasListByDatabaseResponse page.
func (p *DatabaseSchemasListByDatabasePager) PageResponse() DatabaseSchemasListByDatabaseResponse {
	return p.current
}

// DatabaseSecurityAlertPoliciesListByDatabasePager provides operations for iterating over paged responses.
type DatabaseSecurityAlertPoliciesListByDatabasePager struct {
	client    *DatabaseSecurityAlertPoliciesClient
	current   DatabaseSecurityAlertPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseSecurityAlertPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseSecurityAlertPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseSecurityAlertPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSecurityAlertListResult.NextLink == nil || len(*p.current.DatabaseSecurityAlertListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseSecurityAlertPoliciesListByDatabaseResponse page.
func (p *DatabaseSecurityAlertPoliciesListByDatabasePager) PageResponse() DatabaseSecurityAlertPoliciesListByDatabaseResponse {
	return p.current
}

// DatabaseTablesListBySchemaPager provides operations for iterating over paged responses.
type DatabaseTablesListBySchemaPager struct {
	client    *DatabaseTablesClient
	current   DatabaseTablesListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseTablesListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseTablesListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseTablesListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseTableListResult.NextLink == nil || len(*p.current.DatabaseTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySchemaHandleError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseTablesListBySchemaResponse page.
func (p *DatabaseTablesListBySchemaPager) PageResponse() DatabaseTablesListBySchemaResponse {
	return p.current
}

// DatabaseUsagesListByDatabasePager provides operations for iterating over paged responses.
type DatabaseUsagesListByDatabasePager struct {
	client    *DatabaseUsagesClient
	current   DatabaseUsagesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseUsagesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseUsagesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseUsagesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseUsageListResult.NextLink == nil || len(*p.current.DatabaseUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseUsagesListByDatabaseResponse page.
func (p *DatabaseUsagesListByDatabasePager) PageResponse() DatabaseUsagesListByDatabaseResponse {
	return p.current
}

// DatabaseVulnerabilityAssessmentScansListByDatabasePager provides operations for iterating over paged responses.
type DatabaseVulnerabilityAssessmentScansListByDatabasePager struct {
	client    *DatabaseVulnerabilityAssessmentScansClient
	current   DatabaseVulnerabilityAssessmentScansListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseVulnerabilityAssessmentScansListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseVulnerabilityAssessmentScansListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseVulnerabilityAssessmentScansListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseVulnerabilityAssessmentScansListByDatabaseResponse page.
func (p *DatabaseVulnerabilityAssessmentScansListByDatabasePager) PageResponse() DatabaseVulnerabilityAssessmentScansListByDatabaseResponse {
	return p.current
}

// DatabaseVulnerabilityAssessmentsListByDatabasePager provides operations for iterating over paged responses.
type DatabaseVulnerabilityAssessmentsListByDatabasePager struct {
	client    *DatabaseVulnerabilityAssessmentsClient
	current   DatabaseVulnerabilityAssessmentsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabaseVulnerabilityAssessmentsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabaseVulnerabilityAssessmentsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabaseVulnerabilityAssessmentsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.DatabaseVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabaseVulnerabilityAssessmentsListByDatabaseResponse page.
func (p *DatabaseVulnerabilityAssessmentsListByDatabasePager) PageResponse() DatabaseVulnerabilityAssessmentsListByDatabaseResponse {
	return p.current
}

// DatabasesListByElasticPoolPager provides operations for iterating over paged responses.
type DatabasesListByElasticPoolPager struct {
	client    *DatabasesClient
	current   DatabasesListByElasticPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesListByElasticPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesListByElasticPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesListByElasticPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByElasticPoolHandleError(resp)
		return false
	}
	result, err := p.client.listByElasticPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesListByElasticPoolResponse page.
func (p *DatabasesListByElasticPoolPager) PageResponse() DatabasesListByElasticPoolResponse {
	return p.current
}

// DatabasesListByServerPager provides operations for iterating over paged responses.
type DatabasesListByServerPager struct {
	client    *DatabasesClient
	current   DatabasesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesListByServerResponse page.
func (p *DatabasesListByServerPager) PageResponse() DatabasesListByServerResponse {
	return p.current
}

// DatabasesListInaccessibleByServerPager provides operations for iterating over paged responses.
type DatabasesListInaccessibleByServerPager struct {
	client    *DatabasesClient
	current   DatabasesListInaccessibleByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatabasesListInaccessibleByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DatabasesListInaccessibleByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DatabasesListInaccessibleByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseListResult.NextLink == nil || len(*p.current.DatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listInaccessibleByServerHandleError(resp)
		return false
	}
	result, err := p.client.listInaccessibleByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DatabasesListInaccessibleByServerResponse page.
func (p *DatabasesListInaccessibleByServerPager) PageResponse() DatabasesListInaccessibleByServerResponse {
	return p.current
}

// DeletedServersListByLocationPager provides operations for iterating over paged responses.
type DeletedServersListByLocationPager struct {
	client    *DeletedServersClient
	current   DeletedServersListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServersListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServersListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServersListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServerListResult.NextLink == nil || len(*p.current.DeletedServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServersListByLocationResponse page.
func (p *DeletedServersListByLocationPager) PageResponse() DeletedServersListByLocationResponse {
	return p.current
}

// DeletedServersListPager provides operations for iterating over paged responses.
type DeletedServersListPager struct {
	client    *DeletedServersClient
	current   DeletedServersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DeletedServersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DeletedServersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServerListResult.NextLink == nil || len(*p.current.DeletedServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DeletedServersListResponse page.
func (p *DeletedServersListPager) PageResponse() DeletedServersListResponse {
	return p.current
}

// ElasticPoolOperationsListByElasticPoolPager provides operations for iterating over paged responses.
type ElasticPoolOperationsListByElasticPoolPager struct {
	client    *ElasticPoolOperationsClient
	current   ElasticPoolOperationsListByElasticPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ElasticPoolOperationsListByElasticPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ElasticPoolOperationsListByElasticPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ElasticPoolOperationsListByElasticPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ElasticPoolOperationListResult.NextLink == nil || len(*p.current.ElasticPoolOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByElasticPoolHandleError(resp)
		return false
	}
	result, err := p.client.listByElasticPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ElasticPoolOperationsListByElasticPoolResponse page.
func (p *ElasticPoolOperationsListByElasticPoolPager) PageResponse() ElasticPoolOperationsListByElasticPoolResponse {
	return p.current
}

// ElasticPoolsListByServerPager provides operations for iterating over paged responses.
type ElasticPoolsListByServerPager struct {
	client    *ElasticPoolsClient
	current   ElasticPoolsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ElasticPoolsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ElasticPoolsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ElasticPoolsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ElasticPoolListResult.NextLink == nil || len(*p.current.ElasticPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ElasticPoolsListByServerResponse page.
func (p *ElasticPoolsListByServerPager) PageResponse() ElasticPoolsListByServerResponse {
	return p.current
}

// EncryptionProtectorsListByServerPager provides operations for iterating over paged responses.
type EncryptionProtectorsListByServerPager struct {
	client    *EncryptionProtectorsClient
	current   EncryptionProtectorsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EncryptionProtectorsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *EncryptionProtectorsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *EncryptionProtectorsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EncryptionProtectorListResult.NextLink == nil || len(*p.current.EncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current EncryptionProtectorsListByServerResponse page.
func (p *EncryptionProtectorsListByServerPager) PageResponse() EncryptionProtectorsListByServerResponse {
	return p.current
}

// ExtendedDatabaseBlobAuditingPoliciesListByDatabasePager provides operations for iterating over paged responses.
type ExtendedDatabaseBlobAuditingPoliciesListByDatabasePager struct {
	client    *ExtendedDatabaseBlobAuditingPoliciesClient
	current   ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedDatabaseBlobAuditingPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedDatabaseBlobAuditingPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedDatabaseBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedDatabaseBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse page.
func (p *ExtendedDatabaseBlobAuditingPoliciesListByDatabasePager) PageResponse() ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse {
	return p.current
}

// ExtendedServerBlobAuditingPoliciesListByServerPager provides operations for iterating over paged responses.
type ExtendedServerBlobAuditingPoliciesListByServerPager struct {
	client    *ExtendedServerBlobAuditingPoliciesClient
	current   ExtendedServerBlobAuditingPoliciesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedServerBlobAuditingPoliciesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedServerBlobAuditingPoliciesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedServerBlobAuditingPoliciesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedServerBlobAuditingPoliciesListByServerResponse page.
func (p *ExtendedServerBlobAuditingPoliciesListByServerPager) PageResponse() ExtendedServerBlobAuditingPoliciesListByServerResponse {
	return p.current
}

// FailoverGroupsListByServerPager provides operations for iterating over paged responses.
type FailoverGroupsListByServerPager struct {
	client    *FailoverGroupsClient
	current   FailoverGroupsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FailoverGroupsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FailoverGroupsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FailoverGroupsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FailoverGroupListResult.NextLink == nil || len(*p.current.FailoverGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FailoverGroupsListByServerResponse page.
func (p *FailoverGroupsListByServerPager) PageResponse() FailoverGroupsListByServerResponse {
	return p.current
}

// FirewallRulesListByServerPager provides operations for iterating over paged responses.
type FirewallRulesListByServerPager struct {
	client    *FirewallRulesClient
	current   FirewallRulesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallRulesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FirewallRulesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FirewallRulesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallRuleListResult.NextLink == nil || len(*p.current.FirewallRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FirewallRulesListByServerResponse page.
func (p *FirewallRulesListByServerPager) PageResponse() FirewallRulesListByServerResponse {
	return p.current
}

// InstanceFailoverGroupsListByLocationPager provides operations for iterating over paged responses.
type InstanceFailoverGroupsListByLocationPager struct {
	client    *InstanceFailoverGroupsClient
	current   InstanceFailoverGroupsListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstanceFailoverGroupsListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstanceFailoverGroupsListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstanceFailoverGroupsListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstanceFailoverGroupListResult.NextLink == nil || len(*p.current.InstanceFailoverGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstanceFailoverGroupsListByLocationResponse page.
func (p *InstanceFailoverGroupsListByLocationPager) PageResponse() InstanceFailoverGroupsListByLocationResponse {
	return p.current
}

// InstancePoolsListByResourceGroupPager provides operations for iterating over paged responses.
type InstancePoolsListByResourceGroupPager struct {
	client    *InstancePoolsClient
	current   InstancePoolsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstancePoolsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstancePoolsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstancePoolsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstancePoolListResult.NextLink == nil || len(*p.current.InstancePoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstancePoolsListByResourceGroupResponse page.
func (p *InstancePoolsListByResourceGroupPager) PageResponse() InstancePoolsListByResourceGroupResponse {
	return p.current
}

// InstancePoolsListPager provides operations for iterating over paged responses.
type InstancePoolsListPager struct {
	client    *InstancePoolsClient
	current   InstancePoolsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstancePoolsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InstancePoolsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InstancePoolsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstancePoolListResult.NextLink == nil || len(*p.current.InstancePoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InstancePoolsListResponse page.
func (p *InstancePoolsListPager) PageResponse() InstancePoolsListResponse {
	return p.current
}

// JobAgentsListByServerPager provides operations for iterating over paged responses.
type JobAgentsListByServerPager struct {
	client    *JobAgentsClient
	current   JobAgentsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobAgentsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobAgentsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobAgentsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobAgentListResult.NextLink == nil || len(*p.current.JobAgentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobAgentsListByServerResponse page.
func (p *JobAgentsListByServerPager) PageResponse() JobAgentsListByServerResponse {
	return p.current
}

// JobCredentialsListByAgentPager provides operations for iterating over paged responses.
type JobCredentialsListByAgentPager struct {
	client    *JobCredentialsClient
	current   JobCredentialsListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobCredentialsListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobCredentialsListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobCredentialsListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobCredentialListResult.NextLink == nil || len(*p.current.JobCredentialListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAgentHandleError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobCredentialsListByAgentResponse page.
func (p *JobCredentialsListByAgentPager) PageResponse() JobCredentialsListByAgentResponse {
	return p.current
}

// JobExecutionsListByAgentPager provides operations for iterating over paged responses.
type JobExecutionsListByAgentPager struct {
	client    *JobExecutionsClient
	current   JobExecutionsListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobExecutionsListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobExecutionsListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobExecutionsListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAgentHandleError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobExecutionsListByAgentResponse page.
func (p *JobExecutionsListByAgentPager) PageResponse() JobExecutionsListByAgentResponse {
	return p.current
}

// JobExecutionsListByJobPager provides operations for iterating over paged responses.
type JobExecutionsListByJobPager struct {
	client    *JobExecutionsClient
	current   JobExecutionsListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobExecutionsListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobExecutionsListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobExecutionsListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobHandleError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobExecutionsListByJobResponse page.
func (p *JobExecutionsListByJobPager) PageResponse() JobExecutionsListByJobResponse {
	return p.current
}

// JobStepExecutionsListByJobExecutionPager provides operations for iterating over paged responses.
type JobStepExecutionsListByJobExecutionPager struct {
	client    *JobStepExecutionsClient
	current   JobStepExecutionsListByJobExecutionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepExecutionsListByJobExecutionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepExecutionsListByJobExecutionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepExecutionsListByJobExecutionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobExecutionHandleError(resp)
		return false
	}
	result, err := p.client.listByJobExecutionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepExecutionsListByJobExecutionResponse page.
func (p *JobStepExecutionsListByJobExecutionPager) PageResponse() JobStepExecutionsListByJobExecutionResponse {
	return p.current
}

// JobStepsListByJobPager provides operations for iterating over paged responses.
type JobStepsListByJobPager struct {
	client    *JobStepsClient
	current   JobStepsListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepsListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepsListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepsListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStepListResult.NextLink == nil || len(*p.current.JobStepListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobHandleError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepsListByJobResponse page.
func (p *JobStepsListByJobPager) PageResponse() JobStepsListByJobResponse {
	return p.current
}

// JobStepsListByVersionPager provides operations for iterating over paged responses.
type JobStepsListByVersionPager struct {
	client    *JobStepsClient
	current   JobStepsListByVersionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobStepsListByVersionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobStepsListByVersionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobStepsListByVersionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobStepListResult.NextLink == nil || len(*p.current.JobStepListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByVersionHandleError(resp)
		return false
	}
	result, err := p.client.listByVersionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobStepsListByVersionResponse page.
func (p *JobStepsListByVersionPager) PageResponse() JobStepsListByVersionResponse {
	return p.current
}

// JobTargetExecutionsListByJobExecutionPager provides operations for iterating over paged responses.
type JobTargetExecutionsListByJobExecutionPager struct {
	client    *JobTargetExecutionsClient
	current   JobTargetExecutionsListByJobExecutionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetExecutionsListByJobExecutionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetExecutionsListByJobExecutionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetExecutionsListByJobExecutionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobExecutionHandleError(resp)
		return false
	}
	result, err := p.client.listByJobExecutionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetExecutionsListByJobExecutionResponse page.
func (p *JobTargetExecutionsListByJobExecutionPager) PageResponse() JobTargetExecutionsListByJobExecutionResponse {
	return p.current
}

// JobTargetExecutionsListByStepPager provides operations for iterating over paged responses.
type JobTargetExecutionsListByStepPager struct {
	client    *JobTargetExecutionsClient
	current   JobTargetExecutionsListByStepResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetExecutionsListByStepResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetExecutionsListByStepPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetExecutionsListByStepPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobExecutionListResult.NextLink == nil || len(*p.current.JobExecutionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByStepHandleError(resp)
		return false
	}
	result, err := p.client.listByStepHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetExecutionsListByStepResponse page.
func (p *JobTargetExecutionsListByStepPager) PageResponse() JobTargetExecutionsListByStepResponse {
	return p.current
}

// JobTargetGroupsListByAgentPager provides operations for iterating over paged responses.
type JobTargetGroupsListByAgentPager struct {
	client    *JobTargetGroupsClient
	current   JobTargetGroupsListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobTargetGroupsListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobTargetGroupsListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobTargetGroupsListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobTargetGroupListResult.NextLink == nil || len(*p.current.JobTargetGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAgentHandleError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobTargetGroupsListByAgentResponse page.
func (p *JobTargetGroupsListByAgentPager) PageResponse() JobTargetGroupsListByAgentResponse {
	return p.current
}

// JobVersionsListByJobPager provides operations for iterating over paged responses.
type JobVersionsListByJobPager struct {
	client    *JobVersionsClient
	current   JobVersionsListByJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobVersionsListByJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobVersionsListByJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobVersionsListByJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobVersionListResult.NextLink == nil || len(*p.current.JobVersionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByJobHandleError(resp)
		return false
	}
	result, err := p.client.listByJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobVersionsListByJobResponse page.
func (p *JobVersionsListByJobPager) PageResponse() JobVersionsListByJobResponse {
	return p.current
}

// JobsListByAgentPager provides operations for iterating over paged responses.
type JobsListByAgentPager struct {
	client    *JobsClient
	current   JobsListByAgentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsListByAgentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *JobsListByAgentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *JobsListByAgentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobListResult.NextLink == nil || len(*p.current.JobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByAgentHandleError(resp)
		return false
	}
	result, err := p.client.listByAgentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current JobsListByAgentResponse page.
func (p *JobsListByAgentPager) PageResponse() JobsListByAgentResponse {
	return p.current
}

// LedgerDigestUploadsListByDatabasePager provides operations for iterating over paged responses.
type LedgerDigestUploadsListByDatabasePager struct {
	client    *LedgerDigestUploadsClient
	current   LedgerDigestUploadsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LedgerDigestUploadsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LedgerDigestUploadsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LedgerDigestUploadsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LedgerDigestUploadsListResult.NextLink == nil || len(*p.current.LedgerDigestUploadsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LedgerDigestUploadsListByDatabaseResponse page.
func (p *LedgerDigestUploadsListByDatabasePager) PageResponse() LedgerDigestUploadsListByDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByDatabasePager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByDatabaseResponse page.
func (p *LongTermRetentionBackupsListByDatabasePager) PageResponse() LongTermRetentionBackupsListByDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsListByLocationPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByLocationPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByLocationResponse page.
func (p *LongTermRetentionBackupsListByLocationPager) PageResponse() LongTermRetentionBackupsListByLocationResponse {
	return p.current
}

// LongTermRetentionBackupsListByResourceGroupDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByResourceGroupDatabasePager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByResourceGroupDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByResourceGroupDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByResourceGroupDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByResourceGroupDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByResourceGroupDatabaseResponse page.
func (p *LongTermRetentionBackupsListByResourceGroupDatabasePager) PageResponse() LongTermRetentionBackupsListByResourceGroupDatabaseResponse {
	return p.current
}

// LongTermRetentionBackupsListByResourceGroupLocationPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByResourceGroupLocationPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByResourceGroupLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByResourceGroupLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByResourceGroupLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByResourceGroupLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByResourceGroupLocationResponse page.
func (p *LongTermRetentionBackupsListByResourceGroupLocationPager) PageResponse() LongTermRetentionBackupsListByResourceGroupLocationResponse {
	return p.current
}

// LongTermRetentionBackupsListByResourceGroupServerPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByResourceGroupServerPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByResourceGroupServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByResourceGroupServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByResourceGroupServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByResourceGroupServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupServerHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByResourceGroupServerResponse page.
func (p *LongTermRetentionBackupsListByResourceGroupServerPager) PageResponse() LongTermRetentionBackupsListByResourceGroupServerResponse {
	return p.current
}

// LongTermRetentionBackupsListByServerPager provides operations for iterating over paged responses.
type LongTermRetentionBackupsListByServerPager struct {
	client    *LongTermRetentionBackupsClient
	current   LongTermRetentionBackupsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionBackupsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionBackupsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionBackupsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionBackupListResult.NextLink == nil || len(*p.current.LongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionBackupsListByServerResponse page.
func (p *LongTermRetentionBackupsListByServerPager) PageResponse() LongTermRetentionBackupsListByServerResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByDatabasePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByDatabaseResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByDatabasePager) PageResponse() LongTermRetentionManagedInstanceBackupsListByDatabaseResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByInstancePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByInstancePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByInstanceResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByInstancePager) PageResponse() LongTermRetentionManagedInstanceBackupsListByInstanceResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByLocationPager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByLocationPager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByLocationResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByLocationPager) PageResponse() LongTermRetentionManagedInstanceBackupsListByLocationResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabasePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabasePager) PageResponse() LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupInstancePager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupInstancePager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupInstancePager) PageResponse() LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse {
	return p.current
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationPager provides operations for iterating over paged responses.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationPager struct {
	client    *LongTermRetentionManagedInstanceBackupsClient
	current   LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionBackupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse page.
func (p *LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationPager) PageResponse() LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse {
	return p.current
}

// LongTermRetentionPoliciesListByDatabasePager provides operations for iterating over paged responses.
type LongTermRetentionPoliciesListByDatabasePager struct {
	client    *LongTermRetentionPoliciesClient
	current   LongTermRetentionPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LongTermRetentionPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LongTermRetentionPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LongTermRetentionPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LongTermRetentionPolicyListResult.NextLink == nil || len(*p.current.LongTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LongTermRetentionPoliciesListByDatabaseResponse page.
func (p *LongTermRetentionPoliciesListByDatabasePager) PageResponse() LongTermRetentionPoliciesListByDatabaseResponse {
	return p.current
}

// ManagedBackupShortTermRetentionPoliciesListByDatabasePager provides operations for iterating over paged responses.
type ManagedBackupShortTermRetentionPoliciesListByDatabasePager struct {
	client    *ManagedBackupShortTermRetentionPoliciesClient
	current   ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedBackupShortTermRetentionPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedBackupShortTermRetentionPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse page.
func (p *ManagedBackupShortTermRetentionPoliciesListByDatabasePager) PageResponse() ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseColumnsListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseColumnsListByDatabasePager struct {
	client    *ManagedDatabaseColumnsClient
	current   ManagedDatabaseColumnsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseColumnsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseColumnsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseColumnsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseColumnsListByDatabaseResponse page.
func (p *ManagedDatabaseColumnsListByDatabasePager) PageResponse() ManagedDatabaseColumnsListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseColumnsListByTablePager provides operations for iterating over paged responses.
type ManagedDatabaseColumnsListByTablePager struct {
	client    *ManagedDatabaseColumnsClient
	current   ManagedDatabaseColumnsListByTableResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseColumnsListByTableResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseColumnsListByTablePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseColumnsListByTablePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseColumnListResult.NextLink == nil || len(*p.current.DatabaseColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTableHandleError(resp)
		return false
	}
	result, err := p.client.listByTableHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseColumnsListByTableResponse page.
func (p *ManagedDatabaseColumnsListByTablePager) PageResponse() ManagedDatabaseColumnsListByTableResponse {
	return p.current
}

// ManagedDatabaseQueriesListByQueryPager provides operations for iterating over paged responses.
type ManagedDatabaseQueriesListByQueryPager struct {
	client    *ManagedDatabaseQueriesClient
	current   ManagedDatabaseQueriesListByQueryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseQueriesListByQueryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseQueriesListByQueryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseQueriesListByQueryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceQueryStatistics.NextLink == nil || len(*p.current.ManagedInstanceQueryStatistics.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByQueryHandleError(resp)
		return false
	}
	result, err := p.client.listByQueryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseQueriesListByQueryResponse page.
func (p *ManagedDatabaseQueriesListByQueryPager) PageResponse() ManagedDatabaseQueriesListByQueryResponse {
	return p.current
}

// ManagedDatabaseSchemasListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSchemasListByDatabasePager struct {
	client    *ManagedDatabaseSchemasClient
	current   ManagedDatabaseSchemasListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSchemasListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSchemasListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSchemasListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseSchemaListResult.NextLink == nil || len(*p.current.DatabaseSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSchemasListByDatabaseResponse page.
func (p *ManagedDatabaseSchemasListByDatabasePager) PageResponse() ManagedDatabaseSchemasListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSecurityAlertPoliciesListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSecurityAlertPoliciesListByDatabasePager struct {
	client    *ManagedDatabaseSecurityAlertPoliciesClient
	current   ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSecurityAlertPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSecurityAlertPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ManagedDatabaseSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse page.
func (p *ManagedDatabaseSecurityAlertPoliciesListByDatabasePager) PageResponse() ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSecurityEventsListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSecurityEventsListByDatabasePager struct {
	client    *ManagedDatabaseSecurityEventsClient
	current   ManagedDatabaseSecurityEventsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSecurityEventsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSecurityEventsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSecurityEventsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityEventCollection.NextLink == nil || len(*p.current.SecurityEventCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSecurityEventsListByDatabaseResponse page.
func (p *ManagedDatabaseSecurityEventsListByDatabasePager) PageResponse() ManagedDatabaseSecurityEventsListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSensitivityLabelsListCurrentByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSensitivityLabelsListCurrentByDatabasePager struct {
	client    *ManagedDatabaseSensitivityLabelsClient
	current   ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSensitivityLabelsListCurrentByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSensitivityLabelsListCurrentByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCurrentByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listCurrentByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse page.
func (p *ManagedDatabaseSensitivityLabelsListCurrentByDatabasePager) PageResponse() ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse {
	return p.current
}

// ManagedDatabaseSensitivityLabelsListRecommendedByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseSensitivityLabelsListRecommendedByDatabasePager struct {
	client    *ManagedDatabaseSensitivityLabelsClient
	current   ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseSensitivityLabelsListRecommendedByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseSensitivityLabelsListRecommendedByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listRecommendedByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listRecommendedByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse page.
func (p *ManagedDatabaseSensitivityLabelsListRecommendedByDatabasePager) PageResponse() ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse {
	return p.current
}

// ManagedDatabaseTablesListBySchemaPager provides operations for iterating over paged responses.
type ManagedDatabaseTablesListBySchemaPager struct {
	client    *ManagedDatabaseTablesClient
	current   ManagedDatabaseTablesListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseTablesListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseTablesListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseTablesListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseTableListResult.NextLink == nil || len(*p.current.DatabaseTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySchemaHandleError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseTablesListBySchemaResponse page.
func (p *ManagedDatabaseTablesListBySchemaPager) PageResponse() ManagedDatabaseTablesListBySchemaResponse {
	return p.current
}

// ManagedDatabaseTransparentDataEncryptionListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseTransparentDataEncryptionListByDatabasePager struct {
	client    *ManagedDatabaseTransparentDataEncryptionClient
	current   ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseTransparentDataEncryptionListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseTransparentDataEncryptionListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedTransparentDataEncryptionListResult.NextLink == nil || len(*p.current.ManagedTransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse page.
func (p *ManagedDatabaseTransparentDataEncryptionListByDatabasePager) PageResponse() ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseVulnerabilityAssessmentScansListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseVulnerabilityAssessmentScansListByDatabasePager struct {
	client    *ManagedDatabaseVulnerabilityAssessmentScansClient
	current   ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseVulnerabilityAssessmentScansListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseVulnerabilityAssessmentScansListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse page.
func (p *ManagedDatabaseVulnerabilityAssessmentScansListByDatabasePager) PageResponse() ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse {
	return p.current
}

// ManagedDatabaseVulnerabilityAssessmentsListByDatabasePager provides operations for iterating over paged responses.
type ManagedDatabaseVulnerabilityAssessmentsListByDatabasePager struct {
	client    *ManagedDatabaseVulnerabilityAssessmentsClient
	current   ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabaseVulnerabilityAssessmentsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabaseVulnerabilityAssessmentsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatabaseVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.DatabaseVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse page.
func (p *ManagedDatabaseVulnerabilityAssessmentsListByDatabasePager) PageResponse() ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse {
	return p.current
}

// ManagedDatabasesListByInstancePager provides operations for iterating over paged responses.
type ManagedDatabasesListByInstancePager struct {
	client    *ManagedDatabasesClient
	current   ManagedDatabasesListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabasesListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabasesListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabasesListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseListResult.NextLink == nil || len(*p.current.ManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabasesListByInstanceResponse page.
func (p *ManagedDatabasesListByInstancePager) PageResponse() ManagedDatabasesListByInstanceResponse {
	return p.current
}

// ManagedDatabasesListInaccessibleByInstancePager provides operations for iterating over paged responses.
type ManagedDatabasesListInaccessibleByInstancePager struct {
	client    *ManagedDatabasesClient
	current   ManagedDatabasesListInaccessibleByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedDatabasesListInaccessibleByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedDatabasesListInaccessibleByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedDatabasesListInaccessibleByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedDatabaseListResult.NextLink == nil || len(*p.current.ManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listInaccessibleByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listInaccessibleByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedDatabasesListInaccessibleByInstanceResponse page.
func (p *ManagedDatabasesListInaccessibleByInstancePager) PageResponse() ManagedDatabasesListInaccessibleByInstanceResponse {
	return p.current
}

// ManagedInstanceAdministratorsListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceAdministratorsListByInstancePager struct {
	client    *ManagedInstanceAdministratorsClient
	current   ManagedInstanceAdministratorsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceAdministratorsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceAdministratorsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceAdministratorsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceAdministratorListResult.NextLink == nil || len(*p.current.ManagedInstanceAdministratorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceAdministratorsListByInstanceResponse page.
func (p *ManagedInstanceAdministratorsListByInstancePager) PageResponse() ManagedInstanceAdministratorsListByInstanceResponse {
	return p.current
}

// ManagedInstanceAzureADOnlyAuthenticationsListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceAzureADOnlyAuthenticationsListByInstancePager struct {
	client    *ManagedInstanceAzureADOnlyAuthenticationsClient
	current   ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceAzureADOnlyAuthenticationsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceAzureADOnlyAuthenticationsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceAzureADOnlyAuthListResult.NextLink == nil || len(*p.current.ManagedInstanceAzureADOnlyAuthListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse page.
func (p *ManagedInstanceAzureADOnlyAuthenticationsListByInstancePager) PageResponse() ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse {
	return p.current
}

// ManagedInstanceEncryptionProtectorsListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceEncryptionProtectorsListByInstancePager struct {
	client    *ManagedInstanceEncryptionProtectorsClient
	current   ManagedInstanceEncryptionProtectorsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceEncryptionProtectorsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceEncryptionProtectorsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceEncryptionProtectorsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceEncryptionProtectorListResult.NextLink == nil || len(*p.current.ManagedInstanceEncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceEncryptionProtectorsListByInstanceResponse page.
func (p *ManagedInstanceEncryptionProtectorsListByInstancePager) PageResponse() ManagedInstanceEncryptionProtectorsListByInstanceResponse {
	return p.current
}

// ManagedInstanceKeysListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceKeysListByInstancePager struct {
	client    *ManagedInstanceKeysClient
	current   ManagedInstanceKeysListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceKeysListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceKeysListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceKeysListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceKeyListResult.NextLink == nil || len(*p.current.ManagedInstanceKeyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceKeysListByInstanceResponse page.
func (p *ManagedInstanceKeysListByInstancePager) PageResponse() ManagedInstanceKeysListByInstanceResponse {
	return p.current
}

// ManagedInstanceLongTermRetentionPoliciesListByDatabasePager provides operations for iterating over paged responses.
type ManagedInstanceLongTermRetentionPoliciesListByDatabasePager struct {
	client    *ManagedInstanceLongTermRetentionPoliciesClient
	current   ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceLongTermRetentionPoliciesListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceLongTermRetentionPoliciesListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceLongTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedInstanceLongTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse page.
func (p *ManagedInstanceLongTermRetentionPoliciesListByDatabasePager) PageResponse() ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse {
	return p.current
}

// ManagedInstanceOperationsListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstanceOperationsListByManagedInstancePager struct {
	client    *ManagedInstanceOperationsClient
	current   ManagedInstanceOperationsListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceOperationsListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceOperationsListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceOperationsListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceOperationListResult.NextLink == nil || len(*p.current.ManagedInstanceOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByManagedInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceOperationsListByManagedInstanceResponse page.
func (p *ManagedInstanceOperationsListByManagedInstancePager) PageResponse() ManagedInstanceOperationsListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancePrivateEndpointConnectionsListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancePrivateEndpointConnectionsListByManagedInstancePager struct {
	client    *ManagedInstancePrivateEndpointConnectionsClient
	current   ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancePrivateEndpointConnectionsListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancePrivateEndpointConnectionsListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstancePrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.ManagedInstancePrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByManagedInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse page.
func (p *ManagedInstancePrivateEndpointConnectionsListByManagedInstancePager) PageResponse() ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancePrivateLinkResourcesListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancePrivateLinkResourcesListByManagedInstancePager struct {
	client    *ManagedInstancePrivateLinkResourcesClient
	current   ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancePrivateLinkResourcesListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancePrivateLinkResourcesListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstancePrivateLinkListResult.NextLink == nil || len(*p.current.ManagedInstancePrivateLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByManagedInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse page.
func (p *ManagedInstancePrivateLinkResourcesListByManagedInstancePager) PageResponse() ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse {
	return p.current
}

// ManagedInstanceVulnerabilityAssessmentsListByInstancePager provides operations for iterating over paged responses.
type ManagedInstanceVulnerabilityAssessmentsListByInstancePager struct {
	client    *ManagedInstanceVulnerabilityAssessmentsClient
	current   ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstanceVulnerabilityAssessmentsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstanceVulnerabilityAssessmentsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ManagedInstanceVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse page.
func (p *ManagedInstanceVulnerabilityAssessmentsListByInstancePager) PageResponse() ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse {
	return p.current
}

// ManagedInstancesListByInstancePoolPager provides operations for iterating over paged responses.
type ManagedInstancesListByInstancePoolPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesListByInstancePoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesListByInstancePoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesListByInstancePoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesListByInstancePoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstancePoolHandleError(resp)
		return false
	}
	result, err := p.client.listByInstancePoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesListByInstancePoolResponse page.
func (p *ManagedInstancesListByInstancePoolPager) PageResponse() ManagedInstancesListByInstancePoolResponse {
	return p.current
}

// ManagedInstancesListByManagedInstancePager provides operations for iterating over paged responses.
type ManagedInstancesListByManagedInstancePager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesListByManagedInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesListByManagedInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesListByManagedInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesListByManagedInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopQueriesListResult.NextLink == nil || len(*p.current.TopQueriesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByManagedInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByManagedInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesListByManagedInstanceResponse page.
func (p *ManagedInstancesListByManagedInstancePager) PageResponse() ManagedInstancesListByManagedInstanceResponse {
	return p.current
}

// ManagedInstancesListByResourceGroupPager provides operations for iterating over paged responses.
type ManagedInstancesListByResourceGroupPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesListByResourceGroupResponse page.
func (p *ManagedInstancesListByResourceGroupPager) PageResponse() ManagedInstancesListByResourceGroupResponse {
	return p.current
}

// ManagedInstancesListPager provides operations for iterating over paged responses.
type ManagedInstancesListPager struct {
	client    *ManagedInstancesClient
	current   ManagedInstancesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedInstancesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedInstancesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedInstancesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedInstanceListResult.NextLink == nil || len(*p.current.ManagedInstanceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedInstancesListResponse page.
func (p *ManagedInstancesListPager) PageResponse() ManagedInstancesListResponse {
	return p.current
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabasePager provides operations for iterating over paged responses.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabasePager struct {
	client    *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient
	current   ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink == nil || len(*p.current.ManagedBackupShortTermRetentionPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRestorableDroppedDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByRestorableDroppedDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse page.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabasePager) PageResponse() ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse {
	return p.current
}

// ManagedServerSecurityAlertPoliciesListByInstancePager provides operations for iterating over paged responses.
type ManagedServerSecurityAlertPoliciesListByInstancePager struct {
	client    *ManagedServerSecurityAlertPoliciesClient
	current   ManagedServerSecurityAlertPoliciesListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedServerSecurityAlertPoliciesListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ManagedServerSecurityAlertPoliciesListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ManagedServerSecurityAlertPoliciesListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ManagedServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ManagedServerSecurityAlertPoliciesListByInstanceResponse page.
func (p *ManagedServerSecurityAlertPoliciesListByInstancePager) PageResponse() ManagedServerSecurityAlertPoliciesListByInstanceResponse {
	return p.current
}

// OperationsHealthListByLocationPager provides operations for iterating over paged responses.
type OperationsHealthListByLocationPager struct {
	client    *OperationsHealthClient
	current   OperationsHealthListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsHealthListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsHealthListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsHealthListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationsHealthListResult.NextLink == nil || len(*p.current.OperationsHealthListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsHealthListByLocationResponse page.
func (p *OperationsHealthListByLocationPager) PageResponse() OperationsHealthListByLocationResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// OutboundFirewallRulesListByServerPager provides operations for iterating over paged responses.
type OutboundFirewallRulesListByServerPager struct {
	client    *OutboundFirewallRulesClient
	current   OutboundFirewallRulesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OutboundFirewallRulesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OutboundFirewallRulesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OutboundFirewallRulesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OutboundFirewallRuleListResult.NextLink == nil || len(*p.current.OutboundFirewallRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OutboundFirewallRulesListByServerResponse page.
func (p *OutboundFirewallRulesListByServerPager) PageResponse() OutboundFirewallRulesListByServerResponse {
	return p.current
}

// PrivateEndpointConnectionsListByServerPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsListByServerPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsListByServerResponse page.
func (p *PrivateEndpointConnectionsListByServerPager) PageResponse() PrivateEndpointConnectionsListByServerResponse {
	return p.current
}

// PrivateLinkResourcesListByServerPager provides operations for iterating over paged responses.
type PrivateLinkResourcesListByServerPager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkResourcesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkResourcesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkResourcesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkResourcesListByServerResponse page.
func (p *PrivateLinkResourcesListByServerPager) PageResponse() PrivateLinkResourcesListByServerResponse {
	return p.current
}

// RecoverableManagedDatabasesListByInstancePager provides operations for iterating over paged responses.
type RecoverableManagedDatabasesListByInstancePager struct {
	client    *RecoverableManagedDatabasesClient
	current   RecoverableManagedDatabasesListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecoverableManagedDatabasesListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RecoverableManagedDatabasesListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RecoverableManagedDatabasesListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoverableManagedDatabaseListResult.NextLink == nil || len(*p.current.RecoverableManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RecoverableManagedDatabasesListByInstanceResponse page.
func (p *RecoverableManagedDatabasesListByInstancePager) PageResponse() RecoverableManagedDatabasesListByInstanceResponse {
	return p.current
}

// ReplicationLinksListByDatabasePager provides operations for iterating over paged responses.
type ReplicationLinksListByDatabasePager struct {
	client    *ReplicationLinksClient
	current   ReplicationLinksListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReplicationLinksListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReplicationLinksListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReplicationLinksListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReplicationLinksListByDatabaseResponse page.
func (p *ReplicationLinksListByDatabasePager) PageResponse() ReplicationLinksListByDatabaseResponse {
	return p.current
}

// ReplicationLinksListByServerPager provides operations for iterating over paged responses.
type ReplicationLinksListByServerPager struct {
	client    *ReplicationLinksClient
	current   ReplicationLinksListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReplicationLinksListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ReplicationLinksListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ReplicationLinksListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ReplicationLinksListByServerResponse page.
func (p *ReplicationLinksListByServerPager) PageResponse() ReplicationLinksListByServerResponse {
	return p.current
}

// RestorableDroppedDatabasesListByServerPager provides operations for iterating over paged responses.
type RestorableDroppedDatabasesListByServerPager struct {
	client    *RestorableDroppedDatabasesClient
	current   RestorableDroppedDatabasesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorableDroppedDatabasesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorableDroppedDatabasesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorableDroppedDatabasesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorableDroppedDatabaseListResult.NextLink == nil || len(*p.current.RestorableDroppedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorableDroppedDatabasesListByServerResponse page.
func (p *RestorableDroppedDatabasesListByServerPager) PageResponse() RestorableDroppedDatabasesListByServerResponse {
	return p.current
}

// RestorableDroppedManagedDatabasesListByInstancePager provides operations for iterating over paged responses.
type RestorableDroppedManagedDatabasesListByInstancePager struct {
	client    *RestorableDroppedManagedDatabasesClient
	current   RestorableDroppedManagedDatabasesListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorableDroppedManagedDatabasesListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorableDroppedManagedDatabasesListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorableDroppedManagedDatabasesListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorableDroppedManagedDatabaseListResult.NextLink == nil || len(*p.current.RestorableDroppedManagedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorableDroppedManagedDatabasesListByInstanceResponse page.
func (p *RestorableDroppedManagedDatabasesListByInstancePager) PageResponse() RestorableDroppedManagedDatabasesListByInstanceResponse {
	return p.current
}

// RestorePointsListByDatabasePager provides operations for iterating over paged responses.
type RestorePointsListByDatabasePager struct {
	client    *RestorePointsClient
	current   RestorePointsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RestorePointsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RestorePointsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointListResult.NextLink == nil || len(*p.current.RestorePointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RestorePointsListByDatabaseResponse page.
func (p *RestorePointsListByDatabasePager) PageResponse() RestorePointsListByDatabaseResponse {
	return p.current
}

// SensitivityLabelsListCurrentByDatabasePager provides operations for iterating over paged responses.
type SensitivityLabelsListCurrentByDatabasePager struct {
	client    *SensitivityLabelsClient
	current   SensitivityLabelsListCurrentByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SensitivityLabelsListCurrentByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SensitivityLabelsListCurrentByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SensitivityLabelsListCurrentByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCurrentByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listCurrentByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SensitivityLabelsListCurrentByDatabaseResponse page.
func (p *SensitivityLabelsListCurrentByDatabasePager) PageResponse() SensitivityLabelsListCurrentByDatabaseResponse {
	return p.current
}

// SensitivityLabelsListRecommendedByDatabasePager provides operations for iterating over paged responses.
type SensitivityLabelsListRecommendedByDatabasePager struct {
	client    *SensitivityLabelsClient
	current   SensitivityLabelsListRecommendedByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SensitivityLabelsListRecommendedByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SensitivityLabelsListRecommendedByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SensitivityLabelsListRecommendedByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listRecommendedByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listRecommendedByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SensitivityLabelsListRecommendedByDatabaseResponse page.
func (p *SensitivityLabelsListRecommendedByDatabasePager) PageResponse() SensitivityLabelsListRecommendedByDatabaseResponse {
	return p.current
}

// ServerAzureADAdministratorsListByServerPager provides operations for iterating over paged responses.
type ServerAzureADAdministratorsListByServerPager struct {
	client    *ServerAzureADAdministratorsClient
	current   ServerAzureADAdministratorsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerAzureADAdministratorsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerAzureADAdministratorsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerAzureADAdministratorsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AdministratorListResult.NextLink == nil || len(*p.current.AdministratorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerAzureADAdministratorsListByServerResponse page.
func (p *ServerAzureADAdministratorsListByServerPager) PageResponse() ServerAzureADAdministratorsListByServerResponse {
	return p.current
}

// ServerAzureADOnlyAuthenticationsListByServerPager provides operations for iterating over paged responses.
type ServerAzureADOnlyAuthenticationsListByServerPager struct {
	client    *ServerAzureADOnlyAuthenticationsClient
	current   ServerAzureADOnlyAuthenticationsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerAzureADOnlyAuthenticationsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerAzureADOnlyAuthenticationsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerAzureADOnlyAuthenticationsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureADOnlyAuthListResult.NextLink == nil || len(*p.current.AzureADOnlyAuthListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerAzureADOnlyAuthenticationsListByServerResponse page.
func (p *ServerAzureADOnlyAuthenticationsListByServerPager) PageResponse() ServerAzureADOnlyAuthenticationsListByServerResponse {
	return p.current
}

// ServerBlobAuditingPoliciesListByServerPager provides operations for iterating over paged responses.
type ServerBlobAuditingPoliciesListByServerPager struct {
	client    *ServerBlobAuditingPoliciesClient
	current   ServerBlobAuditingPoliciesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerBlobAuditingPoliciesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerBlobAuditingPoliciesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerBlobAuditingPoliciesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerBlobAuditingPoliciesListByServerResponse page.
func (p *ServerBlobAuditingPoliciesListByServerPager) PageResponse() ServerBlobAuditingPoliciesListByServerResponse {
	return p.current
}

// ServerDNSAliasesListByServerPager provides operations for iterating over paged responses.
type ServerDNSAliasesListByServerPager struct {
	client    *ServerDNSAliasesClient
	current   ServerDNSAliasesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerDNSAliasesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerDNSAliasesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerDNSAliasesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerDNSAliasListResult.NextLink == nil || len(*p.current.ServerDNSAliasListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerDNSAliasesListByServerResponse page.
func (p *ServerDNSAliasesListByServerPager) PageResponse() ServerDNSAliasesListByServerResponse {
	return p.current
}

// ServerDevOpsAuditSettingsListByServerPager provides operations for iterating over paged responses.
type ServerDevOpsAuditSettingsListByServerPager struct {
	client    *ServerDevOpsAuditSettingsClient
	current   ServerDevOpsAuditSettingsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerDevOpsAuditSettingsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerDevOpsAuditSettingsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerDevOpsAuditSettingsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerDevOpsAuditSettingsListResult.NextLink == nil || len(*p.current.ServerDevOpsAuditSettingsListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerDevOpsAuditSettingsListByServerResponse page.
func (p *ServerDevOpsAuditSettingsListByServerPager) PageResponse() ServerDevOpsAuditSettingsListByServerResponse {
	return p.current
}

// ServerKeysListByServerPager provides operations for iterating over paged responses.
type ServerKeysListByServerPager struct {
	client    *ServerKeysClient
	current   ServerKeysListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerKeysListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerKeysListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerKeysListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerKeyListResult.NextLink == nil || len(*p.current.ServerKeyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerKeysListByServerResponse page.
func (p *ServerKeysListByServerPager) PageResponse() ServerKeysListByServerResponse {
	return p.current
}

// ServerOperationsListByServerPager provides operations for iterating over paged responses.
type ServerOperationsListByServerPager struct {
	client    *ServerOperationsClient
	current   ServerOperationsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerOperationsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerOperationsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerOperationsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerOperationListResult.NextLink == nil || len(*p.current.ServerOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerOperationsListByServerResponse page.
func (p *ServerOperationsListByServerPager) PageResponse() ServerOperationsListByServerResponse {
	return p.current
}

// ServerSecurityAlertPoliciesListByServerPager provides operations for iterating over paged responses.
type ServerSecurityAlertPoliciesListByServerPager struct {
	client    *ServerSecurityAlertPoliciesClient
	current   ServerSecurityAlertPoliciesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerSecurityAlertPoliciesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerSecurityAlertPoliciesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerSecurityAlertPoliciesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LogicalServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.LogicalServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerSecurityAlertPoliciesListByServerResponse page.
func (p *ServerSecurityAlertPoliciesListByServerPager) PageResponse() ServerSecurityAlertPoliciesListByServerResponse {
	return p.current
}

// ServerTrustGroupsListByInstancePager provides operations for iterating over paged responses.
type ServerTrustGroupsListByInstancePager struct {
	client    *ServerTrustGroupsClient
	current   ServerTrustGroupsListByInstanceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerTrustGroupsListByInstanceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerTrustGroupsListByInstancePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerTrustGroupsListByInstancePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerTrustGroupListResult.NextLink == nil || len(*p.current.ServerTrustGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstanceHandleError(resp)
		return false
	}
	result, err := p.client.listByInstanceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerTrustGroupsListByInstanceResponse page.
func (p *ServerTrustGroupsListByInstancePager) PageResponse() ServerTrustGroupsListByInstanceResponse {
	return p.current
}

// ServerTrustGroupsListByLocationPager provides operations for iterating over paged responses.
type ServerTrustGroupsListByLocationPager struct {
	client    *ServerTrustGroupsClient
	current   ServerTrustGroupsListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerTrustGroupsListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerTrustGroupsListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerTrustGroupsListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerTrustGroupListResult.NextLink == nil || len(*p.current.ServerTrustGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerTrustGroupsListByLocationResponse page.
func (p *ServerTrustGroupsListByLocationPager) PageResponse() ServerTrustGroupsListByLocationResponse {
	return p.current
}

// ServerVulnerabilityAssessmentsListByServerPager provides operations for iterating over paged responses.
type ServerVulnerabilityAssessmentsListByServerPager struct {
	client    *ServerVulnerabilityAssessmentsClient
	current   ServerVulnerabilityAssessmentsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServerVulnerabilityAssessmentsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServerVulnerabilityAssessmentsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServerVulnerabilityAssessmentsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ServerVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServerVulnerabilityAssessmentsListByServerResponse page.
func (p *ServerVulnerabilityAssessmentsListByServerPager) PageResponse() ServerVulnerabilityAssessmentsListByServerResponse {
	return p.current
}

// ServersListByResourceGroupPager provides operations for iterating over paged responses.
type ServersListByResourceGroupPager struct {
	client    *ServersClient
	current   ServersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerListResult.NextLink == nil || len(*p.current.ServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServersListByResourceGroupResponse page.
func (p *ServersListByResourceGroupPager) PageResponse() ServersListByResourceGroupResponse {
	return p.current
}

// ServersListPager provides operations for iterating over paged responses.
type ServersListPager struct {
	client    *ServersClient
	current   ServersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ServersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ServersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerListResult.NextLink == nil || len(*p.current.ServerListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ServersListResponse page.
func (p *ServersListPager) PageResponse() ServersListResponse {
	return p.current
}

// SubscriptionUsagesListByLocationPager provides operations for iterating over paged responses.
type SubscriptionUsagesListByLocationPager struct {
	client    *SubscriptionUsagesClient
	current   SubscriptionUsagesListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionUsagesListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SubscriptionUsagesListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SubscriptionUsagesListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionUsageListResult.NextLink == nil || len(*p.current.SubscriptionUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SubscriptionUsagesListByLocationResponse page.
func (p *SubscriptionUsagesListByLocationPager) PageResponse() SubscriptionUsagesListByLocationResponse {
	return p.current
}

// SyncAgentsListByServerPager provides operations for iterating over paged responses.
type SyncAgentsListByServerPager struct {
	client    *SyncAgentsClient
	current   SyncAgentsListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncAgentsListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncAgentsListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncAgentsListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncAgentListResult.NextLink == nil || len(*p.current.SyncAgentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncAgentsListByServerResponse page.
func (p *SyncAgentsListByServerPager) PageResponse() SyncAgentsListByServerResponse {
	return p.current
}

// SyncAgentsListLinkedDatabasesPager provides operations for iterating over paged responses.
type SyncAgentsListLinkedDatabasesPager struct {
	client    *SyncAgentsClient
	current   SyncAgentsListLinkedDatabasesResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncAgentsListLinkedDatabasesResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncAgentsListLinkedDatabasesPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncAgentsListLinkedDatabasesPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncAgentLinkedDatabaseListResult.NextLink == nil || len(*p.current.SyncAgentLinkedDatabaseListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listLinkedDatabasesHandleError(resp)
		return false
	}
	result, err := p.client.listLinkedDatabasesHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncAgentsListLinkedDatabasesResponse page.
func (p *SyncAgentsListLinkedDatabasesPager) PageResponse() SyncAgentsListLinkedDatabasesResponse {
	return p.current
}

// SyncGroupsListByDatabasePager provides operations for iterating over paged responses.
type SyncGroupsListByDatabasePager struct {
	client    *SyncGroupsClient
	current   SyncGroupsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncGroupListResult.NextLink == nil || len(*p.current.SyncGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsListByDatabaseResponse page.
func (p *SyncGroupsListByDatabasePager) PageResponse() SyncGroupsListByDatabaseResponse {
	return p.current
}

// SyncGroupsListHubSchemasPager provides operations for iterating over paged responses.
type SyncGroupsListHubSchemasPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsListHubSchemasResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsListHubSchemasResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsListHubSchemasPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsListHubSchemasPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncFullSchemaPropertiesListResult.NextLink == nil || len(*p.current.SyncFullSchemaPropertiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHubSchemasHandleError(resp)
		return false
	}
	result, err := p.client.listHubSchemasHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsListHubSchemasResponse page.
func (p *SyncGroupsListHubSchemasPager) PageResponse() SyncGroupsListHubSchemasResponse {
	return p.current
}

// SyncGroupsListLogsPager provides operations for iterating over paged responses.
type SyncGroupsListLogsPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsListLogsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsListLogsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsListLogsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsListLogsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncGroupLogListResult.NextLink == nil || len(*p.current.SyncGroupLogListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listLogsHandleError(resp)
		return false
	}
	result, err := p.client.listLogsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsListLogsResponse page.
func (p *SyncGroupsListLogsPager) PageResponse() SyncGroupsListLogsResponse {
	return p.current
}

// SyncGroupsListSyncDatabaseIDsPager provides operations for iterating over paged responses.
type SyncGroupsListSyncDatabaseIDsPager struct {
	client    *SyncGroupsClient
	current   SyncGroupsListSyncDatabaseIDsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncGroupsListSyncDatabaseIDsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncGroupsListSyncDatabaseIDsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncGroupsListSyncDatabaseIDsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncDatabaseIDListResult.NextLink == nil || len(*p.current.SyncDatabaseIDListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listSyncDatabaseIDsHandleError(resp)
		return false
	}
	result, err := p.client.listSyncDatabaseIDsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncGroupsListSyncDatabaseIDsResponse page.
func (p *SyncGroupsListSyncDatabaseIDsPager) PageResponse() SyncGroupsListSyncDatabaseIDsResponse {
	return p.current
}

// SyncMembersListBySyncGroupPager provides operations for iterating over paged responses.
type SyncMembersListBySyncGroupPager struct {
	client    *SyncMembersClient
	current   SyncMembersListBySyncGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncMembersListBySyncGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncMembersListBySyncGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncMembersListBySyncGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncMemberListResult.NextLink == nil || len(*p.current.SyncMemberListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySyncGroupHandleError(resp)
		return false
	}
	result, err := p.client.listBySyncGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncMembersListBySyncGroupResponse page.
func (p *SyncMembersListBySyncGroupPager) PageResponse() SyncMembersListBySyncGroupResponse {
	return p.current
}

// SyncMembersListMemberSchemasPager provides operations for iterating over paged responses.
type SyncMembersListMemberSchemasPager struct {
	client    *SyncMembersClient
	current   SyncMembersListMemberSchemasResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SyncMembersListMemberSchemasResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SyncMembersListMemberSchemasPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SyncMembersListMemberSchemasPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SyncFullSchemaPropertiesListResult.NextLink == nil || len(*p.current.SyncFullSchemaPropertiesListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listMemberSchemasHandleError(resp)
		return false
	}
	result, err := p.client.listMemberSchemasHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SyncMembersListMemberSchemasResponse page.
func (p *SyncMembersListMemberSchemasPager) PageResponse() SyncMembersListMemberSchemasResponse {
	return p.current
}

// TimeZonesListByLocationPager provides operations for iterating over paged responses.
type TimeZonesListByLocationPager struct {
	client    *TimeZonesClient
	current   TimeZonesListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TimeZonesListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TimeZonesListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TimeZonesListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TimeZoneListResult.NextLink == nil || len(*p.current.TimeZoneListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TimeZonesListByLocationResponse page.
func (p *TimeZonesListByLocationPager) PageResponse() TimeZonesListByLocationResponse {
	return p.current
}

// TransparentDataEncryptionsListByDatabasePager provides operations for iterating over paged responses.
type TransparentDataEncryptionsListByDatabasePager struct {
	client    *TransparentDataEncryptionsClient
	current   TransparentDataEncryptionsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TransparentDataEncryptionsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *TransparentDataEncryptionsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *TransparentDataEncryptionsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LogicalDatabaseTransparentDataEncryptionListResult.NextLink == nil || len(*p.current.LogicalDatabaseTransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current TransparentDataEncryptionsListByDatabaseResponse page.
func (p *TransparentDataEncryptionsListByDatabasePager) PageResponse() TransparentDataEncryptionsListByDatabaseResponse {
	return p.current
}

// UsagesListByInstancePoolPager provides operations for iterating over paged responses.
type UsagesListByInstancePoolPager struct {
	client    *UsagesClient
	current   UsagesListByInstancePoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsagesListByInstancePoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsagesListByInstancePoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsagesListByInstancePoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageListResult.NextLink == nil || len(*p.current.UsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByInstancePoolHandleError(resp)
		return false
	}
	result, err := p.client.listByInstancePoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsagesListByInstancePoolResponse page.
func (p *UsagesListByInstancePoolPager) PageResponse() UsagesListByInstancePoolResponse {
	return p.current
}

// VirtualClustersListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualClustersListByResourceGroupPager struct {
	client    *VirtualClustersClient
	current   VirtualClustersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualClustersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualClustersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualClustersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualClusterListResult.NextLink == nil || len(*p.current.VirtualClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualClustersListByResourceGroupResponse page.
func (p *VirtualClustersListByResourceGroupPager) PageResponse() VirtualClustersListByResourceGroupResponse {
	return p.current
}

// VirtualClustersListPager provides operations for iterating over paged responses.
type VirtualClustersListPager struct {
	client    *VirtualClustersClient
	current   VirtualClustersListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualClustersListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualClustersListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualClustersListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualClusterListResult.NextLink == nil || len(*p.current.VirtualClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualClustersListResponse page.
func (p *VirtualClustersListPager) PageResponse() VirtualClustersListResponse {
	return p.current
}

// VirtualNetworkRulesListByServerPager provides operations for iterating over paged responses.
type VirtualNetworkRulesListByServerPager struct {
	client    *VirtualNetworkRulesClient
	current   VirtualNetworkRulesListByServerResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkRulesListByServerResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualNetworkRulesListByServerPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualNetworkRulesListByServerPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkRuleListResult.NextLink == nil || len(*p.current.VirtualNetworkRuleListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByServerHandleError(resp)
		return false
	}
	result, err := p.client.listByServerHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualNetworkRulesListByServerResponse page.
func (p *VirtualNetworkRulesListByServerPager) PageResponse() VirtualNetworkRulesListByServerResponse {
	return p.current
}

// WorkloadClassifiersListByWorkloadGroupPager provides operations for iterating over paged responses.
type WorkloadClassifiersListByWorkloadGroupPager struct {
	client    *WorkloadClassifiersClient
	current   WorkloadClassifiersListByWorkloadGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadClassifiersListByWorkloadGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkloadClassifiersListByWorkloadGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkloadClassifiersListByWorkloadGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadClassifierListResult.NextLink == nil || len(*p.current.WorkloadClassifierListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkloadGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkloadGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkloadClassifiersListByWorkloadGroupResponse page.
func (p *WorkloadClassifiersListByWorkloadGroupPager) PageResponse() WorkloadClassifiersListByWorkloadGroupResponse {
	return p.current
}

// WorkloadGroupsListByDatabasePager provides operations for iterating over paged responses.
type WorkloadGroupsListByDatabasePager struct {
	client    *WorkloadGroupsClient
	current   WorkloadGroupsListByDatabaseResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadGroupsListByDatabaseResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkloadGroupsListByDatabasePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkloadGroupsListByDatabasePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadGroupListResult.NextLink == nil || len(*p.current.WorkloadGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByDatabaseHandleError(resp)
		return false
	}
	result, err := p.client.listByDatabaseHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkloadGroupsListByDatabaseResponse page.
func (p *WorkloadGroupsListByDatabasePager) PageResponse() WorkloadGroupsListByDatabaseResponse {
	return p.current
}
