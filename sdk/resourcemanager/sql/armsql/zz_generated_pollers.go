//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	"net/http"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// BackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
func (p *BackupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupShortTermRetentionPoliciesUpdateResponse will be returned.
func (p *BackupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseExtensionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseExtensionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseExtensionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseExtensionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseExtensionsCreateOrUpdateResponse will be returned.
func (p *DatabaseExtensionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseExtensionsCreateOrUpdateResponse, error) {
	respType := DatabaseExtensionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportExtensionsOperationResult)
	if err != nil {
		return DatabaseExtensionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseExtensionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseVulnerabilityAssessmentScansInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseVulnerabilityAssessmentScansInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseVulnerabilityAssessmentScansInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseVulnerabilityAssessmentScansInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseVulnerabilityAssessmentScansInitiateScanResponse will be returned.
func (p *DatabaseVulnerabilityAssessmentScansInitiateScanPoller) FinalResponse(ctx context.Context) (DatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseVulnerabilityAssessmentScansInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesCreateOrUpdateResponse will be returned.
func (p *DatabasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabasesCreateOrUpdateResponse, error) {
	respType := DatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesDeleteResponse will be returned.
func (p *DatabasesDeletePoller) FinalResponse(ctx context.Context) (DatabasesDeleteResponse, error) {
	respType := DatabasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesExportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesExportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesExportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesExportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesExportResponse will be returned.
func (p *DatabasesExportPoller) FinalResponse(ctx context.Context) (DatabasesExportResponse, error) {
	respType := DatabasesExportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesExportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesExportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesFailoverPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesFailoverResponse will be returned.
func (p *DatabasesFailoverPoller) FinalResponse(ctx context.Context) (DatabasesFailoverResponse, error) {
	respType := DatabasesFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesImportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesImportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesImportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesImportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesImportResponse will be returned.
func (p *DatabasesImportPoller) FinalResponse(ctx context.Context) (DatabasesImportResponse, error) {
	respType := DatabasesImportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesImportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesImportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesPausePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesPausePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesPausePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesPausePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesPauseResponse will be returned.
func (p *DatabasesPausePoller) FinalResponse(ctx context.Context) (DatabasesPauseResponse, error) {
	respType := DatabasesPauseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesPausePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesResumePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesResumePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesResumePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesResumeResponse will be returned.
func (p *DatabasesResumePoller) FinalResponse(ctx context.Context) (DatabasesResumeResponse, error) {
	respType := DatabasesResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesUpdateResponse will be returned.
func (p *DatabasesUpdatePoller) FinalResponse(ctx context.Context) (DatabasesUpdateResponse, error) {
	respType := DatabasesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesUpgradeDataWarehousePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesUpgradeDataWarehousePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesUpgradeDataWarehousePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesUpgradeDataWarehousePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesUpgradeDataWarehouseResponse will be returned.
func (p *DatabasesUpgradeDataWarehousePoller) FinalResponse(ctx context.Context) (DatabasesUpgradeDataWarehouseResponse, error) {
	respType := DatabasesUpgradeDataWarehouseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesUpgradeDataWarehouseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesUpgradeDataWarehousePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeletedServersRecoverPoller provides polling facilities until the operation reaches a terminal state.
type DeletedServersRecoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeletedServersRecoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeletedServersRecoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeletedServersRecoverResponse will be returned.
func (p *DeletedServersRecoverPoller) FinalResponse(ctx context.Context) (DeletedServersRecoverResponse, error) {
	respType := DeletedServersRecoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeletedServer)
	if err != nil {
		return DeletedServersRecoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeletedServersRecoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsCreateOrUpdateResponse will be returned.
func (p *ElasticPoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsCreateOrUpdateResponse, error) {
	respType := ElasticPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsDeleteResponse will be returned.
func (p *ElasticPoolsDeletePoller) FinalResponse(ctx context.Context) (ElasticPoolsDeleteResponse, error) {
	respType := ElasticPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsFailoverResponse will be returned.
func (p *ElasticPoolsFailoverPoller) FinalResponse(ctx context.Context) (ElasticPoolsFailoverResponse, error) {
	respType := ElasticPoolsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsUpdateResponse will be returned.
func (p *ElasticPoolsUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsUpdateResponse, error) {
	respType := ElasticPoolsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EncryptionProtectorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EncryptionProtectorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EncryptionProtectorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EncryptionProtectorsCreateOrUpdateResponse will be returned.
func (p *EncryptionProtectorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := EncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EncryptionProtector)
	if err != nil {
		return EncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EncryptionProtectorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EncryptionProtectorsRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EncryptionProtectorsRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EncryptionProtectorsRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EncryptionProtectorsRevalidateResponse will be returned.
func (p *EncryptionProtectorsRevalidatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsRevalidateResponse, error) {
	respType := EncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EncryptionProtectorsRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
func (p *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsCreateOrUpdateResponse will be returned.
func (p *FailoverGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsCreateOrUpdateResponse, error) {
	respType := FailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsDeleteResponse will be returned.
func (p *FailoverGroupsDeletePoller) FinalResponse(ctx context.Context) (FailoverGroupsDeleteResponse, error) {
	respType := FailoverGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsFailoverResponse will be returned.
func (p *FailoverGroupsFailoverPoller) FinalResponse(ctx context.Context) (FailoverGroupsFailoverResponse, error) {
	respType := FailoverGroupsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsForceFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsForceFailoverAllowDataLossResponse will be returned.
func (p *FailoverGroupsForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (FailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := FailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsUpdateResponse will be returned.
func (p *FailoverGroupsUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsUpdateResponse, error) {
	respType := FailoverGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsCreateOrUpdateResponse will be returned.
func (p *InstanceFailoverGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsCreateOrUpdateResponse, error) {
	respType := InstanceFailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsDeleteResponse will be returned.
func (p *InstanceFailoverGroupsDeletePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsDeleteResponse, error) {
	respType := InstanceFailoverGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstanceFailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsFailoverResponse will be returned.
func (p *InstanceFailoverGroupsFailoverPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsFailoverResponse, error) {
	respType := InstanceFailoverGroupsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsForceFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsForceFailoverAllowDataLossResponse will be returned.
func (p *InstanceFailoverGroupsForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsCreateOrUpdateResponse will be returned.
func (p *InstancePoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsCreateOrUpdateResponse, error) {
	respType := InstancePoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsDeleteResponse will be returned.
func (p *InstancePoolsDeletePoller) FinalResponse(ctx context.Context) (InstancePoolsDeleteResponse, error) {
	respType := InstancePoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstancePoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsUpdateResponse will be returned.
func (p *InstancePoolsUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsUpdateResponse, error) {
	respType := InstancePoolsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsCreateOrUpdateResponse will be returned.
func (p *JobAgentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsCreateOrUpdateResponse, error) {
	respType := JobAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsDeleteResponse will be returned.
func (p *JobAgentsDeletePoller) FinalResponse(ctx context.Context) (JobAgentsDeleteResponse, error) {
	respType := JobAgentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return JobAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsUpdateResponse will be returned.
func (p *JobAgentsUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsUpdateResponse, error) {
	respType := JobAgentsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobExecutionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobExecutionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobExecutionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobExecutionsCreateOrUpdateResponse will be returned.
func (p *JobExecutionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobExecutionsCreateOrUpdateResponse, error) {
	respType := JobExecutionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobExecutionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobExecutionsCreatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobExecutionsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobExecutionsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobExecutionsCreateResponse will be returned.
func (p *JobExecutionsCreatePoller) FinalResponse(ctx context.Context) (JobExecutionsCreateResponse, error) {
	respType := JobExecutionsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobExecutionsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LedgerDigestUploadsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LedgerDigestUploadsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LedgerDigestUploadsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LedgerDigestUploadsCreateOrUpdateResponse will be returned.
func (p *LedgerDigestUploadsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsCreateOrUpdateResponse, error) {
	respType := LedgerDigestUploadsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LedgerDigestUploadsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LedgerDigestUploadsDisablePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsDisablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LedgerDigestUploadsDisablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LedgerDigestUploadsDisablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LedgerDigestUploadsDisableResponse will be returned.
func (p *LedgerDigestUploadsDisablePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsDisableResponse, error) {
	respType := LedgerDigestUploadsDisableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsDisableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LedgerDigestUploadsDisablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsCopyByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsCopyByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsCopyByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsCopyByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsCopyByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsCopyByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsCopyByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsCopyByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsCopyPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsCopyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsCopyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsCopyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsCopyResponse will be returned.
func (p *LongTermRetentionBackupsCopyPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyResponse, error) {
	respType := LongTermRetentionBackupsCopyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsCopyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsDeleteByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsDeleteByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsDeleteResponse will be returned.
func (p *LongTermRetentionBackupsDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteResponse, error) {
	respType := LongTermRetentionBackupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsUpdateByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsUpdateByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsUpdateByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsUpdateByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsUpdateByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsUpdateByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsUpdateByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsUpdateByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsUpdateResponse will be returned.
func (p *LongTermRetentionBackupsUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateResponse, error) {
	respType := LongTermRetentionBackupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse will be returned.
func (p *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionManagedInstanceBackupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionManagedInstanceBackupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionManagedInstanceBackupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsDeleteResponse will be returned.
func (p *LongTermRetentionManagedInstanceBackupsDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionManagedInstanceBackupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionPoliciesCreateOrUpdateResponse will be returned.
func (p *LongTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := LongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionPolicy)
	if err != nil {
		return LongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
func (p *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedBackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedBackupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedBackupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesUpdateResponse will be returned.
func (p *ManagedBackupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedBackupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse will be returned.
func (p *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) FinalResponse(ctx context.Context) (ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesCompleteRestorePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesCompleteRestorePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesCompleteRestorePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesCompleteRestorePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesCompleteRestoreResponse will be returned.
func (p *ManagedDatabasesCompleteRestorePoller) FinalResponse(ctx context.Context) (ManagedDatabasesCompleteRestoreResponse, error) {
	respType := ManagedDatabasesCompleteRestoreResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesCompleteRestoreResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesCompleteRestorePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesCreateOrUpdateResponse will be returned.
func (p *ManagedDatabasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesCreateOrUpdateResponse, error) {
	respType := ManagedDatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesDeleteResponse will be returned.
func (p *ManagedDatabasesDeletePoller) FinalResponse(ctx context.Context) (ManagedDatabasesDeleteResponse, error) {
	respType := ManagedDatabasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesUpdateResponse will be returned.
func (p *ManagedDatabasesUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesUpdateResponse, error) {
	respType := ManagedDatabasesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAdministratorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAdministratorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAdministratorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAdministratorsCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceAdministratorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAdministrator)
	if err != nil {
		return ManagedInstanceAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAdministratorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAdministratorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAdministratorsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAdministratorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAdministratorsDeleteResponse will be returned.
func (p *ManagedInstanceAdministratorsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsDeleteResponse, error) {
	respType := ManagedInstanceAdministratorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAdministratorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAzureADOnlyAuthentication)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAzureADOnlyAuthenticationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAzureADOnlyAuthenticationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAzureADOnlyAuthenticationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse will be returned.
func (p *ManagedInstanceAzureADOnlyAuthenticationsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAzureADOnlyAuthenticationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceEncryptionProtector)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceEncryptionProtectorsRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceEncryptionProtectorsRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceEncryptionProtectorsRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsRevalidateResponse will be returned.
func (p *ManagedInstanceEncryptionProtectorsRevalidatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsRevalidateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceEncryptionProtectorsRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceKeysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceKeysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceKeysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceKeysCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceKeysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysCreateOrUpdateResponse, error) {
	respType := ManagedInstanceKeysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceKey)
	if err != nil {
		return ManagedInstanceKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceKeysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceKeysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceKeysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceKeysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceKeysDeleteResponse will be returned.
func (p *ManagedInstanceKeysDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysDeleteResponse, error) {
	respType := ManagedInstanceKeysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceKeysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceLongTermRetentionPolicy)
	if err != nil {
		return ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
func (p *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstancePrivateEndpointConnection)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancePrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancePrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancePrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsDeleteResponse will be returned.
func (p *ManagedInstancePrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsDeleteResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancePrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceTdeCertificatesCreatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceTdeCertificatesCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceTdeCertificatesCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceTdeCertificatesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceTdeCertificatesCreateResponse will be returned.
func (p *ManagedInstanceTdeCertificatesCreatePoller) FinalResponse(ctx context.Context) (ManagedInstanceTdeCertificatesCreateResponse, error) {
	respType := ManagedInstanceTdeCertificatesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceTdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceTdeCertificatesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesCreateOrUpdateResponse will be returned.
func (p *ManagedInstancesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesCreateOrUpdateResponse, error) {
	respType := ManagedInstancesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesDeleteResponse will be returned.
func (p *ManagedInstancesDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancesDeleteResponse, error) {
	respType := ManagedInstancesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesFailoverResponse will be returned.
func (p *ManagedInstancesFailoverPoller) FinalResponse(ctx context.Context) (ManagedInstancesFailoverResponse, error) {
	respType := ManagedInstancesFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesUpdateResponse will be returned.
func (p *ManagedInstancesUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesUpdateResponse, error) {
	respType := ManagedInstancesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse will be returned.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse will be returned.
func (p *ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedServerSecurityAlertPolicy)
	if err != nil {
		return ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OutboundFirewallRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OutboundFirewallRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OutboundFirewallRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OutboundFirewallRulesCreateOrUpdateResponse will be returned.
func (p *OutboundFirewallRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesCreateOrUpdateResponse, error) {
	respType := OutboundFirewallRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OutboundFirewallRule)
	if err != nil {
		return OutboundFirewallRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OutboundFirewallRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OutboundFirewallRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OutboundFirewallRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OutboundFirewallRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OutboundFirewallRulesDeleteResponse will be returned.
func (p *OutboundFirewallRulesDeletePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesDeleteResponse, error) {
	respType := OutboundFirewallRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OutboundFirewallRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OutboundFirewallRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksFailoverAllowDataLossResponse will be returned.
func (p *ReplicationLinksFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (ReplicationLinksFailoverAllowDataLossResponse, error) {
	respType := ReplicationLinksFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksFailoverResponse will be returned.
func (p *ReplicationLinksFailoverPoller) FinalResponse(ctx context.Context) (ReplicationLinksFailoverResponse, error) {
	respType := ReplicationLinksFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksUnlinkPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksUnlinkPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksUnlinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksUnlinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksUnlinkResponse will be returned.
func (p *ReplicationLinksUnlinkPoller) FinalResponse(ctx context.Context) (ReplicationLinksUnlinkResponse, error) {
	respType := ReplicationLinksUnlinkResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksUnlinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksUnlinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RestorePointsCreatePoller provides polling facilities until the operation reaches a terminal state.
type RestorePointsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RestorePointsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RestorePointsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RestorePointsCreateResponse will be returned.
func (p *RestorePointsCreatePoller) FinalResponse(ctx context.Context) (RestorePointsCreateResponse, error) {
	respType := RestorePointsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RestorePoint)
	if err != nil {
		return RestorePointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RestorePointsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADAdministratorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADAdministratorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADAdministratorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADAdministratorsCreateOrUpdateResponse will be returned.
func (p *ServerAzureADAdministratorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsCreateOrUpdateResponse, error) {
	respType := ServerAzureADAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADAdministrator)
	if err != nil {
		return ServerAzureADAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADAdministratorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADAdministratorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADAdministratorsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADAdministratorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADAdministratorsDeleteResponse will be returned.
func (p *ServerAzureADAdministratorsDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsDeleteResponse, error) {
	respType := ServerAzureADAdministratorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADAdministratorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse will be returned.
func (p *ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADOnlyAuthentication)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADOnlyAuthenticationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADOnlyAuthenticationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADOnlyAuthenticationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsDeleteResponse will be returned.
func (p *ServerAzureADOnlyAuthenticationsDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADOnlyAuthenticationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
func (p *ServerBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return ServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerCommunicationLinksCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerCommunicationLinksCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerCommunicationLinksCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerCommunicationLinksCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerCommunicationLinksCreateOrUpdateResponse will be returned.
func (p *ServerCommunicationLinksCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerCommunicationLinksCreateOrUpdateResponse, error) {
	respType := ServerCommunicationLinksCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerCommunicationLink)
	if err != nil {
		return ServerCommunicationLinksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerCommunicationLinksCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesAcquirePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesAcquirePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesAcquirePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesAcquirePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesAcquireResponse will be returned.
func (p *ServerDNSAliasesAcquirePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesAcquireResponse, error) {
	respType := ServerDNSAliasesAcquireResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesAcquireResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesAcquirePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesCreateOrUpdateResponse will be returned.
func (p *ServerDNSAliasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesCreateOrUpdateResponse, error) {
	respType := ServerDNSAliasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesDeleteResponse will be returned.
func (p *ServerDNSAliasesDeletePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesDeleteResponse, error) {
	respType := ServerDNSAliasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerDNSAliasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDevOpsAuditSettingsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDevOpsAuditSettingsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDevOpsAuditSettingsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDevOpsAuditSettingsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDevOpsAuditSettingsCreateOrUpdateResponse will be returned.
func (p *ServerDevOpsAuditSettingsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDevOpsAuditSettingsCreateOrUpdateResponse, error) {
	respType := ServerDevOpsAuditSettingsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDevOpsAuditingSettings)
	if err != nil {
		return ServerDevOpsAuditSettingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDevOpsAuditSettingsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerKeysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerKeysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerKeysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerKeysCreateOrUpdateResponse will be returned.
func (p *ServerKeysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerKeysCreateOrUpdateResponse, error) {
	respType := ServerKeysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerKey)
	if err != nil {
		return ServerKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerKeysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerKeysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerKeysDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerKeysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerKeysDeleteResponse will be returned.
func (p *ServerKeysDeletePoller) FinalResponse(ctx context.Context) (ServerKeysDeleteResponse, error) {
	respType := ServerKeysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerKeysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerSecurityAlertPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerSecurityAlertPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerSecurityAlertPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerSecurityAlertPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerSecurityAlertPoliciesCreateOrUpdateResponse will be returned.
func (p *ServerSecurityAlertPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return ServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerSecurityAlertPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerTrustGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerTrustGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerTrustGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerTrustGroupsCreateOrUpdateResponse will be returned.
func (p *ServerTrustGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsCreateOrUpdateResponse, error) {
	respType := ServerTrustGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerTrustGroup)
	if err != nil {
		return ServerTrustGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerTrustGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerTrustGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerTrustGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerTrustGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerTrustGroupsDeleteResponse will be returned.
func (p *ServerTrustGroupsDeletePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsDeleteResponse, error) {
	respType := ServerTrustGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerTrustGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerTrustGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersCreateOrUpdateResponse will be returned.
func (p *ServersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServersCreateOrUpdateResponse, error) {
	respType := ServersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersDeleteResponse will be returned.
func (p *ServersDeletePoller) FinalResponse(ctx context.Context) (ServersDeleteResponse, error) {
	respType := ServersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersImportDatabasePoller provides polling facilities until the operation reaches a terminal state.
type ServersImportDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersImportDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersImportDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersImportDatabaseResponse will be returned.
func (p *ServersImportDatabasePoller) FinalResponse(ctx context.Context) (ServersImportDatabaseResponse, error) {
	respType := ServersImportDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return ServersImportDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersImportDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersUpdateResponse will be returned.
func (p *ServersUpdatePoller) FinalResponse(ctx context.Context) (ServersUpdateResponse, error) {
	respType := ServersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncAgentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncAgentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncAgentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncAgentsCreateOrUpdateResponse will be returned.
func (p *SyncAgentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncAgentsCreateOrUpdateResponse, error) {
	respType := SyncAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncAgent)
	if err != nil {
		return SyncAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncAgentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncAgentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncAgentsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncAgentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncAgentsDeleteResponse will be returned.
func (p *SyncAgentsDeletePoller) FinalResponse(ctx context.Context) (SyncAgentsDeleteResponse, error) {
	respType := SyncAgentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncAgentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsCreateOrUpdateResponse will be returned.
func (p *SyncGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsCreateOrUpdateResponse, error) {
	respType := SyncGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsDeleteResponse will be returned.
func (p *SyncGroupsDeletePoller) FinalResponse(ctx context.Context) (SyncGroupsDeleteResponse, error) {
	respType := SyncGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsRefreshHubSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsRefreshHubSchemaPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsRefreshHubSchemaPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsRefreshHubSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsRefreshHubSchemaResponse will be returned.
func (p *SyncGroupsRefreshHubSchemaPoller) FinalResponse(ctx context.Context) (SyncGroupsRefreshHubSchemaResponse, error) {
	respType := SyncGroupsRefreshHubSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsRefreshHubSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsRefreshHubSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsUpdateResponse will be returned.
func (p *SyncGroupsUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsUpdateResponse, error) {
	respType := SyncGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersCreateOrUpdateResponse will be returned.
func (p *SyncMembersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersCreateOrUpdateResponse, error) {
	respType := SyncMembersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersDeleteResponse will be returned.
func (p *SyncMembersDeletePoller) FinalResponse(ctx context.Context) (SyncMembersDeleteResponse, error) {
	respType := SyncMembersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersRefreshMemberSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersRefreshMemberSchemaPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersRefreshMemberSchemaPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersRefreshMemberSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersRefreshMemberSchemaResponse will be returned.
func (p *SyncMembersRefreshMemberSchemaPoller) FinalResponse(ctx context.Context) (SyncMembersRefreshMemberSchemaResponse, error) {
	respType := SyncMembersRefreshMemberSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersRefreshMemberSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersRefreshMemberSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersUpdateResponse will be returned.
func (p *SyncMembersUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersUpdateResponse, error) {
	respType := SyncMembersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TdeCertificatesCreatePoller provides polling facilities until the operation reaches a terminal state.
type TdeCertificatesCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TdeCertificatesCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TdeCertificatesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TdeCertificatesCreateResponse will be returned.
func (p *TdeCertificatesCreatePoller) FinalResponse(ctx context.Context) (TdeCertificatesCreateResponse, error) {
	respType := TdeCertificatesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TdeCertificatesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualClustersDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualClustersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualClustersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualClustersDeleteResponse will be returned.
func (p *VirtualClustersDeletePoller) FinalResponse(ctx context.Context) (VirtualClustersDeleteResponse, error) {
	respType := VirtualClustersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualClustersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualClustersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualClustersUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualClustersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualClustersUpdateResponse will be returned.
func (p *VirtualClustersUpdatePoller) FinalResponse(ctx context.Context) (VirtualClustersUpdateResponse, error) {
	respType := VirtualClustersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualCluster)
	if err != nil {
		return VirtualClustersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualClustersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkRulesCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkRule)
	if err != nil {
		return VirtualNetworkRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkRulesDeleteResponse will be returned.
func (p *VirtualNetworkRulesDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesDeleteResponse, error) {
	respType := VirtualNetworkRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadClassifiersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadClassifiersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadClassifiersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadClassifiersCreateOrUpdateResponse will be returned.
func (p *WorkloadClassifiersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersCreateOrUpdateResponse, error) {
	respType := WorkloadClassifiersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadClassifier)
	if err != nil {
		return WorkloadClassifiersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadClassifiersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadClassifiersDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadClassifiersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadClassifiersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadClassifiersDeleteResponse will be returned.
func (p *WorkloadClassifiersDeletePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersDeleteResponse, error) {
	respType := WorkloadClassifiersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadClassifiersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadClassifiersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadGroupsCreateOrUpdateResponse will be returned.
func (p *WorkloadGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadGroupsCreateOrUpdateResponse, error) {
	respType := WorkloadGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadGroup)
	if err != nil {
		return WorkloadGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadGroupsDeleteResponse will be returned.
func (p *WorkloadGroupsDeletePoller) FinalResponse(ctx context.Context) (WorkloadGroupsDeleteResponse, error) {
	respType := WorkloadGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
