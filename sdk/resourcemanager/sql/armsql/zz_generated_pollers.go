//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupShortTermRetentionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesClientCreateOrUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupShortTermRetentionPoliciesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupShortTermRetentionPoliciesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupShortTermRetentionPoliciesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupShortTermRetentionPoliciesClientUpdateResponse will be returned.
func (p *BackupShortTermRetentionPoliciesClientUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesClientUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupShortTermRetentionPoliciesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseExtensionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseExtensionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseExtensionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseExtensionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseExtensionsClientCreateOrUpdateResponse will be returned.
func (p *DatabaseExtensionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseExtensionsClientCreateOrUpdateResponse, error) {
	respType := DatabaseExtensionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportExtensionsOperationResult)
	if err != nil {
		return DatabaseExtensionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseExtensionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabaseVulnerabilityAssessmentScansClientInitiateScanResponse will be returned.
func (p *DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) FinalResponse(ctx context.Context) (DatabaseVulnerabilityAssessmentScansClientInitiateScanResponse, error) {
	respType := DatabaseVulnerabilityAssessmentScansClientInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseVulnerabilityAssessmentScansClientInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientCreateOrUpdateResponse will be returned.
func (p *DatabasesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabasesClientCreateOrUpdateResponse, error) {
	respType := DatabasesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientDeleteResponse will be returned.
func (p *DatabasesClientDeletePoller) FinalResponse(ctx context.Context) (DatabasesClientDeleteResponse, error) {
	respType := DatabasesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientExportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientExportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientExportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientExportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientExportResponse will be returned.
func (p *DatabasesClientExportPoller) FinalResponse(ctx context.Context) (DatabasesClientExportResponse, error) {
	respType := DatabasesClientExportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesClientExportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientExportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientFailoverResponse will be returned.
func (p *DatabasesClientFailoverPoller) FinalResponse(ctx context.Context) (DatabasesClientFailoverResponse, error) {
	respType := DatabasesClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientImportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientImportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientImportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientImportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientImportResponse will be returned.
func (p *DatabasesClientImportPoller) FinalResponse(ctx context.Context) (DatabasesClientImportResponse, error) {
	respType := DatabasesClientImportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesClientImportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientImportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientPausePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientPausePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientPausePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientPausePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientPauseResponse will be returned.
func (p *DatabasesClientPausePoller) FinalResponse(ctx context.Context) (DatabasesClientPauseResponse, error) {
	respType := DatabasesClientPauseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesClientPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientPausePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientResumePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientResumePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientResumePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientResumeResponse will be returned.
func (p *DatabasesClientResumePoller) FinalResponse(ctx context.Context) (DatabasesClientResumeResponse, error) {
	respType := DatabasesClientResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesClientResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientUpdateResponse will be returned.
func (p *DatabasesClientUpdatePoller) FinalResponse(ctx context.Context) (DatabasesClientUpdateResponse, error) {
	respType := DatabasesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatabasesClientUpgradeDataWarehousePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesClientUpgradeDataWarehousePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatabasesClientUpgradeDataWarehousePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatabasesClientUpgradeDataWarehousePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatabasesClientUpgradeDataWarehouseResponse will be returned.
func (p *DatabasesClientUpgradeDataWarehousePoller) FinalResponse(ctx context.Context) (DatabasesClientUpgradeDataWarehouseResponse, error) {
	respType := DatabasesClientUpgradeDataWarehouseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesClientUpgradeDataWarehouseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatabasesClientUpgradeDataWarehousePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeletedServersClientRecoverPoller provides polling facilities until the operation reaches a terminal state.
type DeletedServersClientRecoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeletedServersClientRecoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeletedServersClientRecoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeletedServersClientRecoverResponse will be returned.
func (p *DeletedServersClientRecoverPoller) FinalResponse(ctx context.Context) (DeletedServersClientRecoverResponse, error) {
	respType := DeletedServersClientRecoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeletedServer)
	if err != nil {
		return DeletedServersClientRecoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeletedServersClientRecoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsClientCreateOrUpdateResponse will be returned.
func (p *ElasticPoolsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsClientCreateOrUpdateResponse, error) {
	respType := ElasticPoolsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsClientDeleteResponse will be returned.
func (p *ElasticPoolsClientDeletePoller) FinalResponse(ctx context.Context) (ElasticPoolsClientDeleteResponse, error) {
	respType := ElasticPoolsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsClientFailoverResponse will be returned.
func (p *ElasticPoolsClientFailoverPoller) FinalResponse(ctx context.Context) (ElasticPoolsClientFailoverResponse, error) {
	respType := ElasticPoolsClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ElasticPoolsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ElasticPoolsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ElasticPoolsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ElasticPoolsClientUpdateResponse will be returned.
func (p *ElasticPoolsClientUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsClientUpdateResponse, error) {
	respType := ElasticPoolsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ElasticPoolsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EncryptionProtectorsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EncryptionProtectorsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EncryptionProtectorsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EncryptionProtectorsClientCreateOrUpdateResponse will be returned.
func (p *EncryptionProtectorsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsClientCreateOrUpdateResponse, error) {
	respType := EncryptionProtectorsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EncryptionProtector)
	if err != nil {
		return EncryptionProtectorsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EncryptionProtectorsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// EncryptionProtectorsClientRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsClientRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *EncryptionProtectorsClientRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *EncryptionProtectorsClientRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final EncryptionProtectorsClientRevalidateResponse will be returned.
func (p *EncryptionProtectorsClientRevalidatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsClientRevalidateResponse, error) {
	respType := EncryptionProtectorsClientRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EncryptionProtectorsClientRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *EncryptionProtectorsClientRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExtendedServerBlobAuditingPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExtendedServerBlobAuditingPoliciesClientCreateOrUpdateResponse, error) {
	respType := ExtendedServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return ExtendedServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExtendedServerBlobAuditingPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsClientCreateOrUpdateResponse will be returned.
func (p *FailoverGroupsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsClientCreateOrUpdateResponse, error) {
	respType := FailoverGroupsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsClientDeleteResponse will be returned.
func (p *FailoverGroupsClientDeletePoller) FinalResponse(ctx context.Context) (FailoverGroupsClientDeleteResponse, error) {
	respType := FailoverGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FailoverGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsClientFailoverResponse will be returned.
func (p *FailoverGroupsClientFailoverPoller) FinalResponse(ctx context.Context) (FailoverGroupsClientFailoverResponse, error) {
	respType := FailoverGroupsClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsClientForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsClientForceFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsClientForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsClientForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsClientForceFailoverAllowDataLossResponse will be returned.
func (p *FailoverGroupsClientForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (FailoverGroupsClientForceFailoverAllowDataLossResponse, error) {
	respType := FailoverGroupsClientForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsClientForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsClientForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// FailoverGroupsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FailoverGroupsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *FailoverGroupsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final FailoverGroupsClientUpdateResponse will be returned.
func (p *FailoverGroupsClientUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsClientUpdateResponse, error) {
	respType := FailoverGroupsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *FailoverGroupsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsClientCreateOrUpdateResponse will be returned.
func (p *InstanceFailoverGroupsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsClientCreateOrUpdateResponse, error) {
	respType := InstanceFailoverGroupsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsClientDeleteResponse will be returned.
func (p *InstanceFailoverGroupsClientDeletePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsClientDeleteResponse, error) {
	respType := InstanceFailoverGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstanceFailoverGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsClientFailoverResponse will be returned.
func (p *InstanceFailoverGroupsClientFailoverPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsClientFailoverResponse, error) {
	respType := InstanceFailoverGroupsClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstanceFailoverGroupsClientForceFailoverAllowDataLossResponse will be returned.
func (p *InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsClientForceFailoverAllowDataLossResponse, error) {
	respType := InstanceFailoverGroupsClientForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsClientForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstanceFailoverGroupsClientForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsClientCreateOrUpdateResponse will be returned.
func (p *InstancePoolsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsClientCreateOrUpdateResponse, error) {
	respType := InstancePoolsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsClientDeleteResponse will be returned.
func (p *InstancePoolsClientDeletePoller) FinalResponse(ctx context.Context) (InstancePoolsClientDeleteResponse, error) {
	respType := InstancePoolsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstancePoolsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// InstancePoolsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InstancePoolsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *InstancePoolsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final InstancePoolsClientUpdateResponse will be returned.
func (p *InstancePoolsClientUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsClientUpdateResponse, error) {
	respType := InstancePoolsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *InstancePoolsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsClientCreateOrUpdateResponse will be returned.
func (p *JobAgentsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsClientCreateOrUpdateResponse, error) {
	respType := JobAgentsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsClientDeleteResponse will be returned.
func (p *JobAgentsClientDeletePoller) FinalResponse(ctx context.Context) (JobAgentsClientDeleteResponse, error) {
	respType := JobAgentsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return JobAgentsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobAgentsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobAgentsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobAgentsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobAgentsClientUpdateResponse will be returned.
func (p *JobAgentsClientUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsClientUpdateResponse, error) {
	respType := JobAgentsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobAgentsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobExecutionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobExecutionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobExecutionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobExecutionsClientCreateOrUpdateResponse will be returned.
func (p *JobExecutionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobExecutionsClientCreateOrUpdateResponse, error) {
	respType := JobExecutionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobExecutionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobExecutionsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobExecutionsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobExecutionsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobExecutionsClientCreateResponse will be returned.
func (p *JobExecutionsClientCreatePoller) FinalResponse(ctx context.Context) (JobExecutionsClientCreateResponse, error) {
	respType := JobExecutionsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobExecutionsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LedgerDigestUploadsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LedgerDigestUploadsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LedgerDigestUploadsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LedgerDigestUploadsClientCreateOrUpdateResponse will be returned.
func (p *LedgerDigestUploadsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsClientCreateOrUpdateResponse, error) {
	respType := LedgerDigestUploadsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LedgerDigestUploadsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LedgerDigestUploadsClientDisablePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsClientDisablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LedgerDigestUploadsClientDisablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LedgerDigestUploadsClientDisablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LedgerDigestUploadsClientDisableResponse will be returned.
func (p *LedgerDigestUploadsClientDisablePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsClientDisableResponse, error) {
	respType := LedgerDigestUploadsClientDisableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsClientDisableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LedgerDigestUploadsClientDisablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientCopyByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientCopyByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientCopyByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientCopyByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientCopyByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsClientCopyByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientCopyByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsClientCopyByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsClientCopyByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientCopyByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientCopyPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientCopyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientCopyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientCopyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientCopyResponse will be returned.
func (p *LongTermRetentionBackupsClientCopyPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientCopyResponse, error) {
	respType := LongTermRetentionBackupsClientCopyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsClientCopyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientCopyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientDeleteByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientDeleteByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsClientDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsClientDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsClientDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientDeleteResponse will be returned.
func (p *LongTermRetentionBackupsClientDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientDeleteResponse, error) {
	respType := LongTermRetentionBackupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientUpdateByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientUpdateByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientUpdateByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientUpdateByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientUpdateByResourceGroupResponse will be returned.
func (p *LongTermRetentionBackupsClientUpdateByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientUpdateByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsClientUpdateByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsClientUpdateByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientUpdateByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionBackupsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionBackupsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionBackupsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionBackupsClientUpdateResponse will be returned.
func (p *LongTermRetentionBackupsClientUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsClientUpdateResponse, error) {
	respType := LongTermRetentionBackupsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionBackupsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupResponse will be returned.
func (p *LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionManagedInstanceBackupsClientDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionManagedInstanceBackupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionManagedInstanceBackupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionManagedInstanceBackupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsClientDeleteResponse will be returned.
func (p *LongTermRetentionManagedInstanceBackupsClientDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsClientDeleteResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionManagedInstanceBackupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LongTermRetentionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LongTermRetentionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LongTermRetentionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LongTermRetentionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *LongTermRetentionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionPoliciesClientCreateOrUpdateResponse, error) {
	respType := LongTermRetentionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionPolicy)
	if err != nil {
		return LongTermRetentionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LongTermRetentionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedBackupShortTermRetentionPoliciesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedBackupShortTermRetentionPoliciesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedBackupShortTermRetentionPoliciesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesClientUpdateResponse will be returned.
func (p *ManagedBackupShortTermRetentionPoliciesClientUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesClientUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedBackupShortTermRetentionPoliciesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanResponse will be returned.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) FinalResponse(ctx context.Context) (ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanResponse, error) {
	respType := ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabaseVulnerabilityAssessmentScansClientInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesClientCompleteRestorePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesClientCompleteRestorePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesClientCompleteRestorePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesClientCompleteRestorePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesClientCompleteRestoreResponse will be returned.
func (p *ManagedDatabasesClientCompleteRestorePoller) FinalResponse(ctx context.Context) (ManagedDatabasesClientCompleteRestoreResponse, error) {
	respType := ManagedDatabasesClientCompleteRestoreResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesClientCompleteRestoreResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesClientCompleteRestorePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesClientCreateOrUpdateResponse will be returned.
func (p *ManagedDatabasesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesClientCreateOrUpdateResponse, error) {
	respType := ManagedDatabasesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesClientDeleteResponse will be returned.
func (p *ManagedDatabasesClientDeletePoller) FinalResponse(ctx context.Context) (ManagedDatabasesClientDeleteResponse, error) {
	respType := ManagedDatabasesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedDatabasesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedDatabasesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedDatabasesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedDatabasesClientUpdateResponse will be returned.
func (p *ManagedDatabasesClientUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesClientUpdateResponse, error) {
	respType := ManagedDatabasesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedDatabasesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAdministratorsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAdministratorsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAdministratorsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAdministratorsClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceAdministratorsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsClientCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAdministratorsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAdministrator)
	if err != nil {
		return ManagedInstanceAdministratorsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAdministratorsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAdministratorsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAdministratorsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAdministratorsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAdministratorsClientDeleteResponse will be returned.
func (p *ManagedInstanceAdministratorsClientDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsClientDeleteResponse, error) {
	respType := ManagedInstanceAdministratorsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAdministratorsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAdministratorsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAzureADOnlyAuthentication)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsClientDeleteResponse will be returned.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsClientDeleteResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceAzureADOnlyAuthenticationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsClientCreateOrUpdateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceEncryptionProtector)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceEncryptionProtectorsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceEncryptionProtectorsClientRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsClientRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceEncryptionProtectorsClientRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceEncryptionProtectorsClientRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsClientRevalidateResponse will be returned.
func (p *ManagedInstanceEncryptionProtectorsClientRevalidatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsClientRevalidateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsClientRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsClientRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceEncryptionProtectorsClientRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceKeysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceKeysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceKeysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceKeysClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceKeysClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysClientCreateOrUpdateResponse, error) {
	respType := ManagedInstanceKeysClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceKey)
	if err != nil {
		return ManagedInstanceKeysClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceKeysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceKeysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceKeysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceKeysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceKeysClientDeleteResponse will be returned.
func (p *ManagedInstanceKeysClientDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysClientDeleteResponse, error) {
	respType := ManagedInstanceKeysClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceKeysClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceKeysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdateResponse, error) {
	respType := ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceLongTermRetentionPolicy)
	if err != nil {
		return ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceLongTermRetentionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstancePrivateEndpointConnection)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancePrivateEndpointConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancePrivateEndpointConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancePrivateEndpointConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancePrivateEndpointConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsClientDeleteResponse will be returned.
func (p *ManagedInstancePrivateEndpointConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancePrivateEndpointConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstanceTdeCertificatesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceTdeCertificatesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstanceTdeCertificatesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstanceTdeCertificatesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstanceTdeCertificatesClientCreateResponse will be returned.
func (p *ManagedInstanceTdeCertificatesClientCreatePoller) FinalResponse(ctx context.Context) (ManagedInstanceTdeCertificatesClientCreateResponse, error) {
	respType := ManagedInstanceTdeCertificatesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceTdeCertificatesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstanceTdeCertificatesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesClientCreateOrUpdateResponse will be returned.
func (p *ManagedInstancesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesClientCreateOrUpdateResponse, error) {
	respType := ManagedInstancesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesClientDeleteResponse will be returned.
func (p *ManagedInstancesClientDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancesClientDeleteResponse, error) {
	respType := ManagedInstancesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesClientFailoverResponse will be returned.
func (p *ManagedInstancesClientFailoverPoller) FinalResponse(ctx context.Context) (ManagedInstancesClientFailoverResponse, error) {
	respType := ManagedInstancesClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedInstancesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedInstancesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedInstancesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedInstancesClientUpdateResponse will be returned.
func (p *ManagedInstancesClientUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesClientUpdateResponse, error) {
	respType := ManagedInstancesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedInstancesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdateResponse will be returned.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ManagedServerSecurityAlertPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedServerSecurityAlertPoliciesClientCreateOrUpdateResponse, error) {
	respType := ManagedServerSecurityAlertPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedServerSecurityAlertPolicy)
	if err != nil {
		return ManagedServerSecurityAlertPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ManagedServerSecurityAlertPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OutboundFirewallRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OutboundFirewallRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OutboundFirewallRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OutboundFirewallRulesClientCreateOrUpdateResponse will be returned.
func (p *OutboundFirewallRulesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesClientCreateOrUpdateResponse, error) {
	respType := OutboundFirewallRulesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OutboundFirewallRule)
	if err != nil {
		return OutboundFirewallRulesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OutboundFirewallRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// OutboundFirewallRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OutboundFirewallRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *OutboundFirewallRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final OutboundFirewallRulesClientDeleteResponse will be returned.
func (p *OutboundFirewallRulesClientDeletePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesClientDeleteResponse, error) {
	respType := OutboundFirewallRulesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OutboundFirewallRulesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *OutboundFirewallRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksClientFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksClientFailoverAllowDataLossPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksClientFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksClientFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksClientFailoverAllowDataLossResponse will be returned.
func (p *ReplicationLinksClientFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (ReplicationLinksClientFailoverAllowDataLossResponse, error) {
	respType := ReplicationLinksClientFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksClientFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksClientFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksClientFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksClientFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksClientFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksClientFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksClientFailoverResponse will be returned.
func (p *ReplicationLinksClientFailoverPoller) FinalResponse(ctx context.Context) (ReplicationLinksClientFailoverResponse, error) {
	respType := ReplicationLinksClientFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksClientFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksClientFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationLinksClientUnlinkPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksClientUnlinkPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationLinksClientUnlinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationLinksClientUnlinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationLinksClientUnlinkResponse will be returned.
func (p *ReplicationLinksClientUnlinkPoller) FinalResponse(ctx context.Context) (ReplicationLinksClientUnlinkResponse, error) {
	respType := ReplicationLinksClientUnlinkResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksClientUnlinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationLinksClientUnlinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RestorePointsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type RestorePointsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RestorePointsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RestorePointsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RestorePointsClientCreateResponse will be returned.
func (p *RestorePointsClientCreatePoller) FinalResponse(ctx context.Context) (RestorePointsClientCreateResponse, error) {
	respType := RestorePointsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RestorePoint)
	if err != nil {
		return RestorePointsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RestorePointsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADAdministratorsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADAdministratorsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADAdministratorsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADAdministratorsClientCreateOrUpdateResponse will be returned.
func (p *ServerAzureADAdministratorsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsClientCreateOrUpdateResponse, error) {
	respType := ServerAzureADAdministratorsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADAdministrator)
	if err != nil {
		return ServerAzureADAdministratorsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADAdministratorsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADAdministratorsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADAdministratorsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADAdministratorsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADAdministratorsClientDeleteResponse will be returned.
func (p *ServerAzureADAdministratorsClientDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsClientDeleteResponse, error) {
	respType := ServerAzureADAdministratorsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADAdministratorsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADAdministratorsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsClientCreateOrUpdateResponse will be returned.
func (p *ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsClientCreateOrUpdateResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADOnlyAuthentication)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADOnlyAuthenticationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerAzureADOnlyAuthenticationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerAzureADOnlyAuthenticationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerAzureADOnlyAuthenticationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsClientDeleteResponse will be returned.
func (p *ServerAzureADOnlyAuthenticationsClientDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsClientDeleteResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerAzureADOnlyAuthenticationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerBlobAuditingPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerBlobAuditingPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerBlobAuditingPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ServerBlobAuditingPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerBlobAuditingPoliciesClientCreateOrUpdateResponse, error) {
	respType := ServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return ServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerBlobAuditingPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerCommunicationLinksClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerCommunicationLinksClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerCommunicationLinksClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerCommunicationLinksClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerCommunicationLinksClientCreateOrUpdateResponse will be returned.
func (p *ServerCommunicationLinksClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerCommunicationLinksClientCreateOrUpdateResponse, error) {
	respType := ServerCommunicationLinksClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerCommunicationLink)
	if err != nil {
		return ServerCommunicationLinksClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerCommunicationLinksClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerConnectionPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerConnectionPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerConnectionPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerConnectionPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerConnectionPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ServerConnectionPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerConnectionPoliciesClientCreateOrUpdateResponse, error) {
	respType := ServerConnectionPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerConnectionPolicy)
	if err != nil {
		return ServerConnectionPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerConnectionPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesClientAcquirePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesClientAcquirePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesClientAcquirePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesClientAcquirePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesClientAcquireResponse will be returned.
func (p *ServerDNSAliasesClientAcquirePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesClientAcquireResponse, error) {
	respType := ServerDNSAliasesClientAcquireResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesClientAcquireResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesClientAcquirePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesClientCreateOrUpdateResponse will be returned.
func (p *ServerDNSAliasesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesClientCreateOrUpdateResponse, error) {
	respType := ServerDNSAliasesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDNSAliasesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDNSAliasesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDNSAliasesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDNSAliasesClientDeleteResponse will be returned.
func (p *ServerDNSAliasesClientDeletePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesClientDeleteResponse, error) {
	respType := ServerDNSAliasesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerDNSAliasesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDNSAliasesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerDevOpsAuditSettingsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDevOpsAuditSettingsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerDevOpsAuditSettingsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerDevOpsAuditSettingsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerDevOpsAuditSettingsClientCreateOrUpdateResponse will be returned.
func (p *ServerDevOpsAuditSettingsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDevOpsAuditSettingsClientCreateOrUpdateResponse, error) {
	respType := ServerDevOpsAuditSettingsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDevOpsAuditingSettings)
	if err != nil {
		return ServerDevOpsAuditSettingsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerDevOpsAuditSettingsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerKeysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerKeysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerKeysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerKeysClientCreateOrUpdateResponse will be returned.
func (p *ServerKeysClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerKeysClientCreateOrUpdateResponse, error) {
	respType := ServerKeysClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerKey)
	if err != nil {
		return ServerKeysClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerKeysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerKeysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerKeysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerKeysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerKeysClientDeleteResponse will be returned.
func (p *ServerKeysClientDeletePoller) FinalResponse(ctx context.Context) (ServerKeysClientDeleteResponse, error) {
	respType := ServerKeysClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerKeysClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerKeysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerSecurityAlertPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerSecurityAlertPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerSecurityAlertPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerSecurityAlertPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerSecurityAlertPoliciesClientCreateOrUpdateResponse will be returned.
func (p *ServerSecurityAlertPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerSecurityAlertPoliciesClientCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return ServerSecurityAlertPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerSecurityAlertPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerTrustGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerTrustGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerTrustGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerTrustGroupsClientCreateOrUpdateResponse will be returned.
func (p *ServerTrustGroupsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsClientCreateOrUpdateResponse, error) {
	respType := ServerTrustGroupsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerTrustGroup)
	if err != nil {
		return ServerTrustGroupsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerTrustGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServerTrustGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServerTrustGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServerTrustGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServerTrustGroupsClientDeleteResponse will be returned.
func (p *ServerTrustGroupsClientDeletePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsClientDeleteResponse, error) {
	respType := ServerTrustGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerTrustGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServerTrustGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersClientCreateOrUpdateResponse will be returned.
func (p *ServersClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServersClientCreateOrUpdateResponse, error) {
	respType := ServersClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersClientDeleteResponse will be returned.
func (p *ServersClientDeletePoller) FinalResponse(ctx context.Context) (ServersClientDeleteResponse, error) {
	respType := ServersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersClientImportDatabasePoller provides polling facilities until the operation reaches a terminal state.
type ServersClientImportDatabasePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersClientImportDatabasePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersClientImportDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersClientImportDatabaseResponse will be returned.
func (p *ServersClientImportDatabasePoller) FinalResponse(ctx context.Context) (ServersClientImportDatabaseResponse, error) {
	respType := ServersClientImportDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return ServersClientImportDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersClientImportDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ServersClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServersClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ServersClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ServersClientUpdateResponse will be returned.
func (p *ServersClientUpdatePoller) FinalResponse(ctx context.Context) (ServersClientUpdateResponse, error) {
	respType := ServersClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ServersClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncAgentsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncAgentsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncAgentsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncAgentsClientCreateOrUpdateResponse will be returned.
func (p *SyncAgentsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncAgentsClientCreateOrUpdateResponse, error) {
	respType := SyncAgentsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncAgent)
	if err != nil {
		return SyncAgentsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncAgentsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncAgentsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncAgentsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncAgentsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncAgentsClientDeleteResponse will be returned.
func (p *SyncAgentsClientDeletePoller) FinalResponse(ctx context.Context) (SyncAgentsClientDeleteResponse, error) {
	respType := SyncAgentsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncAgentsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncAgentsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsClientCreateOrUpdateResponse will be returned.
func (p *SyncGroupsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsClientCreateOrUpdateResponse, error) {
	respType := SyncGroupsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsClientDeleteResponse will be returned.
func (p *SyncGroupsClientDeletePoller) FinalResponse(ctx context.Context) (SyncGroupsClientDeleteResponse, error) {
	respType := SyncGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsClientRefreshHubSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsClientRefreshHubSchemaPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsClientRefreshHubSchemaPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsClientRefreshHubSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsClientRefreshHubSchemaResponse will be returned.
func (p *SyncGroupsClientRefreshHubSchemaPoller) FinalResponse(ctx context.Context) (SyncGroupsClientRefreshHubSchemaResponse, error) {
	respType := SyncGroupsClientRefreshHubSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsClientRefreshHubSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsClientRefreshHubSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncGroupsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncGroupsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncGroupsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncGroupsClientUpdateResponse will be returned.
func (p *SyncGroupsClientUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsClientUpdateResponse, error) {
	respType := SyncGroupsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncGroupsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersClientCreateOrUpdateResponse will be returned.
func (p *SyncMembersClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersClientCreateOrUpdateResponse, error) {
	respType := SyncMembersClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersClientDeleteResponse will be returned.
func (p *SyncMembersClientDeletePoller) FinalResponse(ctx context.Context) (SyncMembersClientDeleteResponse, error) {
	respType := SyncMembersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersClientRefreshMemberSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersClientRefreshMemberSchemaPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersClientRefreshMemberSchemaPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersClientRefreshMemberSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersClientRefreshMemberSchemaResponse will be returned.
func (p *SyncMembersClientRefreshMemberSchemaPoller) FinalResponse(ctx context.Context) (SyncMembersClientRefreshMemberSchemaResponse, error) {
	respType := SyncMembersClientRefreshMemberSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersClientRefreshMemberSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersClientRefreshMemberSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SyncMembersClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SyncMembersClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SyncMembersClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SyncMembersClientUpdateResponse will be returned.
func (p *SyncMembersClientUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersClientUpdateResponse, error) {
	respType := SyncMembersClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SyncMembersClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TdeCertificatesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type TdeCertificatesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TdeCertificatesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TdeCertificatesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TdeCertificatesClientCreateResponse will be returned.
func (p *TdeCertificatesClientCreatePoller) FinalResponse(ctx context.Context) (TdeCertificatesClientCreateResponse, error) {
	respType := TdeCertificatesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TdeCertificatesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TdeCertificatesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualClustersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualClustersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualClustersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualClustersClientDeleteResponse will be returned.
func (p *VirtualClustersClientDeletePoller) FinalResponse(ctx context.Context) (VirtualClustersClientDeleteResponse, error) {
	respType := VirtualClustersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualClustersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualClustersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualClustersClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualClustersClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualClustersClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualClustersClientUpdateResponse will be returned.
func (p *VirtualClustersClientUpdatePoller) FinalResponse(ctx context.Context) (VirtualClustersClientUpdateResponse, error) {
	respType := VirtualClustersClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualCluster)
	if err != nil {
		return VirtualClustersClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualClustersClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkRulesClientCreateOrUpdateResponse will be returned.
func (p *VirtualNetworkRulesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkRule)
	if err != nil {
		return VirtualNetworkRulesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VirtualNetworkRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VirtualNetworkRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VirtualNetworkRulesClientDeleteResponse will be returned.
func (p *VirtualNetworkRulesClientDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesClientDeleteResponse, error) {
	respType := VirtualNetworkRulesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkRulesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VirtualNetworkRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadClassifiersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadClassifiersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadClassifiersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadClassifiersClientCreateOrUpdateResponse will be returned.
func (p *WorkloadClassifiersClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersClientCreateOrUpdateResponse, error) {
	respType := WorkloadClassifiersClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadClassifier)
	if err != nil {
		return WorkloadClassifiersClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadClassifiersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadClassifiersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadClassifiersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadClassifiersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadClassifiersClientDeleteResponse will be returned.
func (p *WorkloadClassifiersClientDeletePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersClientDeleteResponse, error) {
	respType := WorkloadClassifiersClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadClassifiersClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadClassifiersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadGroupsClientCreateOrUpdateResponse will be returned.
func (p *WorkloadGroupsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadGroupsClientCreateOrUpdateResponse, error) {
	respType := WorkloadGroupsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadGroup)
	if err != nil {
		return WorkloadGroupsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkloadGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkloadGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkloadGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkloadGroupsClientDeleteResponse will be returned.
func (p *WorkloadGroupsClientDeletePoller) FinalResponse(ctx context.Context) (WorkloadGroupsClientDeleteResponse, error) {
	respType := WorkloadGroupsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadGroupsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkloadGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
