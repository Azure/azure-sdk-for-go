//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// BackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse contains the response from method BackupShortTermRetentionPolicies.CreateOrUpdate.
type BackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupShortTermRetentionPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupShortTermRetentionPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &BackupShortTermRetentionPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupShortTermRetentionPoliciesCreateOrUpdateResponse contains the response from method BackupShortTermRetentionPolicies.CreateOrUpdate.
type BackupShortTermRetentionPoliciesCreateOrUpdateResponse struct {
	BackupShortTermRetentionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupShortTermRetentionPoliciesCreateOrUpdateResult contains the result from method BackupShortTermRetentionPolicies.CreateOrUpdate.
type BackupShortTermRetentionPoliciesCreateOrUpdateResult struct {
	BackupShortTermRetentionPolicy
}

// BackupShortTermRetentionPoliciesGetResponse contains the response from method BackupShortTermRetentionPolicies.Get.
type BackupShortTermRetentionPoliciesGetResponse struct {
	BackupShortTermRetentionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupShortTermRetentionPoliciesGetResult contains the result from method BackupShortTermRetentionPolicies.Get.
type BackupShortTermRetentionPoliciesGetResult struct {
	BackupShortTermRetentionPolicy
}

// BackupShortTermRetentionPoliciesListByDatabaseResponse contains the response from method BackupShortTermRetentionPolicies.ListByDatabase.
type BackupShortTermRetentionPoliciesListByDatabaseResponse struct {
	BackupShortTermRetentionPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupShortTermRetentionPoliciesListByDatabaseResult contains the result from method BackupShortTermRetentionPolicies.ListByDatabase.
type BackupShortTermRetentionPoliciesListByDatabaseResult struct {
	BackupShortTermRetentionPolicyListResult
}

// BackupShortTermRetentionPoliciesUpdatePollerResponse contains the response from method BackupShortTermRetentionPolicies.Update.
type BackupShortTermRetentionPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BackupShortTermRetentionPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BackupShortTermRetentionPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BackupShortTermRetentionPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *BackupShortTermRetentionPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *BackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BackupShortTermRetentionPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &BackupShortTermRetentionPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BackupShortTermRetentionPoliciesUpdateResponse contains the response from method BackupShortTermRetentionPolicies.Update.
type BackupShortTermRetentionPoliciesUpdateResponse struct {
	BackupShortTermRetentionPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BackupShortTermRetentionPoliciesUpdateResult contains the result from method BackupShortTermRetentionPolicies.Update.
type BackupShortTermRetentionPoliciesUpdateResult struct {
	BackupShortTermRetentionPolicy
}

// CapabilitiesListByLocationResponse contains the response from method Capabilities.ListByLocation.
type CapabilitiesListByLocationResponse struct {
	CapabilitiesListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CapabilitiesListByLocationResult contains the result from method Capabilities.ListByLocation.
type CapabilitiesListByLocationResult struct {
	LocationCapabilities
}

// DataMaskingPoliciesCreateOrUpdateResponse contains the response from method DataMaskingPolicies.CreateOrUpdate.
type DataMaskingPoliciesCreateOrUpdateResponse struct {
	DataMaskingPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataMaskingPoliciesCreateOrUpdateResult contains the result from method DataMaskingPolicies.CreateOrUpdate.
type DataMaskingPoliciesCreateOrUpdateResult struct {
	DataMaskingPolicy
}

// DataMaskingPoliciesGetResponse contains the response from method DataMaskingPolicies.Get.
type DataMaskingPoliciesGetResponse struct {
	DataMaskingPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataMaskingPoliciesGetResult contains the result from method DataMaskingPolicies.Get.
type DataMaskingPoliciesGetResult struct {
	DataMaskingPolicy
}

// DataMaskingRulesCreateOrUpdateResponse contains the response from method DataMaskingRules.CreateOrUpdate.
type DataMaskingRulesCreateOrUpdateResponse struct {
	DataMaskingRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataMaskingRulesCreateOrUpdateResult contains the result from method DataMaskingRules.CreateOrUpdate.
type DataMaskingRulesCreateOrUpdateResult struct {
	DataMaskingRule
}

// DataMaskingRulesListByDatabaseResponse contains the response from method DataMaskingRules.ListByDatabase.
type DataMaskingRulesListByDatabaseResponse struct {
	DataMaskingRulesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataMaskingRulesListByDatabaseResult contains the result from method DataMaskingRules.ListByDatabase.
type DataMaskingRulesListByDatabaseResult struct {
	DataMaskingRuleListResult
}

// DataWarehouseUserActivitiesGetResponse contains the response from method DataWarehouseUserActivities.Get.
type DataWarehouseUserActivitiesGetResponse struct {
	DataWarehouseUserActivitiesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataWarehouseUserActivitiesGetResult contains the result from method DataWarehouseUserActivities.Get.
type DataWarehouseUserActivitiesGetResult struct {
	DataWarehouseUserActivities
}

// DataWarehouseUserActivitiesListByDatabaseResponse contains the response from method DataWarehouseUserActivities.ListByDatabase.
type DataWarehouseUserActivitiesListByDatabaseResponse struct {
	DataWarehouseUserActivitiesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataWarehouseUserActivitiesListByDatabaseResult contains the result from method DataWarehouseUserActivities.ListByDatabase.
type DataWarehouseUserActivitiesListByDatabaseResult struct {
	DataWarehouseUserActivitiesListResult
}

// DatabaseAdvisorsGetResponse contains the response from method DatabaseAdvisors.Get.
type DatabaseAdvisorsGetResponse struct {
	DatabaseAdvisorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAdvisorsGetResult contains the result from method DatabaseAdvisors.Get.
type DatabaseAdvisorsGetResult struct {
	Advisor
}

// DatabaseAdvisorsListByDatabaseResponse contains the response from method DatabaseAdvisors.ListByDatabase.
type DatabaseAdvisorsListByDatabaseResponse struct {
	DatabaseAdvisorsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAdvisorsListByDatabaseResult contains the result from method DatabaseAdvisors.ListByDatabase.
type DatabaseAdvisorsListByDatabaseResult struct {
	// Array of Advisor
	AdvisorArray []*Advisor
}

// DatabaseAdvisorsUpdateResponse contains the response from method DatabaseAdvisors.Update.
type DatabaseAdvisorsUpdateResponse struct {
	DatabaseAdvisorsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAdvisorsUpdateResult contains the result from method DatabaseAdvisors.Update.
type DatabaseAdvisorsUpdateResult struct {
	Advisor
}

// DatabaseAutomaticTuningGetResponse contains the response from method DatabaseAutomaticTuning.Get.
type DatabaseAutomaticTuningGetResponse struct {
	DatabaseAutomaticTuningGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAutomaticTuningGetResult contains the result from method DatabaseAutomaticTuning.Get.
type DatabaseAutomaticTuningGetResult struct {
	DatabaseAutomaticTuning
}

// DatabaseAutomaticTuningUpdateResponse contains the response from method DatabaseAutomaticTuning.Update.
type DatabaseAutomaticTuningUpdateResponse struct {
	DatabaseAutomaticTuningUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseAutomaticTuningUpdateResult contains the result from method DatabaseAutomaticTuning.Update.
type DatabaseAutomaticTuningUpdateResult struct {
	DatabaseAutomaticTuning
}

// DatabaseBlobAuditingPoliciesCreateOrUpdateResponse contains the response from method DatabaseBlobAuditingPolicies.CreateOrUpdate.
type DatabaseBlobAuditingPoliciesCreateOrUpdateResponse struct {
	DatabaseBlobAuditingPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseBlobAuditingPoliciesCreateOrUpdateResult contains the result from method DatabaseBlobAuditingPolicies.CreateOrUpdate.
type DatabaseBlobAuditingPoliciesCreateOrUpdateResult struct {
	DatabaseBlobAuditingPolicy
}

// DatabaseBlobAuditingPoliciesGetResponse contains the response from method DatabaseBlobAuditingPolicies.Get.
type DatabaseBlobAuditingPoliciesGetResponse struct {
	DatabaseBlobAuditingPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseBlobAuditingPoliciesGetResult contains the result from method DatabaseBlobAuditingPolicies.Get.
type DatabaseBlobAuditingPoliciesGetResult struct {
	DatabaseBlobAuditingPolicy
}

// DatabaseBlobAuditingPoliciesListByDatabaseResponse contains the response from method DatabaseBlobAuditingPolicies.ListByDatabase.
type DatabaseBlobAuditingPoliciesListByDatabaseResponse struct {
	DatabaseBlobAuditingPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseBlobAuditingPoliciesListByDatabaseResult contains the result from method DatabaseBlobAuditingPolicies.ListByDatabase.
type DatabaseBlobAuditingPoliciesListByDatabaseResult struct {
	DatabaseBlobAuditingPolicyListResult
}

// DatabaseColumnsGetResponse contains the response from method DatabaseColumns.Get.
type DatabaseColumnsGetResponse struct {
	DatabaseColumnsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseColumnsGetResult contains the result from method DatabaseColumns.Get.
type DatabaseColumnsGetResult struct {
	DatabaseColumn
}

// DatabaseColumnsListByDatabaseResponse contains the response from method DatabaseColumns.ListByDatabase.
type DatabaseColumnsListByDatabaseResponse struct {
	DatabaseColumnsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseColumnsListByDatabaseResult contains the result from method DatabaseColumns.ListByDatabase.
type DatabaseColumnsListByDatabaseResult struct {
	DatabaseColumnListResult
}

// DatabaseColumnsListByTableResponse contains the response from method DatabaseColumns.ListByTable.
type DatabaseColumnsListByTableResponse struct {
	DatabaseColumnsListByTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseColumnsListByTableResult contains the result from method DatabaseColumns.ListByTable.
type DatabaseColumnsListByTableResult struct {
	DatabaseColumnListResult
}

// DatabaseExtensionsCreateOrUpdatePollerResponse contains the response from method DatabaseExtensions.CreateOrUpdate.
type DatabaseExtensionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseExtensionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseExtensionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseExtensionsCreateOrUpdateResponse, error) {
	respType := DatabaseExtensionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ImportExportExtensionsOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseExtensionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseExtensionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseExtensionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseExtensionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseExtensionsCreateOrUpdateResponse contains the response from method DatabaseExtensions.CreateOrUpdate.
type DatabaseExtensionsCreateOrUpdateResponse struct {
	DatabaseExtensionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseExtensionsCreateOrUpdateResult contains the result from method DatabaseExtensions.CreateOrUpdate.
type DatabaseExtensionsCreateOrUpdateResult struct {
	ImportExportExtensionsOperationResult
}

// DatabaseExtensionsGetResponse contains the response from method DatabaseExtensions.Get.
type DatabaseExtensionsGetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseExtensionsListByDatabaseResponse contains the response from method DatabaseExtensions.ListByDatabase.
type DatabaseExtensionsListByDatabaseResponse struct {
	DatabaseExtensionsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseExtensionsListByDatabaseResult contains the result from method DatabaseExtensions.ListByDatabase.
type DatabaseExtensionsListByDatabaseResult struct {
	ImportExportExtensionsOperationListResult
}

// DatabaseOperationsCancelResponse contains the response from method DatabaseOperations.Cancel.
type DatabaseOperationsCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseOperationsListByDatabaseResponse contains the response from method DatabaseOperations.ListByDatabase.
type DatabaseOperationsListByDatabaseResponse struct {
	DatabaseOperationsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseOperationsListByDatabaseResult contains the result from method DatabaseOperations.ListByDatabase.
type DatabaseOperationsListByDatabaseResult struct {
	DatabaseOperationListResult
}

// DatabaseRecommendedActionsGetResponse contains the response from method DatabaseRecommendedActions.Get.
type DatabaseRecommendedActionsGetResponse struct {
	DatabaseRecommendedActionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseRecommendedActionsGetResult contains the result from method DatabaseRecommendedActions.Get.
type DatabaseRecommendedActionsGetResult struct {
	RecommendedAction
}

// DatabaseRecommendedActionsListByDatabaseAdvisorResponse contains the response from method DatabaseRecommendedActions.ListByDatabaseAdvisor.
type DatabaseRecommendedActionsListByDatabaseAdvisorResponse struct {
	DatabaseRecommendedActionsListByDatabaseAdvisorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseRecommendedActionsListByDatabaseAdvisorResult contains the result from method DatabaseRecommendedActions.ListByDatabaseAdvisor.
type DatabaseRecommendedActionsListByDatabaseAdvisorResult struct {
	// Array of RecommendedAction
	RecommendedActionArray []*RecommendedAction
}

// DatabaseRecommendedActionsUpdateResponse contains the response from method DatabaseRecommendedActions.Update.
type DatabaseRecommendedActionsUpdateResponse struct {
	DatabaseRecommendedActionsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseRecommendedActionsUpdateResult contains the result from method DatabaseRecommendedActions.Update.
type DatabaseRecommendedActionsUpdateResult struct {
	RecommendedAction
}

// DatabaseSchemasGetResponse contains the response from method DatabaseSchemas.Get.
type DatabaseSchemasGetResponse struct {
	DatabaseSchemasGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseSchemasGetResult contains the result from method DatabaseSchemas.Get.
type DatabaseSchemasGetResult struct {
	DatabaseSchema
}

// DatabaseSchemasListByDatabaseResponse contains the response from method DatabaseSchemas.ListByDatabase.
type DatabaseSchemasListByDatabaseResponse struct {
	DatabaseSchemasListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseSchemasListByDatabaseResult contains the result from method DatabaseSchemas.ListByDatabase.
type DatabaseSchemasListByDatabaseResult struct {
	DatabaseSchemaListResult
}

// DatabaseSecurityAlertPoliciesCreateOrUpdateResponse contains the response from method DatabaseSecurityAlertPolicies.CreateOrUpdate.
type DatabaseSecurityAlertPoliciesCreateOrUpdateResponse struct {
	DatabaseSecurityAlertPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseSecurityAlertPoliciesCreateOrUpdateResult contains the result from method DatabaseSecurityAlertPolicies.CreateOrUpdate.
type DatabaseSecurityAlertPoliciesCreateOrUpdateResult struct {
	DatabaseSecurityAlertPolicy
}

// DatabaseSecurityAlertPoliciesGetResponse contains the response from method DatabaseSecurityAlertPolicies.Get.
type DatabaseSecurityAlertPoliciesGetResponse struct {
	DatabaseSecurityAlertPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseSecurityAlertPoliciesGetResult contains the result from method DatabaseSecurityAlertPolicies.Get.
type DatabaseSecurityAlertPoliciesGetResult struct {
	DatabaseSecurityAlertPolicy
}

// DatabaseSecurityAlertPoliciesListByDatabaseResponse contains the response from method DatabaseSecurityAlertPolicies.ListByDatabase.
type DatabaseSecurityAlertPoliciesListByDatabaseResponse struct {
	DatabaseSecurityAlertPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseSecurityAlertPoliciesListByDatabaseResult contains the result from method DatabaseSecurityAlertPolicies.ListByDatabase.
type DatabaseSecurityAlertPoliciesListByDatabaseResult struct {
	DatabaseSecurityAlertListResult
}

// DatabaseTablesGetResponse contains the response from method DatabaseTables.Get.
type DatabaseTablesGetResponse struct {
	DatabaseTablesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseTablesGetResult contains the result from method DatabaseTables.Get.
type DatabaseTablesGetResult struct {
	DatabaseTable
}

// DatabaseTablesListBySchemaResponse contains the response from method DatabaseTables.ListBySchema.
type DatabaseTablesListBySchemaResponse struct {
	DatabaseTablesListBySchemaResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseTablesListBySchemaResult contains the result from method DatabaseTables.ListBySchema.
type DatabaseTablesListBySchemaResult struct {
	DatabaseTableListResult
}

// DatabaseUsagesListByDatabaseResponse contains the response from method DatabaseUsages.ListByDatabase.
type DatabaseUsagesListByDatabaseResponse struct {
	DatabaseUsagesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseUsagesListByDatabaseResult contains the result from method DatabaseUsages.ListByDatabase.
type DatabaseUsagesListByDatabaseResult struct {
	DatabaseUsageListResult
}

// DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse contains the response from method DatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate.
type DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse struct {
	DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult contains the result from method DatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate.
type DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult struct {
	DatabaseVulnerabilityAssessmentRuleBaseline
}

// DatabaseVulnerabilityAssessmentRuleBaselinesDeleteResponse contains the response from method DatabaseVulnerabilityAssessmentRuleBaselines.Delete.
type DatabaseVulnerabilityAssessmentRuleBaselinesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentRuleBaselinesGetResponse contains the response from method DatabaseVulnerabilityAssessmentRuleBaselines.Get.
type DatabaseVulnerabilityAssessmentRuleBaselinesGetResponse struct {
	DatabaseVulnerabilityAssessmentRuleBaselinesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentRuleBaselinesGetResult contains the result from method DatabaseVulnerabilityAssessmentRuleBaselines.Get.
type DatabaseVulnerabilityAssessmentRuleBaselinesGetResult struct {
	DatabaseVulnerabilityAssessmentRuleBaseline
}

// DatabaseVulnerabilityAssessmentScansExportResponse contains the response from method DatabaseVulnerabilityAssessmentScans.Export.
type DatabaseVulnerabilityAssessmentScansExportResponse struct {
	DatabaseVulnerabilityAssessmentScansExportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentScansExportResult contains the result from method DatabaseVulnerabilityAssessmentScans.Export.
type DatabaseVulnerabilityAssessmentScansExportResult struct {
	DatabaseVulnerabilityAssessmentScansExport
}

// DatabaseVulnerabilityAssessmentScansGetResponse contains the response from method DatabaseVulnerabilityAssessmentScans.Get.
type DatabaseVulnerabilityAssessmentScansGetResponse struct {
	DatabaseVulnerabilityAssessmentScansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentScansGetResult contains the result from method DatabaseVulnerabilityAssessmentScans.Get.
type DatabaseVulnerabilityAssessmentScansGetResult struct {
	VulnerabilityAssessmentScanRecord
}

// DatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse contains the response from method DatabaseVulnerabilityAssessmentScans.InitiateScan.
type DatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseVulnerabilityAssessmentScansInitiateScanPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse from the provided client and resume token.
func (l *DatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse) Resume(ctx context.Context, client *DatabaseVulnerabilityAssessmentScansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseVulnerabilityAssessmentScansClient.InitiateScan", token, client.pl, client.initiateScanHandleError)
	if err != nil {
		return err
	}
	poller := &DatabaseVulnerabilityAssessmentScansInitiateScanPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseVulnerabilityAssessmentScansInitiateScanResponse contains the response from method DatabaseVulnerabilityAssessmentScans.InitiateScan.
type DatabaseVulnerabilityAssessmentScansInitiateScanResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentScansListByDatabaseResponse contains the response from method DatabaseVulnerabilityAssessmentScans.ListByDatabase.
type DatabaseVulnerabilityAssessmentScansListByDatabaseResponse struct {
	DatabaseVulnerabilityAssessmentScansListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentScansListByDatabaseResult contains the result from method DatabaseVulnerabilityAssessmentScans.ListByDatabase.
type DatabaseVulnerabilityAssessmentScansListByDatabaseResult struct {
	VulnerabilityAssessmentScanRecordListResult
}

// DatabaseVulnerabilityAssessmentsCreateOrUpdateResponse contains the response from method DatabaseVulnerabilityAssessments.CreateOrUpdate.
type DatabaseVulnerabilityAssessmentsCreateOrUpdateResponse struct {
	DatabaseVulnerabilityAssessmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentsCreateOrUpdateResult contains the result from method DatabaseVulnerabilityAssessments.CreateOrUpdate.
type DatabaseVulnerabilityAssessmentsCreateOrUpdateResult struct {
	DatabaseVulnerabilityAssessment
}

// DatabaseVulnerabilityAssessmentsDeleteResponse contains the response from method DatabaseVulnerabilityAssessments.Delete.
type DatabaseVulnerabilityAssessmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentsGetResponse contains the response from method DatabaseVulnerabilityAssessments.Get.
type DatabaseVulnerabilityAssessmentsGetResponse struct {
	DatabaseVulnerabilityAssessmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentsGetResult contains the result from method DatabaseVulnerabilityAssessments.Get.
type DatabaseVulnerabilityAssessmentsGetResult struct {
	DatabaseVulnerabilityAssessment
}

// DatabaseVulnerabilityAssessmentsListByDatabaseResponse contains the response from method DatabaseVulnerabilityAssessments.ListByDatabase.
type DatabaseVulnerabilityAssessmentsListByDatabaseResponse struct {
	DatabaseVulnerabilityAssessmentsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseVulnerabilityAssessmentsListByDatabaseResult contains the result from method DatabaseVulnerabilityAssessments.ListByDatabase.
type DatabaseVulnerabilityAssessmentsListByDatabaseResult struct {
	DatabaseVulnerabilityAssessmentListResult
}

// DatabasesCreateOrUpdatePollerResponse contains the response from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesCreateOrUpdateResponse, error) {
	respType := DatabasesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesCreateOrUpdateResponse contains the response from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdateResponse struct {
	DatabasesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesCreateOrUpdateResult contains the result from method Databases.CreateOrUpdate.
type DatabasesCreateOrUpdateResult struct {
	Database
}

// DatabasesDeletePollerResponse contains the response from method Databases.Delete.
type DatabasesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesDeleteResponse, error) {
	respType := DatabasesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesDeletePollerResponse from the provided client and resume token.
func (l *DatabasesDeletePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesDeleteResponse contains the response from method Databases.Delete.
type DatabasesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesExportPollerResponse contains the response from method Databases.Export.
type DatabasesExportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesExportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesExportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesExportResponse, error) {
	respType := DatabasesExportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesExportPollerResponse from the provided client and resume token.
func (l *DatabasesExportPollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Export", token, client.pl, client.exportHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesExportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesExportResponse contains the response from method Databases.Export.
type DatabasesExportResponse struct {
	DatabasesExportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesExportResult contains the result from method Databases.Export.
type DatabasesExportResult struct {
	ImportExportOperationResult
}

// DatabasesFailoverPollerResponse contains the response from method Databases.Failover.
type DatabasesFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesFailoverResponse, error) {
	respType := DatabasesFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesFailoverPollerResponse from the provided client and resume token.
func (l *DatabasesFailoverPollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesFailoverResponse contains the response from method Databases.Failover.
type DatabasesFailoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesGetResponse contains the response from method Databases.Get.
type DatabasesGetResponse struct {
	DatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesGetResult contains the result from method Databases.Get.
type DatabasesGetResult struct {
	Database
}

// DatabasesImportPollerResponse contains the response from method Databases.Import.
type DatabasesImportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesImportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesImportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesImportResponse, error) {
	respType := DatabasesImportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesImportPollerResponse from the provided client and resume token.
func (l *DatabasesImportPollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Import", token, client.pl, client.importHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesImportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesImportResponse contains the response from method Databases.Import.
type DatabasesImportResponse struct {
	DatabasesImportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesImportResult contains the result from method Databases.Import.
type DatabasesImportResult struct {
	ImportExportOperationResult
}

// DatabasesListByElasticPoolResponse contains the response from method Databases.ListByElasticPool.
type DatabasesListByElasticPoolResponse struct {
	DatabasesListByElasticPoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListByElasticPoolResult contains the result from method Databases.ListByElasticPool.
type DatabasesListByElasticPoolResult struct {
	DatabaseListResult
}

// DatabasesListByServerResponse contains the response from method Databases.ListByServer.
type DatabasesListByServerResponse struct {
	DatabasesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListByServerResult contains the result from method Databases.ListByServer.
type DatabasesListByServerResult struct {
	DatabaseListResult
}

// DatabasesListInaccessibleByServerResponse contains the response from method Databases.ListInaccessibleByServer.
type DatabasesListInaccessibleByServerResponse struct {
	DatabasesListInaccessibleByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListInaccessibleByServerResult contains the result from method Databases.ListInaccessibleByServer.
type DatabasesListInaccessibleByServerResult struct {
	DatabaseListResult
}

// DatabasesListMetricDefinitionsResponse contains the response from method Databases.ListMetricDefinitions.
type DatabasesListMetricDefinitionsResponse struct {
	DatabasesListMetricDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListMetricDefinitionsResult contains the result from method Databases.ListMetricDefinitions.
type DatabasesListMetricDefinitionsResult struct {
	MetricDefinitionListResult
}

// DatabasesListMetricsResponse contains the response from method Databases.ListMetrics.
type DatabasesListMetricsResponse struct {
	DatabasesListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesListMetricsResult contains the result from method Databases.ListMetrics.
type DatabasesListMetricsResult struct {
	MetricListResult
}

// DatabasesPausePollerResponse contains the response from method Databases.Pause.
type DatabasesPausePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesPausePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesPausePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesPauseResponse, error) {
	respType := DatabasesPauseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesPausePollerResponse from the provided client and resume token.
func (l *DatabasesPausePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Pause", token, client.pl, client.pauseHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesPausePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesPauseResponse contains the response from method Databases.Pause.
type DatabasesPauseResponse struct {
	DatabasesPauseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesPauseResult contains the result from method Databases.Pause.
type DatabasesPauseResult struct {
	Database
}

// DatabasesRenameResponse contains the response from method Databases.Rename.
type DatabasesRenameResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesResumePollerResponse contains the response from method Databases.Resume.
type DatabasesResumePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesResumePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesResumePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesResumeResponse, error) {
	respType := DatabasesResumeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesResumePollerResponse from the provided client and resume token.
func (l *DatabasesResumePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Resume", token, client.pl, client.resumeHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesResumePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesResumeResponse contains the response from method Databases.Resume.
type DatabasesResumeResponse struct {
	DatabasesResumeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesResumeResult contains the result from method Databases.Resume.
type DatabasesResumeResult struct {
	Database
}

// DatabasesUpdatePollerResponse contains the response from method Databases.Update.
type DatabasesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesUpdateResponse, error) {
	respType := DatabasesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesUpdatePollerResponse from the provided client and resume token.
func (l *DatabasesUpdatePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesUpdateResponse contains the response from method Databases.Update.
type DatabasesUpdateResponse struct {
	DatabasesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabasesUpdateResult contains the result from method Databases.Update.
type DatabasesUpdateResult struct {
	Database
}

// DatabasesUpgradeDataWarehousePollerResponse contains the response from method Databases.UpgradeDataWarehouse.
type DatabasesUpgradeDataWarehousePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabasesUpgradeDataWarehousePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabasesUpgradeDataWarehousePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabasesUpgradeDataWarehouseResponse, error) {
	respType := DatabasesUpgradeDataWarehouseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabasesUpgradeDataWarehousePollerResponse from the provided client and resume token.
func (l *DatabasesUpgradeDataWarehousePollerResponse) Resume(ctx context.Context, client *DatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabasesClient.UpgradeDataWarehouse", token, client.pl, client.upgradeDataWarehouseHandleError)
	if err != nil {
		return err
	}
	poller := &DatabasesUpgradeDataWarehousePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabasesUpgradeDataWarehouseResponse contains the response from method Databases.UpgradeDataWarehouse.
type DatabasesUpgradeDataWarehouseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeletedServersGetResponse contains the response from method DeletedServers.Get.
type DeletedServersGetResponse struct {
	DeletedServersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeletedServersGetResult contains the result from method DeletedServers.Get.
type DeletedServersGetResult struct {
	DeletedServer
}

// DeletedServersListByLocationResponse contains the response from method DeletedServers.ListByLocation.
type DeletedServersListByLocationResponse struct {
	DeletedServersListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeletedServersListByLocationResult contains the result from method DeletedServers.ListByLocation.
type DeletedServersListByLocationResult struct {
	DeletedServerListResult
}

// DeletedServersListResponse contains the response from method DeletedServers.List.
type DeletedServersListResponse struct {
	DeletedServersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeletedServersListResult contains the result from method DeletedServers.List.
type DeletedServersListResult struct {
	DeletedServerListResult
}

// DeletedServersRecoverPollerResponse contains the response from method DeletedServers.Recover.
type DeletedServersRecoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DeletedServersRecoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DeletedServersRecoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DeletedServersRecoverResponse, error) {
	respType := DeletedServersRecoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DeletedServer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DeletedServersRecoverPollerResponse from the provided client and resume token.
func (l *DeletedServersRecoverPollerResponse) Resume(ctx context.Context, client *DeletedServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DeletedServersClient.Recover", token, client.pl, client.recoverHandleError)
	if err != nil {
		return err
	}
	poller := &DeletedServersRecoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DeletedServersRecoverResponse contains the response from method DeletedServers.Recover.
type DeletedServersRecoverResponse struct {
	DeletedServersRecoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DeletedServersRecoverResult contains the result from method DeletedServers.Recover.
type DeletedServersRecoverResult struct {
	DeletedServer
}

// ElasticPoolActivitiesListByElasticPoolResponse contains the response from method ElasticPoolActivities.ListByElasticPool.
type ElasticPoolActivitiesListByElasticPoolResponse struct {
	ElasticPoolActivitiesListByElasticPoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolActivitiesListByElasticPoolResult contains the result from method ElasticPoolActivities.ListByElasticPool.
type ElasticPoolActivitiesListByElasticPoolResult struct {
	ElasticPoolActivityListResult
}

// ElasticPoolDatabaseActivitiesListByElasticPoolResponse contains the response from method ElasticPoolDatabaseActivities.ListByElasticPool.
type ElasticPoolDatabaseActivitiesListByElasticPoolResponse struct {
	ElasticPoolDatabaseActivitiesListByElasticPoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolDatabaseActivitiesListByElasticPoolResult contains the result from method ElasticPoolDatabaseActivities.ListByElasticPool.
type ElasticPoolDatabaseActivitiesListByElasticPoolResult struct {
	ElasticPoolDatabaseActivityListResult
}

// ElasticPoolOperationsCancelResponse contains the response from method ElasticPoolOperations.Cancel.
type ElasticPoolOperationsCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolOperationsListByElasticPoolResponse contains the response from method ElasticPoolOperations.ListByElasticPool.
type ElasticPoolOperationsListByElasticPoolResponse struct {
	ElasticPoolOperationsListByElasticPoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolOperationsListByElasticPoolResult contains the result from method ElasticPoolOperations.ListByElasticPool.
type ElasticPoolOperationsListByElasticPoolResult struct {
	ElasticPoolOperationListResult
}

// ElasticPoolsCreateOrUpdatePollerResponse contains the response from method ElasticPools.CreateOrUpdate.
type ElasticPoolsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ElasticPoolsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ElasticPoolsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsCreateOrUpdateResponse, error) {
	respType := ElasticPoolsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ElasticPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ElasticPoolsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ElasticPoolsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ElasticPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ElasticPoolsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ElasticPoolsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ElasticPoolsCreateOrUpdateResponse contains the response from method ElasticPools.CreateOrUpdate.
type ElasticPoolsCreateOrUpdateResponse struct {
	ElasticPoolsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsCreateOrUpdateResult contains the result from method ElasticPools.CreateOrUpdate.
type ElasticPoolsCreateOrUpdateResult struct {
	ElasticPool
}

// ElasticPoolsDeletePollerResponse contains the response from method ElasticPools.Delete.
type ElasticPoolsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ElasticPoolsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ElasticPoolsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsDeleteResponse, error) {
	respType := ElasticPoolsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ElasticPoolsDeletePollerResponse from the provided client and resume token.
func (l *ElasticPoolsDeletePollerResponse) Resume(ctx context.Context, client *ElasticPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ElasticPoolsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ElasticPoolsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ElasticPoolsDeleteResponse contains the response from method ElasticPools.Delete.
type ElasticPoolsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsFailoverPollerResponse contains the response from method ElasticPools.Failover.
type ElasticPoolsFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ElasticPoolsFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ElasticPoolsFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsFailoverResponse, error) {
	respType := ElasticPoolsFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ElasticPoolsFailoverPollerResponse from the provided client and resume token.
func (l *ElasticPoolsFailoverPollerResponse) Resume(ctx context.Context, client *ElasticPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ElasticPoolsClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &ElasticPoolsFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ElasticPoolsFailoverResponse contains the response from method ElasticPools.Failover.
type ElasticPoolsFailoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsGetResponse contains the response from method ElasticPools.Get.
type ElasticPoolsGetResponse struct {
	ElasticPoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsGetResult contains the result from method ElasticPools.Get.
type ElasticPoolsGetResult struct {
	ElasticPool
}

// ElasticPoolsListByServerResponse contains the response from method ElasticPools.ListByServer.
type ElasticPoolsListByServerResponse struct {
	ElasticPoolsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsListByServerResult contains the result from method ElasticPools.ListByServer.
type ElasticPoolsListByServerResult struct {
	ElasticPoolListResult
}

// ElasticPoolsListMetricDefinitionsResponse contains the response from method ElasticPools.ListMetricDefinitions.
type ElasticPoolsListMetricDefinitionsResponse struct {
	ElasticPoolsListMetricDefinitionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsListMetricDefinitionsResult contains the result from method ElasticPools.ListMetricDefinitions.
type ElasticPoolsListMetricDefinitionsResult struct {
	MetricDefinitionListResult
}

// ElasticPoolsListMetricsResponse contains the response from method ElasticPools.ListMetrics.
type ElasticPoolsListMetricsResponse struct {
	ElasticPoolsListMetricsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsListMetricsResult contains the result from method ElasticPools.ListMetrics.
type ElasticPoolsListMetricsResult struct {
	MetricListResult
}

// ElasticPoolsUpdatePollerResponse contains the response from method ElasticPools.Update.
type ElasticPoolsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ElasticPoolsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ElasticPoolsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsUpdateResponse, error) {
	respType := ElasticPoolsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ElasticPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ElasticPoolsUpdatePollerResponse from the provided client and resume token.
func (l *ElasticPoolsUpdatePollerResponse) Resume(ctx context.Context, client *ElasticPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ElasticPoolsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ElasticPoolsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ElasticPoolsUpdateResponse contains the response from method ElasticPools.Update.
type ElasticPoolsUpdateResponse struct {
	ElasticPoolsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ElasticPoolsUpdateResult contains the result from method ElasticPools.Update.
type ElasticPoolsUpdateResult struct {
	ElasticPool
}

// EncryptionProtectorsCreateOrUpdatePollerResponse contains the response from method EncryptionProtectors.CreateOrUpdate.
type EncryptionProtectorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EncryptionProtectorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EncryptionProtectorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := EncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.EncryptionProtector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EncryptionProtectorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *EncryptionProtectorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *EncryptionProtectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EncryptionProtectorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &EncryptionProtectorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EncryptionProtectorsCreateOrUpdateResponse contains the response from method EncryptionProtectors.CreateOrUpdate.
type EncryptionProtectorsCreateOrUpdateResponse struct {
	EncryptionProtectorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EncryptionProtectorsCreateOrUpdateResult contains the result from method EncryptionProtectors.CreateOrUpdate.
type EncryptionProtectorsCreateOrUpdateResult struct {
	EncryptionProtector
}

// EncryptionProtectorsGetResponse contains the response from method EncryptionProtectors.Get.
type EncryptionProtectorsGetResponse struct {
	EncryptionProtectorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EncryptionProtectorsGetResult contains the result from method EncryptionProtectors.Get.
type EncryptionProtectorsGetResult struct {
	EncryptionProtector
}

// EncryptionProtectorsListByServerResponse contains the response from method EncryptionProtectors.ListByServer.
type EncryptionProtectorsListByServerResponse struct {
	EncryptionProtectorsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// EncryptionProtectorsListByServerResult contains the result from method EncryptionProtectors.ListByServer.
type EncryptionProtectorsListByServerResult struct {
	EncryptionProtectorListResult
}

// EncryptionProtectorsRevalidatePollerResponse contains the response from method EncryptionProtectors.Revalidate.
type EncryptionProtectorsRevalidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EncryptionProtectorsRevalidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EncryptionProtectorsRevalidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EncryptionProtectorsRevalidateResponse, error) {
	respType := EncryptionProtectorsRevalidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a EncryptionProtectorsRevalidatePollerResponse from the provided client and resume token.
func (l *EncryptionProtectorsRevalidatePollerResponse) Resume(ctx context.Context, client *EncryptionProtectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EncryptionProtectorsClient.Revalidate", token, client.pl, client.revalidateHandleError)
	if err != nil {
		return err
	}
	poller := &EncryptionProtectorsRevalidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// EncryptionProtectorsRevalidateResponse contains the response from method EncryptionProtectors.Revalidate.
type EncryptionProtectorsRevalidateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResponse contains the response from method ExtendedDatabaseBlobAuditingPolicies.CreateOrUpdate.
type ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResponse struct {
	ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResult contains the result from method ExtendedDatabaseBlobAuditingPolicies.CreateOrUpdate.
type ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResult struct {
	ExtendedDatabaseBlobAuditingPolicy
}

// ExtendedDatabaseBlobAuditingPoliciesGetResponse contains the response from method ExtendedDatabaseBlobAuditingPolicies.Get.
type ExtendedDatabaseBlobAuditingPoliciesGetResponse struct {
	ExtendedDatabaseBlobAuditingPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedDatabaseBlobAuditingPoliciesGetResult contains the result from method ExtendedDatabaseBlobAuditingPolicies.Get.
type ExtendedDatabaseBlobAuditingPoliciesGetResult struct {
	ExtendedDatabaseBlobAuditingPolicy
}

// ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse contains the response from method ExtendedDatabaseBlobAuditingPolicies.ListByDatabase.
type ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse struct {
	ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResult contains the result from method ExtendedDatabaseBlobAuditingPolicies.ListByDatabase.
type ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResult struct {
	ExtendedDatabaseBlobAuditingPolicyListResult
}

// ExtendedServerBlobAuditingPoliciesCreateOrUpdatePollerResponse contains the response from method ExtendedServerBlobAuditingPolicies.CreateOrUpdate.
type ExtendedServerBlobAuditingPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExtendedServerBlobAuditingPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExtendedServerBlobAuditingPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExtendedServerBlobAuditingPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExtendedServerBlobAuditingPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExtendedServerBlobAuditingPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse contains the response from method ExtendedServerBlobAuditingPolicies.CreateOrUpdate.
type ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse struct {
	ExtendedServerBlobAuditingPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedServerBlobAuditingPoliciesCreateOrUpdateResult contains the result from method ExtendedServerBlobAuditingPolicies.CreateOrUpdate.
type ExtendedServerBlobAuditingPoliciesCreateOrUpdateResult struct {
	ExtendedServerBlobAuditingPolicy
}

// ExtendedServerBlobAuditingPoliciesGetResponse contains the response from method ExtendedServerBlobAuditingPolicies.Get.
type ExtendedServerBlobAuditingPoliciesGetResponse struct {
	ExtendedServerBlobAuditingPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedServerBlobAuditingPoliciesGetResult contains the result from method ExtendedServerBlobAuditingPolicies.Get.
type ExtendedServerBlobAuditingPoliciesGetResult struct {
	ExtendedServerBlobAuditingPolicy
}

// ExtendedServerBlobAuditingPoliciesListByServerResponse contains the response from method ExtendedServerBlobAuditingPolicies.ListByServer.
type ExtendedServerBlobAuditingPoliciesListByServerResponse struct {
	ExtendedServerBlobAuditingPoliciesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExtendedServerBlobAuditingPoliciesListByServerResult contains the result from method ExtendedServerBlobAuditingPolicies.ListByServer.
type ExtendedServerBlobAuditingPoliciesListByServerResult struct {
	ExtendedServerBlobAuditingPolicyListResult
}

// FailoverGroupsCreateOrUpdatePollerResponse contains the response from method FailoverGroups.CreateOrUpdate.
type FailoverGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FailoverGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FailoverGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsCreateOrUpdateResponse, error) {
	respType := FailoverGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FailoverGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FailoverGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FailoverGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &FailoverGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FailoverGroupsCreateOrUpdateResponse contains the response from method FailoverGroups.CreateOrUpdate.
type FailoverGroupsCreateOrUpdateResponse struct {
	FailoverGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsCreateOrUpdateResult contains the result from method FailoverGroups.CreateOrUpdate.
type FailoverGroupsCreateOrUpdateResult struct {
	FailoverGroup
}

// FailoverGroupsDeletePollerResponse contains the response from method FailoverGroups.Delete.
type FailoverGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FailoverGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FailoverGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsDeleteResponse, error) {
	respType := FailoverGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FailoverGroupsDeletePollerResponse from the provided client and resume token.
func (l *FailoverGroupsDeletePollerResponse) Resume(ctx context.Context, client *FailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FailoverGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &FailoverGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FailoverGroupsDeleteResponse contains the response from method FailoverGroups.Delete.
type FailoverGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsFailoverPollerResponse contains the response from method FailoverGroups.Failover.
type FailoverGroupsFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FailoverGroupsFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FailoverGroupsFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsFailoverResponse, error) {
	respType := FailoverGroupsFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FailoverGroupsFailoverPollerResponse from the provided client and resume token.
func (l *FailoverGroupsFailoverPollerResponse) Resume(ctx context.Context, client *FailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FailoverGroupsClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &FailoverGroupsFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FailoverGroupsFailoverResponse contains the response from method FailoverGroups.Failover.
type FailoverGroupsFailoverResponse struct {
	FailoverGroupsFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsFailoverResult contains the result from method FailoverGroups.Failover.
type FailoverGroupsFailoverResult struct {
	FailoverGroup
}

// FailoverGroupsForceFailoverAllowDataLossPollerResponse contains the response from method FailoverGroups.ForceFailoverAllowDataLoss.
type FailoverGroupsForceFailoverAllowDataLossPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FailoverGroupsForceFailoverAllowDataLossPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FailoverGroupsForceFailoverAllowDataLossPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := FailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FailoverGroupsForceFailoverAllowDataLossPollerResponse from the provided client and resume token.
func (l *FailoverGroupsForceFailoverAllowDataLossPollerResponse) Resume(ctx context.Context, client *FailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FailoverGroupsClient.ForceFailoverAllowDataLoss", token, client.pl, client.forceFailoverAllowDataLossHandleError)
	if err != nil {
		return err
	}
	poller := &FailoverGroupsForceFailoverAllowDataLossPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FailoverGroupsForceFailoverAllowDataLossResponse contains the response from method FailoverGroups.ForceFailoverAllowDataLoss.
type FailoverGroupsForceFailoverAllowDataLossResponse struct {
	FailoverGroupsForceFailoverAllowDataLossResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsForceFailoverAllowDataLossResult contains the result from method FailoverGroups.ForceFailoverAllowDataLoss.
type FailoverGroupsForceFailoverAllowDataLossResult struct {
	FailoverGroup
}

// FailoverGroupsGetResponse contains the response from method FailoverGroups.Get.
type FailoverGroupsGetResponse struct {
	FailoverGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsGetResult contains the result from method FailoverGroups.Get.
type FailoverGroupsGetResult struct {
	FailoverGroup
}

// FailoverGroupsListByServerResponse contains the response from method FailoverGroups.ListByServer.
type FailoverGroupsListByServerResponse struct {
	FailoverGroupsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsListByServerResult contains the result from method FailoverGroups.ListByServer.
type FailoverGroupsListByServerResult struct {
	FailoverGroupListResult
}

// FailoverGroupsUpdatePollerResponse contains the response from method FailoverGroups.Update.
type FailoverGroupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FailoverGroupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FailoverGroupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsUpdateResponse, error) {
	respType := FailoverGroupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FailoverGroupsUpdatePollerResponse from the provided client and resume token.
func (l *FailoverGroupsUpdatePollerResponse) Resume(ctx context.Context, client *FailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FailoverGroupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &FailoverGroupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FailoverGroupsUpdateResponse contains the response from method FailoverGroups.Update.
type FailoverGroupsUpdateResponse struct {
	FailoverGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FailoverGroupsUpdateResult contains the result from method FailoverGroups.Update.
type FailoverGroupsUpdateResult struct {
	FailoverGroup
}

// FirewallRulesCreateOrUpdateResponse contains the response from method FirewallRules.CreateOrUpdate.
type FirewallRulesCreateOrUpdateResponse struct {
	FirewallRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesCreateOrUpdateResult contains the result from method FirewallRules.CreateOrUpdate.
type FirewallRulesCreateOrUpdateResult struct {
	FirewallRule
}

// FirewallRulesDeleteResponse contains the response from method FirewallRules.Delete.
type FirewallRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesGetResponse contains the response from method FirewallRules.Get.
type FirewallRulesGetResponse struct {
	FirewallRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesGetResult contains the result from method FirewallRules.Get.
type FirewallRulesGetResult struct {
	FirewallRule
}

// FirewallRulesListByServerResponse contains the response from method FirewallRules.ListByServer.
type FirewallRulesListByServerResponse struct {
	FirewallRulesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesListByServerResult contains the result from method FirewallRules.ListByServer.
type FirewallRulesListByServerResult struct {
	FirewallRuleListResult
}

// FirewallRulesReplaceResponse contains the response from method FirewallRules.Replace.
type FirewallRulesReplaceResponse struct {
	FirewallRulesReplaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallRulesReplaceResult contains the result from method FirewallRules.Replace.
type FirewallRulesReplaceResult struct {
	FirewallRule
}

// GeoBackupPoliciesCreateOrUpdateResponse contains the response from method GeoBackupPolicies.CreateOrUpdate.
type GeoBackupPoliciesCreateOrUpdateResponse struct {
	GeoBackupPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GeoBackupPoliciesCreateOrUpdateResult contains the result from method GeoBackupPolicies.CreateOrUpdate.
type GeoBackupPoliciesCreateOrUpdateResult struct {
	GeoBackupPolicy
}

// GeoBackupPoliciesGetResponse contains the response from method GeoBackupPolicies.Get.
type GeoBackupPoliciesGetResponse struct {
	GeoBackupPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GeoBackupPoliciesGetResult contains the result from method GeoBackupPolicies.Get.
type GeoBackupPoliciesGetResult struct {
	GeoBackupPolicy
}

// GeoBackupPoliciesListByDatabaseResponse contains the response from method GeoBackupPolicies.ListByDatabase.
type GeoBackupPoliciesListByDatabaseResponse struct {
	GeoBackupPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GeoBackupPoliciesListByDatabaseResult contains the result from method GeoBackupPolicies.ListByDatabase.
type GeoBackupPoliciesListByDatabaseResult struct {
	GeoBackupPolicyListResult
}

// InstanceFailoverGroupsCreateOrUpdatePollerResponse contains the response from method InstanceFailoverGroups.CreateOrUpdate.
type InstanceFailoverGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstanceFailoverGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstanceFailoverGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsCreateOrUpdateResponse, error) {
	respType := InstanceFailoverGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstanceFailoverGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InstanceFailoverGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InstanceFailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstanceFailoverGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &InstanceFailoverGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstanceFailoverGroupsCreateOrUpdateResponse contains the response from method InstanceFailoverGroups.CreateOrUpdate.
type InstanceFailoverGroupsCreateOrUpdateResponse struct {
	InstanceFailoverGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsCreateOrUpdateResult contains the result from method InstanceFailoverGroups.CreateOrUpdate.
type InstanceFailoverGroupsCreateOrUpdateResult struct {
	InstanceFailoverGroup
}

// InstanceFailoverGroupsDeletePollerResponse contains the response from method InstanceFailoverGroups.Delete.
type InstanceFailoverGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstanceFailoverGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstanceFailoverGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsDeleteResponse, error) {
	respType := InstanceFailoverGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstanceFailoverGroupsDeletePollerResponse from the provided client and resume token.
func (l *InstanceFailoverGroupsDeletePollerResponse) Resume(ctx context.Context, client *InstanceFailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstanceFailoverGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &InstanceFailoverGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstanceFailoverGroupsDeleteResponse contains the response from method InstanceFailoverGroups.Delete.
type InstanceFailoverGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsFailoverPollerResponse contains the response from method InstanceFailoverGroups.Failover.
type InstanceFailoverGroupsFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstanceFailoverGroupsFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstanceFailoverGroupsFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsFailoverResponse, error) {
	respType := InstanceFailoverGroupsFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstanceFailoverGroupsFailoverPollerResponse from the provided client and resume token.
func (l *InstanceFailoverGroupsFailoverPollerResponse) Resume(ctx context.Context, client *InstanceFailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstanceFailoverGroupsClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &InstanceFailoverGroupsFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstanceFailoverGroupsFailoverResponse contains the response from method InstanceFailoverGroups.Failover.
type InstanceFailoverGroupsFailoverResponse struct {
	InstanceFailoverGroupsFailoverResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsFailoverResult contains the result from method InstanceFailoverGroups.Failover.
type InstanceFailoverGroupsFailoverResult struct {
	InstanceFailoverGroup
}

// InstanceFailoverGroupsForceFailoverAllowDataLossPollerResponse contains the response from method InstanceFailoverGroups.ForceFailoverAllowDataLoss.
type InstanceFailoverGroupsForceFailoverAllowDataLossPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstanceFailoverGroupsForceFailoverAllowDataLossPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstanceFailoverGroupsForceFailoverAllowDataLossPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstanceFailoverGroupsForceFailoverAllowDataLossPollerResponse from the provided client and resume token.
func (l *InstanceFailoverGroupsForceFailoverAllowDataLossPollerResponse) Resume(ctx context.Context, client *InstanceFailoverGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstanceFailoverGroupsClient.ForceFailoverAllowDataLoss", token, client.pl, client.forceFailoverAllowDataLossHandleError)
	if err != nil {
		return err
	}
	poller := &InstanceFailoverGroupsForceFailoverAllowDataLossPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstanceFailoverGroupsForceFailoverAllowDataLossResponse contains the response from method InstanceFailoverGroups.ForceFailoverAllowDataLoss.
type InstanceFailoverGroupsForceFailoverAllowDataLossResponse struct {
	InstanceFailoverGroupsForceFailoverAllowDataLossResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsForceFailoverAllowDataLossResult contains the result from method InstanceFailoverGroups.ForceFailoverAllowDataLoss.
type InstanceFailoverGroupsForceFailoverAllowDataLossResult struct {
	InstanceFailoverGroup
}

// InstanceFailoverGroupsGetResponse contains the response from method InstanceFailoverGroups.Get.
type InstanceFailoverGroupsGetResponse struct {
	InstanceFailoverGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsGetResult contains the result from method InstanceFailoverGroups.Get.
type InstanceFailoverGroupsGetResult struct {
	InstanceFailoverGroup
}

// InstanceFailoverGroupsListByLocationResponse contains the response from method InstanceFailoverGroups.ListByLocation.
type InstanceFailoverGroupsListByLocationResponse struct {
	InstanceFailoverGroupsListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceFailoverGroupsListByLocationResult contains the result from method InstanceFailoverGroups.ListByLocation.
type InstanceFailoverGroupsListByLocationResult struct {
	InstanceFailoverGroupListResult
}

// InstancePoolsCreateOrUpdatePollerResponse contains the response from method InstancePools.CreateOrUpdate.
type InstancePoolsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstancePoolsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstancePoolsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsCreateOrUpdateResponse, error) {
	respType := InstancePoolsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InstancePool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstancePoolsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InstancePoolsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InstancePoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstancePoolsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &InstancePoolsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstancePoolsCreateOrUpdateResponse contains the response from method InstancePools.CreateOrUpdate.
type InstancePoolsCreateOrUpdateResponse struct {
	InstancePoolsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsCreateOrUpdateResult contains the result from method InstancePools.CreateOrUpdate.
type InstancePoolsCreateOrUpdateResult struct {
	InstancePool
}

// InstancePoolsDeletePollerResponse contains the response from method InstancePools.Delete.
type InstancePoolsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstancePoolsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstancePoolsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsDeleteResponse, error) {
	respType := InstancePoolsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstancePoolsDeletePollerResponse from the provided client and resume token.
func (l *InstancePoolsDeletePollerResponse) Resume(ctx context.Context, client *InstancePoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstancePoolsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &InstancePoolsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstancePoolsDeleteResponse contains the response from method InstancePools.Delete.
type InstancePoolsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsGetResponse contains the response from method InstancePools.Get.
type InstancePoolsGetResponse struct {
	InstancePoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsGetResult contains the result from method InstancePools.Get.
type InstancePoolsGetResult struct {
	InstancePool
}

// InstancePoolsListByResourceGroupResponse contains the response from method InstancePools.ListByResourceGroup.
type InstancePoolsListByResourceGroupResponse struct {
	InstancePoolsListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsListByResourceGroupResult contains the result from method InstancePools.ListByResourceGroup.
type InstancePoolsListByResourceGroupResult struct {
	InstancePoolListResult
}

// InstancePoolsListResponse contains the response from method InstancePools.List.
type InstancePoolsListResponse struct {
	InstancePoolsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsListResult contains the result from method InstancePools.List.
type InstancePoolsListResult struct {
	InstancePoolListResult
}

// InstancePoolsUpdatePollerResponse contains the response from method InstancePools.Update.
type InstancePoolsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InstancePoolsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InstancePoolsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsUpdateResponse, error) {
	respType := InstancePoolsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InstancePool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InstancePoolsUpdatePollerResponse from the provided client and resume token.
func (l *InstancePoolsUpdatePollerResponse) Resume(ctx context.Context, client *InstancePoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InstancePoolsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &InstancePoolsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InstancePoolsUpdateResponse contains the response from method InstancePools.Update.
type InstancePoolsUpdateResponse struct {
	InstancePoolsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstancePoolsUpdateResult contains the result from method InstancePools.Update.
type InstancePoolsUpdateResult struct {
	InstancePool
}

// JobAgentsCreateOrUpdatePollerResponse contains the response from method JobAgents.CreateOrUpdate.
type JobAgentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobAgentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobAgentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsCreateOrUpdateResponse, error) {
	respType := JobAgentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobAgent)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobAgentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *JobAgentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *JobAgentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobAgentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &JobAgentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobAgentsCreateOrUpdateResponse contains the response from method JobAgents.CreateOrUpdate.
type JobAgentsCreateOrUpdateResponse struct {
	JobAgentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobAgentsCreateOrUpdateResult contains the result from method JobAgents.CreateOrUpdate.
type JobAgentsCreateOrUpdateResult struct {
	JobAgent
}

// JobAgentsDeletePollerResponse contains the response from method JobAgents.Delete.
type JobAgentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobAgentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobAgentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsDeleteResponse, error) {
	respType := JobAgentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobAgentsDeletePollerResponse from the provided client and resume token.
func (l *JobAgentsDeletePollerResponse) Resume(ctx context.Context, client *JobAgentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobAgentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &JobAgentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobAgentsDeleteResponse contains the response from method JobAgents.Delete.
type JobAgentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobAgentsGetResponse contains the response from method JobAgents.Get.
type JobAgentsGetResponse struct {
	JobAgentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobAgentsGetResult contains the result from method JobAgents.Get.
type JobAgentsGetResult struct {
	JobAgent
}

// JobAgentsListByServerResponse contains the response from method JobAgents.ListByServer.
type JobAgentsListByServerResponse struct {
	JobAgentsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobAgentsListByServerResult contains the result from method JobAgents.ListByServer.
type JobAgentsListByServerResult struct {
	JobAgentListResult
}

// JobAgentsUpdatePollerResponse contains the response from method JobAgents.Update.
type JobAgentsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobAgentsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobAgentsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsUpdateResponse, error) {
	respType := JobAgentsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobAgent)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobAgentsUpdatePollerResponse from the provided client and resume token.
func (l *JobAgentsUpdatePollerResponse) Resume(ctx context.Context, client *JobAgentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobAgentsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &JobAgentsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobAgentsUpdateResponse contains the response from method JobAgents.Update.
type JobAgentsUpdateResponse struct {
	JobAgentsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobAgentsUpdateResult contains the result from method JobAgents.Update.
type JobAgentsUpdateResult struct {
	JobAgent
}

// JobCredentialsCreateOrUpdateResponse contains the response from method JobCredentials.CreateOrUpdate.
type JobCredentialsCreateOrUpdateResponse struct {
	JobCredentialsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobCredentialsCreateOrUpdateResult contains the result from method JobCredentials.CreateOrUpdate.
type JobCredentialsCreateOrUpdateResult struct {
	JobCredential
}

// JobCredentialsDeleteResponse contains the response from method JobCredentials.Delete.
type JobCredentialsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobCredentialsGetResponse contains the response from method JobCredentials.Get.
type JobCredentialsGetResponse struct {
	JobCredentialsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobCredentialsGetResult contains the result from method JobCredentials.Get.
type JobCredentialsGetResult struct {
	JobCredential
}

// JobCredentialsListByAgentResponse contains the response from method JobCredentials.ListByAgent.
type JobCredentialsListByAgentResponse struct {
	JobCredentialsListByAgentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobCredentialsListByAgentResult contains the result from method JobCredentials.ListByAgent.
type JobCredentialsListByAgentResult struct {
	JobCredentialListResult
}

// JobExecutionsCancelResponse contains the response from method JobExecutions.Cancel.
type JobExecutionsCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsCreateOrUpdatePollerResponse contains the response from method JobExecutions.CreateOrUpdate.
type JobExecutionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobExecutionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobExecutionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobExecutionsCreateOrUpdateResponse, error) {
	respType := JobExecutionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobExecution)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobExecutionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *JobExecutionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *JobExecutionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobExecutionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &JobExecutionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobExecutionsCreateOrUpdateResponse contains the response from method JobExecutions.CreateOrUpdate.
type JobExecutionsCreateOrUpdateResponse struct {
	JobExecutionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsCreateOrUpdateResult contains the result from method JobExecutions.CreateOrUpdate.
type JobExecutionsCreateOrUpdateResult struct {
	JobExecution
}

// JobExecutionsCreatePollerResponse contains the response from method JobExecutions.Create.
type JobExecutionsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobExecutionsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobExecutionsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobExecutionsCreateResponse, error) {
	respType := JobExecutionsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobExecution)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobExecutionsCreatePollerResponse from the provided client and resume token.
func (l *JobExecutionsCreatePollerResponse) Resume(ctx context.Context, client *JobExecutionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobExecutionsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &JobExecutionsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobExecutionsCreateResponse contains the response from method JobExecutions.Create.
type JobExecutionsCreateResponse struct {
	JobExecutionsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsCreateResult contains the result from method JobExecutions.Create.
type JobExecutionsCreateResult struct {
	JobExecution
}

// JobExecutionsGetResponse contains the response from method JobExecutions.Get.
type JobExecutionsGetResponse struct {
	JobExecutionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsGetResult contains the result from method JobExecutions.Get.
type JobExecutionsGetResult struct {
	JobExecution
}

// JobExecutionsListByAgentResponse contains the response from method JobExecutions.ListByAgent.
type JobExecutionsListByAgentResponse struct {
	JobExecutionsListByAgentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsListByAgentResult contains the result from method JobExecutions.ListByAgent.
type JobExecutionsListByAgentResult struct {
	JobExecutionListResult
}

// JobExecutionsListByJobResponse contains the response from method JobExecutions.ListByJob.
type JobExecutionsListByJobResponse struct {
	JobExecutionsListByJobResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobExecutionsListByJobResult contains the result from method JobExecutions.ListByJob.
type JobExecutionsListByJobResult struct {
	JobExecutionListResult
}

// JobStepExecutionsGetResponse contains the response from method JobStepExecutions.Get.
type JobStepExecutionsGetResponse struct {
	JobStepExecutionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepExecutionsGetResult contains the result from method JobStepExecutions.Get.
type JobStepExecutionsGetResult struct {
	JobExecution
}

// JobStepExecutionsListByJobExecutionResponse contains the response from method JobStepExecutions.ListByJobExecution.
type JobStepExecutionsListByJobExecutionResponse struct {
	JobStepExecutionsListByJobExecutionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepExecutionsListByJobExecutionResult contains the result from method JobStepExecutions.ListByJobExecution.
type JobStepExecutionsListByJobExecutionResult struct {
	JobExecutionListResult
}

// JobStepsCreateOrUpdateResponse contains the response from method JobSteps.CreateOrUpdate.
type JobStepsCreateOrUpdateResponse struct {
	JobStepsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsCreateOrUpdateResult contains the result from method JobSteps.CreateOrUpdate.
type JobStepsCreateOrUpdateResult struct {
	JobStep
}

// JobStepsDeleteResponse contains the response from method JobSteps.Delete.
type JobStepsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsGetByVersionResponse contains the response from method JobSteps.GetByVersion.
type JobStepsGetByVersionResponse struct {
	JobStepsGetByVersionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsGetByVersionResult contains the result from method JobSteps.GetByVersion.
type JobStepsGetByVersionResult struct {
	JobStep
}

// JobStepsGetResponse contains the response from method JobSteps.Get.
type JobStepsGetResponse struct {
	JobStepsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsGetResult contains the result from method JobSteps.Get.
type JobStepsGetResult struct {
	JobStep
}

// JobStepsListByJobResponse contains the response from method JobSteps.ListByJob.
type JobStepsListByJobResponse struct {
	JobStepsListByJobResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsListByJobResult contains the result from method JobSteps.ListByJob.
type JobStepsListByJobResult struct {
	JobStepListResult
}

// JobStepsListByVersionResponse contains the response from method JobSteps.ListByVersion.
type JobStepsListByVersionResponse struct {
	JobStepsListByVersionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobStepsListByVersionResult contains the result from method JobSteps.ListByVersion.
type JobStepsListByVersionResult struct {
	JobStepListResult
}

// JobTargetExecutionsGetResponse contains the response from method JobTargetExecutions.Get.
type JobTargetExecutionsGetResponse struct {
	JobTargetExecutionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetExecutionsGetResult contains the result from method JobTargetExecutions.Get.
type JobTargetExecutionsGetResult struct {
	JobExecution
}

// JobTargetExecutionsListByJobExecutionResponse contains the response from method JobTargetExecutions.ListByJobExecution.
type JobTargetExecutionsListByJobExecutionResponse struct {
	JobTargetExecutionsListByJobExecutionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetExecutionsListByJobExecutionResult contains the result from method JobTargetExecutions.ListByJobExecution.
type JobTargetExecutionsListByJobExecutionResult struct {
	JobExecutionListResult
}

// JobTargetExecutionsListByStepResponse contains the response from method JobTargetExecutions.ListByStep.
type JobTargetExecutionsListByStepResponse struct {
	JobTargetExecutionsListByStepResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetExecutionsListByStepResult contains the result from method JobTargetExecutions.ListByStep.
type JobTargetExecutionsListByStepResult struct {
	JobExecutionListResult
}

// JobTargetGroupsCreateOrUpdateResponse contains the response from method JobTargetGroups.CreateOrUpdate.
type JobTargetGroupsCreateOrUpdateResponse struct {
	JobTargetGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetGroupsCreateOrUpdateResult contains the result from method JobTargetGroups.CreateOrUpdate.
type JobTargetGroupsCreateOrUpdateResult struct {
	JobTargetGroup
}

// JobTargetGroupsDeleteResponse contains the response from method JobTargetGroups.Delete.
type JobTargetGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetGroupsGetResponse contains the response from method JobTargetGroups.Get.
type JobTargetGroupsGetResponse struct {
	JobTargetGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetGroupsGetResult contains the result from method JobTargetGroups.Get.
type JobTargetGroupsGetResult struct {
	JobTargetGroup
}

// JobTargetGroupsListByAgentResponse contains the response from method JobTargetGroups.ListByAgent.
type JobTargetGroupsListByAgentResponse struct {
	JobTargetGroupsListByAgentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobTargetGroupsListByAgentResult contains the result from method JobTargetGroups.ListByAgent.
type JobTargetGroupsListByAgentResult struct {
	JobTargetGroupListResult
}

// JobVersionsGetResponse contains the response from method JobVersions.Get.
type JobVersionsGetResponse struct {
	JobVersionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobVersionsGetResult contains the result from method JobVersions.Get.
type JobVersionsGetResult struct {
	JobVersion
}

// JobVersionsListByJobResponse contains the response from method JobVersions.ListByJob.
type JobVersionsListByJobResponse struct {
	JobVersionsListByJobResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobVersionsListByJobResult contains the result from method JobVersions.ListByJob.
type JobVersionsListByJobResult struct {
	JobVersionListResult
}

// JobsCreateOrUpdateResponse contains the response from method Jobs.CreateOrUpdate.
type JobsCreateOrUpdateResponse struct {
	JobsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsCreateOrUpdateResult contains the result from method Jobs.CreateOrUpdate.
type JobsCreateOrUpdateResult struct {
	Job
}

// JobsDeleteResponse contains the response from method Jobs.Delete.
type JobsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsGetResponse contains the response from method Jobs.Get.
type JobsGetResponse struct {
	JobsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsGetResult contains the result from method Jobs.Get.
type JobsGetResult struct {
	Job
}

// JobsListByAgentResponse contains the response from method Jobs.ListByAgent.
type JobsListByAgentResponse struct {
	JobsListByAgentResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobsListByAgentResult contains the result from method Jobs.ListByAgent.
type JobsListByAgentResult struct {
	JobListResult
}

// LedgerDigestUploadsCreateOrUpdatePollerResponse contains the response from method LedgerDigestUploads.CreateOrUpdate.
type LedgerDigestUploadsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LedgerDigestUploadsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LedgerDigestUploadsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LedgerDigestUploadsCreateOrUpdateResponse, error) {
	respType := LedgerDigestUploadsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LedgerDigestUploads)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LedgerDigestUploadsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LedgerDigestUploadsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LedgerDigestUploadsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LedgerDigestUploadsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LedgerDigestUploadsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LedgerDigestUploadsCreateOrUpdateResponse contains the response from method LedgerDigestUploads.CreateOrUpdate.
type LedgerDigestUploadsCreateOrUpdateResponse struct {
	LedgerDigestUploadsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LedgerDigestUploadsCreateOrUpdateResult contains the result from method LedgerDigestUploads.CreateOrUpdate.
type LedgerDigestUploadsCreateOrUpdateResult struct {
	LedgerDigestUploads
}

// LedgerDigestUploadsDisablePollerResponse contains the response from method LedgerDigestUploads.Disable.
type LedgerDigestUploadsDisablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LedgerDigestUploadsDisablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LedgerDigestUploadsDisablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LedgerDigestUploadsDisableResponse, error) {
	respType := LedgerDigestUploadsDisableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LedgerDigestUploads)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LedgerDigestUploadsDisablePollerResponse from the provided client and resume token.
func (l *LedgerDigestUploadsDisablePollerResponse) Resume(ctx context.Context, client *LedgerDigestUploadsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LedgerDigestUploadsClient.Disable", token, client.pl, client.disableHandleError)
	if err != nil {
		return err
	}
	poller := &LedgerDigestUploadsDisablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LedgerDigestUploadsDisableResponse contains the response from method LedgerDigestUploads.Disable.
type LedgerDigestUploadsDisableResponse struct {
	LedgerDigestUploadsDisableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LedgerDigestUploadsDisableResult contains the result from method LedgerDigestUploads.Disable.
type LedgerDigestUploadsDisableResult struct {
	LedgerDigestUploads
}

// LedgerDigestUploadsGetResponse contains the response from method LedgerDigestUploads.Get.
type LedgerDigestUploadsGetResponse struct {
	LedgerDigestUploadsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LedgerDigestUploadsGetResult contains the result from method LedgerDigestUploads.Get.
type LedgerDigestUploadsGetResult struct {
	LedgerDigestUploads
}

// LedgerDigestUploadsListByDatabaseResponse contains the response from method LedgerDigestUploads.ListByDatabase.
type LedgerDigestUploadsListByDatabaseResponse struct {
	LedgerDigestUploadsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LedgerDigestUploadsListByDatabaseResult contains the result from method LedgerDigestUploads.ListByDatabase.
type LedgerDigestUploadsListByDatabaseResult struct {
	LedgerDigestUploadsListResult
}

// LongTermRetentionBackupsCopyByResourceGroupPollerResponse contains the response from method LongTermRetentionBackups.CopyByResourceGroup.
type LongTermRetentionBackupsCopyByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsCopyByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsCopyByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsCopyByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsCopyByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsCopyByResourceGroupPollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsCopyByResourceGroupPollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.CopyByResourceGroup", token, client.pl, client.copyByResourceGroupHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsCopyByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsCopyByResourceGroupResponse contains the response from method LongTermRetentionBackups.CopyByResourceGroup.
type LongTermRetentionBackupsCopyByResourceGroupResponse struct {
	LongTermRetentionBackupsCopyByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsCopyByResourceGroupResult contains the result from method LongTermRetentionBackups.CopyByResourceGroup.
type LongTermRetentionBackupsCopyByResourceGroupResult struct {
	LongTermRetentionBackupOperationResult
}

// LongTermRetentionBackupsCopyPollerResponse contains the response from method LongTermRetentionBackups.Copy.
type LongTermRetentionBackupsCopyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsCopyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsCopyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsCopyResponse, error) {
	respType := LongTermRetentionBackupsCopyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsCopyPollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsCopyPollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.Copy", token, client.pl, client.copyHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsCopyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsCopyResponse contains the response from method LongTermRetentionBackups.Copy.
type LongTermRetentionBackupsCopyResponse struct {
	LongTermRetentionBackupsCopyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsCopyResult contains the result from method LongTermRetentionBackups.Copy.
type LongTermRetentionBackupsCopyResult struct {
	LongTermRetentionBackupOperationResult
}

// LongTermRetentionBackupsDeleteByResourceGroupPollerResponse contains the response from method LongTermRetentionBackups.DeleteByResourceGroup.
type LongTermRetentionBackupsDeleteByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsDeleteByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsDeleteByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsDeleteByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsDeleteByResourceGroupPollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsDeleteByResourceGroupPollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.DeleteByResourceGroup", token, client.pl, client.deleteByResourceGroupHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsDeleteByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsDeleteByResourceGroupResponse contains the response from method LongTermRetentionBackups.DeleteByResourceGroup.
type LongTermRetentionBackupsDeleteByResourceGroupResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsDeletePollerResponse contains the response from method LongTermRetentionBackups.Delete.
type LongTermRetentionBackupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsDeleteResponse, error) {
	respType := LongTermRetentionBackupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsDeletePollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsDeletePollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsDeleteResponse contains the response from method LongTermRetentionBackups.Delete.
type LongTermRetentionBackupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsGetByResourceGroupResponse contains the response from method LongTermRetentionBackups.GetByResourceGroup.
type LongTermRetentionBackupsGetByResourceGroupResponse struct {
	LongTermRetentionBackupsGetByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsGetByResourceGroupResult contains the result from method LongTermRetentionBackups.GetByResourceGroup.
type LongTermRetentionBackupsGetByResourceGroupResult struct {
	LongTermRetentionBackup
}

// LongTermRetentionBackupsGetResponse contains the response from method LongTermRetentionBackups.Get.
type LongTermRetentionBackupsGetResponse struct {
	LongTermRetentionBackupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsGetResult contains the result from method LongTermRetentionBackups.Get.
type LongTermRetentionBackupsGetResult struct {
	LongTermRetentionBackup
}

// LongTermRetentionBackupsListByDatabaseResponse contains the response from method LongTermRetentionBackups.ListByDatabase.
type LongTermRetentionBackupsListByDatabaseResponse struct {
	LongTermRetentionBackupsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByDatabaseResult contains the result from method LongTermRetentionBackups.ListByDatabase.
type LongTermRetentionBackupsListByDatabaseResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsListByLocationResponse contains the response from method LongTermRetentionBackups.ListByLocation.
type LongTermRetentionBackupsListByLocationResponse struct {
	LongTermRetentionBackupsListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByLocationResult contains the result from method LongTermRetentionBackups.ListByLocation.
type LongTermRetentionBackupsListByLocationResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsListByResourceGroupDatabaseResponse contains the response from method LongTermRetentionBackups.ListByResourceGroupDatabase.
type LongTermRetentionBackupsListByResourceGroupDatabaseResponse struct {
	LongTermRetentionBackupsListByResourceGroupDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByResourceGroupDatabaseResult contains the result from method LongTermRetentionBackups.ListByResourceGroupDatabase.
type LongTermRetentionBackupsListByResourceGroupDatabaseResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsListByResourceGroupLocationResponse contains the response from method LongTermRetentionBackups.ListByResourceGroupLocation.
type LongTermRetentionBackupsListByResourceGroupLocationResponse struct {
	LongTermRetentionBackupsListByResourceGroupLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByResourceGroupLocationResult contains the result from method LongTermRetentionBackups.ListByResourceGroupLocation.
type LongTermRetentionBackupsListByResourceGroupLocationResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsListByResourceGroupServerResponse contains the response from method LongTermRetentionBackups.ListByResourceGroupServer.
type LongTermRetentionBackupsListByResourceGroupServerResponse struct {
	LongTermRetentionBackupsListByResourceGroupServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByResourceGroupServerResult contains the result from method LongTermRetentionBackups.ListByResourceGroupServer.
type LongTermRetentionBackupsListByResourceGroupServerResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsListByServerResponse contains the response from method LongTermRetentionBackups.ListByServer.
type LongTermRetentionBackupsListByServerResponse struct {
	LongTermRetentionBackupsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsListByServerResult contains the result from method LongTermRetentionBackups.ListByServer.
type LongTermRetentionBackupsListByServerResult struct {
	LongTermRetentionBackupListResult
}

// LongTermRetentionBackupsUpdateByResourceGroupPollerResponse contains the response from method LongTermRetentionBackups.UpdateByResourceGroup.
type LongTermRetentionBackupsUpdateByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsUpdateByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsUpdateByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsUpdateByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsUpdateByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsUpdateByResourceGroupPollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsUpdateByResourceGroupPollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.UpdateByResourceGroup", token, client.pl, client.updateByResourceGroupHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsUpdateByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsUpdateByResourceGroupResponse contains the response from method LongTermRetentionBackups.UpdateByResourceGroup.
type LongTermRetentionBackupsUpdateByResourceGroupResponse struct {
	LongTermRetentionBackupsUpdateByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsUpdateByResourceGroupResult contains the result from method LongTermRetentionBackups.UpdateByResourceGroup.
type LongTermRetentionBackupsUpdateByResourceGroupResult struct {
	LongTermRetentionBackupOperationResult
}

// LongTermRetentionBackupsUpdatePollerResponse contains the response from method LongTermRetentionBackups.Update.
type LongTermRetentionBackupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionBackupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionBackupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsUpdateResponse, error) {
	respType := LongTermRetentionBackupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionBackupsUpdatePollerResponse from the provided client and resume token.
func (l *LongTermRetentionBackupsUpdatePollerResponse) Resume(ctx context.Context, client *LongTermRetentionBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionBackupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionBackupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionBackupsUpdateResponse contains the response from method LongTermRetentionBackups.Update.
type LongTermRetentionBackupsUpdateResponse struct {
	LongTermRetentionBackupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionBackupsUpdateResult contains the result from method LongTermRetentionBackups.Update.
type LongTermRetentionBackupsUpdateResult struct {
	LongTermRetentionBackupOperationResult
}

// LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPollerResponse contains the response from method LongTermRetentionManagedInstanceBackups.DeleteByResourceGroup.
type LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPollerResponse from the provided client and resume token.
func (l *LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPollerResponse) Resume(ctx context.Context, client *LongTermRetentionManagedInstanceBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionManagedInstanceBackupsClient.DeleteByResourceGroup", token, client.pl, client.deleteByResourceGroupHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse contains the response from method LongTermRetentionManagedInstanceBackups.DeleteByResourceGroup.
type LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsDeletePollerResponse contains the response from method LongTermRetentionManagedInstanceBackups.Delete.
type LongTermRetentionManagedInstanceBackupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionManagedInstanceBackupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionManagedInstanceBackupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionManagedInstanceBackupsDeleteResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionManagedInstanceBackupsDeletePollerResponse from the provided client and resume token.
func (l *LongTermRetentionManagedInstanceBackupsDeletePollerResponse) Resume(ctx context.Context, client *LongTermRetentionManagedInstanceBackupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionManagedInstanceBackupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionManagedInstanceBackupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionManagedInstanceBackupsDeleteResponse contains the response from method LongTermRetentionManagedInstanceBackups.Delete.
type LongTermRetentionManagedInstanceBackupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsGetByResourceGroupResponse contains the response from method LongTermRetentionManagedInstanceBackups.GetByResourceGroup.
type LongTermRetentionManagedInstanceBackupsGetByResourceGroupResponse struct {
	LongTermRetentionManagedInstanceBackupsGetByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsGetByResourceGroupResult contains the result from method LongTermRetentionManagedInstanceBackups.GetByResourceGroup.
type LongTermRetentionManagedInstanceBackupsGetByResourceGroupResult struct {
	ManagedInstanceLongTermRetentionBackup
}

// LongTermRetentionManagedInstanceBackupsGetResponse contains the response from method LongTermRetentionManagedInstanceBackups.Get.
type LongTermRetentionManagedInstanceBackupsGetResponse struct {
	LongTermRetentionManagedInstanceBackupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsGetResult contains the result from method LongTermRetentionManagedInstanceBackups.Get.
type LongTermRetentionManagedInstanceBackupsGetResult struct {
	ManagedInstanceLongTermRetentionBackup
}

// LongTermRetentionManagedInstanceBackupsListByDatabaseResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByDatabase.
type LongTermRetentionManagedInstanceBackupsListByDatabaseResponse struct {
	LongTermRetentionManagedInstanceBackupsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByDatabaseResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByDatabase.
type LongTermRetentionManagedInstanceBackupsListByDatabaseResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionManagedInstanceBackupsListByInstanceResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByInstance.
type LongTermRetentionManagedInstanceBackupsListByInstanceResponse struct {
	LongTermRetentionManagedInstanceBackupsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByInstanceResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByInstance.
type LongTermRetentionManagedInstanceBackupsListByInstanceResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionManagedInstanceBackupsListByLocationResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByLocation.
type LongTermRetentionManagedInstanceBackupsListByLocationResponse struct {
	LongTermRetentionManagedInstanceBackupsListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByLocationResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByLocation.
type LongTermRetentionManagedInstanceBackupsListByLocationResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupDatabase.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse struct {
	LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupDatabase.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupInstance.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse struct {
	LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupInstance.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse contains the response from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupLocation.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse struct {
	LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResult contains the result from method LongTermRetentionManagedInstanceBackups.ListByResourceGroupLocation.
type LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResult struct {
	ManagedInstanceLongTermRetentionBackupListResult
}

// LongTermRetentionPoliciesCreateOrUpdatePollerResponse contains the response from method LongTermRetentionPolicies.CreateOrUpdate.
type LongTermRetentionPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LongTermRetentionPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LongTermRetentionPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := LongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LongTermRetentionPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LongTermRetentionPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LongTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LongTermRetentionPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &LongTermRetentionPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LongTermRetentionPoliciesCreateOrUpdateResponse contains the response from method LongTermRetentionPolicies.CreateOrUpdate.
type LongTermRetentionPoliciesCreateOrUpdateResponse struct {
	LongTermRetentionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionPoliciesCreateOrUpdateResult contains the result from method LongTermRetentionPolicies.CreateOrUpdate.
type LongTermRetentionPoliciesCreateOrUpdateResult struct {
	LongTermRetentionPolicy
}

// LongTermRetentionPoliciesGetResponse contains the response from method LongTermRetentionPolicies.Get.
type LongTermRetentionPoliciesGetResponse struct {
	LongTermRetentionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionPoliciesGetResult contains the result from method LongTermRetentionPolicies.Get.
type LongTermRetentionPoliciesGetResult struct {
	LongTermRetentionPolicy
}

// LongTermRetentionPoliciesListByDatabaseResponse contains the response from method LongTermRetentionPolicies.ListByDatabase.
type LongTermRetentionPoliciesListByDatabaseResponse struct {
	LongTermRetentionPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LongTermRetentionPoliciesListByDatabaseResult contains the result from method LongTermRetentionPolicies.ListByDatabase.
type LongTermRetentionPoliciesListByDatabaseResult struct {
	LongTermRetentionPolicyListResult
}

// MaintenanceWindowOptionsGetResponse contains the response from method MaintenanceWindowOptions.Get.
type MaintenanceWindowOptionsGetResponse struct {
	MaintenanceWindowOptionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MaintenanceWindowOptionsGetResult contains the result from method MaintenanceWindowOptions.Get.
type MaintenanceWindowOptionsGetResult struct {
	MaintenanceWindowOptions
}

// MaintenanceWindowsCreateOrUpdateResponse contains the response from method MaintenanceWindows.CreateOrUpdate.
type MaintenanceWindowsCreateOrUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MaintenanceWindowsGetResponse contains the response from method MaintenanceWindows.Get.
type MaintenanceWindowsGetResponse struct {
	MaintenanceWindowsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MaintenanceWindowsGetResult contains the result from method MaintenanceWindows.Get.
type MaintenanceWindowsGetResult struct {
	MaintenanceWindows
}

// ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse contains the response from method ManagedBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedBackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedBackupShortTermRetentionPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse contains the response from method ManagedBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse struct {
	ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResult contains the result from method ManagedBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedBackupShortTermRetentionPoliciesGetResponse contains the response from method ManagedBackupShortTermRetentionPolicies.Get.
type ManagedBackupShortTermRetentionPoliciesGetResponse struct {
	ManagedBackupShortTermRetentionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedBackupShortTermRetentionPoliciesGetResult contains the result from method ManagedBackupShortTermRetentionPolicies.Get.
type ManagedBackupShortTermRetentionPoliciesGetResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse contains the response from method ManagedBackupShortTermRetentionPolicies.ListByDatabase.
type ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse struct {
	ManagedBackupShortTermRetentionPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedBackupShortTermRetentionPoliciesListByDatabaseResult contains the result from method ManagedBackupShortTermRetentionPolicies.ListByDatabase.
type ManagedBackupShortTermRetentionPoliciesListByDatabaseResult struct {
	ManagedBackupShortTermRetentionPolicyListResult
}

// ManagedBackupShortTermRetentionPoliciesUpdatePollerResponse contains the response from method ManagedBackupShortTermRetentionPolicies.Update.
type ManagedBackupShortTermRetentionPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedBackupShortTermRetentionPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedBackupShortTermRetentionPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedBackupShortTermRetentionPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *ManagedBackupShortTermRetentionPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *ManagedBackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedBackupShortTermRetentionPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedBackupShortTermRetentionPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedBackupShortTermRetentionPoliciesUpdateResponse contains the response from method ManagedBackupShortTermRetentionPolicies.Update.
type ManagedBackupShortTermRetentionPoliciesUpdateResponse struct {
	ManagedBackupShortTermRetentionPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedBackupShortTermRetentionPoliciesUpdateResult contains the result from method ManagedBackupShortTermRetentionPolicies.Update.
type ManagedBackupShortTermRetentionPoliciesUpdateResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedDatabaseColumnsGetResponse contains the response from method ManagedDatabaseColumns.Get.
type ManagedDatabaseColumnsGetResponse struct {
	ManagedDatabaseColumnsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseColumnsGetResult contains the result from method ManagedDatabaseColumns.Get.
type ManagedDatabaseColumnsGetResult struct {
	DatabaseColumn
}

// ManagedDatabaseColumnsListByDatabaseResponse contains the response from method ManagedDatabaseColumns.ListByDatabase.
type ManagedDatabaseColumnsListByDatabaseResponse struct {
	ManagedDatabaseColumnsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseColumnsListByDatabaseResult contains the result from method ManagedDatabaseColumns.ListByDatabase.
type ManagedDatabaseColumnsListByDatabaseResult struct {
	DatabaseColumnListResult
}

// ManagedDatabaseColumnsListByTableResponse contains the response from method ManagedDatabaseColumns.ListByTable.
type ManagedDatabaseColumnsListByTableResponse struct {
	ManagedDatabaseColumnsListByTableResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseColumnsListByTableResult contains the result from method ManagedDatabaseColumns.ListByTable.
type ManagedDatabaseColumnsListByTableResult struct {
	DatabaseColumnListResult
}

// ManagedDatabaseQueriesGetResponse contains the response from method ManagedDatabaseQueries.Get.
type ManagedDatabaseQueriesGetResponse struct {
	ManagedDatabaseQueriesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseQueriesGetResult contains the result from method ManagedDatabaseQueries.Get.
type ManagedDatabaseQueriesGetResult struct {
	ManagedInstanceQuery
}

// ManagedDatabaseQueriesListByQueryResponse contains the response from method ManagedDatabaseQueries.ListByQuery.
type ManagedDatabaseQueriesListByQueryResponse struct {
	ManagedDatabaseQueriesListByQueryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseQueriesListByQueryResult contains the result from method ManagedDatabaseQueries.ListByQuery.
type ManagedDatabaseQueriesListByQueryResult struct {
	ManagedInstanceQueryStatistics
}

// ManagedDatabaseRecommendedSensitivityLabelsUpdateResponse contains the response from method ManagedDatabaseRecommendedSensitivityLabels.Update.
type ManagedDatabaseRecommendedSensitivityLabelsUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseRestoreDetailsGetResponse contains the response from method ManagedDatabaseRestoreDetails.Get.
type ManagedDatabaseRestoreDetailsGetResponse struct {
	ManagedDatabaseRestoreDetailsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseRestoreDetailsGetResult contains the result from method ManagedDatabaseRestoreDetails.Get.
type ManagedDatabaseRestoreDetailsGetResult struct {
	ManagedDatabaseRestoreDetailsResult
}

// ManagedDatabaseSchemasGetResponse contains the response from method ManagedDatabaseSchemas.Get.
type ManagedDatabaseSchemasGetResponse struct {
	ManagedDatabaseSchemasGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSchemasGetResult contains the result from method ManagedDatabaseSchemas.Get.
type ManagedDatabaseSchemasGetResult struct {
	DatabaseSchema
}

// ManagedDatabaseSchemasListByDatabaseResponse contains the response from method ManagedDatabaseSchemas.ListByDatabase.
type ManagedDatabaseSchemasListByDatabaseResponse struct {
	ManagedDatabaseSchemasListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSchemasListByDatabaseResult contains the result from method ManagedDatabaseSchemas.ListByDatabase.
type ManagedDatabaseSchemasListByDatabaseResult struct {
	DatabaseSchemaListResult
}

// ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResponse contains the response from method ManagedDatabaseSecurityAlertPolicies.CreateOrUpdate.
type ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResponse struct {
	ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResult contains the result from method ManagedDatabaseSecurityAlertPolicies.CreateOrUpdate.
type ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResult struct {
	ManagedDatabaseSecurityAlertPolicy
}

// ManagedDatabaseSecurityAlertPoliciesGetResponse contains the response from method ManagedDatabaseSecurityAlertPolicies.Get.
type ManagedDatabaseSecurityAlertPoliciesGetResponse struct {
	ManagedDatabaseSecurityAlertPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSecurityAlertPoliciesGetResult contains the result from method ManagedDatabaseSecurityAlertPolicies.Get.
type ManagedDatabaseSecurityAlertPoliciesGetResult struct {
	ManagedDatabaseSecurityAlertPolicy
}

// ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse contains the response from method ManagedDatabaseSecurityAlertPolicies.ListByDatabase.
type ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse struct {
	ManagedDatabaseSecurityAlertPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSecurityAlertPoliciesListByDatabaseResult contains the result from method ManagedDatabaseSecurityAlertPolicies.ListByDatabase.
type ManagedDatabaseSecurityAlertPoliciesListByDatabaseResult struct {
	ManagedDatabaseSecurityAlertPolicyListResult
}

// ManagedDatabaseSecurityEventsListByDatabaseResponse contains the response from method ManagedDatabaseSecurityEvents.ListByDatabase.
type ManagedDatabaseSecurityEventsListByDatabaseResponse struct {
	ManagedDatabaseSecurityEventsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSecurityEventsListByDatabaseResult contains the result from method ManagedDatabaseSecurityEvents.ListByDatabase.
type ManagedDatabaseSecurityEventsListByDatabaseResult struct {
	SecurityEventCollection
}

// ManagedDatabaseSensitivityLabelsCreateOrUpdateResponse contains the response from method ManagedDatabaseSensitivityLabels.CreateOrUpdate.
type ManagedDatabaseSensitivityLabelsCreateOrUpdateResponse struct {
	ManagedDatabaseSensitivityLabelsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsCreateOrUpdateResult contains the result from method ManagedDatabaseSensitivityLabels.CreateOrUpdate.
type ManagedDatabaseSensitivityLabelsCreateOrUpdateResult struct {
	SensitivityLabel
}

// ManagedDatabaseSensitivityLabelsDeleteResponse contains the response from method ManagedDatabaseSensitivityLabels.Delete.
type ManagedDatabaseSensitivityLabelsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsDisableRecommendationResponse contains the response from method ManagedDatabaseSensitivityLabels.DisableRecommendation.
type ManagedDatabaseSensitivityLabelsDisableRecommendationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsEnableRecommendationResponse contains the response from method ManagedDatabaseSensitivityLabels.EnableRecommendation.
type ManagedDatabaseSensitivityLabelsEnableRecommendationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsGetResponse contains the response from method ManagedDatabaseSensitivityLabels.Get.
type ManagedDatabaseSensitivityLabelsGetResponse struct {
	ManagedDatabaseSensitivityLabelsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsGetResult contains the result from method ManagedDatabaseSensitivityLabels.Get.
type ManagedDatabaseSensitivityLabelsGetResult struct {
	SensitivityLabel
}

// ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse contains the response from method ManagedDatabaseSensitivityLabels.ListCurrentByDatabase.
type ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse struct {
	ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResult contains the result from method ManagedDatabaseSensitivityLabels.ListCurrentByDatabase.
type ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResult struct {
	SensitivityLabelListResult
}

// ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse contains the response from method ManagedDatabaseSensitivityLabels.ListRecommendedByDatabase.
type ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse struct {
	ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResult contains the result from method ManagedDatabaseSensitivityLabels.ListRecommendedByDatabase.
type ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResult struct {
	SensitivityLabelListResult
}

// ManagedDatabaseSensitivityLabelsUpdateResponse contains the response from method ManagedDatabaseSensitivityLabels.Update.
type ManagedDatabaseSensitivityLabelsUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTablesGetResponse contains the response from method ManagedDatabaseTables.Get.
type ManagedDatabaseTablesGetResponse struct {
	ManagedDatabaseTablesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTablesGetResult contains the result from method ManagedDatabaseTables.Get.
type ManagedDatabaseTablesGetResult struct {
	DatabaseTable
}

// ManagedDatabaseTablesListBySchemaResponse contains the response from method ManagedDatabaseTables.ListBySchema.
type ManagedDatabaseTablesListBySchemaResponse struct {
	ManagedDatabaseTablesListBySchemaResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTablesListBySchemaResult contains the result from method ManagedDatabaseTables.ListBySchema.
type ManagedDatabaseTablesListBySchemaResult struct {
	DatabaseTableListResult
}

// ManagedDatabaseTransparentDataEncryptionCreateOrUpdateResponse contains the response from method ManagedDatabaseTransparentDataEncryption.CreateOrUpdate.
type ManagedDatabaseTransparentDataEncryptionCreateOrUpdateResponse struct {
	ManagedDatabaseTransparentDataEncryptionCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTransparentDataEncryptionCreateOrUpdateResult contains the result from method ManagedDatabaseTransparentDataEncryption.CreateOrUpdate.
type ManagedDatabaseTransparentDataEncryptionCreateOrUpdateResult struct {
	ManagedTransparentDataEncryption
}

// ManagedDatabaseTransparentDataEncryptionGetResponse contains the response from method ManagedDatabaseTransparentDataEncryption.Get.
type ManagedDatabaseTransparentDataEncryptionGetResponse struct {
	ManagedDatabaseTransparentDataEncryptionGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTransparentDataEncryptionGetResult contains the result from method ManagedDatabaseTransparentDataEncryption.Get.
type ManagedDatabaseTransparentDataEncryptionGetResult struct {
	ManagedTransparentDataEncryption
}

// ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse contains the response from method ManagedDatabaseTransparentDataEncryption.ListByDatabase.
type ManagedDatabaseTransparentDataEncryptionListByDatabaseResponse struct {
	ManagedDatabaseTransparentDataEncryptionListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseTransparentDataEncryptionListByDatabaseResult contains the result from method ManagedDatabaseTransparentDataEncryption.ListByDatabase.
type ManagedDatabaseTransparentDataEncryptionListByDatabaseResult struct {
	ManagedTransparentDataEncryptionListResult
}

// ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate.
type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse struct {
	ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult contains the result from method ManagedDatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate.
type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResult struct {
	DatabaseVulnerabilityAssessmentRuleBaseline
}

// ManagedDatabaseVulnerabilityAssessmentRuleBaselinesDeleteResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Delete.
type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get.
type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResponse struct {
	ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResult contains the result from method ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get.
type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResult struct {
	DatabaseVulnerabilityAssessmentRuleBaseline
}

// ManagedDatabaseVulnerabilityAssessmentScansExportResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentScans.Export.
type ManagedDatabaseVulnerabilityAssessmentScansExportResponse struct {
	ManagedDatabaseVulnerabilityAssessmentScansExportResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentScansExportResult contains the result from method ManagedDatabaseVulnerabilityAssessmentScans.Export.
type ManagedDatabaseVulnerabilityAssessmentScansExportResult struct {
	DatabaseVulnerabilityAssessmentScansExport
}

// ManagedDatabaseVulnerabilityAssessmentScansGetResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentScans.Get.
type ManagedDatabaseVulnerabilityAssessmentScansGetResponse struct {
	ManagedDatabaseVulnerabilityAssessmentScansGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentScansGetResult contains the result from method ManagedDatabaseVulnerabilityAssessmentScans.Get.
type ManagedDatabaseVulnerabilityAssessmentScansGetResult struct {
	VulnerabilityAssessmentScanRecord
}

// ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan.
type ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse from the provided client and resume token.
func (l *ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPollerResponse) Resume(ctx context.Context, client *ManagedDatabaseVulnerabilityAssessmentScansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedDatabaseVulnerabilityAssessmentScansClient.InitiateScan", token, client.pl, client.initiateScanHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan.
type ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse contains the response from method ManagedDatabaseVulnerabilityAssessmentScans.ListByDatabase.
type ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse struct {
	ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResult contains the result from method ManagedDatabaseVulnerabilityAssessmentScans.ListByDatabase.
type ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResult struct {
	VulnerabilityAssessmentScanRecordListResult
}

// ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResponse contains the response from method ManagedDatabaseVulnerabilityAssessments.CreateOrUpdate.
type ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResponse struct {
	ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResult contains the result from method ManagedDatabaseVulnerabilityAssessments.CreateOrUpdate.
type ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResult struct {
	DatabaseVulnerabilityAssessment
}

// ManagedDatabaseVulnerabilityAssessmentsDeleteResponse contains the response from method ManagedDatabaseVulnerabilityAssessments.Delete.
type ManagedDatabaseVulnerabilityAssessmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentsGetResponse contains the response from method ManagedDatabaseVulnerabilityAssessments.Get.
type ManagedDatabaseVulnerabilityAssessmentsGetResponse struct {
	ManagedDatabaseVulnerabilityAssessmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentsGetResult contains the result from method ManagedDatabaseVulnerabilityAssessments.Get.
type ManagedDatabaseVulnerabilityAssessmentsGetResult struct {
	DatabaseVulnerabilityAssessment
}

// ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse contains the response from method ManagedDatabaseVulnerabilityAssessments.ListByDatabase.
type ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse struct {
	ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResult contains the result from method ManagedDatabaseVulnerabilityAssessments.ListByDatabase.
type ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResult struct {
	DatabaseVulnerabilityAssessmentListResult
}

// ManagedDatabasesCompleteRestorePollerResponse contains the response from method ManagedDatabases.CompleteRestore.
type ManagedDatabasesCompleteRestorePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedDatabasesCompleteRestorePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedDatabasesCompleteRestorePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesCompleteRestoreResponse, error) {
	respType := ManagedDatabasesCompleteRestoreResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedDatabasesCompleteRestorePollerResponse from the provided client and resume token.
func (l *ManagedDatabasesCompleteRestorePollerResponse) Resume(ctx context.Context, client *ManagedDatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedDatabasesClient.CompleteRestore", token, client.pl, client.completeRestoreHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedDatabasesCompleteRestorePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedDatabasesCompleteRestoreResponse contains the response from method ManagedDatabases.CompleteRestore.
type ManagedDatabasesCompleteRestoreResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesCreateOrUpdatePollerResponse contains the response from method ManagedDatabases.CreateOrUpdate.
type ManagedDatabasesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedDatabasesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedDatabasesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesCreateOrUpdateResponse, error) {
	respType := ManagedDatabasesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedDatabase)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedDatabasesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedDatabasesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedDatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedDatabasesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedDatabasesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedDatabasesCreateOrUpdateResponse contains the response from method ManagedDatabases.CreateOrUpdate.
type ManagedDatabasesCreateOrUpdateResponse struct {
	ManagedDatabasesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesCreateOrUpdateResult contains the result from method ManagedDatabases.CreateOrUpdate.
type ManagedDatabasesCreateOrUpdateResult struct {
	ManagedDatabase
}

// ManagedDatabasesDeletePollerResponse contains the response from method ManagedDatabases.Delete.
type ManagedDatabasesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedDatabasesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedDatabasesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesDeleteResponse, error) {
	respType := ManagedDatabasesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedDatabasesDeletePollerResponse from the provided client and resume token.
func (l *ManagedDatabasesDeletePollerResponse) Resume(ctx context.Context, client *ManagedDatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedDatabasesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedDatabasesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedDatabasesDeleteResponse contains the response from method ManagedDatabases.Delete.
type ManagedDatabasesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesGetResponse contains the response from method ManagedDatabases.Get.
type ManagedDatabasesGetResponse struct {
	ManagedDatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesGetResult contains the result from method ManagedDatabases.Get.
type ManagedDatabasesGetResult struct {
	ManagedDatabase
}

// ManagedDatabasesListByInstanceResponse contains the response from method ManagedDatabases.ListByInstance.
type ManagedDatabasesListByInstanceResponse struct {
	ManagedDatabasesListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesListByInstanceResult contains the result from method ManagedDatabases.ListByInstance.
type ManagedDatabasesListByInstanceResult struct {
	ManagedDatabaseListResult
}

// ManagedDatabasesListInaccessibleByInstanceResponse contains the response from method ManagedDatabases.ListInaccessibleByInstance.
type ManagedDatabasesListInaccessibleByInstanceResponse struct {
	ManagedDatabasesListInaccessibleByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesListInaccessibleByInstanceResult contains the result from method ManagedDatabases.ListInaccessibleByInstance.
type ManagedDatabasesListInaccessibleByInstanceResult struct {
	ManagedDatabaseListResult
}

// ManagedDatabasesUpdatePollerResponse contains the response from method ManagedDatabases.Update.
type ManagedDatabasesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedDatabasesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedDatabasesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesUpdateResponse, error) {
	respType := ManagedDatabasesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedDatabase)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedDatabasesUpdatePollerResponse from the provided client and resume token.
func (l *ManagedDatabasesUpdatePollerResponse) Resume(ctx context.Context, client *ManagedDatabasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedDatabasesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedDatabasesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedDatabasesUpdateResponse contains the response from method ManagedDatabases.Update.
type ManagedDatabasesUpdateResponse struct {
	ManagedDatabasesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedDatabasesUpdateResult contains the result from method ManagedDatabases.Update.
type ManagedDatabasesUpdateResult struct {
	ManagedDatabase
}

// ManagedInstanceAdministratorsCreateOrUpdatePollerResponse contains the response from method ManagedInstanceAdministrators.CreateOrUpdate.
type ManagedInstanceAdministratorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceAdministratorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceAdministratorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAdministratorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAdministratorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceAdministrator)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceAdministratorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceAdministratorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceAdministratorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceAdministratorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceAdministratorsCreateOrUpdateResponse contains the response from method ManagedInstanceAdministrators.CreateOrUpdate.
type ManagedInstanceAdministratorsCreateOrUpdateResponse struct {
	ManagedInstanceAdministratorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAdministratorsCreateOrUpdateResult contains the result from method ManagedInstanceAdministrators.CreateOrUpdate.
type ManagedInstanceAdministratorsCreateOrUpdateResult struct {
	ManagedInstanceAdministrator
}

// ManagedInstanceAdministratorsDeletePollerResponse contains the response from method ManagedInstanceAdministrators.Delete.
type ManagedInstanceAdministratorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceAdministratorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceAdministratorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAdministratorsDeleteResponse, error) {
	respType := ManagedInstanceAdministratorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceAdministratorsDeletePollerResponse from the provided client and resume token.
func (l *ManagedInstanceAdministratorsDeletePollerResponse) Resume(ctx context.Context, client *ManagedInstanceAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceAdministratorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceAdministratorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceAdministratorsDeleteResponse contains the response from method ManagedInstanceAdministrators.Delete.
type ManagedInstanceAdministratorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAdministratorsGetResponse contains the response from method ManagedInstanceAdministrators.Get.
type ManagedInstanceAdministratorsGetResponse struct {
	ManagedInstanceAdministratorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAdministratorsGetResult contains the result from method ManagedInstanceAdministrators.Get.
type ManagedInstanceAdministratorsGetResult struct {
	ManagedInstanceAdministrator
}

// ManagedInstanceAdministratorsListByInstanceResponse contains the response from method ManagedInstanceAdministrators.ListByInstance.
type ManagedInstanceAdministratorsListByInstanceResponse struct {
	ManagedInstanceAdministratorsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAdministratorsListByInstanceResult contains the result from method ManagedInstanceAdministrators.ListByInstance.
type ManagedInstanceAdministratorsListByInstanceResult struct {
	ManagedInstanceAdministratorListResult
}

// ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.CreateOrUpdate.
type ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceAzureADOnlyAuthentication)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceAzureADOnlyAuthenticationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceAzureADOnlyAuthenticationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.CreateOrUpdate.
type ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse struct {
	ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResult contains the result from method ManagedInstanceAzureADOnlyAuthentications.CreateOrUpdate.
type ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResult struct {
	ManagedInstanceAzureADOnlyAuthentication
}

// ManagedInstanceAzureADOnlyAuthenticationsDeletePollerResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.Delete.
type ManagedInstanceAzureADOnlyAuthenticationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceAzureADOnlyAuthenticationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceAzureADOnlyAuthenticationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceAzureADOnlyAuthenticationsDeletePollerResponse from the provided client and resume token.
func (l *ManagedInstanceAzureADOnlyAuthenticationsDeletePollerResponse) Resume(ctx context.Context, client *ManagedInstanceAzureADOnlyAuthenticationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceAzureADOnlyAuthenticationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceAzureADOnlyAuthenticationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.Delete.
type ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAzureADOnlyAuthenticationsGetResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.Get.
type ManagedInstanceAzureADOnlyAuthenticationsGetResponse struct {
	ManagedInstanceAzureADOnlyAuthenticationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAzureADOnlyAuthenticationsGetResult contains the result from method ManagedInstanceAzureADOnlyAuthentications.Get.
type ManagedInstanceAzureADOnlyAuthenticationsGetResult struct {
	ManagedInstanceAzureADOnlyAuthentication
}

// ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse contains the response from method ManagedInstanceAzureADOnlyAuthentications.ListByInstance.
type ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResponse struct {
	ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResult contains the result from method ManagedInstanceAzureADOnlyAuthentications.ListByInstance.
type ManagedInstanceAzureADOnlyAuthenticationsListByInstanceResult struct {
	ManagedInstanceAzureADOnlyAuthListResult
}

// ManagedInstanceEncryptionProtectorsCreateOrUpdatePollerResponse contains the response from method ManagedInstanceEncryptionProtectors.CreateOrUpdate.
type ManagedInstanceEncryptionProtectorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceEncryptionProtectorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceEncryptionProtector)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceEncryptionProtectorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceEncryptionProtectorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceEncryptionProtectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceEncryptionProtectorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse contains the response from method ManagedInstanceEncryptionProtectors.CreateOrUpdate.
type ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse struct {
	ManagedInstanceEncryptionProtectorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceEncryptionProtectorsCreateOrUpdateResult contains the result from method ManagedInstanceEncryptionProtectors.CreateOrUpdate.
type ManagedInstanceEncryptionProtectorsCreateOrUpdateResult struct {
	ManagedInstanceEncryptionProtector
}

// ManagedInstanceEncryptionProtectorsGetResponse contains the response from method ManagedInstanceEncryptionProtectors.Get.
type ManagedInstanceEncryptionProtectorsGetResponse struct {
	ManagedInstanceEncryptionProtectorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceEncryptionProtectorsGetResult contains the result from method ManagedInstanceEncryptionProtectors.Get.
type ManagedInstanceEncryptionProtectorsGetResult struct {
	ManagedInstanceEncryptionProtector
}

// ManagedInstanceEncryptionProtectorsListByInstanceResponse contains the response from method ManagedInstanceEncryptionProtectors.ListByInstance.
type ManagedInstanceEncryptionProtectorsListByInstanceResponse struct {
	ManagedInstanceEncryptionProtectorsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceEncryptionProtectorsListByInstanceResult contains the result from method ManagedInstanceEncryptionProtectors.ListByInstance.
type ManagedInstanceEncryptionProtectorsListByInstanceResult struct {
	ManagedInstanceEncryptionProtectorListResult
}

// ManagedInstanceEncryptionProtectorsRevalidatePollerResponse contains the response from method ManagedInstanceEncryptionProtectors.Revalidate.
type ManagedInstanceEncryptionProtectorsRevalidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceEncryptionProtectorsRevalidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceEncryptionProtectorsRevalidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceEncryptionProtectorsRevalidateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsRevalidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceEncryptionProtectorsRevalidatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceEncryptionProtectorsRevalidatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceEncryptionProtectorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceEncryptionProtectorsClient.Revalidate", token, client.pl, client.revalidateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceEncryptionProtectorsRevalidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceEncryptionProtectorsRevalidateResponse contains the response from method ManagedInstanceEncryptionProtectors.Revalidate.
type ManagedInstanceEncryptionProtectorsRevalidateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceKeysCreateOrUpdatePollerResponse contains the response from method ManagedInstanceKeys.CreateOrUpdate.
type ManagedInstanceKeysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceKeysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceKeysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceKeysCreateOrUpdateResponse, error) {
	respType := ManagedInstanceKeysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceKeysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceKeysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceKeysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceKeysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceKeysCreateOrUpdateResponse contains the response from method ManagedInstanceKeys.CreateOrUpdate.
type ManagedInstanceKeysCreateOrUpdateResponse struct {
	ManagedInstanceKeysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceKeysCreateOrUpdateResult contains the result from method ManagedInstanceKeys.CreateOrUpdate.
type ManagedInstanceKeysCreateOrUpdateResult struct {
	ManagedInstanceKey
}

// ManagedInstanceKeysDeletePollerResponse contains the response from method ManagedInstanceKeys.Delete.
type ManagedInstanceKeysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceKeysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceKeysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceKeysDeleteResponse, error) {
	respType := ManagedInstanceKeysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceKeysDeletePollerResponse from the provided client and resume token.
func (l *ManagedInstanceKeysDeletePollerResponse) Resume(ctx context.Context, client *ManagedInstanceKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceKeysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceKeysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceKeysDeleteResponse contains the response from method ManagedInstanceKeys.Delete.
type ManagedInstanceKeysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceKeysGetResponse contains the response from method ManagedInstanceKeys.Get.
type ManagedInstanceKeysGetResponse struct {
	ManagedInstanceKeysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceKeysGetResult contains the result from method ManagedInstanceKeys.Get.
type ManagedInstanceKeysGetResult struct {
	ManagedInstanceKey
}

// ManagedInstanceKeysListByInstanceResponse contains the response from method ManagedInstanceKeys.ListByInstance.
type ManagedInstanceKeysListByInstanceResponse struct {
	ManagedInstanceKeysListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceKeysListByInstanceResult contains the result from method ManagedInstanceKeys.ListByInstance.
type ManagedInstanceKeysListByInstanceResult struct {
	ManagedInstanceKeyListResult
}

// ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePollerResponse contains the response from method ManagedInstanceLongTermRetentionPolicies.CreateOrUpdate.
type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceLongTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceLongTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceLongTermRetentionPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse contains the response from method ManagedInstanceLongTermRetentionPolicies.CreateOrUpdate.
type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse struct {
	ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResult contains the result from method ManagedInstanceLongTermRetentionPolicies.CreateOrUpdate.
type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResult struct {
	ManagedInstanceLongTermRetentionPolicy
}

// ManagedInstanceLongTermRetentionPoliciesGetResponse contains the response from method ManagedInstanceLongTermRetentionPolicies.Get.
type ManagedInstanceLongTermRetentionPoliciesGetResponse struct {
	ManagedInstanceLongTermRetentionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceLongTermRetentionPoliciesGetResult contains the result from method ManagedInstanceLongTermRetentionPolicies.Get.
type ManagedInstanceLongTermRetentionPoliciesGetResult struct {
	ManagedInstanceLongTermRetentionPolicy
}

// ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse contains the response from method ManagedInstanceLongTermRetentionPolicies.ListByDatabase.
type ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse struct {
	ManagedInstanceLongTermRetentionPoliciesListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceLongTermRetentionPoliciesListByDatabaseResult contains the result from method ManagedInstanceLongTermRetentionPolicies.ListByDatabase.
type ManagedInstanceLongTermRetentionPoliciesListByDatabaseResult struct {
	ManagedInstanceLongTermRetentionPolicyListResult
}

// ManagedInstanceOperationsCancelResponse contains the response from method ManagedInstanceOperations.Cancel.
type ManagedInstanceOperationsCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceOperationsGetResponse contains the response from method ManagedInstanceOperations.Get.
type ManagedInstanceOperationsGetResponse struct {
	ManagedInstanceOperationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceOperationsGetResult contains the result from method ManagedInstanceOperations.Get.
type ManagedInstanceOperationsGetResult struct {
	ManagedInstanceOperation
}

// ManagedInstanceOperationsListByManagedInstanceResponse contains the response from method ManagedInstanceOperations.ListByManagedInstance.
type ManagedInstanceOperationsListByManagedInstanceResponse struct {
	ManagedInstanceOperationsListByManagedInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceOperationsListByManagedInstanceResult contains the result from method ManagedInstanceOperations.ListByManagedInstance.
type ManagedInstanceOperationsListByManagedInstanceResult struct {
	ManagedInstanceOperationListResult
}

// ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePollerResponse contains the response from method ManagedInstancePrivateEndpointConnections.CreateOrUpdate.
type ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstancePrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstancePrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancePrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse contains the response from method ManagedInstancePrivateEndpointConnections.CreateOrUpdate.
type ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse struct {
	ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResult contains the result from method ManagedInstancePrivateEndpointConnections.CreateOrUpdate.
type ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResult struct {
	ManagedInstancePrivateEndpointConnection
}

// ManagedInstancePrivateEndpointConnectionsDeletePollerResponse contains the response from method ManagedInstancePrivateEndpointConnections.Delete.
type ManagedInstancePrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancePrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancePrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancePrivateEndpointConnectionsDeleteResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancePrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *ManagedInstancePrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *ManagedInstancePrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancePrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancePrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancePrivateEndpointConnectionsDeleteResponse contains the response from method ManagedInstancePrivateEndpointConnections.Delete.
type ManagedInstancePrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateEndpointConnectionsGetResponse contains the response from method ManagedInstancePrivateEndpointConnections.Get.
type ManagedInstancePrivateEndpointConnectionsGetResponse struct {
	ManagedInstancePrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateEndpointConnectionsGetResult contains the result from method ManagedInstancePrivateEndpointConnections.Get.
type ManagedInstancePrivateEndpointConnectionsGetResult struct {
	ManagedInstancePrivateEndpointConnection
}

// ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse contains the response from method ManagedInstancePrivateEndpointConnections.ListByManagedInstance.
type ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResponse struct {
	ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResult contains the result from method ManagedInstancePrivateEndpointConnections.ListByManagedInstance.
type ManagedInstancePrivateEndpointConnectionsListByManagedInstanceResult struct {
	ManagedInstancePrivateEndpointConnectionListResult
}

// ManagedInstancePrivateLinkResourcesGetResponse contains the response from method ManagedInstancePrivateLinkResources.Get.
type ManagedInstancePrivateLinkResourcesGetResponse struct {
	ManagedInstancePrivateLinkResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateLinkResourcesGetResult contains the result from method ManagedInstancePrivateLinkResources.Get.
type ManagedInstancePrivateLinkResourcesGetResult struct {
	ManagedInstancePrivateLink
}

// ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse contains the response from method ManagedInstancePrivateLinkResources.ListByManagedInstance.
type ManagedInstancePrivateLinkResourcesListByManagedInstanceResponse struct {
	ManagedInstancePrivateLinkResourcesListByManagedInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancePrivateLinkResourcesListByManagedInstanceResult contains the result from method ManagedInstancePrivateLinkResources.ListByManagedInstance.
type ManagedInstancePrivateLinkResourcesListByManagedInstanceResult struct {
	ManagedInstancePrivateLinkListResult
}

// ManagedInstanceTdeCertificatesCreatePollerResponse contains the response from method ManagedInstanceTdeCertificates.Create.
type ManagedInstanceTdeCertificatesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstanceTdeCertificatesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstanceTdeCertificatesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceTdeCertificatesCreateResponse, error) {
	respType := ManagedInstanceTdeCertificatesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstanceTdeCertificatesCreatePollerResponse from the provided client and resume token.
func (l *ManagedInstanceTdeCertificatesCreatePollerResponse) Resume(ctx context.Context, client *ManagedInstanceTdeCertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstanceTdeCertificatesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstanceTdeCertificatesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstanceTdeCertificatesCreateResponse contains the response from method ManagedInstanceTdeCertificates.Create.
type ManagedInstanceTdeCertificatesCreateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResponse contains the response from method ManagedInstanceVulnerabilityAssessments.CreateOrUpdate.
type ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResponse struct {
	ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResult contains the result from method ManagedInstanceVulnerabilityAssessments.CreateOrUpdate.
type ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResult struct {
	ManagedInstanceVulnerabilityAssessment
}

// ManagedInstanceVulnerabilityAssessmentsDeleteResponse contains the response from method ManagedInstanceVulnerabilityAssessments.Delete.
type ManagedInstanceVulnerabilityAssessmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceVulnerabilityAssessmentsGetResponse contains the response from method ManagedInstanceVulnerabilityAssessments.Get.
type ManagedInstanceVulnerabilityAssessmentsGetResponse struct {
	ManagedInstanceVulnerabilityAssessmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceVulnerabilityAssessmentsGetResult contains the result from method ManagedInstanceVulnerabilityAssessments.Get.
type ManagedInstanceVulnerabilityAssessmentsGetResult struct {
	ManagedInstanceVulnerabilityAssessment
}

// ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse contains the response from method ManagedInstanceVulnerabilityAssessments.ListByInstance.
type ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse struct {
	ManagedInstanceVulnerabilityAssessmentsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstanceVulnerabilityAssessmentsListByInstanceResult contains the result from method ManagedInstanceVulnerabilityAssessments.ListByInstance.
type ManagedInstanceVulnerabilityAssessmentsListByInstanceResult struct {
	ManagedInstanceVulnerabilityAssessmentListResult
}

// ManagedInstancesCreateOrUpdatePollerResponse contains the response from method ManagedInstances.CreateOrUpdate.
type ManagedInstancesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesCreateOrUpdateResponse, error) {
	respType := ManagedInstancesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstance)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstancesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancesCreateOrUpdateResponse contains the response from method ManagedInstances.CreateOrUpdate.
type ManagedInstancesCreateOrUpdateResponse struct {
	ManagedInstancesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesCreateOrUpdateResult contains the result from method ManagedInstances.CreateOrUpdate.
type ManagedInstancesCreateOrUpdateResult struct {
	ManagedInstance
}

// ManagedInstancesDeletePollerResponse contains the response from method ManagedInstances.Delete.
type ManagedInstancesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesDeleteResponse, error) {
	respType := ManagedInstancesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancesDeletePollerResponse from the provided client and resume token.
func (l *ManagedInstancesDeletePollerResponse) Resume(ctx context.Context, client *ManagedInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancesDeleteResponse contains the response from method ManagedInstances.Delete.
type ManagedInstancesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesFailoverPollerResponse contains the response from method ManagedInstances.Failover.
type ManagedInstancesFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancesFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancesFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesFailoverResponse, error) {
	respType := ManagedInstancesFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancesFailoverPollerResponse from the provided client and resume token.
func (l *ManagedInstancesFailoverPollerResponse) Resume(ctx context.Context, client *ManagedInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancesClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancesFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancesFailoverResponse contains the response from method ManagedInstances.Failover.
type ManagedInstancesFailoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesGetResponse contains the response from method ManagedInstances.Get.
type ManagedInstancesGetResponse struct {
	ManagedInstancesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesGetResult contains the result from method ManagedInstances.Get.
type ManagedInstancesGetResult struct {
	ManagedInstance
}

// ManagedInstancesListByInstancePoolResponse contains the response from method ManagedInstances.ListByInstancePool.
type ManagedInstancesListByInstancePoolResponse struct {
	ManagedInstancesListByInstancePoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesListByInstancePoolResult contains the result from method ManagedInstances.ListByInstancePool.
type ManagedInstancesListByInstancePoolResult struct {
	ManagedInstanceListResult
}

// ManagedInstancesListByManagedInstanceResponse contains the response from method ManagedInstances.ListByManagedInstance.
type ManagedInstancesListByManagedInstanceResponse struct {
	ManagedInstancesListByManagedInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesListByManagedInstanceResult contains the result from method ManagedInstances.ListByManagedInstance.
type ManagedInstancesListByManagedInstanceResult struct {
	TopQueriesListResult
}

// ManagedInstancesListByResourceGroupResponse contains the response from method ManagedInstances.ListByResourceGroup.
type ManagedInstancesListByResourceGroupResponse struct {
	ManagedInstancesListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesListByResourceGroupResult contains the result from method ManagedInstances.ListByResourceGroup.
type ManagedInstancesListByResourceGroupResult struct {
	ManagedInstanceListResult
}

// ManagedInstancesListResponse contains the response from method ManagedInstances.List.
type ManagedInstancesListResponse struct {
	ManagedInstancesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesListResult contains the result from method ManagedInstances.List.
type ManagedInstancesListResult struct {
	ManagedInstanceListResult
}

// ManagedInstancesUpdatePollerResponse contains the response from method ManagedInstances.Update.
type ManagedInstancesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedInstancesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedInstancesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesUpdateResponse, error) {
	respType := ManagedInstancesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedInstance)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedInstancesUpdatePollerResponse from the provided client and resume token.
func (l *ManagedInstancesUpdatePollerResponse) Resume(ctx context.Context, client *ManagedInstancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedInstancesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedInstancesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedInstancesUpdateResponse contains the response from method ManagedInstances.Update.
type ManagedInstancesUpdateResponse struct {
	ManagedInstancesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedInstancesUpdateResult contains the result from method ManagedInstances.Update.
type ManagedInstancesUpdateResult struct {
	ManagedInstance
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse struct {
	ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResult contains the result from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.CreateOrUpdate.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.Get.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResponse struct {
	ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResult contains the result from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.Get.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.ListByRestorableDroppedDatabase.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse struct {
	ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResult contains the result from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.ListByRestorableDroppedDatabase.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResult struct {
	ManagedBackupShortTermRetentionPolicyListResult
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePollerResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.Update.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePollerResponse from the provided client and resume token.
func (l *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePollerResponse) Resume(ctx context.Context, client *ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse contains the response from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.Update.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse struct {
	ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResult contains the result from method ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies.Update.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResult struct {
	ManagedBackupShortTermRetentionPolicy
}

// ManagedServerSecurityAlertPoliciesCreateOrUpdatePollerResponse contains the response from method ManagedServerSecurityAlertPolicies.CreateOrUpdate.
type ManagedServerSecurityAlertPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagedServerSecurityAlertPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ManagedServerSecurityAlertPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagedServerSecurityAlertPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ManagedServerSecurityAlertPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ManagedServerSecurityAlertPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagedServerSecurityAlertPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse contains the response from method ManagedServerSecurityAlertPolicies.CreateOrUpdate.
type ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse struct {
	ManagedServerSecurityAlertPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedServerSecurityAlertPoliciesCreateOrUpdateResult contains the result from method ManagedServerSecurityAlertPolicies.CreateOrUpdate.
type ManagedServerSecurityAlertPoliciesCreateOrUpdateResult struct {
	ManagedServerSecurityAlertPolicy
}

// ManagedServerSecurityAlertPoliciesGetResponse contains the response from method ManagedServerSecurityAlertPolicies.Get.
type ManagedServerSecurityAlertPoliciesGetResponse struct {
	ManagedServerSecurityAlertPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedServerSecurityAlertPoliciesGetResult contains the result from method ManagedServerSecurityAlertPolicies.Get.
type ManagedServerSecurityAlertPoliciesGetResult struct {
	ManagedServerSecurityAlertPolicy
}

// ManagedServerSecurityAlertPoliciesListByInstanceResponse contains the response from method ManagedServerSecurityAlertPolicies.ListByInstance.
type ManagedServerSecurityAlertPoliciesListByInstanceResponse struct {
	ManagedServerSecurityAlertPoliciesListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagedServerSecurityAlertPoliciesListByInstanceResult contains the result from method ManagedServerSecurityAlertPolicies.ListByInstance.
type ManagedServerSecurityAlertPoliciesListByInstanceResult struct {
	ManagedServerSecurityAlertPolicyListResult
}

// OperationsHealthListByLocationResponse contains the response from method OperationsHealth.ListByLocation.
type OperationsHealthListByLocationResponse struct {
	OperationsHealthListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsHealthListByLocationResult contains the result from method OperationsHealth.ListByLocation.
type OperationsHealthListByLocationResult struct {
	OperationsHealthListResult
}

// OperationsListResponse contains the response from method Operations.List.
type OperationsListResponse struct {
	OperationsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsListResult contains the result from method Operations.List.
type OperationsListResult struct {
	OperationListResult
}

// OutboundFirewallRulesCreateOrUpdatePollerResponse contains the response from method OutboundFirewallRules.CreateOrUpdate.
type OutboundFirewallRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OutboundFirewallRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OutboundFirewallRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OutboundFirewallRulesCreateOrUpdateResponse, error) {
	respType := OutboundFirewallRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.OutboundFirewallRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OutboundFirewallRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *OutboundFirewallRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *OutboundFirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OutboundFirewallRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &OutboundFirewallRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OutboundFirewallRulesCreateOrUpdateResponse contains the response from method OutboundFirewallRules.CreateOrUpdate.
type OutboundFirewallRulesCreateOrUpdateResponse struct {
	OutboundFirewallRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OutboundFirewallRulesCreateOrUpdateResult contains the result from method OutboundFirewallRules.CreateOrUpdate.
type OutboundFirewallRulesCreateOrUpdateResult struct {
	OutboundFirewallRule
}

// OutboundFirewallRulesDeletePollerResponse contains the response from method OutboundFirewallRules.Delete.
type OutboundFirewallRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *OutboundFirewallRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l OutboundFirewallRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (OutboundFirewallRulesDeleteResponse, error) {
	respType := OutboundFirewallRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a OutboundFirewallRulesDeletePollerResponse from the provided client and resume token.
func (l *OutboundFirewallRulesDeletePollerResponse) Resume(ctx context.Context, client *OutboundFirewallRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("OutboundFirewallRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &OutboundFirewallRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// OutboundFirewallRulesDeleteResponse contains the response from method OutboundFirewallRules.Delete.
type OutboundFirewallRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OutboundFirewallRulesGetResponse contains the response from method OutboundFirewallRules.Get.
type OutboundFirewallRulesGetResponse struct {
	OutboundFirewallRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OutboundFirewallRulesGetResult contains the result from method OutboundFirewallRules.Get.
type OutboundFirewallRulesGetResult struct {
	OutboundFirewallRule
}

// OutboundFirewallRulesListByServerResponse contains the response from method OutboundFirewallRules.ListByServer.
type OutboundFirewallRulesListByServerResponse struct {
	OutboundFirewallRulesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OutboundFirewallRulesListByServerResult contains the result from method OutboundFirewallRules.ListByServer.
type OutboundFirewallRulesListByServerResult struct {
	OutboundFirewallRuleListResult
}

// PrivateEndpointConnectionsCreateOrUpdatePollerResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsCreateOrUpdateResponse contains the response from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResponse struct {
	PrivateEndpointConnectionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsCreateOrUpdateResult contains the result from method PrivateEndpointConnections.CreateOrUpdate.
type PrivateEndpointConnectionsCreateOrUpdateResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsDeletePollerResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointConnectionsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointConnectionsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointConnectionsDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointConnectionsDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointConnectionsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointConnectionsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointConnectionsDeleteResponse contains the response from method PrivateEndpointConnections.Delete.
type PrivateEndpointConnectionsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResponse contains the response from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResponse struct {
	PrivateEndpointConnectionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsGetResult contains the result from method PrivateEndpointConnections.Get.
type PrivateEndpointConnectionsGetResult struct {
	PrivateEndpointConnection
}

// PrivateEndpointConnectionsListByServerResponse contains the response from method PrivateEndpointConnections.ListByServer.
type PrivateEndpointConnectionsListByServerResponse struct {
	PrivateEndpointConnectionsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointConnectionsListByServerResult contains the result from method PrivateEndpointConnections.ListByServer.
type PrivateEndpointConnectionsListByServerResult struct {
	PrivateEndpointConnectionListResult
}

// PrivateLinkResourcesGetResponse contains the response from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResponse struct {
	PrivateLinkResourcesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesGetResult contains the result from method PrivateLinkResources.Get.
type PrivateLinkResourcesGetResult struct {
	PrivateLinkResource
}

// PrivateLinkResourcesListByServerResponse contains the response from method PrivateLinkResources.ListByServer.
type PrivateLinkResourcesListByServerResponse struct {
	PrivateLinkResourcesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkResourcesListByServerResult contains the result from method PrivateLinkResources.ListByServer.
type PrivateLinkResourcesListByServerResult struct {
	PrivateLinkResourceListResult
}

// RecommendedSensitivityLabelsUpdateResponse contains the response from method RecommendedSensitivityLabels.Update.
type RecommendedSensitivityLabelsUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableDatabasesGetResponse contains the response from method RecoverableDatabases.Get.
type RecoverableDatabasesGetResponse struct {
	RecoverableDatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableDatabasesGetResult contains the result from method RecoverableDatabases.Get.
type RecoverableDatabasesGetResult struct {
	RecoverableDatabase
}

// RecoverableDatabasesListByServerResponse contains the response from method RecoverableDatabases.ListByServer.
type RecoverableDatabasesListByServerResponse struct {
	RecoverableDatabasesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableDatabasesListByServerResult contains the result from method RecoverableDatabases.ListByServer.
type RecoverableDatabasesListByServerResult struct {
	RecoverableDatabaseListResult
}

// RecoverableManagedDatabasesGetResponse contains the response from method RecoverableManagedDatabases.Get.
type RecoverableManagedDatabasesGetResponse struct {
	RecoverableManagedDatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableManagedDatabasesGetResult contains the result from method RecoverableManagedDatabases.Get.
type RecoverableManagedDatabasesGetResult struct {
	RecoverableManagedDatabase
}

// RecoverableManagedDatabasesListByInstanceResponse contains the response from method RecoverableManagedDatabases.ListByInstance.
type RecoverableManagedDatabasesListByInstanceResponse struct {
	RecoverableManagedDatabasesListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RecoverableManagedDatabasesListByInstanceResult contains the result from method RecoverableManagedDatabases.ListByInstance.
type RecoverableManagedDatabasesListByInstanceResult struct {
	RecoverableManagedDatabaseListResult
}

// ReplicationLinksDeleteResponse contains the response from method ReplicationLinks.Delete.
type ReplicationLinksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksFailoverAllowDataLossPollerResponse contains the response from method ReplicationLinks.FailoverAllowDataLoss.
type ReplicationLinksFailoverAllowDataLossPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationLinksFailoverAllowDataLossPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationLinksFailoverAllowDataLossPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksFailoverAllowDataLossResponse, error) {
	respType := ReplicationLinksFailoverAllowDataLossResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationLinksFailoverAllowDataLossPollerResponse from the provided client and resume token.
func (l *ReplicationLinksFailoverAllowDataLossPollerResponse) Resume(ctx context.Context, client *ReplicationLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationLinksClient.FailoverAllowDataLoss", token, client.pl, client.failoverAllowDataLossHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationLinksFailoverAllowDataLossPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationLinksFailoverAllowDataLossResponse contains the response from method ReplicationLinks.FailoverAllowDataLoss.
type ReplicationLinksFailoverAllowDataLossResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksFailoverPollerResponse contains the response from method ReplicationLinks.Failover.
type ReplicationLinksFailoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationLinksFailoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationLinksFailoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksFailoverResponse, error) {
	respType := ReplicationLinksFailoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationLinksFailoverPollerResponse from the provided client and resume token.
func (l *ReplicationLinksFailoverPollerResponse) Resume(ctx context.Context, client *ReplicationLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationLinksClient.Failover", token, client.pl, client.failoverHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationLinksFailoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationLinksFailoverResponse contains the response from method ReplicationLinks.Failover.
type ReplicationLinksFailoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksGetResponse contains the response from method ReplicationLinks.Get.
type ReplicationLinksGetResponse struct {
	ReplicationLinksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksGetResult contains the result from method ReplicationLinks.Get.
type ReplicationLinksGetResult struct {
	ReplicationLink
}

// ReplicationLinksListByDatabaseResponse contains the response from method ReplicationLinks.ListByDatabase.
type ReplicationLinksListByDatabaseResponse struct {
	ReplicationLinksListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksListByDatabaseResult contains the result from method ReplicationLinks.ListByDatabase.
type ReplicationLinksListByDatabaseResult struct {
	ReplicationLinkListResult
}

// ReplicationLinksListByServerResponse contains the response from method ReplicationLinks.ListByServer.
type ReplicationLinksListByServerResponse struct {
	ReplicationLinksListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ReplicationLinksListByServerResult contains the result from method ReplicationLinks.ListByServer.
type ReplicationLinksListByServerResult struct {
	ReplicationLinkListResult
}

// ReplicationLinksUnlinkPollerResponse contains the response from method ReplicationLinks.Unlink.
type ReplicationLinksUnlinkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ReplicationLinksUnlinkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ReplicationLinksUnlinkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksUnlinkResponse, error) {
	respType := ReplicationLinksUnlinkResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ReplicationLinksUnlinkPollerResponse from the provided client and resume token.
func (l *ReplicationLinksUnlinkPollerResponse) Resume(ctx context.Context, client *ReplicationLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ReplicationLinksClient.Unlink", token, client.pl, client.unlinkHandleError)
	if err != nil {
		return err
	}
	poller := &ReplicationLinksUnlinkPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ReplicationLinksUnlinkResponse contains the response from method ReplicationLinks.Unlink.
type ReplicationLinksUnlinkResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDroppedDatabasesGetResponse contains the response from method RestorableDroppedDatabases.Get.
type RestorableDroppedDatabasesGetResponse struct {
	RestorableDroppedDatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDroppedDatabasesGetResult contains the result from method RestorableDroppedDatabases.Get.
type RestorableDroppedDatabasesGetResult struct {
	RestorableDroppedDatabase
}

// RestorableDroppedDatabasesListByServerResponse contains the response from method RestorableDroppedDatabases.ListByServer.
type RestorableDroppedDatabasesListByServerResponse struct {
	RestorableDroppedDatabasesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDroppedDatabasesListByServerResult contains the result from method RestorableDroppedDatabases.ListByServer.
type RestorableDroppedDatabasesListByServerResult struct {
	RestorableDroppedDatabaseListResult
}

// RestorableDroppedManagedDatabasesGetResponse contains the response from method RestorableDroppedManagedDatabases.Get.
type RestorableDroppedManagedDatabasesGetResponse struct {
	RestorableDroppedManagedDatabasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDroppedManagedDatabasesGetResult contains the result from method RestorableDroppedManagedDatabases.Get.
type RestorableDroppedManagedDatabasesGetResult struct {
	RestorableDroppedManagedDatabase
}

// RestorableDroppedManagedDatabasesListByInstanceResponse contains the response from method RestorableDroppedManagedDatabases.ListByInstance.
type RestorableDroppedManagedDatabasesListByInstanceResponse struct {
	RestorableDroppedManagedDatabasesListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorableDroppedManagedDatabasesListByInstanceResult contains the result from method RestorableDroppedManagedDatabases.ListByInstance.
type RestorableDroppedManagedDatabasesListByInstanceResult struct {
	RestorableDroppedManagedDatabaseListResult
}

// RestorePointsCreatePollerResponse contains the response from method RestorePoints.Create.
type RestorePointsCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RestorePointsCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RestorePointsCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RestorePointsCreateResponse, error) {
	respType := RestorePointsCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RestorePoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RestorePointsCreatePollerResponse from the provided client and resume token.
func (l *RestorePointsCreatePollerResponse) Resume(ctx context.Context, client *RestorePointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RestorePointsClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &RestorePointsCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RestorePointsCreateResponse contains the response from method RestorePoints.Create.
type RestorePointsCreateResponse struct {
	RestorePointsCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorePointsCreateResult contains the result from method RestorePoints.Create.
type RestorePointsCreateResult struct {
	RestorePoint
}

// RestorePointsDeleteResponse contains the response from method RestorePoints.Delete.
type RestorePointsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorePointsGetResponse contains the response from method RestorePoints.Get.
type RestorePointsGetResponse struct {
	RestorePointsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorePointsGetResult contains the result from method RestorePoints.Get.
type RestorePointsGetResult struct {
	RestorePoint
}

// RestorePointsListByDatabaseResponse contains the response from method RestorePoints.ListByDatabase.
type RestorePointsListByDatabaseResponse struct {
	RestorePointsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RestorePointsListByDatabaseResult contains the result from method RestorePoints.ListByDatabase.
type RestorePointsListByDatabaseResult struct {
	RestorePointListResult
}

// SQLAgentCreateOrUpdateResponse contains the response from method SQLAgent.CreateOrUpdate.
type SQLAgentCreateOrUpdateResponse struct {
	SQLAgentCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLAgentCreateOrUpdateResult contains the result from method SQLAgent.CreateOrUpdate.
type SQLAgentCreateOrUpdateResult struct {
	SQLAgentConfiguration
}

// SQLAgentGetResponse contains the response from method SQLAgent.Get.
type SQLAgentGetResponse struct {
	SQLAgentGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLAgentGetResult contains the result from method SQLAgent.Get.
type SQLAgentGetResult struct {
	SQLAgentConfiguration
}

// SensitivityLabelsCreateOrUpdateResponse contains the response from method SensitivityLabels.CreateOrUpdate.
type SensitivityLabelsCreateOrUpdateResponse struct {
	SensitivityLabelsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsCreateOrUpdateResult contains the result from method SensitivityLabels.CreateOrUpdate.
type SensitivityLabelsCreateOrUpdateResult struct {
	SensitivityLabel
}

// SensitivityLabelsDeleteResponse contains the response from method SensitivityLabels.Delete.
type SensitivityLabelsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsDisableRecommendationResponse contains the response from method SensitivityLabels.DisableRecommendation.
type SensitivityLabelsDisableRecommendationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsEnableRecommendationResponse contains the response from method SensitivityLabels.EnableRecommendation.
type SensitivityLabelsEnableRecommendationResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsGetResponse contains the response from method SensitivityLabels.Get.
type SensitivityLabelsGetResponse struct {
	SensitivityLabelsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsGetResult contains the result from method SensitivityLabels.Get.
type SensitivityLabelsGetResult struct {
	SensitivityLabel
}

// SensitivityLabelsListCurrentByDatabaseResponse contains the response from method SensitivityLabels.ListCurrentByDatabase.
type SensitivityLabelsListCurrentByDatabaseResponse struct {
	SensitivityLabelsListCurrentByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsListCurrentByDatabaseResult contains the result from method SensitivityLabels.ListCurrentByDatabase.
type SensitivityLabelsListCurrentByDatabaseResult struct {
	SensitivityLabelListResult
}

// SensitivityLabelsListRecommendedByDatabaseResponse contains the response from method SensitivityLabels.ListRecommendedByDatabase.
type SensitivityLabelsListRecommendedByDatabaseResponse struct {
	SensitivityLabelsListRecommendedByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SensitivityLabelsListRecommendedByDatabaseResult contains the result from method SensitivityLabels.ListRecommendedByDatabase.
type SensitivityLabelsListRecommendedByDatabaseResult struct {
	SensitivityLabelListResult
}

// SensitivityLabelsUpdateResponse contains the response from method SensitivityLabels.Update.
type SensitivityLabelsUpdateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdvisorsGetResponse contains the response from method ServerAdvisors.Get.
type ServerAdvisorsGetResponse struct {
	ServerAdvisorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdvisorsGetResult contains the result from method ServerAdvisors.Get.
type ServerAdvisorsGetResult struct {
	Advisor
}

// ServerAdvisorsListByServerResponse contains the response from method ServerAdvisors.ListByServer.
type ServerAdvisorsListByServerResponse struct {
	ServerAdvisorsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdvisorsListByServerResult contains the result from method ServerAdvisors.ListByServer.
type ServerAdvisorsListByServerResult struct {
	// Array of Advisor
	AdvisorArray []*Advisor
}

// ServerAdvisorsUpdateResponse contains the response from method ServerAdvisors.Update.
type ServerAdvisorsUpdateResponse struct {
	ServerAdvisorsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAdvisorsUpdateResult contains the result from method ServerAdvisors.Update.
type ServerAdvisorsUpdateResult struct {
	Advisor
}

// ServerAutomaticTuningGetResponse contains the response from method ServerAutomaticTuning.Get.
type ServerAutomaticTuningGetResponse struct {
	ServerAutomaticTuningGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAutomaticTuningGetResult contains the result from method ServerAutomaticTuning.Get.
type ServerAutomaticTuningGetResult struct {
	ServerAutomaticTuning
}

// ServerAutomaticTuningUpdateResponse contains the response from method ServerAutomaticTuning.Update.
type ServerAutomaticTuningUpdateResponse struct {
	ServerAutomaticTuningUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAutomaticTuningUpdateResult contains the result from method ServerAutomaticTuning.Update.
type ServerAutomaticTuningUpdateResult struct {
	ServerAutomaticTuning
}

// ServerAzureADAdministratorsCreateOrUpdatePollerResponse contains the response from method ServerAzureADAdministrators.CreateOrUpdate.
type ServerAzureADAdministratorsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAzureADAdministratorsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAzureADAdministratorsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADAdministratorsCreateOrUpdateResponse, error) {
	respType := ServerAzureADAdministratorsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerAzureADAdministrator)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAzureADAdministratorsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerAzureADAdministratorsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerAzureADAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAzureADAdministratorsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerAzureADAdministratorsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAzureADAdministratorsCreateOrUpdateResponse contains the response from method ServerAzureADAdministrators.CreateOrUpdate.
type ServerAzureADAdministratorsCreateOrUpdateResponse struct {
	ServerAzureADAdministratorsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADAdministratorsCreateOrUpdateResult contains the result from method ServerAzureADAdministrators.CreateOrUpdate.
type ServerAzureADAdministratorsCreateOrUpdateResult struct {
	ServerAzureADAdministrator
}

// ServerAzureADAdministratorsDeletePollerResponse contains the response from method ServerAzureADAdministrators.Delete.
type ServerAzureADAdministratorsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAzureADAdministratorsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAzureADAdministratorsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADAdministratorsDeleteResponse, error) {
	respType := ServerAzureADAdministratorsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAzureADAdministratorsDeletePollerResponse from the provided client and resume token.
func (l *ServerAzureADAdministratorsDeletePollerResponse) Resume(ctx context.Context, client *ServerAzureADAdministratorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAzureADAdministratorsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerAzureADAdministratorsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAzureADAdministratorsDeleteResponse contains the response from method ServerAzureADAdministrators.Delete.
type ServerAzureADAdministratorsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADAdministratorsGetResponse contains the response from method ServerAzureADAdministrators.Get.
type ServerAzureADAdministratorsGetResponse struct {
	ServerAzureADAdministratorsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADAdministratorsGetResult contains the result from method ServerAzureADAdministrators.Get.
type ServerAzureADAdministratorsGetResult struct {
	ServerAzureADAdministrator
}

// ServerAzureADAdministratorsListByServerResponse contains the response from method ServerAzureADAdministrators.ListByServer.
type ServerAzureADAdministratorsListByServerResponse struct {
	ServerAzureADAdministratorsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADAdministratorsListByServerResult contains the result from method ServerAzureADAdministrators.ListByServer.
type ServerAzureADAdministratorsListByServerResult struct {
	AdministratorListResult
}

// ServerAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse contains the response from method ServerAzureADOnlyAuthentications.CreateOrUpdate.
type ServerAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerAzureADOnlyAuthentication)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerAzureADOnlyAuthenticationsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerAzureADOnlyAuthenticationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAzureADOnlyAuthenticationsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse contains the response from method ServerAzureADOnlyAuthentications.CreateOrUpdate.
type ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse struct {
	ServerAzureADOnlyAuthenticationsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADOnlyAuthenticationsCreateOrUpdateResult contains the result from method ServerAzureADOnlyAuthentications.CreateOrUpdate.
type ServerAzureADOnlyAuthenticationsCreateOrUpdateResult struct {
	ServerAzureADOnlyAuthentication
}

// ServerAzureADOnlyAuthenticationsDeletePollerResponse contains the response from method ServerAzureADOnlyAuthentications.Delete.
type ServerAzureADOnlyAuthenticationsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerAzureADOnlyAuthenticationsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerAzureADOnlyAuthenticationsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerAzureADOnlyAuthenticationsDeletePollerResponse from the provided client and resume token.
func (l *ServerAzureADOnlyAuthenticationsDeletePollerResponse) Resume(ctx context.Context, client *ServerAzureADOnlyAuthenticationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerAzureADOnlyAuthenticationsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerAzureADOnlyAuthenticationsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerAzureADOnlyAuthenticationsDeleteResponse contains the response from method ServerAzureADOnlyAuthentications.Delete.
type ServerAzureADOnlyAuthenticationsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADOnlyAuthenticationsGetResponse contains the response from method ServerAzureADOnlyAuthentications.Get.
type ServerAzureADOnlyAuthenticationsGetResponse struct {
	ServerAzureADOnlyAuthenticationsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADOnlyAuthenticationsGetResult contains the result from method ServerAzureADOnlyAuthentications.Get.
type ServerAzureADOnlyAuthenticationsGetResult struct {
	ServerAzureADOnlyAuthentication
}

// ServerAzureADOnlyAuthenticationsListByServerResponse contains the response from method ServerAzureADOnlyAuthentications.ListByServer.
type ServerAzureADOnlyAuthenticationsListByServerResponse struct {
	ServerAzureADOnlyAuthenticationsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerAzureADOnlyAuthenticationsListByServerResult contains the result from method ServerAzureADOnlyAuthentications.ListByServer.
type ServerAzureADOnlyAuthenticationsListByServerResult struct {
	AzureADOnlyAuthListResult
}

// ServerBlobAuditingPoliciesCreateOrUpdatePollerResponse contains the response from method ServerBlobAuditingPolicies.CreateOrUpdate.
type ServerBlobAuditingPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerBlobAuditingPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerBlobAuditingPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerBlobAuditingPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerBlobAuditingPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerBlobAuditingPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerBlobAuditingPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerBlobAuditingPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerBlobAuditingPoliciesCreateOrUpdateResponse contains the response from method ServerBlobAuditingPolicies.CreateOrUpdate.
type ServerBlobAuditingPoliciesCreateOrUpdateResponse struct {
	ServerBlobAuditingPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerBlobAuditingPoliciesCreateOrUpdateResult contains the result from method ServerBlobAuditingPolicies.CreateOrUpdate.
type ServerBlobAuditingPoliciesCreateOrUpdateResult struct {
	ServerBlobAuditingPolicy
}

// ServerBlobAuditingPoliciesGetResponse contains the response from method ServerBlobAuditingPolicies.Get.
type ServerBlobAuditingPoliciesGetResponse struct {
	ServerBlobAuditingPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerBlobAuditingPoliciesGetResult contains the result from method ServerBlobAuditingPolicies.Get.
type ServerBlobAuditingPoliciesGetResult struct {
	ServerBlobAuditingPolicy
}

// ServerBlobAuditingPoliciesListByServerResponse contains the response from method ServerBlobAuditingPolicies.ListByServer.
type ServerBlobAuditingPoliciesListByServerResponse struct {
	ServerBlobAuditingPoliciesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerBlobAuditingPoliciesListByServerResult contains the result from method ServerBlobAuditingPolicies.ListByServer.
type ServerBlobAuditingPoliciesListByServerResult struct {
	ServerBlobAuditingPolicyListResult
}

// ServerCommunicationLinksCreateOrUpdatePollerResponse contains the response from method ServerCommunicationLinks.CreateOrUpdate.
type ServerCommunicationLinksCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerCommunicationLinksCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerCommunicationLinksCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerCommunicationLinksCreateOrUpdateResponse, error) {
	respType := ServerCommunicationLinksCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerCommunicationLink)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerCommunicationLinksCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerCommunicationLinksCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerCommunicationLinksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerCommunicationLinksClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerCommunicationLinksCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerCommunicationLinksCreateOrUpdateResponse contains the response from method ServerCommunicationLinks.CreateOrUpdate.
type ServerCommunicationLinksCreateOrUpdateResponse struct {
	ServerCommunicationLinksCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerCommunicationLinksCreateOrUpdateResult contains the result from method ServerCommunicationLinks.CreateOrUpdate.
type ServerCommunicationLinksCreateOrUpdateResult struct {
	ServerCommunicationLink
}

// ServerCommunicationLinksDeleteResponse contains the response from method ServerCommunicationLinks.Delete.
type ServerCommunicationLinksDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerCommunicationLinksGetResponse contains the response from method ServerCommunicationLinks.Get.
type ServerCommunicationLinksGetResponse struct {
	ServerCommunicationLinksGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerCommunicationLinksGetResult contains the result from method ServerCommunicationLinks.Get.
type ServerCommunicationLinksGetResult struct {
	ServerCommunicationLink
}

// ServerCommunicationLinksListByServerResponse contains the response from method ServerCommunicationLinks.ListByServer.
type ServerCommunicationLinksListByServerResponse struct {
	ServerCommunicationLinksListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerCommunicationLinksListByServerResult contains the result from method ServerCommunicationLinks.ListByServer.
type ServerCommunicationLinksListByServerResult struct {
	ServerCommunicationLinkListResult
}

// ServerConnectionPoliciesCreateOrUpdateResponse contains the response from method ServerConnectionPolicies.CreateOrUpdate.
type ServerConnectionPoliciesCreateOrUpdateResponse struct {
	ServerConnectionPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerConnectionPoliciesCreateOrUpdateResult contains the result from method ServerConnectionPolicies.CreateOrUpdate.
type ServerConnectionPoliciesCreateOrUpdateResult struct {
	ServerConnectionPolicy
}

// ServerConnectionPoliciesGetResponse contains the response from method ServerConnectionPolicies.Get.
type ServerConnectionPoliciesGetResponse struct {
	ServerConnectionPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerConnectionPoliciesGetResult contains the result from method ServerConnectionPolicies.Get.
type ServerConnectionPoliciesGetResult struct {
	ServerConnectionPolicy
}

// ServerDNSAliasesAcquirePollerResponse contains the response from method ServerDNSAliases.Acquire.
type ServerDNSAliasesAcquirePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerDNSAliasesAcquirePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerDNSAliasesAcquirePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesAcquireResponse, error) {
	respType := ServerDNSAliasesAcquireResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerDNSAlias)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerDNSAliasesAcquirePollerResponse from the provided client and resume token.
func (l *ServerDNSAliasesAcquirePollerResponse) Resume(ctx context.Context, client *ServerDNSAliasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerDNSAliasesClient.Acquire", token, client.pl, client.acquireHandleError)
	if err != nil {
		return err
	}
	poller := &ServerDNSAliasesAcquirePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerDNSAliasesAcquireResponse contains the response from method ServerDNSAliases.Acquire.
type ServerDNSAliasesAcquireResponse struct {
	ServerDNSAliasesAcquireResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDNSAliasesAcquireResult contains the result from method ServerDNSAliases.Acquire.
type ServerDNSAliasesAcquireResult struct {
	ServerDNSAlias
}

// ServerDNSAliasesCreateOrUpdatePollerResponse contains the response from method ServerDNSAliases.CreateOrUpdate.
type ServerDNSAliasesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerDNSAliasesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerDNSAliasesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesCreateOrUpdateResponse, error) {
	respType := ServerDNSAliasesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerDNSAlias)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerDNSAliasesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerDNSAliasesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerDNSAliasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerDNSAliasesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerDNSAliasesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerDNSAliasesCreateOrUpdateResponse contains the response from method ServerDNSAliases.CreateOrUpdate.
type ServerDNSAliasesCreateOrUpdateResponse struct {
	ServerDNSAliasesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDNSAliasesCreateOrUpdateResult contains the result from method ServerDNSAliases.CreateOrUpdate.
type ServerDNSAliasesCreateOrUpdateResult struct {
	ServerDNSAlias
}

// ServerDNSAliasesDeletePollerResponse contains the response from method ServerDNSAliases.Delete.
type ServerDNSAliasesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerDNSAliasesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerDNSAliasesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesDeleteResponse, error) {
	respType := ServerDNSAliasesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerDNSAliasesDeletePollerResponse from the provided client and resume token.
func (l *ServerDNSAliasesDeletePollerResponse) Resume(ctx context.Context, client *ServerDNSAliasesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerDNSAliasesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerDNSAliasesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerDNSAliasesDeleteResponse contains the response from method ServerDNSAliases.Delete.
type ServerDNSAliasesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDNSAliasesGetResponse contains the response from method ServerDNSAliases.Get.
type ServerDNSAliasesGetResponse struct {
	ServerDNSAliasesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDNSAliasesGetResult contains the result from method ServerDNSAliases.Get.
type ServerDNSAliasesGetResult struct {
	ServerDNSAlias
}

// ServerDNSAliasesListByServerResponse contains the response from method ServerDNSAliases.ListByServer.
type ServerDNSAliasesListByServerResponse struct {
	ServerDNSAliasesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDNSAliasesListByServerResult contains the result from method ServerDNSAliases.ListByServer.
type ServerDNSAliasesListByServerResult struct {
	ServerDNSAliasListResult
}

// ServerDevOpsAuditSettingsCreateOrUpdatePollerResponse contains the response from method ServerDevOpsAuditSettings.CreateOrUpdate.
type ServerDevOpsAuditSettingsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerDevOpsAuditSettingsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerDevOpsAuditSettingsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerDevOpsAuditSettingsCreateOrUpdateResponse, error) {
	respType := ServerDevOpsAuditSettingsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerDevOpsAuditingSettings)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerDevOpsAuditSettingsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerDevOpsAuditSettingsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerDevOpsAuditSettingsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerDevOpsAuditSettingsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerDevOpsAuditSettingsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerDevOpsAuditSettingsCreateOrUpdateResponse contains the response from method ServerDevOpsAuditSettings.CreateOrUpdate.
type ServerDevOpsAuditSettingsCreateOrUpdateResponse struct {
	ServerDevOpsAuditSettingsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDevOpsAuditSettingsCreateOrUpdateResult contains the result from method ServerDevOpsAuditSettings.CreateOrUpdate.
type ServerDevOpsAuditSettingsCreateOrUpdateResult struct {
	ServerDevOpsAuditingSettings
}

// ServerDevOpsAuditSettingsGetResponse contains the response from method ServerDevOpsAuditSettings.Get.
type ServerDevOpsAuditSettingsGetResponse struct {
	ServerDevOpsAuditSettingsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDevOpsAuditSettingsGetResult contains the result from method ServerDevOpsAuditSettings.Get.
type ServerDevOpsAuditSettingsGetResult struct {
	ServerDevOpsAuditingSettings
}

// ServerDevOpsAuditSettingsListByServerResponse contains the response from method ServerDevOpsAuditSettings.ListByServer.
type ServerDevOpsAuditSettingsListByServerResponse struct {
	ServerDevOpsAuditSettingsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerDevOpsAuditSettingsListByServerResult contains the result from method ServerDevOpsAuditSettings.ListByServer.
type ServerDevOpsAuditSettingsListByServerResult struct {
	ServerDevOpsAuditSettingsListResult
}

// ServerKeysCreateOrUpdatePollerResponse contains the response from method ServerKeys.CreateOrUpdate.
type ServerKeysCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerKeysCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerKeysCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysCreateOrUpdateResponse, error) {
	respType := ServerKeysCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerKeysCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerKeysCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerKeysClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerKeysCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerKeysCreateOrUpdateResponse contains the response from method ServerKeys.CreateOrUpdate.
type ServerKeysCreateOrUpdateResponse struct {
	ServerKeysCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysCreateOrUpdateResult contains the result from method ServerKeys.CreateOrUpdate.
type ServerKeysCreateOrUpdateResult struct {
	ServerKey
}

// ServerKeysDeletePollerResponse contains the response from method ServerKeys.Delete.
type ServerKeysDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerKeysDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerKeysDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysDeleteResponse, error) {
	respType := ServerKeysDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerKeysDeletePollerResponse from the provided client and resume token.
func (l *ServerKeysDeletePollerResponse) Resume(ctx context.Context, client *ServerKeysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerKeysClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerKeysDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerKeysDeleteResponse contains the response from method ServerKeys.Delete.
type ServerKeysDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysGetResponse contains the response from method ServerKeys.Get.
type ServerKeysGetResponse struct {
	ServerKeysGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysGetResult contains the result from method ServerKeys.Get.
type ServerKeysGetResult struct {
	ServerKey
}

// ServerKeysListByServerResponse contains the response from method ServerKeys.ListByServer.
type ServerKeysListByServerResponse struct {
	ServerKeysListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerKeysListByServerResult contains the result from method ServerKeys.ListByServer.
type ServerKeysListByServerResult struct {
	ServerKeyListResult
}

// ServerOperationsListByServerResponse contains the response from method ServerOperations.ListByServer.
type ServerOperationsListByServerResponse struct {
	ServerOperationsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerOperationsListByServerResult contains the result from method ServerOperations.ListByServer.
type ServerOperationsListByServerResult struct {
	ServerOperationListResult
}

// ServerSecurityAlertPoliciesCreateOrUpdatePollerResponse contains the response from method ServerSecurityAlertPolicies.CreateOrUpdate.
type ServerSecurityAlertPoliciesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerSecurityAlertPoliciesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerSecurityAlertPoliciesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerSecurityAlertPoliciesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerSecurityAlertPoliciesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerSecurityAlertPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerSecurityAlertPoliciesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerSecurityAlertPoliciesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerSecurityAlertPoliciesCreateOrUpdateResponse contains the response from method ServerSecurityAlertPolicies.CreateOrUpdate.
type ServerSecurityAlertPoliciesCreateOrUpdateResponse struct {
	ServerSecurityAlertPoliciesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesCreateOrUpdateResult contains the result from method ServerSecurityAlertPolicies.CreateOrUpdate.
type ServerSecurityAlertPoliciesCreateOrUpdateResult struct {
	ServerSecurityAlertPolicy
}

// ServerSecurityAlertPoliciesGetResponse contains the response from method ServerSecurityAlertPolicies.Get.
type ServerSecurityAlertPoliciesGetResponse struct {
	ServerSecurityAlertPoliciesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesGetResult contains the result from method ServerSecurityAlertPolicies.Get.
type ServerSecurityAlertPoliciesGetResult struct {
	ServerSecurityAlertPolicy
}

// ServerSecurityAlertPoliciesListByServerResponse contains the response from method ServerSecurityAlertPolicies.ListByServer.
type ServerSecurityAlertPoliciesListByServerResponse struct {
	ServerSecurityAlertPoliciesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerSecurityAlertPoliciesListByServerResult contains the result from method ServerSecurityAlertPolicies.ListByServer.
type ServerSecurityAlertPoliciesListByServerResult struct {
	LogicalServerSecurityAlertPolicyListResult
}

// ServerTrustGroupsCreateOrUpdatePollerResponse contains the response from method ServerTrustGroups.CreateOrUpdate.
type ServerTrustGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerTrustGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerTrustGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerTrustGroupsCreateOrUpdateResponse, error) {
	respType := ServerTrustGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServerTrustGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerTrustGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServerTrustGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServerTrustGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerTrustGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServerTrustGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerTrustGroupsCreateOrUpdateResponse contains the response from method ServerTrustGroups.CreateOrUpdate.
type ServerTrustGroupsCreateOrUpdateResponse struct {
	ServerTrustGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerTrustGroupsCreateOrUpdateResult contains the result from method ServerTrustGroups.CreateOrUpdate.
type ServerTrustGroupsCreateOrUpdateResult struct {
	ServerTrustGroup
}

// ServerTrustGroupsDeletePollerResponse contains the response from method ServerTrustGroups.Delete.
type ServerTrustGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServerTrustGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServerTrustGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServerTrustGroupsDeleteResponse, error) {
	respType := ServerTrustGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServerTrustGroupsDeletePollerResponse from the provided client and resume token.
func (l *ServerTrustGroupsDeletePollerResponse) Resume(ctx context.Context, client *ServerTrustGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServerTrustGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServerTrustGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServerTrustGroupsDeleteResponse contains the response from method ServerTrustGroups.Delete.
type ServerTrustGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerTrustGroupsGetResponse contains the response from method ServerTrustGroups.Get.
type ServerTrustGroupsGetResponse struct {
	ServerTrustGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerTrustGroupsGetResult contains the result from method ServerTrustGroups.Get.
type ServerTrustGroupsGetResult struct {
	ServerTrustGroup
}

// ServerTrustGroupsListByInstanceResponse contains the response from method ServerTrustGroups.ListByInstance.
type ServerTrustGroupsListByInstanceResponse struct {
	ServerTrustGroupsListByInstanceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerTrustGroupsListByInstanceResult contains the result from method ServerTrustGroups.ListByInstance.
type ServerTrustGroupsListByInstanceResult struct {
	ServerTrustGroupListResult
}

// ServerTrustGroupsListByLocationResponse contains the response from method ServerTrustGroups.ListByLocation.
type ServerTrustGroupsListByLocationResponse struct {
	ServerTrustGroupsListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerTrustGroupsListByLocationResult contains the result from method ServerTrustGroups.ListByLocation.
type ServerTrustGroupsListByLocationResult struct {
	ServerTrustGroupListResult
}

// ServerUsagesListByServerResponse contains the response from method ServerUsages.ListByServer.
type ServerUsagesListByServerResponse struct {
	ServerUsagesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerUsagesListByServerResult contains the result from method ServerUsages.ListByServer.
type ServerUsagesListByServerResult struct {
	ServerUsageListResult
}

// ServerVulnerabilityAssessmentsCreateOrUpdateResponse contains the response from method ServerVulnerabilityAssessments.CreateOrUpdate.
type ServerVulnerabilityAssessmentsCreateOrUpdateResponse struct {
	ServerVulnerabilityAssessmentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerVulnerabilityAssessmentsCreateOrUpdateResult contains the result from method ServerVulnerabilityAssessments.CreateOrUpdate.
type ServerVulnerabilityAssessmentsCreateOrUpdateResult struct {
	ServerVulnerabilityAssessment
}

// ServerVulnerabilityAssessmentsDeleteResponse contains the response from method ServerVulnerabilityAssessments.Delete.
type ServerVulnerabilityAssessmentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerVulnerabilityAssessmentsGetResponse contains the response from method ServerVulnerabilityAssessments.Get.
type ServerVulnerabilityAssessmentsGetResponse struct {
	ServerVulnerabilityAssessmentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerVulnerabilityAssessmentsGetResult contains the result from method ServerVulnerabilityAssessments.Get.
type ServerVulnerabilityAssessmentsGetResult struct {
	ServerVulnerabilityAssessment
}

// ServerVulnerabilityAssessmentsListByServerResponse contains the response from method ServerVulnerabilityAssessments.ListByServer.
type ServerVulnerabilityAssessmentsListByServerResponse struct {
	ServerVulnerabilityAssessmentsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServerVulnerabilityAssessmentsListByServerResult contains the result from method ServerVulnerabilityAssessments.ListByServer.
type ServerVulnerabilityAssessmentsListByServerResult struct {
	ServerVulnerabilityAssessmentListResult
}

// ServersCheckNameAvailabilityResponse contains the response from method Servers.CheckNameAvailability.
type ServersCheckNameAvailabilityResponse struct {
	ServersCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersCheckNameAvailabilityResult contains the result from method Servers.CheckNameAvailability.
type ServersCheckNameAvailabilityResult struct {
	CheckNameAvailabilityResponse
}

// ServersCreateOrUpdatePollerResponse contains the response from method Servers.CreateOrUpdate.
type ServersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersCreateOrUpdateResponse, error) {
	respType := ServersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ServersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersCreateOrUpdateResponse contains the response from method Servers.CreateOrUpdate.
type ServersCreateOrUpdateResponse struct {
	ServersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersCreateOrUpdateResult contains the result from method Servers.CreateOrUpdate.
type ServersCreateOrUpdateResult struct {
	Server
}

// ServersDeletePollerResponse contains the response from method Servers.Delete.
type ServersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersDeleteResponse, error) {
	respType := ServersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersDeletePollerResponse from the provided client and resume token.
func (l *ServersDeletePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ServersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersDeleteResponse contains the response from method Servers.Delete.
type ServersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersGetResponse contains the response from method Servers.Get.
type ServersGetResponse struct {
	ServersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersGetResult contains the result from method Servers.Get.
type ServersGetResult struct {
	Server
}

// ServersImportDatabasePollerResponse contains the response from method Servers.ImportDatabase.
type ServersImportDatabasePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersImportDatabasePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersImportDatabasePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersImportDatabaseResponse, error) {
	respType := ServersImportDatabaseResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersImportDatabasePollerResponse from the provided client and resume token.
func (l *ServersImportDatabasePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.ImportDatabase", token, client.pl, client.importDatabaseHandleError)
	if err != nil {
		return err
	}
	poller := &ServersImportDatabasePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersImportDatabaseResponse contains the response from method Servers.ImportDatabase.
type ServersImportDatabaseResponse struct {
	ServersImportDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersImportDatabaseResult contains the result from method Servers.ImportDatabase.
type ServersImportDatabaseResult struct {
	ImportExportOperationResult
}

// ServersListByResourceGroupResponse contains the response from method Servers.ListByResourceGroup.
type ServersListByResourceGroupResponse struct {
	ServersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersListByResourceGroupResult contains the result from method Servers.ListByResourceGroup.
type ServersListByResourceGroupResult struct {
	ServerListResult
}

// ServersListResponse contains the response from method Servers.List.
type ServersListResponse struct {
	ServersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersListResult contains the result from method Servers.List.
type ServersListResult struct {
	ServerListResult
}

// ServersUpdatePollerResponse contains the response from method Servers.Update.
type ServersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServersUpdateResponse, error) {
	respType := ServersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServersUpdatePollerResponse from the provided client and resume token.
func (l *ServersUpdatePollerResponse) Resume(ctx context.Context, client *ServersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &ServersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServersUpdateResponse contains the response from method Servers.Update.
type ServersUpdateResponse struct {
	ServersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServersUpdateResult contains the result from method Servers.Update.
type ServersUpdateResult struct {
	Server
}

// ServiceObjectivesGetResponse contains the response from method ServiceObjectives.Get.
type ServiceObjectivesGetResponse struct {
	ServiceObjectivesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceObjectivesGetResult contains the result from method ServiceObjectives.Get.
type ServiceObjectivesGetResult struct {
	ServiceObjective
}

// ServiceObjectivesListByServerResponse contains the response from method ServiceObjectives.ListByServer.
type ServiceObjectivesListByServerResponse struct {
	ServiceObjectivesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceObjectivesListByServerResult contains the result from method ServiceObjectives.ListByServer.
type ServiceObjectivesListByServerResult struct {
	ServiceObjectiveListResult
}

// SubscriptionUsagesGetResponse contains the response from method SubscriptionUsages.Get.
type SubscriptionUsagesGetResponse struct {
	SubscriptionUsagesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubscriptionUsagesGetResult contains the result from method SubscriptionUsages.Get.
type SubscriptionUsagesGetResult struct {
	SubscriptionUsage
}

// SubscriptionUsagesListByLocationResponse contains the response from method SubscriptionUsages.ListByLocation.
type SubscriptionUsagesListByLocationResponse struct {
	SubscriptionUsagesListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubscriptionUsagesListByLocationResult contains the result from method SubscriptionUsages.ListByLocation.
type SubscriptionUsagesListByLocationResult struct {
	SubscriptionUsageListResult
}

// SyncAgentsCreateOrUpdatePollerResponse contains the response from method SyncAgents.CreateOrUpdate.
type SyncAgentsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncAgentsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncAgentsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncAgentsCreateOrUpdateResponse, error) {
	respType := SyncAgentsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SyncAgent)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncAgentsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SyncAgentsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SyncAgentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncAgentsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SyncAgentsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncAgentsCreateOrUpdateResponse contains the response from method SyncAgents.CreateOrUpdate.
type SyncAgentsCreateOrUpdateResponse struct {
	SyncAgentsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsCreateOrUpdateResult contains the result from method SyncAgents.CreateOrUpdate.
type SyncAgentsCreateOrUpdateResult struct {
	SyncAgent
}

// SyncAgentsDeletePollerResponse contains the response from method SyncAgents.Delete.
type SyncAgentsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncAgentsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncAgentsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncAgentsDeleteResponse, error) {
	respType := SyncAgentsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncAgentsDeletePollerResponse from the provided client and resume token.
func (l *SyncAgentsDeletePollerResponse) Resume(ctx context.Context, client *SyncAgentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncAgentsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SyncAgentsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncAgentsDeleteResponse contains the response from method SyncAgents.Delete.
type SyncAgentsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsGenerateKeyResponse contains the response from method SyncAgents.GenerateKey.
type SyncAgentsGenerateKeyResponse struct {
	SyncAgentsGenerateKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsGenerateKeyResult contains the result from method SyncAgents.GenerateKey.
type SyncAgentsGenerateKeyResult struct {
	SyncAgentKeyProperties
}

// SyncAgentsGetResponse contains the response from method SyncAgents.Get.
type SyncAgentsGetResponse struct {
	SyncAgentsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsGetResult contains the result from method SyncAgents.Get.
type SyncAgentsGetResult struct {
	SyncAgent
}

// SyncAgentsListByServerResponse contains the response from method SyncAgents.ListByServer.
type SyncAgentsListByServerResponse struct {
	SyncAgentsListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsListByServerResult contains the result from method SyncAgents.ListByServer.
type SyncAgentsListByServerResult struct {
	SyncAgentListResult
}

// SyncAgentsListLinkedDatabasesResponse contains the response from method SyncAgents.ListLinkedDatabases.
type SyncAgentsListLinkedDatabasesResponse struct {
	SyncAgentsListLinkedDatabasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncAgentsListLinkedDatabasesResult contains the result from method SyncAgents.ListLinkedDatabases.
type SyncAgentsListLinkedDatabasesResult struct {
	SyncAgentLinkedDatabaseListResult
}

// SyncGroupsCancelSyncResponse contains the response from method SyncGroups.CancelSync.
type SyncGroupsCancelSyncResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsCreateOrUpdatePollerResponse contains the response from method SyncGroups.CreateOrUpdate.
type SyncGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsCreateOrUpdateResponse, error) {
	respType := SyncGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SyncGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SyncGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SyncGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SyncGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncGroupsCreateOrUpdateResponse contains the response from method SyncGroups.CreateOrUpdate.
type SyncGroupsCreateOrUpdateResponse struct {
	SyncGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsCreateOrUpdateResult contains the result from method SyncGroups.CreateOrUpdate.
type SyncGroupsCreateOrUpdateResult struct {
	SyncGroup
}

// SyncGroupsDeletePollerResponse contains the response from method SyncGroups.Delete.
type SyncGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsDeleteResponse, error) {
	respType := SyncGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncGroupsDeletePollerResponse from the provided client and resume token.
func (l *SyncGroupsDeletePollerResponse) Resume(ctx context.Context, client *SyncGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SyncGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncGroupsDeleteResponse contains the response from method SyncGroups.Delete.
type SyncGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsGetResponse contains the response from method SyncGroups.Get.
type SyncGroupsGetResponse struct {
	SyncGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsGetResult contains the result from method SyncGroups.Get.
type SyncGroupsGetResult struct {
	SyncGroup
}

// SyncGroupsListByDatabaseResponse contains the response from method SyncGroups.ListByDatabase.
type SyncGroupsListByDatabaseResponse struct {
	SyncGroupsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsListByDatabaseResult contains the result from method SyncGroups.ListByDatabase.
type SyncGroupsListByDatabaseResult struct {
	SyncGroupListResult
}

// SyncGroupsListHubSchemasResponse contains the response from method SyncGroups.ListHubSchemas.
type SyncGroupsListHubSchemasResponse struct {
	SyncGroupsListHubSchemasResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsListHubSchemasResult contains the result from method SyncGroups.ListHubSchemas.
type SyncGroupsListHubSchemasResult struct {
	SyncFullSchemaPropertiesListResult
}

// SyncGroupsListLogsResponse contains the response from method SyncGroups.ListLogs.
type SyncGroupsListLogsResponse struct {
	SyncGroupsListLogsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsListLogsResult contains the result from method SyncGroups.ListLogs.
type SyncGroupsListLogsResult struct {
	SyncGroupLogListResult
}

// SyncGroupsListSyncDatabaseIDsResponse contains the response from method SyncGroups.ListSyncDatabaseIDs.
type SyncGroupsListSyncDatabaseIDsResponse struct {
	SyncGroupsListSyncDatabaseIDsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsListSyncDatabaseIDsResult contains the result from method SyncGroups.ListSyncDatabaseIDs.
type SyncGroupsListSyncDatabaseIDsResult struct {
	SyncDatabaseIDListResult
}

// SyncGroupsRefreshHubSchemaPollerResponse contains the response from method SyncGroups.RefreshHubSchema.
type SyncGroupsRefreshHubSchemaPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncGroupsRefreshHubSchemaPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncGroupsRefreshHubSchemaPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsRefreshHubSchemaResponse, error) {
	respType := SyncGroupsRefreshHubSchemaResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncGroupsRefreshHubSchemaPollerResponse from the provided client and resume token.
func (l *SyncGroupsRefreshHubSchemaPollerResponse) Resume(ctx context.Context, client *SyncGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncGroupsClient.RefreshHubSchema", token, client.pl, client.refreshHubSchemaHandleError)
	if err != nil {
		return err
	}
	poller := &SyncGroupsRefreshHubSchemaPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncGroupsRefreshHubSchemaResponse contains the response from method SyncGroups.RefreshHubSchema.
type SyncGroupsRefreshHubSchemaResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsTriggerSyncResponse contains the response from method SyncGroups.TriggerSync.
type SyncGroupsTriggerSyncResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsUpdatePollerResponse contains the response from method SyncGroups.Update.
type SyncGroupsUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncGroupsUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncGroupsUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsUpdateResponse, error) {
	respType := SyncGroupsUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SyncGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncGroupsUpdatePollerResponse from the provided client and resume token.
func (l *SyncGroupsUpdatePollerResponse) Resume(ctx context.Context, client *SyncGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncGroupsClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &SyncGroupsUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncGroupsUpdateResponse contains the response from method SyncGroups.Update.
type SyncGroupsUpdateResponse struct {
	SyncGroupsUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncGroupsUpdateResult contains the result from method SyncGroups.Update.
type SyncGroupsUpdateResult struct {
	SyncGroup
}

// SyncMembersCreateOrUpdatePollerResponse contains the response from method SyncMembers.CreateOrUpdate.
type SyncMembersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncMembersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncMembersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersCreateOrUpdateResponse, error) {
	respType := SyncMembersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SyncMember)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncMembersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SyncMembersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SyncMembersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncMembersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &SyncMembersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncMembersCreateOrUpdateResponse contains the response from method SyncMembers.CreateOrUpdate.
type SyncMembersCreateOrUpdateResponse struct {
	SyncMembersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersCreateOrUpdateResult contains the result from method SyncMembers.CreateOrUpdate.
type SyncMembersCreateOrUpdateResult struct {
	SyncMember
}

// SyncMembersDeletePollerResponse contains the response from method SyncMembers.Delete.
type SyncMembersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncMembersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncMembersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersDeleteResponse, error) {
	respType := SyncMembersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncMembersDeletePollerResponse from the provided client and resume token.
func (l *SyncMembersDeletePollerResponse) Resume(ctx context.Context, client *SyncMembersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncMembersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &SyncMembersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncMembersDeleteResponse contains the response from method SyncMembers.Delete.
type SyncMembersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersGetResponse contains the response from method SyncMembers.Get.
type SyncMembersGetResponse struct {
	SyncMembersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersGetResult contains the result from method SyncMembers.Get.
type SyncMembersGetResult struct {
	SyncMember
}

// SyncMembersListBySyncGroupResponse contains the response from method SyncMembers.ListBySyncGroup.
type SyncMembersListBySyncGroupResponse struct {
	SyncMembersListBySyncGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersListBySyncGroupResult contains the result from method SyncMembers.ListBySyncGroup.
type SyncMembersListBySyncGroupResult struct {
	SyncMemberListResult
}

// SyncMembersListMemberSchemasResponse contains the response from method SyncMembers.ListMemberSchemas.
type SyncMembersListMemberSchemasResponse struct {
	SyncMembersListMemberSchemasResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersListMemberSchemasResult contains the result from method SyncMembers.ListMemberSchemas.
type SyncMembersListMemberSchemasResult struct {
	SyncFullSchemaPropertiesListResult
}

// SyncMembersRefreshMemberSchemaPollerResponse contains the response from method SyncMembers.RefreshMemberSchema.
type SyncMembersRefreshMemberSchemaPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncMembersRefreshMemberSchemaPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncMembersRefreshMemberSchemaPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersRefreshMemberSchemaResponse, error) {
	respType := SyncMembersRefreshMemberSchemaResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncMembersRefreshMemberSchemaPollerResponse from the provided client and resume token.
func (l *SyncMembersRefreshMemberSchemaPollerResponse) Resume(ctx context.Context, client *SyncMembersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncMembersClient.RefreshMemberSchema", token, client.pl, client.refreshMemberSchemaHandleError)
	if err != nil {
		return err
	}
	poller := &SyncMembersRefreshMemberSchemaPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncMembersRefreshMemberSchemaResponse contains the response from method SyncMembers.RefreshMemberSchema.
type SyncMembersRefreshMemberSchemaResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersUpdatePollerResponse contains the response from method SyncMembers.Update.
type SyncMembersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SyncMembersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SyncMembersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersUpdateResponse, error) {
	respType := SyncMembersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SyncMember)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SyncMembersUpdatePollerResponse from the provided client and resume token.
func (l *SyncMembersUpdatePollerResponse) Resume(ctx context.Context, client *SyncMembersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SyncMembersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &SyncMembersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SyncMembersUpdateResponse contains the response from method SyncMembers.Update.
type SyncMembersUpdateResponse struct {
	SyncMembersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SyncMembersUpdateResult contains the result from method SyncMembers.Update.
type SyncMembersUpdateResult struct {
	SyncMember
}

// TdeCertificatesCreatePollerResponse contains the response from method TdeCertificates.Create.
type TdeCertificatesCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TdeCertificatesCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l TdeCertificatesCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TdeCertificatesCreateResponse, error) {
	respType := TdeCertificatesCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TdeCertificatesCreatePollerResponse from the provided client and resume token.
func (l *TdeCertificatesCreatePollerResponse) Resume(ctx context.Context, client *TdeCertificatesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("TdeCertificatesClient.Create", token, client.pl, client.createHandleError)
	if err != nil {
		return err
	}
	poller := &TdeCertificatesCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TdeCertificatesCreateResponse contains the response from method TdeCertificates.Create.
type TdeCertificatesCreateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TimeZonesGetResponse contains the response from method TimeZones.Get.
type TimeZonesGetResponse struct {
	TimeZonesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TimeZonesGetResult contains the result from method TimeZones.Get.
type TimeZonesGetResult struct {
	TimeZone
}

// TimeZonesListByLocationResponse contains the response from method TimeZones.ListByLocation.
type TimeZonesListByLocationResponse struct {
	TimeZonesListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TimeZonesListByLocationResult contains the result from method TimeZones.ListByLocation.
type TimeZonesListByLocationResult struct {
	TimeZoneListResult
}

// TransparentDataEncryptionsCreateOrUpdateResponse contains the response from method TransparentDataEncryptions.CreateOrUpdate.
type TransparentDataEncryptionsCreateOrUpdateResponse struct {
	TransparentDataEncryptionsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TransparentDataEncryptionsCreateOrUpdateResult contains the result from method TransparentDataEncryptions.CreateOrUpdate.
type TransparentDataEncryptionsCreateOrUpdateResult struct {
	LogicalDatabaseTransparentDataEncryption
}

// TransparentDataEncryptionsGetResponse contains the response from method TransparentDataEncryptions.Get.
type TransparentDataEncryptionsGetResponse struct {
	TransparentDataEncryptionsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TransparentDataEncryptionsGetResult contains the result from method TransparentDataEncryptions.Get.
type TransparentDataEncryptionsGetResult struct {
	LogicalDatabaseTransparentDataEncryption
}

// TransparentDataEncryptionsListByDatabaseResponse contains the response from method TransparentDataEncryptions.ListByDatabase.
type TransparentDataEncryptionsListByDatabaseResponse struct {
	TransparentDataEncryptionsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TransparentDataEncryptionsListByDatabaseResult contains the result from method TransparentDataEncryptions.ListByDatabase.
type TransparentDataEncryptionsListByDatabaseResult struct {
	LogicalDatabaseTransparentDataEncryptionListResult
}

// UsagesListByInstancePoolResponse contains the response from method Usages.ListByInstancePool.
type UsagesListByInstancePoolResponse struct {
	UsagesListByInstancePoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesListByInstancePoolResult contains the result from method Usages.ListByInstancePool.
type UsagesListByInstancePoolResult struct {
	UsageListResult
}

// VirtualClustersDeletePollerResponse contains the response from method VirtualClusters.Delete.
type VirtualClustersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualClustersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualClustersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualClustersDeleteResponse, error) {
	respType := VirtualClustersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualClustersDeletePollerResponse from the provided client and resume token.
func (l *VirtualClustersDeletePollerResponse) Resume(ctx context.Context, client *VirtualClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualClustersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualClustersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualClustersDeleteResponse contains the response from method VirtualClusters.Delete.
type VirtualClustersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersGetResponse contains the response from method VirtualClusters.Get.
type VirtualClustersGetResponse struct {
	VirtualClustersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersGetResult contains the result from method VirtualClusters.Get.
type VirtualClustersGetResult struct {
	VirtualCluster
}

// VirtualClustersListByResourceGroupResponse contains the response from method VirtualClusters.ListByResourceGroup.
type VirtualClustersListByResourceGroupResponse struct {
	VirtualClustersListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersListByResourceGroupResult contains the result from method VirtualClusters.ListByResourceGroup.
type VirtualClustersListByResourceGroupResult struct {
	VirtualClusterListResult
}

// VirtualClustersListResponse contains the response from method VirtualClusters.List.
type VirtualClustersListResponse struct {
	VirtualClustersListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersListResult contains the result from method VirtualClusters.List.
type VirtualClustersListResult struct {
	VirtualClusterListResult
}

// VirtualClustersUpdateDNSServersResponse contains the response from method VirtualClusters.UpdateDNSServers.
type VirtualClustersUpdateDNSServersResponse struct {
	VirtualClustersUpdateDNSServersResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersUpdateDNSServersResult contains the result from method VirtualClusters.UpdateDNSServers.
type VirtualClustersUpdateDNSServersResult struct {
	UpdateManagedInstanceDNSServersOperation
}

// VirtualClustersUpdatePollerResponse contains the response from method VirtualClusters.Update.
type VirtualClustersUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualClustersUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualClustersUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualClustersUpdateResponse, error) {
	respType := VirtualClustersUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualCluster)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualClustersUpdatePollerResponse from the provided client and resume token.
func (l *VirtualClustersUpdatePollerResponse) Resume(ctx context.Context, client *VirtualClustersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualClustersClient.Update", token, client.pl, client.updateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualClustersUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualClustersUpdateResponse contains the response from method VirtualClusters.Update.
type VirtualClustersUpdateResponse struct {
	VirtualClustersUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualClustersUpdateResult contains the result from method VirtualClusters.Update.
type VirtualClustersUpdateResult struct {
	VirtualCluster
}

// VirtualNetworkRulesCreateOrUpdatePollerResponse contains the response from method VirtualNetworkRules.CreateOrUpdate.
type VirtualNetworkRulesCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkRulesCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkRulesCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkRulesCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkRulesCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkRulesClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkRulesCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkRulesCreateOrUpdateResponse contains the response from method VirtualNetworkRules.CreateOrUpdate.
type VirtualNetworkRulesCreateOrUpdateResponse struct {
	VirtualNetworkRulesCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesCreateOrUpdateResult contains the result from method VirtualNetworkRules.CreateOrUpdate.
type VirtualNetworkRulesCreateOrUpdateResult struct {
	VirtualNetworkRule
}

// VirtualNetworkRulesDeletePollerResponse contains the response from method VirtualNetworkRules.Delete.
type VirtualNetworkRulesDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkRulesDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkRulesDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesDeleteResponse, error) {
	respType := VirtualNetworkRulesDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkRulesDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkRulesDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkRulesClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkRulesDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkRulesDeleteResponse contains the response from method VirtualNetworkRules.Delete.
type VirtualNetworkRulesDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesGetResponse contains the response from method VirtualNetworkRules.Get.
type VirtualNetworkRulesGetResponse struct {
	VirtualNetworkRulesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesGetResult contains the result from method VirtualNetworkRules.Get.
type VirtualNetworkRulesGetResult struct {
	VirtualNetworkRule
}

// VirtualNetworkRulesListByServerResponse contains the response from method VirtualNetworkRules.ListByServer.
type VirtualNetworkRulesListByServerResponse struct {
	VirtualNetworkRulesListByServerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkRulesListByServerResult contains the result from method VirtualNetworkRules.ListByServer.
type VirtualNetworkRulesListByServerResult struct {
	VirtualNetworkRuleListResult
}

// WorkloadClassifiersCreateOrUpdatePollerResponse contains the response from method WorkloadClassifiers.CreateOrUpdate.
type WorkloadClassifiersCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadClassifiersCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadClassifiersCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadClassifiersCreateOrUpdateResponse, error) {
	respType := WorkloadClassifiersCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadClassifier)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadClassifiersCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *WorkloadClassifiersCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *WorkloadClassifiersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadClassifiersClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadClassifiersCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadClassifiersCreateOrUpdateResponse contains the response from method WorkloadClassifiers.CreateOrUpdate.
type WorkloadClassifiersCreateOrUpdateResponse struct {
	WorkloadClassifiersCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadClassifiersCreateOrUpdateResult contains the result from method WorkloadClassifiers.CreateOrUpdate.
type WorkloadClassifiersCreateOrUpdateResult struct {
	WorkloadClassifier
}

// WorkloadClassifiersDeletePollerResponse contains the response from method WorkloadClassifiers.Delete.
type WorkloadClassifiersDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadClassifiersDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadClassifiersDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadClassifiersDeleteResponse, error) {
	respType := WorkloadClassifiersDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadClassifiersDeletePollerResponse from the provided client and resume token.
func (l *WorkloadClassifiersDeletePollerResponse) Resume(ctx context.Context, client *WorkloadClassifiersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadClassifiersClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadClassifiersDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadClassifiersDeleteResponse contains the response from method WorkloadClassifiers.Delete.
type WorkloadClassifiersDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadClassifiersGetResponse contains the response from method WorkloadClassifiers.Get.
type WorkloadClassifiersGetResponse struct {
	WorkloadClassifiersGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadClassifiersGetResult contains the result from method WorkloadClassifiers.Get.
type WorkloadClassifiersGetResult struct {
	WorkloadClassifier
}

// WorkloadClassifiersListByWorkloadGroupResponse contains the response from method WorkloadClassifiers.ListByWorkloadGroup.
type WorkloadClassifiersListByWorkloadGroupResponse struct {
	WorkloadClassifiersListByWorkloadGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadClassifiersListByWorkloadGroupResult contains the result from method WorkloadClassifiers.ListByWorkloadGroup.
type WorkloadClassifiersListByWorkloadGroupResult struct {
	WorkloadClassifierListResult
}

// WorkloadGroupsCreateOrUpdatePollerResponse contains the response from method WorkloadGroups.CreateOrUpdate.
type WorkloadGroupsCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadGroupsCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadGroupsCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadGroupsCreateOrUpdateResponse, error) {
	respType := WorkloadGroupsCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.WorkloadGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadGroupsCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *WorkloadGroupsCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *WorkloadGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadGroupsClient.CreateOrUpdate", token, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadGroupsCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadGroupsCreateOrUpdateResponse contains the response from method WorkloadGroups.CreateOrUpdate.
type WorkloadGroupsCreateOrUpdateResponse struct {
	WorkloadGroupsCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadGroupsCreateOrUpdateResult contains the result from method WorkloadGroups.CreateOrUpdate.
type WorkloadGroupsCreateOrUpdateResult struct {
	WorkloadGroup
}

// WorkloadGroupsDeletePollerResponse contains the response from method WorkloadGroups.Delete.
type WorkloadGroupsDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WorkloadGroupsDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WorkloadGroupsDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WorkloadGroupsDeleteResponse, error) {
	respType := WorkloadGroupsDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WorkloadGroupsDeletePollerResponse from the provided client and resume token.
func (l *WorkloadGroupsDeletePollerResponse) Resume(ctx context.Context, client *WorkloadGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WorkloadGroupsClient.Delete", token, client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &WorkloadGroupsDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WorkloadGroupsDeleteResponse contains the response from method WorkloadGroups.Delete.
type WorkloadGroupsDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadGroupsGetResponse contains the response from method WorkloadGroups.Get.
type WorkloadGroupsGetResponse struct {
	WorkloadGroupsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadGroupsGetResult contains the result from method WorkloadGroups.Get.
type WorkloadGroupsGetResult struct {
	WorkloadGroup
}

// WorkloadGroupsListByDatabaseResponse contains the response from method WorkloadGroups.ListByDatabase.
type WorkloadGroupsListByDatabaseResponse struct {
	WorkloadGroupsListByDatabaseResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkloadGroupsListByDatabaseResult contains the result from method WorkloadGroups.ListByDatabase.
type WorkloadGroupsListByDatabaseResult struct {
	WorkloadGroupListResult
}
