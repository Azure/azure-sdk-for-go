//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AccessPolicy.
func (a AccessPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiryTime", a.ExpiryTime)
	populate(objectMap, "permission", a.Permission)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessPolicy.
func (a *AccessPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, "ExpiryTime", &a.ExpiryTime)
			delete(rawMsg, key)
		case "permission":
			err = unpopulate(val, "Permission", &a.Permission)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Account.
func (a Account) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", a.ExtendedLocation)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "sku", a.SKU)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type AccountCreateParameters.
func (a AccountCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", a.ExtendedLocation)
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "sku", a.SKU)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountKey.
func (a *AccountKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, "CreationTime", &a.CreationTime)
			delete(rawMsg, key)
		case "keyName":
			err = unpopulate(val, "KeyName", &a.KeyName)
			delete(rawMsg, key)
		case "permissions":
			err = unpopulate(val, "Permissions", &a.Permissions)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountProperties.
func (a AccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessTier", a.AccessTier)
	populate(objectMap, "allowBlobPublicAccess", a.AllowBlobPublicAccess)
	populate(objectMap, "allowCrossTenantReplication", a.AllowCrossTenantReplication)
	populate(objectMap, "allowSharedKeyAccess", a.AllowSharedKeyAccess)
	populate(objectMap, "allowedCopyScope", a.AllowedCopyScope)
	populate(objectMap, "azureFilesIdentityBasedAuthentication", a.AzureFilesIdentityBasedAuthentication)
	populate(objectMap, "blobRestoreStatus", a.BlobRestoreStatus)
	populateTimeRFC3339(objectMap, "creationTime", a.CreationTime)
	populate(objectMap, "customDomain", a.CustomDomain)
	populate(objectMap, "dnsEndpointType", a.DNSEndpointType)
	populate(objectMap, "defaultToOAuthAuthentication", a.DefaultToOAuthAuthentication)
	populate(objectMap, "supportsHttpsTrafficOnly", a.EnableHTTPSTrafficOnly)
	populate(objectMap, "isNfsV3Enabled", a.EnableNfsV3)
	populate(objectMap, "encryption", a.Encryption)
	populate(objectMap, "failoverInProgress", a.FailoverInProgress)
	populate(objectMap, "geoReplicationStats", a.GeoReplicationStats)
	populate(objectMap, "immutableStorageWithVersioning", a.ImmutableStorageWithVersioning)
	populate(objectMap, "isHnsEnabled", a.IsHnsEnabled)
	populate(objectMap, "isLocalUserEnabled", a.IsLocalUserEnabled)
	populate(objectMap, "isSftpEnabled", a.IsSftpEnabled)
	populate(objectMap, "keyCreationTime", a.KeyCreationTime)
	populate(objectMap, "keyPolicy", a.KeyPolicy)
	populate(objectMap, "largeFileSharesState", a.LargeFileSharesState)
	populateTimeRFC3339(objectMap, "lastGeoFailoverTime", a.LastGeoFailoverTime)
	populate(objectMap, "minimumTlsVersion", a.MinimumTLSVersion)
	populate(objectMap, "networkAcls", a.NetworkRuleSet)
	populate(objectMap, "primaryEndpoints", a.PrimaryEndpoints)
	populate(objectMap, "primaryLocation", a.PrimaryLocation)
	populate(objectMap, "privateEndpointConnections", a.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", a.PublicNetworkAccess)
	populate(objectMap, "routingPreference", a.RoutingPreference)
	populate(objectMap, "sasPolicy", a.SasPolicy)
	populate(objectMap, "secondaryEndpoints", a.SecondaryEndpoints)
	populate(objectMap, "secondaryLocation", a.SecondaryLocation)
	populate(objectMap, "statusOfPrimary", a.StatusOfPrimary)
	populate(objectMap, "statusOfSecondary", a.StatusOfSecondary)
	populate(objectMap, "storageAccountSkuConversionStatus", a.StorageAccountSKUConversionStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountProperties.
func (a *AccountProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTier":
			err = unpopulate(val, "AccessTier", &a.AccessTier)
			delete(rawMsg, key)
		case "allowBlobPublicAccess":
			err = unpopulate(val, "AllowBlobPublicAccess", &a.AllowBlobPublicAccess)
			delete(rawMsg, key)
		case "allowCrossTenantReplication":
			err = unpopulate(val, "AllowCrossTenantReplication", &a.AllowCrossTenantReplication)
			delete(rawMsg, key)
		case "allowSharedKeyAccess":
			err = unpopulate(val, "AllowSharedKeyAccess", &a.AllowSharedKeyAccess)
			delete(rawMsg, key)
		case "allowedCopyScope":
			err = unpopulate(val, "AllowedCopyScope", &a.AllowedCopyScope)
			delete(rawMsg, key)
		case "azureFilesIdentityBasedAuthentication":
			err = unpopulate(val, "AzureFilesIdentityBasedAuthentication", &a.AzureFilesIdentityBasedAuthentication)
			delete(rawMsg, key)
		case "blobRestoreStatus":
			err = unpopulate(val, "BlobRestoreStatus", &a.BlobRestoreStatus)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTimeRFC3339(val, "CreationTime", &a.CreationTime)
			delete(rawMsg, key)
		case "customDomain":
			err = unpopulate(val, "CustomDomain", &a.CustomDomain)
			delete(rawMsg, key)
		case "dnsEndpointType":
			err = unpopulate(val, "DNSEndpointType", &a.DNSEndpointType)
			delete(rawMsg, key)
		case "defaultToOAuthAuthentication":
			err = unpopulate(val, "DefaultToOAuthAuthentication", &a.DefaultToOAuthAuthentication)
			delete(rawMsg, key)
		case "supportsHttpsTrafficOnly":
			err = unpopulate(val, "EnableHTTPSTrafficOnly", &a.EnableHTTPSTrafficOnly)
			delete(rawMsg, key)
		case "isNfsV3Enabled":
			err = unpopulate(val, "EnableNfsV3", &a.EnableNfsV3)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, "Encryption", &a.Encryption)
			delete(rawMsg, key)
		case "failoverInProgress":
			err = unpopulate(val, "FailoverInProgress", &a.FailoverInProgress)
			delete(rawMsg, key)
		case "geoReplicationStats":
			err = unpopulate(val, "GeoReplicationStats", &a.GeoReplicationStats)
			delete(rawMsg, key)
		case "immutableStorageWithVersioning":
			err = unpopulate(val, "ImmutableStorageWithVersioning", &a.ImmutableStorageWithVersioning)
			delete(rawMsg, key)
		case "isHnsEnabled":
			err = unpopulate(val, "IsHnsEnabled", &a.IsHnsEnabled)
			delete(rawMsg, key)
		case "isLocalUserEnabled":
			err = unpopulate(val, "IsLocalUserEnabled", &a.IsLocalUserEnabled)
			delete(rawMsg, key)
		case "isSftpEnabled":
			err = unpopulate(val, "IsSftpEnabled", &a.IsSftpEnabled)
			delete(rawMsg, key)
		case "keyCreationTime":
			err = unpopulate(val, "KeyCreationTime", &a.KeyCreationTime)
			delete(rawMsg, key)
		case "keyPolicy":
			err = unpopulate(val, "KeyPolicy", &a.KeyPolicy)
			delete(rawMsg, key)
		case "largeFileSharesState":
			err = unpopulate(val, "LargeFileSharesState", &a.LargeFileSharesState)
			delete(rawMsg, key)
		case "lastGeoFailoverTime":
			err = unpopulateTimeRFC3339(val, "LastGeoFailoverTime", &a.LastGeoFailoverTime)
			delete(rawMsg, key)
		case "minimumTlsVersion":
			err = unpopulate(val, "MinimumTLSVersion", &a.MinimumTLSVersion)
			delete(rawMsg, key)
		case "networkAcls":
			err = unpopulate(val, "NetworkRuleSet", &a.NetworkRuleSet)
			delete(rawMsg, key)
		case "primaryEndpoints":
			err = unpopulate(val, "PrimaryEndpoints", &a.PrimaryEndpoints)
			delete(rawMsg, key)
		case "primaryLocation":
			err = unpopulate(val, "PrimaryLocation", &a.PrimaryLocation)
			delete(rawMsg, key)
		case "privateEndpointConnections":
			err = unpopulate(val, "PrivateEndpointConnections", &a.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, "PublicNetworkAccess", &a.PublicNetworkAccess)
			delete(rawMsg, key)
		case "routingPreference":
			err = unpopulate(val, "RoutingPreference", &a.RoutingPreference)
			delete(rawMsg, key)
		case "sasPolicy":
			err = unpopulate(val, "SasPolicy", &a.SasPolicy)
			delete(rawMsg, key)
		case "secondaryEndpoints":
			err = unpopulate(val, "SecondaryEndpoints", &a.SecondaryEndpoints)
			delete(rawMsg, key)
		case "secondaryLocation":
			err = unpopulate(val, "SecondaryLocation", &a.SecondaryLocation)
			delete(rawMsg, key)
		case "statusOfPrimary":
			err = unpopulate(val, "StatusOfPrimary", &a.StatusOfPrimary)
			delete(rawMsg, key)
		case "statusOfSecondary":
			err = unpopulate(val, "StatusOfSecondary", &a.StatusOfSecondary)
			delete(rawMsg, key)
		case "storageAccountSkuConversionStatus":
			err = unpopulate(val, "StorageAccountSKUConversionStatus", &a.StorageAccountSKUConversionStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountSasParameters.
func (a AccountSasParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "signedIp", a.IPAddressOrRange)
	populate(objectMap, "keyToSign", a.KeyToSign)
	populate(objectMap, "signedPermission", a.Permissions)
	populate(objectMap, "signedProtocol", a.Protocols)
	populate(objectMap, "signedResourceTypes", a.ResourceTypes)
	populate(objectMap, "signedServices", a.Services)
	populateTimeRFC3339(objectMap, "signedExpiry", a.SharedAccessExpiryTime)
	populateTimeRFC3339(objectMap, "signedStart", a.SharedAccessStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccountSasParameters.
func (a *AccountSasParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "signedIp":
			err = unpopulate(val, "IPAddressOrRange", &a.IPAddressOrRange)
			delete(rawMsg, key)
		case "keyToSign":
			err = unpopulate(val, "KeyToSign", &a.KeyToSign)
			delete(rawMsg, key)
		case "signedPermission":
			err = unpopulate(val, "Permissions", &a.Permissions)
			delete(rawMsg, key)
		case "signedProtocol":
			err = unpopulate(val, "Protocols", &a.Protocols)
			delete(rawMsg, key)
		case "signedResourceTypes":
			err = unpopulate(val, "ResourceTypes", &a.ResourceTypes)
			delete(rawMsg, key)
		case "signedServices":
			err = unpopulate(val, "Services", &a.Services)
			delete(rawMsg, key)
		case "signedExpiry":
			err = unpopulateTimeRFC3339(val, "SharedAccessExpiryTime", &a.SharedAccessExpiryTime)
			delete(rawMsg, key)
		case "signedStart":
			err = unpopulateTimeRFC3339(val, "SharedAccessStartTime", &a.SharedAccessStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AccountUpdateParameters.
func (a AccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", a.Identity)
	populate(objectMap, "kind", a.Kind)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "sku", a.SKU)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobContainer.
func (b BlobContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", b.ContainerProperties)
	populate(objectMap, "etag", b.Etag)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobInventoryPolicyDefinition.
func (b BlobInventoryPolicyDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filters", b.Filters)
	populate(objectMap, "format", b.Format)
	populate(objectMap, "objectType", b.ObjectType)
	populate(objectMap, "schedule", b.Schedule)
	populate(objectMap, "schemaFields", b.SchemaFields)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobInventoryPolicyFilter.
func (b BlobInventoryPolicyFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobTypes", b.BlobTypes)
	populate(objectMap, "excludePrefix", b.ExcludePrefix)
	populate(objectMap, "includeBlobVersions", b.IncludeBlobVersions)
	populate(objectMap, "includeDeleted", b.IncludeDeleted)
	populate(objectMap, "includeSnapshots", b.IncludeSnapshots)
	populate(objectMap, "prefixMatch", b.PrefixMatch)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobInventoryPolicyProperties.
func (b BlobInventoryPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "lastModifiedTime", b.LastModifiedTime)
	populate(objectMap, "policy", b.Policy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobInventoryPolicyProperties.
func (b *BlobInventoryPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &b.LastModifiedTime)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &b.Policy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobInventoryPolicySchema.
func (b BlobInventoryPolicySchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", b.Destination)
	populate(objectMap, "enabled", b.Enabled)
	populate(objectMap, "rules", b.Rules)
	populate(objectMap, "type", b.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobRestoreParameters.
func (b BlobRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobRanges", b.BlobRanges)
	populateTimeRFC3339(objectMap, "timeToRestore", b.TimeToRestore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobRestoreParameters.
func (b *BlobRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobRanges":
			err = unpopulate(val, "BlobRanges", &b.BlobRanges)
			delete(rawMsg, key)
		case "timeToRestore":
			err = unpopulateTimeRFC3339(val, "TimeToRestore", &b.TimeToRestore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultEncryptionScope", c.DefaultEncryptionScope)
	populate(objectMap, "deleted", c.Deleted)
	populateTimeRFC3339(objectMap, "deletedTime", c.DeletedTime)
	populate(objectMap, "denyEncryptionScopeOverride", c.DenyEncryptionScopeOverride)
	populate(objectMap, "enableNfsV3AllSquash", c.EnableNfsV3AllSquash)
	populate(objectMap, "enableNfsV3RootSquash", c.EnableNfsV3RootSquash)
	populate(objectMap, "hasImmutabilityPolicy", c.HasImmutabilityPolicy)
	populate(objectMap, "hasLegalHold", c.HasLegalHold)
	populate(objectMap, "immutabilityPolicy", c.ImmutabilityPolicy)
	populate(objectMap, "immutableStorageWithVersioning", c.ImmutableStorageWithVersioning)
	populateTimeRFC3339(objectMap, "lastModifiedTime", c.LastModifiedTime)
	populate(objectMap, "leaseDuration", c.LeaseDuration)
	populate(objectMap, "leaseState", c.LeaseState)
	populate(objectMap, "leaseStatus", c.LeaseStatus)
	populate(objectMap, "legalHold", c.LegalHold)
	populate(objectMap, "metadata", c.Metadata)
	populate(objectMap, "publicAccess", c.PublicAccess)
	populate(objectMap, "remainingRetentionDays", c.RemainingRetentionDays)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultEncryptionScope":
			err = unpopulate(val, "DefaultEncryptionScope", &c.DefaultEncryptionScope)
			delete(rawMsg, key)
		case "deleted":
			err = unpopulate(val, "Deleted", &c.Deleted)
			delete(rawMsg, key)
		case "deletedTime":
			err = unpopulateTimeRFC3339(val, "DeletedTime", &c.DeletedTime)
			delete(rawMsg, key)
		case "denyEncryptionScopeOverride":
			err = unpopulate(val, "DenyEncryptionScopeOverride", &c.DenyEncryptionScopeOverride)
			delete(rawMsg, key)
		case "enableNfsV3AllSquash":
			err = unpopulate(val, "EnableNfsV3AllSquash", &c.EnableNfsV3AllSquash)
			delete(rawMsg, key)
		case "enableNfsV3RootSquash":
			err = unpopulate(val, "EnableNfsV3RootSquash", &c.EnableNfsV3RootSquash)
			delete(rawMsg, key)
		case "hasImmutabilityPolicy":
			err = unpopulate(val, "HasImmutabilityPolicy", &c.HasImmutabilityPolicy)
			delete(rawMsg, key)
		case "hasLegalHold":
			err = unpopulate(val, "HasLegalHold", &c.HasLegalHold)
			delete(rawMsg, key)
		case "immutabilityPolicy":
			err = unpopulate(val, "ImmutabilityPolicy", &c.ImmutabilityPolicy)
			delete(rawMsg, key)
		case "immutableStorageWithVersioning":
			err = unpopulate(val, "ImmutableStorageWithVersioning", &c.ImmutableStorageWithVersioning)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &c.LastModifiedTime)
			delete(rawMsg, key)
		case "leaseDuration":
			err = unpopulate(val, "LeaseDuration", &c.LeaseDuration)
			delete(rawMsg, key)
		case "leaseState":
			err = unpopulate(val, "LeaseState", &c.LeaseState)
			delete(rawMsg, key)
		case "leaseStatus":
			err = unpopulate(val, "LeaseStatus", &c.LeaseStatus)
			delete(rawMsg, key)
		case "legalHold":
			err = unpopulate(val, "LegalHold", &c.LegalHold)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &c.Metadata)
			delete(rawMsg, key)
		case "publicAccess":
			err = unpopulate(val, "PublicAccess", &c.PublicAccess)
			delete(rawMsg, key)
		case "remainingRetentionDays":
			err = unpopulate(val, "RemainingRetentionDays", &c.RemainingRetentionDays)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CorsRule.
func (c CorsRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedHeaders", c.AllowedHeaders)
	populate(objectMap, "allowedMethods", c.AllowedMethods)
	populate(objectMap, "allowedOrigins", c.AllowedOrigins)
	populate(objectMap, "exposedHeaders", c.ExposedHeaders)
	populate(objectMap, "maxAgeInSeconds", c.MaxAgeInSeconds)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CorsRules.
func (c CorsRules) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "corsRules", c.CorsRules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionScope.
func (e EncryptionScope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.EncryptionScopeProperties)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionScopeKeyVaultProperties.
func (e EncryptionScopeKeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentVersionedKeyIdentifier", e.CurrentVersionedKeyIdentifier)
	populate(objectMap, "keyUri", e.KeyURI)
	populateTimeRFC3339(objectMap, "lastKeyRotationTimestamp", e.LastKeyRotationTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionScopeKeyVaultProperties.
func (e *EncryptionScopeKeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentVersionedKeyIdentifier":
			err = unpopulate(val, "CurrentVersionedKeyIdentifier", &e.CurrentVersionedKeyIdentifier)
			delete(rawMsg, key)
		case "keyUri":
			err = unpopulate(val, "KeyURI", &e.KeyURI)
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			err = unpopulateTimeRFC3339(val, "LastKeyRotationTimestamp", &e.LastKeyRotationTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionScopeProperties.
func (e EncryptionScopeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationTime", e.CreationTime)
	populate(objectMap, "keyVaultProperties", e.KeyVaultProperties)
	populateTimeRFC3339(objectMap, "lastModifiedTime", e.LastModifiedTime)
	populate(objectMap, "requireInfrastructureEncryption", e.RequireInfrastructureEncryption)
	populate(objectMap, "source", e.Source)
	populate(objectMap, "state", e.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionScopeProperties.
func (e *EncryptionScopeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, "CreationTime", &e.CreationTime)
			delete(rawMsg, key)
		case "keyVaultProperties":
			err = unpopulate(val, "KeyVaultProperties", &e.KeyVaultProperties)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &e.LastModifiedTime)
			delete(rawMsg, key)
		case "requireInfrastructureEncryption":
			err = unpopulate(val, "RequireInfrastructureEncryption", &e.RequireInfrastructureEncryption)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &e.Source)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &e.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionService.
func (e EncryptionService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", e.Enabled)
	populate(objectMap, "keyType", e.KeyType)
	populateTimeRFC3339(objectMap, "lastEnabledTime", e.LastEnabledTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionService.
func (e *EncryptionService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, "Enabled", &e.Enabled)
			delete(rawMsg, key)
		case "keyType":
			err = unpopulate(val, "KeyType", &e.KeyType)
			delete(rawMsg, key)
		case "lastEnabledTime":
			err = unpopulateTimeRFC3339(val, "LastEnabledTime", &e.LastEnabledTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileShare.
func (f FileShare) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", f.Etag)
	populate(objectMap, "properties", f.FileShareProperties)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type FileShareProperties.
func (f FileShareProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessTier", f.AccessTier)
	populateTimeRFC3339(objectMap, "accessTierChangeTime", f.AccessTierChangeTime)
	populate(objectMap, "accessTierStatus", f.AccessTierStatus)
	populate(objectMap, "deleted", f.Deleted)
	populateTimeRFC3339(objectMap, "deletedTime", f.DeletedTime)
	populate(objectMap, "enabledProtocols", f.EnabledProtocols)
	populateTimeRFC3339(objectMap, "lastModifiedTime", f.LastModifiedTime)
	populate(objectMap, "leaseDuration", f.LeaseDuration)
	populate(objectMap, "leaseState", f.LeaseState)
	populate(objectMap, "leaseStatus", f.LeaseStatus)
	populate(objectMap, "metadata", f.Metadata)
	populate(objectMap, "remainingRetentionDays", f.RemainingRetentionDays)
	populate(objectMap, "rootSquash", f.RootSquash)
	populate(objectMap, "shareQuota", f.ShareQuota)
	populate(objectMap, "shareUsageBytes", f.ShareUsageBytes)
	populate(objectMap, "signedIdentifiers", f.SignedIdentifiers)
	populateTimeRFC3339(objectMap, "snapshotTime", f.SnapshotTime)
	populate(objectMap, "version", f.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileShareProperties.
func (f *FileShareProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessTier":
			err = unpopulate(val, "AccessTier", &f.AccessTier)
			delete(rawMsg, key)
		case "accessTierChangeTime":
			err = unpopulateTimeRFC3339(val, "AccessTierChangeTime", &f.AccessTierChangeTime)
			delete(rawMsg, key)
		case "accessTierStatus":
			err = unpopulate(val, "AccessTierStatus", &f.AccessTierStatus)
			delete(rawMsg, key)
		case "deleted":
			err = unpopulate(val, "Deleted", &f.Deleted)
			delete(rawMsg, key)
		case "deletedTime":
			err = unpopulateTimeRFC3339(val, "DeletedTime", &f.DeletedTime)
			delete(rawMsg, key)
		case "enabledProtocols":
			err = unpopulate(val, "EnabledProtocols", &f.EnabledProtocols)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &f.LastModifiedTime)
			delete(rawMsg, key)
		case "leaseDuration":
			err = unpopulate(val, "LeaseDuration", &f.LeaseDuration)
			delete(rawMsg, key)
		case "leaseState":
			err = unpopulate(val, "LeaseState", &f.LeaseState)
			delete(rawMsg, key)
		case "leaseStatus":
			err = unpopulate(val, "LeaseStatus", &f.LeaseStatus)
			delete(rawMsg, key)
		case "metadata":
			err = unpopulate(val, "Metadata", &f.Metadata)
			delete(rawMsg, key)
		case "remainingRetentionDays":
			err = unpopulate(val, "RemainingRetentionDays", &f.RemainingRetentionDays)
			delete(rawMsg, key)
		case "rootSquash":
			err = unpopulate(val, "RootSquash", &f.RootSquash)
			delete(rawMsg, key)
		case "shareQuota":
			err = unpopulate(val, "ShareQuota", &f.ShareQuota)
			delete(rawMsg, key)
		case "shareUsageBytes":
			err = unpopulate(val, "ShareUsageBytes", &f.ShareUsageBytes)
			delete(rawMsg, key)
		case "signedIdentifiers":
			err = unpopulate(val, "SignedIdentifiers", &f.SignedIdentifiers)
			delete(rawMsg, key)
		case "snapshotTime":
			err = unpopulateTimeRFC3339(val, "SnapshotTime", &f.SnapshotTime)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &f.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GeoReplicationStats.
func (g GeoReplicationStats) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "canFailover", g.CanFailover)
	populateTimeRFC3339(objectMap, "lastSyncTime", g.LastSyncTime)
	populate(objectMap, "status", g.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoReplicationStats.
func (g *GeoReplicationStats) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "canFailover":
			err = unpopulate(val, "CanFailover", &g.CanFailover)
			delete(rawMsg, key)
		case "lastSyncTime":
			err = unpopulateTimeRFC3339(val, "LastSyncTime", &g.LastSyncTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &g.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", i.PrincipalID)
	populate(objectMap, "tenantId", i.TenantID)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "userAssignedIdentities", i.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ImmutabilityPolicyProperties.
func (i ImmutabilityPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", i.Etag)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "updateHistory", i.UpdateHistory)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ImmutableStorageWithVersioning.
func (i ImmutableStorageWithVersioning) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", i.Enabled)
	populate(objectMap, "migrationState", i.MigrationState)
	populateTimeRFC3339(objectMap, "timeStamp", i.TimeStamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImmutableStorageWithVersioning.
func (i *ImmutableStorageWithVersioning) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
			err = unpopulate(val, "Enabled", &i.Enabled)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, "MigrationState", &i.MigrationState)
			delete(rawMsg, key)
		case "timeStamp":
			err = unpopulateTimeRFC3339(val, "TimeStamp", &i.TimeStamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyCreationTime.
func (k KeyCreationTime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "key1", k.Key1)
	populateTimeRFC3339(objectMap, "key2", k.Key2)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyCreationTime.
func (k *KeyCreationTime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key1":
			err = unpopulateTimeRFC3339(val, "Key1", &k.Key1)
			delete(rawMsg, key)
		case "key2":
			err = unpopulateTimeRFC3339(val, "Key2", &k.Key2)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyVaultProperties.
func (k KeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "currentVersionedKeyExpirationTimestamp", k.CurrentVersionedKeyExpirationTimestamp)
	populate(objectMap, "currentVersionedKeyIdentifier", k.CurrentVersionedKeyIdentifier)
	populate(objectMap, "keyname", k.KeyName)
	populate(objectMap, "keyvaulturi", k.KeyVaultURI)
	populate(objectMap, "keyversion", k.KeyVersion)
	populateTimeRFC3339(objectMap, "lastKeyRotationTimestamp", k.LastKeyRotationTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyVaultProperties.
func (k *KeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentVersionedKeyExpirationTimestamp":
			err = unpopulateTimeRFC3339(val, "CurrentVersionedKeyExpirationTimestamp", &k.CurrentVersionedKeyExpirationTimestamp)
			delete(rawMsg, key)
		case "currentVersionedKeyIdentifier":
			err = unpopulate(val, "CurrentVersionedKeyIdentifier", &k.CurrentVersionedKeyIdentifier)
			delete(rawMsg, key)
		case "keyname":
			err = unpopulate(val, "KeyName", &k.KeyName)
			delete(rawMsg, key)
		case "keyvaulturi":
			err = unpopulate(val, "KeyVaultURI", &k.KeyVaultURI)
			delete(rawMsg, key)
		case "keyversion":
			err = unpopulate(val, "KeyVersion", &k.KeyVersion)
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			err = unpopulateTimeRFC3339(val, "LastKeyRotationTimestamp", &k.LastKeyRotationTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LastAccessTimeTrackingPolicy.
func (l LastAccessTimeTrackingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobType", l.BlobType)
	populate(objectMap, "enable", l.Enable)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "trackingGranularityInDays", l.TrackingGranularityInDays)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LegalHold.
func (l LegalHold) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowProtectedAppendWritesAll", l.AllowProtectedAppendWritesAll)
	populate(objectMap, "hasLegalHold", l.HasLegalHold)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LegalHoldProperties.
func (l LegalHoldProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hasLegalHold", l.HasLegalHold)
	populate(objectMap, "protectedAppendWritesHistory", l.ProtectedAppendWritesHistory)
	populate(objectMap, "tags", l.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ListQueueProperties.
func (l ListQueueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "metadata", l.Metadata)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type LocalUserProperties.
func (l LocalUserProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hasSshKey", l.HasSSHKey)
	populate(objectMap, "hasSshPassword", l.HasSSHPassword)
	populate(objectMap, "hasSharedKey", l.HasSharedKey)
	populate(objectMap, "homeDirectory", l.HomeDirectory)
	populate(objectMap, "permissionScopes", l.PermissionScopes)
	populate(objectMap, "sshAuthorizedKeys", l.SSHAuthorizedKeys)
	populate(objectMap, "sid", l.Sid)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ManagementPolicyFilter.
func (m ManagementPolicyFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobIndexMatch", m.BlobIndexMatch)
	populate(objectMap, "blobTypes", m.BlobTypes)
	populate(objectMap, "prefixMatch", m.PrefixMatch)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ManagementPolicyProperties.
func (m ManagementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "lastModifiedTime", m.LastModifiedTime)
	populate(objectMap, "policy", m.Policy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementPolicyProperties.
func (m *ManagementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, "LastModifiedTime", &m.LastModifiedTime)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, "Policy", &m.Policy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementPolicySchema.
func (m ManagementPolicySchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rules", m.Rules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSet.
func (n NetworkRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bypass", n.Bypass)
	populate(objectMap, "defaultAction", n.DefaultAction)
	populate(objectMap, "ipRules", n.IPRules)
	populate(objectMap, "resourceAccessRules", n.ResourceAccessRules)
	populate(objectMap, "virtualNetworkRules", n.VirtualNetworkRules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ObjectReplicationPolicyFilter.
func (o ObjectReplicationPolicyFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "minCreationTime", o.MinCreationTime)
	populate(objectMap, "prefixMatch", o.PrefixMatch)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ObjectReplicationPolicyProperties.
func (o ObjectReplicationPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destinationAccount", o.DestinationAccount)
	populateTimeRFC3339(objectMap, "enabledTime", o.EnabledTime)
	populate(objectMap, "policyId", o.PolicyID)
	populate(objectMap, "rules", o.Rules)
	populate(objectMap, "sourceAccount", o.SourceAccount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ObjectReplicationPolicyProperties.
func (o *ObjectReplicationPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destinationAccount":
			err = unpopulate(val, "DestinationAccount", &o.DestinationAccount)
			delete(rawMsg, key)
		case "enabledTime":
			err = unpopulateTimeRFC3339(val, "EnabledTime", &o.EnabledTime)
			delete(rawMsg, key)
		case "policyId":
			err = unpopulate(val, "PolicyID", &o.PolicyID)
			delete(rawMsg, key)
		case "rules":
			err = unpopulate(val, "Rules", &o.Rules)
			delete(rawMsg, key)
		case "sourceAccount":
			err = unpopulate(val, "SourceAccount", &o.SourceAccount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedAppendWritesHistory.
func (p ProtectedAppendWritesHistory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowProtectedAppendWritesAll", p.AllowProtectedAppendWritesAll)
	populateTimeRFC3339(objectMap, "timestamp", p.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedAppendWritesHistory.
func (p *ProtectedAppendWritesHistory) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowProtectedAppendWritesAll":
			err = unpopulate(val, "AllowProtectedAppendWritesAll", &p.AllowProtectedAppendWritesAll)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &p.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Queue.
func (q Queue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", q.ID)
	populate(objectMap, "name", q.Name)
	populate(objectMap, "properties", q.QueueProperties)
	populate(objectMap, "type", q.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type QueueProperties.
func (q QueueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "approximateMessageCount", q.ApproximateMessageCount)
	populate(objectMap, "metadata", q.Metadata)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RestorePolicyProperties.
func (r RestorePolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", r.Days)
	populate(objectMap, "enabled", r.Enabled)
	populateTimeRFC3339(objectMap, "lastEnabledTime", r.LastEnabledTime)
	populateTimeRFC3339(objectMap, "minRestoreTime", r.MinRestoreTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorePolicyProperties.
func (r *RestorePolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "days":
			err = unpopulate(val, "Days", &r.Days)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &r.Enabled)
			delete(rawMsg, key)
		case "lastEnabledTime":
			err = unpopulateTimeRFC3339(val, "LastEnabledTime", &r.LastEnabledTime)
			delete(rawMsg, key)
		case "minRestoreTime":
			err = unpopulateTimeRFC3339(val, "MinRestoreTime", &r.MinRestoreTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSasParameters.
func (s ServiceSasParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rscc", s.CacheControl)
	populate(objectMap, "canonicalizedResource", s.CanonicalizedResource)
	populate(objectMap, "rscd", s.ContentDisposition)
	populate(objectMap, "rsce", s.ContentEncoding)
	populate(objectMap, "rscl", s.ContentLanguage)
	populate(objectMap, "rsct", s.ContentType)
	populate(objectMap, "signedIp", s.IPAddressOrRange)
	populate(objectMap, "signedIdentifier", s.Identifier)
	populate(objectMap, "keyToSign", s.KeyToSign)
	populate(objectMap, "endPk", s.PartitionKeyEnd)
	populate(objectMap, "startPk", s.PartitionKeyStart)
	populate(objectMap, "signedPermission", s.Permissions)
	populate(objectMap, "signedProtocol", s.Protocols)
	populate(objectMap, "signedResource", s.Resource)
	populate(objectMap, "endRk", s.RowKeyEnd)
	populate(objectMap, "startRk", s.RowKeyStart)
	populateTimeRFC3339(objectMap, "signedExpiry", s.SharedAccessExpiryTime)
	populateTimeRFC3339(objectMap, "signedStart", s.SharedAccessStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceSasParameters.
func (s *ServiceSasParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rscc":
			err = unpopulate(val, "CacheControl", &s.CacheControl)
			delete(rawMsg, key)
		case "canonicalizedResource":
			err = unpopulate(val, "CanonicalizedResource", &s.CanonicalizedResource)
			delete(rawMsg, key)
		case "rscd":
			err = unpopulate(val, "ContentDisposition", &s.ContentDisposition)
			delete(rawMsg, key)
		case "rsce":
			err = unpopulate(val, "ContentEncoding", &s.ContentEncoding)
			delete(rawMsg, key)
		case "rscl":
			err = unpopulate(val, "ContentLanguage", &s.ContentLanguage)
			delete(rawMsg, key)
		case "rsct":
			err = unpopulate(val, "ContentType", &s.ContentType)
			delete(rawMsg, key)
		case "signedIp":
			err = unpopulate(val, "IPAddressOrRange", &s.IPAddressOrRange)
			delete(rawMsg, key)
		case "signedIdentifier":
			err = unpopulate(val, "Identifier", &s.Identifier)
			delete(rawMsg, key)
		case "keyToSign":
			err = unpopulate(val, "KeyToSign", &s.KeyToSign)
			delete(rawMsg, key)
		case "endPk":
			err = unpopulate(val, "PartitionKeyEnd", &s.PartitionKeyEnd)
			delete(rawMsg, key)
		case "startPk":
			err = unpopulate(val, "PartitionKeyStart", &s.PartitionKeyStart)
			delete(rawMsg, key)
		case "signedPermission":
			err = unpopulate(val, "Permissions", &s.Permissions)
			delete(rawMsg, key)
		case "signedProtocol":
			err = unpopulate(val, "Protocols", &s.Protocols)
			delete(rawMsg, key)
		case "signedResource":
			err = unpopulate(val, "Resource", &s.Resource)
			delete(rawMsg, key)
		case "endRk":
			err = unpopulate(val, "RowKeyEnd", &s.RowKeyEnd)
			delete(rawMsg, key)
		case "startRk":
			err = unpopulate(val, "RowKeyStart", &s.RowKeyStart)
			delete(rawMsg, key)
		case "signedExpiry":
			err = unpopulateTimeRFC3339(val, "SharedAccessExpiryTime", &s.SharedAccessExpiryTime)
			delete(rawMsg, key)
		case "signedStart":
			err = unpopulateTimeRFC3339(val, "SharedAccessStartTime", &s.SharedAccessStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Table.
func (t Table) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.TableProperties)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TableAccessPolicy.
func (t TableAccessPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expiryTime", t.ExpiryTime)
	populate(objectMap, "permission", t.Permission)
	populateTimeRFC3339(objectMap, "startTime", t.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TableAccessPolicy.
func (t *TableAccessPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, "ExpiryTime", &t.ExpiryTime)
			delete(rawMsg, key)
		case "permission":
			err = unpopulate(val, "Permission", &t.Permission)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, "StartTime", &t.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TableProperties.
func (t TableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "signedIdentifiers", t.SignedIdentifiers)
	populate(objectMap, "tableName", t.TableName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TagProperty.
func (t TagProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "objectIdentifier", t.ObjectIdentifier)
	populate(objectMap, "tag", t.Tag)
	populate(objectMap, "tenantId", t.TenantID)
	populateTimeRFC3339(objectMap, "timestamp", t.Timestamp)
	populate(objectMap, "upn", t.Upn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagProperty.
func (t *TagProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectIdentifier":
			err = unpopulate(val, "ObjectIdentifier", &t.ObjectIdentifier)
			delete(rawMsg, key)
		case "tag":
			err = unpopulate(val, "Tag", &t.Tag)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &t.TenantID)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &t.Timestamp)
			delete(rawMsg, key)
		case "upn":
			err = unpopulate(val, "Upn", &t.Upn)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type UpdateHistoryProperty.
func (u UpdateHistoryProperty) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowProtectedAppendWrites", u.AllowProtectedAppendWrites)
	populate(objectMap, "allowProtectedAppendWritesAll", u.AllowProtectedAppendWritesAll)
	populate(objectMap, "immutabilityPeriodSinceCreationInDays", u.ImmutabilityPeriodSinceCreationInDays)
	populate(objectMap, "objectIdentifier", u.ObjectIdentifier)
	populate(objectMap, "tenantId", u.TenantID)
	populateTimeRFC3339(objectMap, "timestamp", u.Timestamp)
	populate(objectMap, "update", u.Update)
	populate(objectMap, "upn", u.Upn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateHistoryProperty.
func (u *UpdateHistoryProperty) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowProtectedAppendWrites":
			err = unpopulate(val, "AllowProtectedAppendWrites", &u.AllowProtectedAppendWrites)
			delete(rawMsg, key)
		case "allowProtectedAppendWritesAll":
			err = unpopulate(val, "AllowProtectedAppendWritesAll", &u.AllowProtectedAppendWritesAll)
			delete(rawMsg, key)
		case "immutabilityPeriodSinceCreationInDays":
			err = unpopulate(val, "ImmutabilityPeriodSinceCreationInDays", &u.ImmutabilityPeriodSinceCreationInDays)
			delete(rawMsg, key)
		case "objectIdentifier":
			err = unpopulate(val, "ObjectIdentifier", &u.ObjectIdentifier)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &u.TenantID)
			delete(rawMsg, key)
		case "timestamp":
			err = unpopulateTimeRFC3339(val, "Timestamp", &u.Timestamp)
			delete(rawMsg, key)
		case "update":
			err = unpopulate(val, "Update", &u.Update)
			delete(rawMsg, key)
		case "upn":
			err = unpopulate(val, "Upn", &u.Upn)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
