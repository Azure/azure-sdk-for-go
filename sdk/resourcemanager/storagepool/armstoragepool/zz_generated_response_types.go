//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstoragepool

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DiskPoolZonesClientListResponse contains the response from method DiskPoolZonesClient.List.
type DiskPoolZonesClientListResponse struct {
	DiskPoolZonesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolZonesClientListResult contains the result from method DiskPoolZonesClient.List.
type DiskPoolZonesClientListResult struct {
	DiskPoolZoneListResult
}

// DiskPoolsClientCreateOrUpdatePollerResponse contains the response from method DiskPoolsClient.CreateOrUpdate.
type DiskPoolsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientCreateOrUpdateResponse, error) {
	respType := DiskPoolsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DiskPoolsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientCreateOrUpdateResponse contains the response from method DiskPoolsClient.CreateOrUpdate.
type DiskPoolsClientCreateOrUpdateResponse struct {
	DiskPoolsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientCreateOrUpdateResult contains the result from method DiskPoolsClient.CreateOrUpdate.
type DiskPoolsClientCreateOrUpdateResult struct {
	DiskPool
}

// DiskPoolsClientDeallocatePollerResponse contains the response from method DiskPoolsClient.Deallocate.
type DiskPoolsClientDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientDeallocatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientDeallocateResponse, error) {
	respType := DiskPoolsClientDeallocateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientDeallocatePollerResponse from the provided client and resume token.
func (l *DiskPoolsClientDeallocatePollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.Deallocate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientDeallocatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientDeallocateResponse contains the response from method DiskPoolsClient.Deallocate.
type DiskPoolsClientDeallocateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientDeletePollerResponse contains the response from method DiskPoolsClient.Delete.
type DiskPoolsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientDeleteResponse, error) {
	respType := DiskPoolsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientDeletePollerResponse from the provided client and resume token.
func (l *DiskPoolsClientDeletePollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientDeleteResponse contains the response from method DiskPoolsClient.Delete.
type DiskPoolsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientGetResponse contains the response from method DiskPoolsClient.Get.
type DiskPoolsClientGetResponse struct {
	DiskPoolsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientGetResult contains the result from method DiskPoolsClient.Get.
type DiskPoolsClientGetResult struct {
	DiskPool
}

// DiskPoolsClientListByResourceGroupResponse contains the response from method DiskPoolsClient.ListByResourceGroup.
type DiskPoolsClientListByResourceGroupResponse struct {
	DiskPoolsClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientListByResourceGroupResult contains the result from method DiskPoolsClient.ListByResourceGroup.
type DiskPoolsClientListByResourceGroupResult struct {
	DiskPoolListResult
}

// DiskPoolsClientListBySubscriptionResponse contains the response from method DiskPoolsClient.ListBySubscription.
type DiskPoolsClientListBySubscriptionResponse struct {
	DiskPoolsClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientListBySubscriptionResult contains the result from method DiskPoolsClient.ListBySubscription.
type DiskPoolsClientListBySubscriptionResult struct {
	DiskPoolListResult
}

// DiskPoolsClientListOutboundNetworkDependenciesEndpointsResponse contains the response from method DiskPoolsClient.ListOutboundNetworkDependenciesEndpoints.
type DiskPoolsClientListOutboundNetworkDependenciesEndpointsResponse struct {
	DiskPoolsClientListOutboundNetworkDependenciesEndpointsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientListOutboundNetworkDependenciesEndpointsResult contains the result from method DiskPoolsClient.ListOutboundNetworkDependenciesEndpoints.
type DiskPoolsClientListOutboundNetworkDependenciesEndpointsResult struct {
	OutboundEnvironmentEndpointList
}

// DiskPoolsClientStartPollerResponse contains the response from method DiskPoolsClient.Start.
type DiskPoolsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientStartResponse, error) {
	respType := DiskPoolsClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientStartPollerResponse from the provided client and resume token.
func (l *DiskPoolsClientStartPollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientStartResponse contains the response from method DiskPoolsClient.Start.
type DiskPoolsClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientUpdatePollerResponse contains the response from method DiskPoolsClient.Update.
type DiskPoolsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientUpdateResponse, error) {
	respType := DiskPoolsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskPool)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientUpdatePollerResponse from the provided client and resume token.
func (l *DiskPoolsClientUpdatePollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientUpdateResponse contains the response from method DiskPoolsClient.Update.
type DiskPoolsClientUpdateResponse struct {
	DiskPoolsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskPoolsClientUpdateResult contains the result from method DiskPoolsClient.Update.
type DiskPoolsClientUpdateResult struct {
	DiskPool
}

// DiskPoolsClientUpgradePollerResponse contains the response from method DiskPoolsClient.Upgrade.
type DiskPoolsClientUpgradePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskPoolsClientUpgradePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskPoolsClientUpgradePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskPoolsClientUpgradeResponse, error) {
	respType := DiskPoolsClientUpgradeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskPoolsClientUpgradePollerResponse from the provided client and resume token.
func (l *DiskPoolsClientUpgradePollerResponse) Resume(ctx context.Context, client *DiskPoolsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskPoolsClient.Upgrade", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskPoolsClientUpgradePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskPoolsClientUpgradeResponse contains the response from method DiskPoolsClient.Upgrade.
type DiskPoolsClientUpgradeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientCreateOrUpdatePollerResponse contains the response from method IscsiTargetsClient.CreateOrUpdate.
type IscsiTargetsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IscsiTargetsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IscsiTargetsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IscsiTargetsClientCreateOrUpdateResponse, error) {
	respType := IscsiTargetsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IscsiTarget)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IscsiTargetsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IscsiTargetsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IscsiTargetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IscsiTargetsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IscsiTargetsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IscsiTargetsClientCreateOrUpdateResponse contains the response from method IscsiTargetsClient.CreateOrUpdate.
type IscsiTargetsClientCreateOrUpdateResponse struct {
	IscsiTargetsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientCreateOrUpdateResult contains the result from method IscsiTargetsClient.CreateOrUpdate.
type IscsiTargetsClientCreateOrUpdateResult struct {
	IscsiTarget
}

// IscsiTargetsClientDeletePollerResponse contains the response from method IscsiTargetsClient.Delete.
type IscsiTargetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IscsiTargetsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IscsiTargetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IscsiTargetsClientDeleteResponse, error) {
	respType := IscsiTargetsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IscsiTargetsClientDeletePollerResponse from the provided client and resume token.
func (l *IscsiTargetsClientDeletePollerResponse) Resume(ctx context.Context, client *IscsiTargetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IscsiTargetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IscsiTargetsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IscsiTargetsClientDeleteResponse contains the response from method IscsiTargetsClient.Delete.
type IscsiTargetsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientGetResponse contains the response from method IscsiTargetsClient.Get.
type IscsiTargetsClientGetResponse struct {
	IscsiTargetsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientGetResult contains the result from method IscsiTargetsClient.Get.
type IscsiTargetsClientGetResult struct {
	IscsiTarget
}

// IscsiTargetsClientListByDiskPoolResponse contains the response from method IscsiTargetsClient.ListByDiskPool.
type IscsiTargetsClientListByDiskPoolResponse struct {
	IscsiTargetsClientListByDiskPoolResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientListByDiskPoolResult contains the result from method IscsiTargetsClient.ListByDiskPool.
type IscsiTargetsClientListByDiskPoolResult struct {
	IscsiTargetList
}

// IscsiTargetsClientUpdatePollerResponse contains the response from method IscsiTargetsClient.Update.
type IscsiTargetsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IscsiTargetsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IscsiTargetsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IscsiTargetsClientUpdateResponse, error) {
	respType := IscsiTargetsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IscsiTarget)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IscsiTargetsClientUpdatePollerResponse from the provided client and resume token.
func (l *IscsiTargetsClientUpdatePollerResponse) Resume(ctx context.Context, client *IscsiTargetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IscsiTargetsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IscsiTargetsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IscsiTargetsClientUpdateResponse contains the response from method IscsiTargetsClient.Update.
type IscsiTargetsClientUpdateResponse struct {
	IscsiTargetsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IscsiTargetsClientUpdateResult contains the result from method IscsiTargetsClient.Update.
type IscsiTargetsClientUpdateResult struct {
	IscsiTarget
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}

// ResourceSKUsClientListResponse contains the response from method ResourceSKUsClient.List.
type ResourceSKUsClientListResponse struct {
	ResourceSKUsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceSKUsClientListResult contains the result from method ResourceSKUsClient.List.
type ResourceSKUsClientListResult struct {
	ResourceSKUListResult
}
