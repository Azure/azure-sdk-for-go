//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstreamanalytics

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// GetFunctionProperties implements the FunctionPropertiesClassification interface for type AggregateFunctionProperties.
func (a *AggregateFunctionProperties) GetFunctionProperties() *FunctionProperties {
	return &FunctionProperties{
		Type:       a.Type,
		Etag:       a.Etag,
		Properties: a.Properties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AggregateFunctionProperties.
func (a AggregateFunctionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Aggregate"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AggregateFunctionProperties.
func (a *AggregateFunctionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSerialization implements the SerializationClassification interface for type AvroSerialization.
func (a *AvroSerialization) GetSerialization() *Serialization {
	return &Serialization{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AvroSerialization.
func (a AvroSerialization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", &a.Properties)
	objectMap["type"] = EventSerializationTypeAvro
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSerialization.
func (a *AvroSerialization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type AzureDataLakeStoreOutputDataSource.
func (a *AzureDataLakeStoreOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreOutputDataSource.
func (a AzureDataLakeStoreOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.DataLake/Accounts"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreOutputDataSource.
func (a *AzureDataLakeStoreOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type AzureFunctionOutputDataSource.
func (a *AzureFunctionOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionOutputDataSource.
func (a AzureFunctionOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.AzureFunction"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionOutputDataSource.
func (a *AzureFunctionOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFunctionBinding implements the FunctionBindingClassification interface for type AzureMachineLearningWebServiceFunctionBinding.
func (a *AzureMachineLearningWebServiceFunctionBinding) GetFunctionBinding() *FunctionBinding {
	return &FunctionBinding{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningWebServiceFunctionBinding.
func (a AzureMachineLearningWebServiceFunctionBinding) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.MachineLearning/WebService"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMachineLearningWebServiceFunctionBinding.
func (a *AzureMachineLearningWebServiceFunctionBinding) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningWebServiceFunctionBindingProperties.
func (a AzureMachineLearningWebServiceFunctionBindingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiKey", a.APIKey)
	populate(objectMap, "batchSize", a.BatchSize)
	populate(objectMap, "endpoint", a.Endpoint)
	populate(objectMap, "inputs", a.Inputs)
	populate(objectMap, "outputs", a.Outputs)
	return json.Marshal(objectMap)
}

// GetFunctionRetrieveDefaultDefinitionParameters implements the FunctionRetrieveDefaultDefinitionParametersClassification
// interface for type AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters.
func (a *AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters) GetFunctionRetrieveDefaultDefinitionParameters() *FunctionRetrieveDefaultDefinitionParameters {
	return &FunctionRetrieveDefaultDefinitionParameters{
		BindingType: a.BindingType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters.
func (a AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bindingRetrievalProperties", a.BindingRetrievalProperties)
	objectMap["bindingType"] = "Microsoft.MachineLearning/WebService"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters.
func (a *AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bindingRetrievalProperties":
			err = unpopulate(val, &a.BindingRetrievalProperties)
			delete(rawMsg, key)
		case "bindingType":
			err = unpopulate(val, &a.BindingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureMachineLearningWebServiceInputs.
func (a AzureMachineLearningWebServiceInputs) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "columnNames", a.ColumnNames)
	populate(objectMap, "name", a.Name)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type AzureSQLDatabaseOutputDataSource.
func (a *AzureSQLDatabaseOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseOutputDataSource.
func (a AzureSQLDatabaseOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.Sql/Server/Database"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseOutputDataSource.
func (a *AzureSQLDatabaseOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetReferenceInputDataSource implements the ReferenceInputDataSourceClassification interface for type AzureSQLReferenceInputDataSource.
func (a *AzureSQLReferenceInputDataSource) GetReferenceInputDataSource() *ReferenceInputDataSource {
	return &ReferenceInputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLReferenceInputDataSource.
func (a AzureSQLReferenceInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.Sql/Server/Database"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLReferenceInputDataSource.
func (a *AzureSQLReferenceInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type AzureSynapseOutputDataSource.
func (a *AzureSynapseOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureSynapseOutputDataSource.
func (a AzureSynapseOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.Sql/Server/DataWarehouse"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSynapseOutputDataSource.
func (a *AzureSynapseOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type AzureTableOutputDataSource.
func (a *AzureTableOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: a.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableOutputDataSource.
func (a AzureTableOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	objectMap["type"] = "Microsoft.Storage/Table"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableOutputDataSource.
func (a *AzureTableOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableOutputDataSourceProperties.
func (a AzureTableOutputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "batchSize", a.BatchSize)
	populate(objectMap, "columnsToRemove", a.ColumnsToRemove)
	populate(objectMap, "partitionKey", a.PartitionKey)
	populate(objectMap, "rowKey", a.RowKey)
	populate(objectMap, "table", a.Table)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobDataSourceProperties.
func (b BlobDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", b.AuthenticationMode)
	populate(objectMap, "container", b.Container)
	populate(objectMap, "dateFormat", b.DateFormat)
	populate(objectMap, "pathPattern", b.PathPattern)
	populate(objectMap, "storageAccounts", b.StorageAccounts)
	populate(objectMap, "timeFormat", b.TimeFormat)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type BlobOutputDataSource.
func (b *BlobOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: b.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobOutputDataSource.
func (b BlobOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", b.Properties)
	objectMap["type"] = "Microsoft.Storage/Blob"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobOutputDataSource.
func (b *BlobOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobOutputDataSourceProperties.
func (b BlobOutputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", b.AuthenticationMode)
	populate(objectMap, "container", b.Container)
	populate(objectMap, "dateFormat", b.DateFormat)
	populate(objectMap, "pathPattern", b.PathPattern)
	populate(objectMap, "storageAccounts", b.StorageAccounts)
	populate(objectMap, "timeFormat", b.TimeFormat)
	return json.Marshal(objectMap)
}

// GetReferenceInputDataSource implements the ReferenceInputDataSourceClassification interface for type BlobReferenceInputDataSource.
func (b *BlobReferenceInputDataSource) GetReferenceInputDataSource() *ReferenceInputDataSource {
	return &ReferenceInputDataSource{
		Type: b.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobReferenceInputDataSource.
func (b BlobReferenceInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", b.Properties)
	objectMap["type"] = "Microsoft.Storage/Blob"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobReferenceInputDataSource.
func (b *BlobReferenceInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobReferenceInputDataSourceProperties.
func (b BlobReferenceInputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", b.AuthenticationMode)
	populate(objectMap, "container", b.Container)
	populate(objectMap, "dateFormat", b.DateFormat)
	populate(objectMap, "pathPattern", b.PathPattern)
	populate(objectMap, "storageAccounts", b.StorageAccounts)
	populate(objectMap, "timeFormat", b.TimeFormat)
	return json.Marshal(objectMap)
}

// GetStreamInputDataSource implements the StreamInputDataSourceClassification interface for type BlobStreamInputDataSource.
func (b *BlobStreamInputDataSource) GetStreamInputDataSource() *StreamInputDataSource {
	return &StreamInputDataSource{
		Type: b.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobStreamInputDataSource.
func (b BlobStreamInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", b.Properties)
	objectMap["type"] = "Microsoft.Storage/Blob"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobStreamInputDataSource.
func (b *BlobStreamInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobStreamInputDataSourceProperties.
func (b BlobStreamInputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", b.AuthenticationMode)
	populate(objectMap, "container", b.Container)
	populate(objectMap, "dateFormat", b.DateFormat)
	populate(objectMap, "pathPattern", b.PathPattern)
	populate(objectMap, "sourcePartitionCount", b.SourcePartitionCount)
	populate(objectMap, "storageAccounts", b.StorageAccounts)
	populate(objectMap, "timeFormat", b.TimeFormat)
	return json.Marshal(objectMap)
}

// GetSerialization implements the SerializationClassification interface for type CSVSerialization.
func (c *CSVSerialization) GetSerialization() *Serialization {
	return &Serialization{
		Type: c.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CSVSerialization.
func (c CSVSerialization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", c.Properties)
	objectMap["type"] = EventSerializationTypeCSV
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CSVSerialization.
func (c *CSVSerialization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterJobListResult.
func (c ClusterJobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterListResult.
func (c ClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capacityAllocated", c.CapacityAllocated)
	populate(objectMap, "capacityAssigned", c.CapacityAssigned)
	populate(objectMap, "clusterId", c.ClusterID)
	populateTimeRFC3339(objectMap, "createdDate", c.CreatedDate)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterProperties.
func (c *ClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityAllocated":
			err = unpopulate(val, &c.CapacityAllocated)
			delete(rawMsg, key)
		case "capacityAssigned":
			err = unpopulate(val, &c.CapacityAssigned)
			delete(rawMsg, key)
		case "clusterId":
			err = unpopulate(val, &c.ClusterID)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &c.CreatedDate)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Diagnostics.
func (d Diagnostics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "conditions", d.Conditions)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type DocumentDbOutputDataSource.
func (d *DocumentDbOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: d.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbOutputDataSource.
func (d DocumentDbOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", d.Properties)
	objectMap["type"] = "Microsoft.Storage/DocumentDB"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbOutputDataSource.
func (d *DocumentDbOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorError.
func (e ErrorError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type EventHubOutputDataSource.
func (e *EventHubOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: e.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EventHubOutputDataSource.
func (e EventHubOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	objectMap["type"] = "Microsoft.ServiceBus/EventHub"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubOutputDataSource.
func (e *EventHubOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EventHubOutputDataSourceProperties.
func (e EventHubOutputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", e.AuthenticationMode)
	populate(objectMap, "eventHubName", e.EventHubName)
	populate(objectMap, "partitionKey", e.PartitionKey)
	populate(objectMap, "propertyColumns", e.PropertyColumns)
	populate(objectMap, "serviceBusNamespace", e.ServiceBusNamespace)
	populate(objectMap, "sharedAccessPolicyKey", e.SharedAccessPolicyKey)
	populate(objectMap, "sharedAccessPolicyName", e.SharedAccessPolicyName)
	return json.Marshal(objectMap)
}

// GetStreamInputDataSource implements the StreamInputDataSourceClassification interface for type EventHubStreamInputDataSource.
func (e *EventHubStreamInputDataSource) GetStreamInputDataSource() *StreamInputDataSource {
	return &StreamInputDataSource{
		Type: e.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EventHubStreamInputDataSource.
func (e EventHubStreamInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	objectMap["type"] = "Microsoft.ServiceBus/EventHub"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubStreamInputDataSource.
func (e *EventHubStreamInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type EventHubV2OutputDataSource.
func (e *EventHubV2OutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: e.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EventHubV2OutputDataSource.
func (e EventHubV2OutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	objectMap["type"] = "Microsoft.EventHub/EventHub"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubV2OutputDataSource.
func (e *EventHubV2OutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetStreamInputDataSource implements the StreamInputDataSourceClassification interface for type EventHubV2StreamInputDataSource.
func (e *EventHubV2StreamInputDataSource) GetStreamInputDataSource() *StreamInputDataSource {
	return &StreamInputDataSource{
		Type: e.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type EventHubV2StreamInputDataSource.
func (e EventHubV2StreamInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", e.Properties)
	objectMap["type"] = "Microsoft.EventHub/EventHub"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubV2StreamInputDataSource.
func (e *EventHubV2StreamInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Function.
func (f Function) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", f.ID)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "type", f.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Function.
func (f *Function) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &f.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &f.Name)
			delete(rawMsg, key)
		case "properties":
			f.Properties, err = unmarshalFunctionPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFunctionBinding implements the FunctionBindingClassification interface for type FunctionBinding.
func (f *FunctionBinding) GetFunctionBinding() *FunctionBinding { return f }

// MarshalJSON implements the json.Marshaller interface for type FunctionConfiguration.
func (f FunctionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "binding", f.Binding)
	populate(objectMap, "inputs", f.Inputs)
	populate(objectMap, "output", f.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionConfiguration.
func (f *FunctionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "binding":
			f.Binding, err = unmarshalFunctionBindingClassification(val)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, &f.Inputs)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &f.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionListResult.
func (f FunctionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// GetFunctionProperties implements the FunctionPropertiesClassification interface for type FunctionProperties.
func (f *FunctionProperties) GetFunctionProperties() *FunctionProperties { return f }

// GetFunctionRetrieveDefaultDefinitionParameters implements the FunctionRetrieveDefaultDefinitionParametersClassification
// interface for type FunctionRetrieveDefaultDefinitionParameters.
func (f *FunctionRetrieveDefaultDefinitionParameters) GetFunctionRetrieveDefaultDefinitionParameters() *FunctionRetrieveDefaultDefinitionParameters {
	return f
}

// MarshalJSON implements the json.Marshaller interface for type Input.
func (i Input) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Input.
func (i *Input) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalInputPropertiesClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InputListResult.
func (i InputListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// GetInputProperties implements the InputPropertiesClassification interface for type InputProperties.
func (i *InputProperties) GetInputProperties() *InputProperties { return i }

// MarshalJSON implements the json.Marshaller interface for type InputProperties.
func (i InputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", i.Compression)
	populate(objectMap, "diagnostics", i.Diagnostics)
	populate(objectMap, "etag", i.Etag)
	populate(objectMap, "partitionKey", i.PartitionKey)
	populate(objectMap, "serialization", i.Serialization)
	objectMap["type"] = i.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputProperties.
func (i *InputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &i.Compression)
			delete(rawMsg, key)
		case "diagnostics":
			err = unpopulate(val, &i.Diagnostics)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &i.Etag)
			delete(rawMsg, key)
		case "partitionKey":
			err = unpopulate(val, &i.PartitionKey)
			delete(rawMsg, key)
		case "serialization":
			i.Serialization, err = unmarshalSerializationClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetStreamInputDataSource implements the StreamInputDataSourceClassification interface for type IoTHubStreamInputDataSource.
func (i *IoTHubStreamInputDataSource) GetStreamInputDataSource() *StreamInputDataSource {
	return &StreamInputDataSource{
		Type: i.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type IoTHubStreamInputDataSource.
func (i IoTHubStreamInputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", i.Properties)
	objectMap["type"] = "Microsoft.Devices/IotHubs"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoTHubStreamInputDataSource.
func (i *IoTHubStreamInputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSerialization implements the SerializationClassification interface for type JSONSerialization.
func (j *JSONSerialization) GetSerialization() *Serialization {
	return &Serialization{
		Type: j.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JSONSerialization.
func (j JSONSerialization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", j.Properties)
	objectMap["type"] = EventSerializationTypeJSON
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSerialization.
func (j *JSONSerialization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFunctionBinding implements the FunctionBindingClassification interface for type JavaScriptFunctionBinding.
func (j *JavaScriptFunctionBinding) GetFunctionBinding() *FunctionBinding {
	return &FunctionBinding{
		Type: j.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JavaScriptFunctionBinding.
func (j JavaScriptFunctionBinding) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", j.Properties)
	objectMap["type"] = "Microsoft.StreamAnalytics/JavascriptUdf"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JavaScriptFunctionBinding.
func (j *JavaScriptFunctionBinding) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &j.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFunctionRetrieveDefaultDefinitionParameters implements the FunctionRetrieveDefaultDefinitionParametersClassification
// interface for type JavaScriptFunctionRetrieveDefaultDefinitionParameters.
func (j *JavaScriptFunctionRetrieveDefaultDefinitionParameters) GetFunctionRetrieveDefaultDefinitionParameters() *FunctionRetrieveDefaultDefinitionParameters {
	return &FunctionRetrieveDefaultDefinitionParameters{
		BindingType: j.BindingType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type JavaScriptFunctionRetrieveDefaultDefinitionParameters.
func (j JavaScriptFunctionRetrieveDefaultDefinitionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bindingRetrievalProperties", j.BindingRetrievalProperties)
	objectMap["bindingType"] = "Microsoft.StreamAnalytics/JavascriptUdf"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JavaScriptFunctionRetrieveDefaultDefinitionParameters.
func (j *JavaScriptFunctionRetrieveDefaultDefinitionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bindingRetrievalProperties":
			err = unpopulate(val, &j.BindingRetrievalProperties)
			delete(rawMsg, key)
		case "bindingType":
			err = unpopulate(val, &j.BindingType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Output.
func (o Output) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "properties", o.Properties)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type OutputDataSource.
func (o *OutputDataSource) GetOutputDataSource() *OutputDataSource { return o }

// MarshalJSON implements the json.Marshaller interface for type OutputListResult.
func (o OutputListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OutputProperties.
func (o OutputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasource", o.Datasource)
	populate(objectMap, "diagnostics", o.Diagnostics)
	populate(objectMap, "etag", o.Etag)
	populate(objectMap, "serialization", o.Serialization)
	populate(objectMap, "sizeWindow", o.SizeWindow)
	populate(objectMap, "timeWindow", o.TimeWindow)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputProperties.
func (o *OutputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasource":
			o.Datasource, err = unmarshalOutputDataSourceClassification(val)
			delete(rawMsg, key)
		case "diagnostics":
			err = unpopulate(val, &o.Diagnostics)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &o.Etag)
			delete(rawMsg, key)
		case "serialization":
			o.Serialization, err = unmarshalSerializationClassification(val)
			delete(rawMsg, key)
		case "sizeWindow":
			err = unpopulate(val, &o.SizeWindow)
			delete(rawMsg, key)
		case "timeWindow":
			err = unpopulate(val, &o.TimeWindow)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSerialization implements the SerializationClassification interface for type ParquetSerialization.
func (p *ParquetSerialization) GetSerialization() *Serialization {
	return &Serialization{
		Type: p.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSerialization.
func (p ParquetSerialization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", &p.Properties)
	objectMap["type"] = EventSerializationTypeParquet
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSerialization.
func (p *ParquetSerialization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type PowerBIOutputDataSource.
func (p *PowerBIOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: p.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PowerBIOutputDataSource.
func (p PowerBIOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	objectMap["type"] = "PowerBI"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PowerBIOutputDataSource.
func (p *PowerBIOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointListResult.
func (p PrivateEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointProperties.
func (p PrivateEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdDate", p.CreatedDate)
	populate(objectMap, "manualPrivateLinkServiceConnections", p.ManualPrivateLinkServiceConnections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkServiceConnectionProperties.
func (p PrivateLinkServiceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupIds", p.GroupIDs)
	populate(objectMap, "privateLinkServiceConnectionState", p.PrivateLinkServiceConnectionState)
	populate(objectMap, "privateLinkServiceId", p.PrivateLinkServiceID)
	populate(objectMap, "requestMessage", p.RequestMessage)
	return json.Marshal(objectMap)
}

// GetReferenceInputDataSource implements the ReferenceInputDataSourceClassification interface for type ReferenceInputDataSource.
func (r *ReferenceInputDataSource) GetReferenceInputDataSource() *ReferenceInputDataSource { return r }

// GetInputProperties implements the InputPropertiesClassification interface for type ReferenceInputProperties.
func (r *ReferenceInputProperties) GetInputProperties() *InputProperties {
	return &InputProperties{
		Type:          r.Type,
		Serialization: r.Serialization,
		Diagnostics:   r.Diagnostics,
		Etag:          r.Etag,
		Compression:   r.Compression,
		PartitionKey:  r.PartitionKey,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ReferenceInputProperties.
func (r ReferenceInputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", r.Compression)
	populate(objectMap, "datasource", r.Datasource)
	populate(objectMap, "diagnostics", r.Diagnostics)
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "partitionKey", r.PartitionKey)
	populate(objectMap, "serialization", r.Serialization)
	objectMap["type"] = "Reference"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReferenceInputProperties.
func (r *ReferenceInputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &r.Compression)
			delete(rawMsg, key)
		case "datasource":
			r.Datasource, err = unmarshalReferenceInputDataSourceClassification(val)
			delete(rawMsg, key)
		case "diagnostics":
			err = unpopulate(val, &r.Diagnostics)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &r.Etag)
			delete(rawMsg, key)
		case "partitionKey":
			err = unpopulate(val, &r.PartitionKey)
			delete(rawMsg, key)
		case "serialization":
			r.Serialization, err = unmarshalSerializationClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFunctionProperties implements the FunctionPropertiesClassification interface for type ScalarFunctionProperties.
func (s *ScalarFunctionProperties) GetFunctionProperties() *FunctionProperties {
	return &FunctionProperties{
		Type:       s.Type,
		Etag:       s.Etag,
		Properties: s.Properties,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScalarFunctionProperties.
func (s ScalarFunctionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "properties", s.Properties)
	objectMap["type"] = "Scalar"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalarFunctionProperties.
func (s *ScalarFunctionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetSerialization implements the SerializationClassification interface for type Serialization.
func (s *Serialization) GetSerialization() *Serialization { return s }

// GetOutputDataSource implements the OutputDataSourceClassification interface for type ServiceBusQueueOutputDataSource.
func (s *ServiceBusQueueOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueOutputDataSource.
func (s ServiceBusQueueOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	objectMap["type"] = "Microsoft.ServiceBus/Queue"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusQueueOutputDataSource.
func (s *ServiceBusQueueOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusQueueOutputDataSourceProperties.
func (s ServiceBusQueueOutputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", s.AuthenticationMode)
	populate(objectMap, "propertyColumns", s.PropertyColumns)
	populate(objectMap, "queueName", s.QueueName)
	populate(objectMap, "serviceBusNamespace", s.ServiceBusNamespace)
	populate(objectMap, "sharedAccessPolicyKey", s.SharedAccessPolicyKey)
	populate(objectMap, "sharedAccessPolicyName", s.SharedAccessPolicyName)
	populate(objectMap, "systemPropertyColumns", &s.SystemPropertyColumns)
	return json.Marshal(objectMap)
}

// GetOutputDataSource implements the OutputDataSourceClassification interface for type ServiceBusTopicOutputDataSource.
func (s *ServiceBusTopicOutputDataSource) GetOutputDataSource() *OutputDataSource {
	return &OutputDataSource{
		Type: s.Type,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicOutputDataSource.
func (s ServiceBusTopicOutputDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	objectMap["type"] = "Microsoft.ServiceBus/Topic"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceBusTopicOutputDataSource.
func (s *ServiceBusTopicOutputDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceBusTopicOutputDataSourceProperties.
func (s ServiceBusTopicOutputDataSourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authenticationMode", s.AuthenticationMode)
	populate(objectMap, "propertyColumns", s.PropertyColumns)
	populate(objectMap, "serviceBusNamespace", s.ServiceBusNamespace)
	populate(objectMap, "sharedAccessPolicyKey", s.SharedAccessPolicyKey)
	populate(objectMap, "sharedAccessPolicyName", s.SharedAccessPolicyName)
	populate(objectMap, "systemPropertyColumns", s.SystemPropertyColumns)
	populate(objectMap, "topicName", s.TopicName)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StartStreamingJobParameters.
func (s StartStreamingJobParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "outputStartMode", s.OutputStartMode)
	populateTimeRFC3339(objectMap, "outputStartTime", s.OutputStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartStreamingJobParameters.
func (s *StartStreamingJobParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "outputStartMode":
			err = unpopulate(val, &s.OutputStartMode)
			delete(rawMsg, key)
		case "outputStartTime":
			err = unpopulateTimeRFC3339(val, &s.OutputStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetStreamInputDataSource implements the StreamInputDataSourceClassification interface for type StreamInputDataSource.
func (s *StreamInputDataSource) GetStreamInputDataSource() *StreamInputDataSource { return s }

// GetInputProperties implements the InputPropertiesClassification interface for type StreamInputProperties.
func (s *StreamInputProperties) GetInputProperties() *InputProperties {
	return &InputProperties{
		Type:          s.Type,
		Serialization: s.Serialization,
		Diagnostics:   s.Diagnostics,
		Etag:          s.Etag,
		Compression:   s.Compression,
		PartitionKey:  s.PartitionKey,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StreamInputProperties.
func (s StreamInputProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", s.Compression)
	populate(objectMap, "datasource", s.Datasource)
	populate(objectMap, "diagnostics", s.Diagnostics)
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "partitionKey", s.PartitionKey)
	populate(objectMap, "serialization", s.Serialization)
	objectMap["type"] = "Stream"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamInputProperties.
func (s *StreamInputProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			err = unpopulate(val, &s.Compression)
			delete(rawMsg, key)
		case "datasource":
			s.Datasource, err = unmarshalStreamInputDataSourceClassification(val)
			delete(rawMsg, key)
		case "diagnostics":
			err = unpopulate(val, &s.Diagnostics)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "partitionKey":
			err = unpopulate(val, &s.PartitionKey)
			delete(rawMsg, key)
		case "serialization":
			s.Serialization, err = unmarshalSerializationClassification(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StreamingJob.
func (s StreamingJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingJobListResult.
func (s StreamingJobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StreamingJobProperties.
func (s StreamingJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cluster", s.Cluster)
	populate(objectMap, "compatibilityLevel", s.CompatibilityLevel)
	populate(objectMap, "contentStoragePolicy", s.ContentStoragePolicy)
	populateTimeRFC3339(objectMap, "createdDate", s.CreatedDate)
	populate(objectMap, "dataLocale", s.DataLocale)
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "eventsLateArrivalMaxDelayInSeconds", s.EventsLateArrivalMaxDelayInSeconds)
	populate(objectMap, "eventsOutOfOrderMaxDelayInSeconds", s.EventsOutOfOrderMaxDelayInSeconds)
	populate(objectMap, "eventsOutOfOrderPolicy", s.EventsOutOfOrderPolicy)
	populate(objectMap, "functions", s.Functions)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "jobId", s.JobID)
	populate(objectMap, "jobState", s.JobState)
	populate(objectMap, "jobStorageAccount", s.JobStorageAccount)
	populate(objectMap, "jobType", s.JobType)
	populateTimeRFC3339(objectMap, "lastOutputEventTime", s.LastOutputEventTime)
	populate(objectMap, "outputErrorPolicy", s.OutputErrorPolicy)
	populate(objectMap, "outputStartMode", s.OutputStartMode)
	populateTimeRFC3339(objectMap, "outputStartTime", s.OutputStartTime)
	populate(objectMap, "outputs", s.Outputs)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "transformation", s.Transformation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StreamingJobProperties.
func (s *StreamingJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cluster":
			err = unpopulate(val, &s.Cluster)
			delete(rawMsg, key)
		case "compatibilityLevel":
			err = unpopulate(val, &s.CompatibilityLevel)
			delete(rawMsg, key)
		case "contentStoragePolicy":
			err = unpopulate(val, &s.ContentStoragePolicy)
			delete(rawMsg, key)
		case "createdDate":
			err = unpopulateTimeRFC3339(val, &s.CreatedDate)
			delete(rawMsg, key)
		case "dataLocale":
			err = unpopulate(val, &s.DataLocale)
			delete(rawMsg, key)
		case "etag":
			err = unpopulate(val, &s.Etag)
			delete(rawMsg, key)
		case "eventsLateArrivalMaxDelayInSeconds":
			err = unpopulate(val, &s.EventsLateArrivalMaxDelayInSeconds)
			delete(rawMsg, key)
		case "eventsOutOfOrderMaxDelayInSeconds":
			err = unpopulate(val, &s.EventsOutOfOrderMaxDelayInSeconds)
			delete(rawMsg, key)
		case "eventsOutOfOrderPolicy":
			err = unpopulate(val, &s.EventsOutOfOrderPolicy)
			delete(rawMsg, key)
		case "functions":
			err = unpopulate(val, &s.Functions)
			delete(rawMsg, key)
		case "inputs":
			err = unpopulate(val, &s.Inputs)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &s.JobID)
			delete(rawMsg, key)
		case "jobState":
			err = unpopulate(val, &s.JobState)
			delete(rawMsg, key)
		case "jobStorageAccount":
			err = unpopulate(val, &s.JobStorageAccount)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, &s.JobType)
			delete(rawMsg, key)
		case "lastOutputEventTime":
			err = unpopulateTimeRFC3339(val, &s.LastOutputEventTime)
			delete(rawMsg, key)
		case "outputErrorPolicy":
			err = unpopulate(val, &s.OutputErrorPolicy)
			delete(rawMsg, key)
		case "outputStartMode":
			err = unpopulate(val, &s.OutputStartMode)
			delete(rawMsg, key)
		case "outputStartTime":
			err = unpopulateTimeRFC3339(val, &s.OutputStartTime)
			delete(rawMsg, key)
		case "outputs":
			err = unpopulate(val, &s.Outputs)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &s.SKU)
			delete(rawMsg, key)
		case "transformation":
			err = unpopulate(val, &s.Transformation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionQuotasListResult.
func (s SubscriptionQuotasListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Transformation.
func (t Transformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TransformationProperties.
func (t TransformationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "query", t.Query)
	populate(objectMap, "streamingUnits", t.StreamingUnits)
	populate(objectMap, "validStreamingUnits", t.ValidStreamingUnits)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
