//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstreamanalytics

import (
	"context"
	"net/http"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// ClustersListByResourceGroupPager provides operations for iterating over paged responses.
type ClustersListByResourceGroupPager struct {
	client    *ClustersClient
	current   ClustersListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClustersListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ClustersListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ClustersListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ClusterListResult.NextLink == nil || len(*p.current.ClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ClustersListByResourceGroupResponse page.
func (p *ClustersListByResourceGroupPager) PageResponse() ClustersListByResourceGroupResponse {
	return p.current
}

// ClustersListBySubscriptionPager provides operations for iterating over paged responses.
type ClustersListBySubscriptionPager struct {
	client    *ClustersClient
	current   ClustersListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClustersListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ClustersListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ClustersListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ClusterListResult.NextLink == nil || len(*p.current.ClusterListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ClustersListBySubscriptionResponse page.
func (p *ClustersListBySubscriptionPager) PageResponse() ClustersListBySubscriptionResponse {
	return p.current
}

// ClustersListStreamingJobsPager provides operations for iterating over paged responses.
type ClustersListStreamingJobsPager struct {
	client    *ClustersClient
	current   ClustersListStreamingJobsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClustersListStreamingJobsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ClustersListStreamingJobsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ClustersListStreamingJobsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ClusterJobListResult.NextLink == nil || len(*p.current.ClusterJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listStreamingJobsHandleError(resp)
		return false
	}
	result, err := p.client.listStreamingJobsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ClustersListStreamingJobsResponse page.
func (p *ClustersListStreamingJobsPager) PageResponse() ClustersListStreamingJobsResponse {
	return p.current
}

// FunctionsListByStreamingJobPager provides operations for iterating over paged responses.
type FunctionsListByStreamingJobPager struct {
	client    *FunctionsClient
	current   FunctionsListByStreamingJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FunctionsListByStreamingJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *FunctionsListByStreamingJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *FunctionsListByStreamingJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionListResult.NextLink == nil || len(*p.current.FunctionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByStreamingJobHandleError(resp)
		return false
	}
	result, err := p.client.listByStreamingJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current FunctionsListByStreamingJobResponse page.
func (p *FunctionsListByStreamingJobPager) PageResponse() FunctionsListByStreamingJobResponse {
	return p.current
}

// InputsListByStreamingJobPager provides operations for iterating over paged responses.
type InputsListByStreamingJobPager struct {
	client    *InputsClient
	current   InputsListByStreamingJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InputsListByStreamingJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *InputsListByStreamingJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *InputsListByStreamingJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InputListResult.NextLink == nil || len(*p.current.InputListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByStreamingJobHandleError(resp)
		return false
	}
	result, err := p.client.listByStreamingJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current InputsListByStreamingJobResponse page.
func (p *InputsListByStreamingJobPager) PageResponse() InputsListByStreamingJobResponse {
	return p.current
}

// OperationsListPager provides operations for iterating over paged responses.
type OperationsListPager struct {
	client    *OperationsClient
	current   OperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OperationsListResponse page.
func (p *OperationsListPager) PageResponse() OperationsListResponse {
	return p.current
}

// OutputsListByStreamingJobPager provides operations for iterating over paged responses.
type OutputsListByStreamingJobPager struct {
	client    *OutputsClient
	current   OutputsListByStreamingJobResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OutputsListByStreamingJobResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *OutputsListByStreamingJobPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *OutputsListByStreamingJobPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OutputListResult.NextLink == nil || len(*p.current.OutputListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByStreamingJobHandleError(resp)
		return false
	}
	result, err := p.client.listByStreamingJobHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current OutputsListByStreamingJobResponse page.
func (p *OutputsListByStreamingJobPager) PageResponse() OutputsListByStreamingJobResponse {
	return p.current
}

// PrivateEndpointsListByClusterPager provides operations for iterating over paged responses.
type PrivateEndpointsListByClusterPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsListByClusterResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsListByClusterResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointsListByClusterPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointsListByClusterPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByClusterHandleError(resp)
		return false
	}
	result, err := p.client.listByClusterHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointsListByClusterResponse page.
func (p *PrivateEndpointsListByClusterPager) PageResponse() PrivateEndpointsListByClusterResponse {
	return p.current
}

// StreamingJobsListByResourceGroupPager provides operations for iterating over paged responses.
type StreamingJobsListByResourceGroupPager struct {
	client    *StreamingJobsClient
	current   StreamingJobsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StreamingJobsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StreamingJobsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StreamingJobsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StreamingJobListResult.NextLink == nil || len(*p.current.StreamingJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StreamingJobsListByResourceGroupResponse page.
func (p *StreamingJobsListByResourceGroupPager) PageResponse() StreamingJobsListByResourceGroupResponse {
	return p.current
}

// StreamingJobsListPager provides operations for iterating over paged responses.
type StreamingJobsListPager struct {
	client    *StreamingJobsClient
	current   StreamingJobsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, StreamingJobsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *StreamingJobsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *StreamingJobsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StreamingJobListResult.NextLink == nil || len(*p.current.StreamingJobListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current StreamingJobsListResponse page.
func (p *StreamingJobsListPager) PageResponse() StreamingJobsListResponse {
	return p.current
}
