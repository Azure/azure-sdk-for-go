//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsynapse

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AADAdminProperties - Workspace active directory administrator properties
type AADAdminProperties struct {
	// Workspace active directory administrator type
	AdministratorType *string `json:"administratorType,omitempty"`

	// Login of the workspace active directory administrator
	Login *string `json:"login,omitempty"`

	// Object ID of the workspace active directory administrator
	Sid *string `json:"sid,omitempty"`

	// Tenant ID of the workspace active directory administrator
	TenantID *string `json:"tenantId,omitempty"`
}

// AttachedDatabaseConfiguration - Class representing an attached database configuration.
type AttachedDatabaseConfiguration struct {
	ProxyResource
	// Resource location.
	Location *string `json:"location,omitempty"`

	// The properties of the attached database configuration.
	Properties *AttachedDatabaseConfigurationProperties `json:"properties,omitempty"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AttachedDatabaseConfiguration.
func (a AttachedDatabaseConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AttachedDatabaseConfiguration.
func (a *AttachedDatabaseConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &a.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AttachedDatabaseConfigurationListResult - The list attached database configurations operation response.
type AttachedDatabaseConfigurationListResult struct {
	// The list of attached database configurations.
	Value []*AttachedDatabaseConfiguration `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AttachedDatabaseConfigurationListResult.
func (a AttachedDatabaseConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AttachedDatabaseConfigurationProperties - Class representing the an attached database configuration properties of kind specific.
type AttachedDatabaseConfigurationProperties struct {
	// REQUIRED; The name of the database which you would like to attach, use * if you want to follow all current and future databases.
	DatabaseName *string `json:"databaseName,omitempty"`

	// REQUIRED; The default principals modification kind
	DefaultPrincipalsModificationKind *DefaultPrincipalsModificationKind `json:"defaultPrincipalsModificationKind,omitempty"`

	// REQUIRED; The resource id of the kusto pool where the databases you would like to attach reside.
	KustoPoolResourceID *string `json:"clusterResourceId,omitempty"`

	// Table level sharing specifications
	TableLevelSharingProperties *TableLevelSharingProperties `json:"tableLevelSharingProperties,omitempty"`

	// READ-ONLY; The list of databases from the clusterResourceId which are currently attached to the kusto pool.
	AttachedDatabaseNames []*string `json:"attachedDatabaseNames,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AttachedDatabaseConfigurationProperties.
func (a AttachedDatabaseConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attachedDatabaseNames", a.AttachedDatabaseNames)
	populate(objectMap, "databaseName", a.DatabaseName)
	populate(objectMap, "defaultPrincipalsModificationKind", a.DefaultPrincipalsModificationKind)
	populate(objectMap, "clusterResourceId", a.KustoPoolResourceID)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "tableLevelSharingProperties", a.TableLevelSharingProperties)
	return json.Marshal(objectMap)
}

// AutoPauseProperties - Auto-pausing properties of a Big Data pool powered by Apache Spark
type AutoPauseProperties struct {
	// Number of minutes of idle time before the Big Data pool is automatically paused.
	DelayInMinutes *int32 `json:"delayInMinutes,omitempty"`

	// Whether auto-pausing is enabled for the Big Data pool.
	Enabled *bool `json:"enabled,omitempty"`
}

// AutoScaleProperties - Auto-scaling properties of a Big Data pool powered by Apache Spark
type AutoScaleProperties struct {
	// Whether automatic scaling is enabled for the Big Data pool.
	Enabled *bool `json:"enabled,omitempty"`

	// The maximum number of nodes the Big Data pool can support.
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`

	// The minimum number of nodes the Big Data pool can support.
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
}

// AvailableRpOperation - An operation that is available in this resource provider
type AvailableRpOperation struct {
	// Display properties of the operation
	Display *AvailableRpOperationDisplayInfo `json:"display,omitempty"`

	// Whether this operation is a data action
	IsDataAction *string `json:"isDataAction,omitempty"`

	// Operation name
	Name *string `json:"name,omitempty"`

	// Operation origin
	Origin *string `json:"origin,omitempty"`

	// Operation properties
	Properties *OperationMetaPropertyInfo `json:"properties,omitempty"`
}

// AvailableRpOperationDisplayInfo - Description of an available operation
type AvailableRpOperationDisplayInfo struct {
	// Operation description
	Description *string `json:"description,omitempty"`

	// Operation name
	Operation *string `json:"operation,omitempty"`

	// Resource provider name
	Provider *string `json:"provider,omitempty"`

	// Resource type
	Resource *string `json:"resource,omitempty"`
}

// AzureADOnlyAuthentication - Azure Active Directory Only Authentication Info
type AzureADOnlyAuthentication struct {
	ProxyResource
	// azureADOnlyAuthentication resource properties
	Properties *AzureADOnlyAuthenticationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureADOnlyAuthentication.
func (a AzureADOnlyAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureADOnlyAuthentication.
func (a *AzureADOnlyAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureADOnlyAuthenticationListResult - A list of active directory only authentications.
type AzureADOnlyAuthenticationListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*AzureADOnlyAuthentication `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureADOnlyAuthenticationListResult.
func (a AzureADOnlyAuthenticationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AzureADOnlyAuthenticationProperties - Properties of a active directory only authentication.
type AzureADOnlyAuthenticationProperties struct {
	// REQUIRED; Azure Active Directory only Authentication enabled.
	AzureADOnlyAuthentication *bool `json:"azureADOnlyAuthentication,omitempty"`

	// READ-ONLY; property configuration date
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; property configuration state
	State *StateValue `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureADOnlyAuthenticationProperties.
func (a AzureADOnlyAuthenticationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureADOnlyAuthentication", a.AzureADOnlyAuthentication)
	populateTimeRFC3339(objectMap, "creationDate", a.CreationDate)
	populate(objectMap, "state", a.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureADOnlyAuthenticationProperties.
func (a *AzureADOnlyAuthenticationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureADOnlyAuthentication":
			err = unpopulate(val, &a.AzureADOnlyAuthentication)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &a.CreationDate)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &a.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureADOnlyAuthenticationsBeginCreateOptions contains the optional parameters for the AzureADOnlyAuthentications.BeginCreate method.
type AzureADOnlyAuthenticationsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// AzureADOnlyAuthenticationsGetOptions contains the optional parameters for the AzureADOnlyAuthentications.Get method.
type AzureADOnlyAuthenticationsGetOptions struct {
	// placeholder for future optional parameters
}

// AzureADOnlyAuthenticationsListOptions contains the optional parameters for the AzureADOnlyAuthentications.List method.
type AzureADOnlyAuthenticationsListOptions struct {
	// placeholder for future optional parameters
}

// AzureCapacity - Azure capacity definition.
type AzureCapacity struct {
	// REQUIRED; The default capacity that would be used.
	Default *int32 `json:"default,omitempty"`

	// REQUIRED; Maximum allowed capacity.
	Maximum *int32 `json:"maximum,omitempty"`

	// REQUIRED; Minimum allowed capacity.
	Minimum *int32 `json:"minimum,omitempty"`

	// REQUIRED; Scale type.
	ScaleType *AzureScaleType `json:"scaleType,omitempty"`
}

// AzureEntityResource - The resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	Resource
	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureEntityResource.
func (a AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureEntityResource.
func (a *AzureEntityResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AzureEntityResource) marshalInternal(objectMap map[string]interface{}) {
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", a.Etag)
}

func (a *AzureEntityResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &a.Etag)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureResourceSKU - Azure resource SKU definition.
type AzureResourceSKU struct {
	// The number of instances of the cluster.
	Capacity *AzureCapacity `json:"capacity,omitempty"`

	// Resource Namespace and Type.
	ResourceType *string `json:"resourceType,omitempty"`

	// The SKU details.
	SKU *AzureSKU `json:"sku,omitempty"`
}

// AzureSKU - Azure SKU definition.
type AzureSKU struct {
	// REQUIRED; SKU name.
	Name *SKUName `json:"name,omitempty"`

	// REQUIRED; SKU size.
	Size *SKUSize `json:"size,omitempty"`

	// The number of instances of the cluster.
	Capacity *int32 `json:"capacity,omitempty"`
}

// BigDataPoolPatchInfo - Properties patch for a Big Data pool
type BigDataPoolPatchInfo struct {
	// Updated tags for the Big Data pool
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolPatchInfo.
func (b BigDataPoolPatchInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", b.Tags)
	return json.Marshal(objectMap)
}

// BigDataPoolResourceInfo - A Big Data pool
type BigDataPoolResourceInfo struct {
	TrackedResource
	// Big Data pool properties
	Properties *BigDataPoolResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolResourceInfo.
func (b BigDataPoolResourceInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BigDataPoolResourceInfo.
func (b *BigDataPoolResourceInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BigDataPoolResourceInfoListResult - Collection of Big Data pool information
type BigDataPoolResourceInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of Big Data pools
	Value []*BigDataPoolResourceInfo `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolResourceInfoListResult.
func (b BigDataPoolResourceInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BigDataPoolResourceProperties - Properties of a Big Data pool powered by Apache Spark
type BigDataPoolResourceProperties struct {
	// Auto-pausing properties
	AutoPause *AutoPauseProperties `json:"autoPause,omitempty"`

	// Auto-scaling properties
	AutoScale *AutoScaleProperties `json:"autoScale,omitempty"`

	// The cache size
	CacheSize *int32 `json:"cacheSize,omitempty"`

	// The time when the Big Data pool was created.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// List of custom libraries/packages associated with the spark pool.
	CustomLibraries []*LibraryInfo `json:"customLibraries,omitempty"`

	// The default folder where Spark logs will be written.
	DefaultSparkLogFolder *string `json:"defaultSparkLogFolder,omitempty"`

	// Dynamic Executor Allocation
	DynamicExecutorAllocation *DynamicExecutorAllocation `json:"dynamicExecutorAllocation,omitempty"`

	// Whether compute isolation is required or not.
	IsComputeIsolationEnabled *bool `json:"isComputeIsolationEnabled,omitempty"`

	// Library version requirements
	LibraryRequirements *LibraryRequirements `json:"libraryRequirements,omitempty"`

	// The number of nodes in the Big Data pool.
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// The level of compute power that each node in the Big Data pool has.
	NodeSize *NodeSize `json:"nodeSize,omitempty"`

	// The kind of nodes that the Big Data pool provides.
	NodeSizeFamily *NodeSizeFamily `json:"nodeSizeFamily,omitempty"`

	// The state of the Big Data pool.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Whether session level packages enabled.
	SessionLevelPackagesEnabled *bool `json:"sessionLevelPackagesEnabled,omitempty"`

	// Spark configuration file to specify additional properties
	SparkConfigProperties *SparkConfigProperties `json:"sparkConfigProperties,omitempty"`

	// The Spark events folder
	SparkEventsFolder *string `json:"sparkEventsFolder,omitempty"`

	// The Apache Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// READ-ONLY; The time when the Big Data pool was updated successfully.
	LastSucceededTimestamp *time.Time `json:"lastSucceededTimestamp,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolResourceProperties.
func (b BigDataPoolResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoPause", b.AutoPause)
	populate(objectMap, "autoScale", b.AutoScale)
	populate(objectMap, "cacheSize", b.CacheSize)
	populateTimeRFC3339(objectMap, "creationDate", b.CreationDate)
	populate(objectMap, "customLibraries", b.CustomLibraries)
	populate(objectMap, "defaultSparkLogFolder", b.DefaultSparkLogFolder)
	populate(objectMap, "dynamicExecutorAllocation", b.DynamicExecutorAllocation)
	populate(objectMap, "isComputeIsolationEnabled", b.IsComputeIsolationEnabled)
	populateTimeRFC3339(objectMap, "lastSucceededTimestamp", b.LastSucceededTimestamp)
	populate(objectMap, "libraryRequirements", b.LibraryRequirements)
	populate(objectMap, "nodeCount", b.NodeCount)
	populate(objectMap, "nodeSize", b.NodeSize)
	populate(objectMap, "nodeSizeFamily", b.NodeSizeFamily)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "sessionLevelPackagesEnabled", b.SessionLevelPackagesEnabled)
	populate(objectMap, "sparkConfigProperties", b.SparkConfigProperties)
	populate(objectMap, "sparkEventsFolder", b.SparkEventsFolder)
	populate(objectMap, "sparkVersion", b.SparkVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BigDataPoolResourceProperties.
func (b *BigDataPoolResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPause":
			err = unpopulate(val, &b.AutoPause)
			delete(rawMsg, key)
		case "autoScale":
			err = unpopulate(val, &b.AutoScale)
			delete(rawMsg, key)
		case "cacheSize":
			err = unpopulate(val, &b.CacheSize)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &b.CreationDate)
			delete(rawMsg, key)
		case "customLibraries":
			err = unpopulate(val, &b.CustomLibraries)
			delete(rawMsg, key)
		case "defaultSparkLogFolder":
			err = unpopulate(val, &b.DefaultSparkLogFolder)
			delete(rawMsg, key)
		case "dynamicExecutorAllocation":
			err = unpopulate(val, &b.DynamicExecutorAllocation)
			delete(rawMsg, key)
		case "isComputeIsolationEnabled":
			err = unpopulate(val, &b.IsComputeIsolationEnabled)
			delete(rawMsg, key)
		case "lastSucceededTimestamp":
			err = unpopulateTimeRFC3339(val, &b.LastSucceededTimestamp)
			delete(rawMsg, key)
		case "libraryRequirements":
			err = unpopulate(val, &b.LibraryRequirements)
			delete(rawMsg, key)
		case "nodeCount":
			err = unpopulate(val, &b.NodeCount)
			delete(rawMsg, key)
		case "nodeSize":
			err = unpopulate(val, &b.NodeSize)
			delete(rawMsg, key)
		case "nodeSizeFamily":
			err = unpopulate(val, &b.NodeSizeFamily)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &b.ProvisioningState)
			delete(rawMsg, key)
		case "sessionLevelPackagesEnabled":
			err = unpopulate(val, &b.SessionLevelPackagesEnabled)
			delete(rawMsg, key)
		case "sparkConfigProperties":
			err = unpopulate(val, &b.SparkConfigProperties)
			delete(rawMsg, key)
		case "sparkEventsFolder":
			err = unpopulate(val, &b.SparkEventsFolder)
			delete(rawMsg, key)
		case "sparkVersion":
			err = unpopulate(val, &b.SparkVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BigDataPoolsBeginCreateOrUpdateOptions contains the optional parameters for the BigDataPools.BeginCreateOrUpdate method.
type BigDataPoolsBeginCreateOrUpdateOptions struct {
	// Whether to stop any running jobs in the Big Data pool
	Force *bool
}

// BigDataPoolsBeginDeleteOptions contains the optional parameters for the BigDataPools.BeginDelete method.
type BigDataPoolsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BigDataPoolsGetOptions contains the optional parameters for the BigDataPools.Get method.
type BigDataPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// BigDataPoolsListByWorkspaceOptions contains the optional parameters for the BigDataPools.ListByWorkspace method.
type BigDataPoolsListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// BigDataPoolsUpdateOptions contains the optional parameters for the BigDataPools.Update method.
type BigDataPoolsUpdateOptions struct {
	// placeholder for future optional parameters
}

// CheckNameAvailabilityRequest - A request about whether a workspace name is available
type CheckNameAvailabilityRequest struct {
	// Workspace name
	Name *string `json:"name,omitempty"`

	// Type: workspace
	Type *string `json:"type,omitempty"`
}

// CheckNameAvailabilityResponse - A response saying whether the workspace name is available
type CheckNameAvailabilityResponse struct {
	// Whether the workspace name is available
	Available *bool `json:"available,omitempty"`

	// Validation message
	Message *string `json:"message,omitempty"`

	// Workspace name
	Name *string `json:"name,omitempty"`

	// Reason the workspace name is or is not available
	Reason *string `json:"reason,omitempty"`
}

// CheckNameResult - The result returned from a check name availability request.
type CheckNameResult struct {
	// Message indicating an unavailable name due to a conflict, or a description of the naming rules that are violated.
	Message *string `json:"message,omitempty"`

	// The name that was checked.
	Name *string `json:"name,omitempty"`

	// Specifies a Boolean value that indicates if the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// Message providing the reason why the given name is invalid.
	Reason *Reason `json:"reason,omitempty"`
}

// ClusterPrincipalAssignment - Class representing a cluster principal assignment.
type ClusterPrincipalAssignment struct {
	ProxyResource
	// The cluster principal.
	Properties *ClusterPrincipalProperties `json:"properties,omitempty"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPrincipalAssignment.
func (c ClusterPrincipalAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterPrincipalAssignment.
func (c *ClusterPrincipalAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &c.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ClusterPrincipalAssignmentCheckNameRequest - A principal assignment check name availability request.
type ClusterPrincipalAssignmentCheckNameRequest struct {
	// REQUIRED; Principal Assignment resource name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of resource, Microsoft.Synapse/workspaces/kustoPools/principalAssignments.
	Type *string `json:"type,omitempty"`
}

// ClusterPrincipalAssignmentListResult - The list Kusto cluster principal assignments operation response.
type ClusterPrincipalAssignmentListResult struct {
	// The list of Kusto cluster principal assignments.
	Value []*ClusterPrincipalAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPrincipalAssignmentListResult.
func (c ClusterPrincipalAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ClusterPrincipalProperties - A class representing cluster principal property.
type ClusterPrincipalProperties struct {
	// REQUIRED; The principal ID assigned to the cluster principal. It can be a user email, application ID, or security group name.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; Principal type.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// REQUIRED; Cluster principal role.
	Role *ClusterPrincipalRole `json:"role,omitempty"`

	// The tenant id of the principal
	TenantID *string `json:"tenantId,omitempty"`

	// READ-ONLY; The principal name
	PrincipalName *string `json:"principalName,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The tenant name of the principal
	TenantName *string `json:"tenantName,omitempty" azure:"ro"`
}

// CmdkeySetup - The custom setup of running cmdkey commands.
type CmdkeySetup struct {
	CustomSetupBase
	// REQUIRED; Cmdkey command custom setup type properties.
	TypeProperties *CmdkeySetupTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetup.
func (c CmdkeySetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.CustomSetupBase.marshalInternal(objectMap, "CmdkeySetup")
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetup.
func (c *CmdkeySetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.CustomSetupBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CmdkeySetupTypeProperties - Cmdkey command custom setup type properties.
type CmdkeySetupTypeProperties struct {
	// REQUIRED; The password of data source access.
	Password SecretBaseClassification `json:"password,omitempty"`

	// REQUIRED; The server name of data source access.
	TargetName map[string]interface{} `json:"targetName,omitempty"`

	// REQUIRED; The user name of data source access.
	UserName map[string]interface{} `json:"userName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CmdkeySetupTypeProperties.
func (c CmdkeySetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "password", c.Password)
	populate(objectMap, "targetName", c.TargetName)
	populate(objectMap, "userName", c.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CmdkeySetupTypeProperties.
func (c *CmdkeySetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			c.Password, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		case "targetName":
			err = unpopulate(val, &c.TargetName)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &c.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ComponentSetup - The custom setup of installing 3rd party components.
type ComponentSetup struct {
	CustomSetupBase
	// REQUIRED; Install 3rd party component type properties.
	TypeProperties *LicensedComponentSetupTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ComponentSetup.
func (c ComponentSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.CustomSetupBase.marshalInternal(objectMap, "ComponentSetup")
	populate(objectMap, "typeProperties", c.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComponentSetup.
func (c *ComponentSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &c.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.CustomSetupBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CreateSQLPoolRestorePointDefinition - Contains the information necessary to perform a create Sql pool restore point operation.
type CreateSQLPoolRestorePointDefinition struct {
	// REQUIRED; The restore point label to apply
	RestorePointLabel *string `json:"restorePointLabel,omitempty"`
}

// CspWorkspaceAdminProperties - Initial workspace AAD admin properties for a CSP subscription
type CspWorkspaceAdminProperties struct {
	// AAD object ID of initial workspace admin
	InitialWorkspaceAdminObjectID *string `json:"initialWorkspaceAdminObjectId,omitempty"`
}

// CustomSetupBaseClassification provides polymorphic access to related types.
// Call the interface's GetCustomSetupBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CmdkeySetup, *ComponentSetup, *CustomSetupBase, *EnvironmentVariableSetup
type CustomSetupBaseClassification interface {
	// GetCustomSetupBase returns the CustomSetupBase content of the underlying type.
	GetCustomSetupBase() *CustomSetupBase
}

// CustomSetupBase - The base definition of the custom setup.
type CustomSetupBase struct {
	// REQUIRED; The type of custom setup.
	Type *string `json:"type,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type CustomSetupBase.
func (c *CustomSetupBase) GetCustomSetupBase() *CustomSetupBase { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomSetupBase.
func (c *CustomSetupBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CustomSetupBase) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.Type = &discValue
	objectMap["type"] = c.Type
}

func (c *CustomSetupBase) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomerManagedKeyDetails - Details of the customer managed key associated with the workspace
type CustomerManagedKeyDetails struct {
	// Key encryption key
	KekIdentity *KekIdentityProperties `json:"kekIdentity,omitempty"`

	// The key object of the workspace
	Key *WorkspaceKeyDetails `json:"key,omitempty"`

	// READ-ONLY; The customer managed key status on the workspace
	Status *string `json:"status,omitempty" azure:"ro"`
}

// DataConnectionClassification provides polymorphic access to related types.
// Call the interface's GetDataConnection() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataConnection, *EventGridDataConnection, *EventHubDataConnection, *IotHubDataConnection
type DataConnectionClassification interface {
	// GetDataConnection returns the DataConnection content of the underlying type.
	GetDataConnection() *DataConnection
}

// DataConnection - Class representing a data connection.
type DataConnection struct {
	ProxyResource
	// REQUIRED; Kind of the endpoint for the data connection
	Kind *DataConnectionKind `json:"kind,omitempty"`

	// Resource location.
	Location *string `json:"location,omitempty"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetDataConnection implements the DataConnectionClassification interface for type DataConnection.
func (d *DataConnection) GetDataConnection() *DataConnection { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnection.
func (d *DataConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DataConnection) marshalInternal(objectMap map[string]interface{}, discValue DataConnectionKind) {
	d.ProxyResource.marshalInternal(objectMap)
	d.Kind = &discValue
	objectMap["kind"] = d.Kind
	populate(objectMap, "location", d.Location)
	populate(objectMap, "systemData", d.SystemData)
}

func (d *DataConnection) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataConnectionCheckNameRequest - A data connection check name availability request.
type DataConnectionCheckNameRequest struct {
	// REQUIRED; Data Connection name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of resource, Microsoft.Synapse/workspaces/kustoPools/databases/dataConnections.
	Type *string `json:"type,omitempty"`
}

// DataConnectionListResult - The list Kusto data connections operation response.
type DataConnectionListResult struct {
	// The list of Kusto data connections.
	Value []DataConnectionClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataConnectionListResult.
func (d DataConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionListResult.
func (d *DataConnectionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			d.Value, err = unmarshalDataConnectionClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataConnectionValidation - Class representing an data connection validation.
type DataConnectionValidation struct {
	// The name of the data connection.
	DataConnectionName *string `json:"dataConnectionName,omitempty"`

	// The data connection properties to validate.
	Properties DataConnectionClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataConnectionValidation.
func (d DataConnectionValidation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataConnectionName", d.DataConnectionName)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataConnectionValidation.
func (d *DataConnectionValidation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataConnectionName":
			err = unpopulate(val, &d.DataConnectionName)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDataConnectionClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataConnectionValidationListResult - The list Kusto data connection validation result.
type DataConnectionValidationListResult struct {
	// The list of Kusto data connection validation errors.
	Value []*DataConnectionValidationResult `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataConnectionValidationListResult.
func (d DataConnectionValidationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataConnectionValidationResult - The result returned from a data connection validation request.
type DataConnectionValidationResult struct {
	// A message which indicates a problem in data connection validation.
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// DataLakeStorageAccountDetails - Details of the data lake storage account associated with the workspace
type DataLakeStorageAccountDetails struct {
	// Account URL
	AccountURL *string `json:"accountUrl,omitempty"`

	// Create managed private endpoint to this storage account or not
	CreateManagedPrivateEndpoint *bool `json:"createManagedPrivateEndpoint,omitempty"`

	// Filesystem name
	Filesystem *string `json:"filesystem,omitempty"`

	// ARM resource Id of this storage account
	ResourceID *string `json:"resourceId,omitempty"`
}

// DataMaskingPoliciesCreateOrUpdateOptions contains the optional parameters for the DataMaskingPolicies.CreateOrUpdate method.
type DataMaskingPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DataMaskingPoliciesGetOptions contains the optional parameters for the DataMaskingPolicies.Get method.
type DataMaskingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

type DataMaskingPolicy struct {
	ProxyResource
	// The properties of the data masking policy.
	Properties *DataMaskingPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; The kind of data masking policy. Metadata, used for Azure portal.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The location of the data masking policy.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID of the sql pool
	ManagedBy *string `json:"managedBy,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMaskingPolicy.
func (d DataMaskingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "managedBy", d.ManagedBy)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataMaskingPolicy.
func (d *DataMaskingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "managedBy":
			err = unpopulate(val, &d.ManagedBy)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataMaskingPolicyProperties - The properties of a database data masking policy.
type DataMaskingPolicyProperties struct {
	// REQUIRED; The state of the data masking policy.
	DataMaskingState *DataMaskingState `json:"dataMaskingState,omitempty"`

	// The list of the exempt principals. Specifies the semicolon-separated list of database users for which the data masking policy does not apply. The specified
	// users receive data results without masking
	// for all of the database queries.
	ExemptPrincipals *string `json:"exemptPrincipals,omitempty"`

	// READ-ONLY; The list of the application principals. This is a legacy parameter and is no longer used.
	ApplicationPrincipals *string `json:"applicationPrincipals,omitempty" azure:"ro"`

	// READ-ONLY; The masking level. This is a legacy parameter and is no longer used.
	MaskingLevel *string `json:"maskingLevel,omitempty" azure:"ro"`
}

// DataMaskingRule - Represents a Sql pool data masking rule.
type DataMaskingRule struct {
	ProxyResource
	// The properties of the resource.
	Properties *DataMaskingRuleProperties `json:"properties,omitempty"`

	// READ-ONLY; The kind of Data Masking Rule. Metadata, used for Azure portal.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The location of the data masking rule.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMaskingRule.
func (d DataMaskingRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataMaskingRule.
func (d *DataMaskingRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataMaskingRuleListResult - The response to a list data masking rules request.
type DataMaskingRuleListResult struct {
	// The list of Sql pool data masking rules.
	Value []*DataMaskingRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMaskingRuleListResult.
func (d DataMaskingRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataMaskingRuleProperties - The properties of a Sql pool data masking rule.
type DataMaskingRuleProperties struct {
	// REQUIRED; The column name on which the data masking rule is applied.
	ColumnName *string `json:"columnName,omitempty"`

	// REQUIRED; The masking function that is used for the data masking rule.
	MaskingFunction *DataMaskingFunction `json:"maskingFunction,omitempty"`

	// REQUIRED; The schema name on which the data masking rule is applied.
	SchemaName *string `json:"schemaName,omitempty"`

	// REQUIRED; The table name on which the data masking rule is applied.
	TableName *string `json:"tableName,omitempty"`

	// The alias name. This is a legacy parameter and is no longer used.
	AliasName *string `json:"aliasName,omitempty"`

	// The numberFrom property of the masking rule. Required if maskingFunction is set to Number, otherwise this parameter will be ignored.
	NumberFrom *string `json:"numberFrom,omitempty"`

	// The numberTo property of the data masking rule. Required if maskingFunction is set to Number, otherwise this parameter will be ignored.
	NumberTo *string `json:"numberTo,omitempty"`

	// If maskingFunction is set to Text, the number of characters to show unmasked in the beginning of the string. Otherwise, this parameter will be ignored.
	PrefixSize *string `json:"prefixSize,omitempty"`

	// If maskingFunction is set to Text, the character to use for masking the unexposed part of the string. Otherwise, this parameter will be ignored.
	ReplacementString *string `json:"replacementString,omitempty"`

	// The rule state. Used to delete a rule. To delete an existing rule, specify the schemaName, tableName, columnName, maskingFunction, and specify ruleState
	// as disabled. However, if the rule doesn't
	// already exist, the rule will be created with ruleState set to enabled, regardless of the provided value of ruleState.
	RuleState *DataMaskingRuleState `json:"ruleState,omitempty"`

	// If maskingFunction is set to Text, the number of characters to show unmasked at the end of the string. Otherwise, this parameter will be ignored.
	SuffixSize *string `json:"suffixSize,omitempty"`

	// READ-ONLY; The rule Id.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// DataMaskingRulesCreateOrUpdateOptions contains the optional parameters for the DataMaskingRules.CreateOrUpdate method.
type DataMaskingRulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DataMaskingRulesGetOptions contains the optional parameters for the DataMaskingRules.Get method.
type DataMaskingRulesGetOptions struct {
	// placeholder for future optional parameters
}

// DataMaskingRulesListBySQLPoolOptions contains the optional parameters for the DataMaskingRules.ListBySQLPool method.
type DataMaskingRulesListBySQLPoolOptions struct {
	// placeholder for future optional parameters
}

// DataWarehouseUserActivities - User activities of a data warehouse
type DataWarehouseUserActivities struct {
	ProxyResource
	// Resource properties.
	Properties *DataWarehouseUserActivitiesProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataWarehouseUserActivities.
func (d DataWarehouseUserActivities) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataWarehouseUserActivities.
func (d *DataWarehouseUserActivities) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataWarehouseUserActivitiesProperties - User activities of a data warehouse. This currently includes the count of running or suspended queries. For more
// information, please view the sys.dmpdwexec_requests dynamic management view (DMV).
type DataWarehouseUserActivitiesProperties struct {
	// READ-ONLY; Count of running and suspended queries.
	ActiveQueriesCount *int32 `json:"activeQueriesCount,omitempty" azure:"ro"`
}

// DatabaseClassification provides polymorphic access to related types.
// Call the interface's GetDatabase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Database, *ReadWriteDatabase
type DatabaseClassification interface {
	// GetDatabase returns the Database content of the underlying type.
	GetDatabase() *Database
}

// Database - Class representing a Kusto database.
type Database struct {
	ProxyResource
	// REQUIRED; Kind of the database
	Kind *Kind `json:"kind,omitempty"`

	// Resource location.
	Location *string `json:"location,omitempty"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// GetDatabase implements the DatabaseClassification interface for type Database.
func (d *Database) GetDatabase() *Database { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type Database.
func (d *Database) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d Database) marshalInternal(objectMap map[string]interface{}, discValue Kind) {
	d.ProxyResource.marshalInternal(objectMap)
	d.Kind = &discValue
	objectMap["kind"] = d.Kind
	populate(objectMap, "location", d.Location)
	populate(objectMap, "systemData", d.SystemData)
}

func (d *Database) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &d.Location)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatabaseCheckNameRequest - The result returned from a database check name availability request.
type DatabaseCheckNameRequest struct {
	// REQUIRED; Resource name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of resource, for instance Microsoft.Synapse/workspaces/kustoPools/databases.
	Type *Type `json:"type,omitempty"`
}

// DatabaseListResult - The list Kusto databases operation response.
type DatabaseListResult struct {
	// The list of Kusto databases.
	Value []DatabaseClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseListResult.
func (d DatabaseListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseListResult.
func (d *DatabaseListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			d.Value, err = unmarshalDatabaseClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabasePrincipalAssignment - Class representing a database principal assignment.
type DatabasePrincipalAssignment struct {
	ProxyResource
	// The database principal.
	Properties *DatabasePrincipalProperties `json:"properties,omitempty"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabasePrincipalAssignment.
func (d DatabasePrincipalAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabasePrincipalAssignment.
func (d *DatabasePrincipalAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatabasePrincipalAssignmentCheckNameRequest - A principal assignment check name availability request.
type DatabasePrincipalAssignmentCheckNameRequest struct {
	// REQUIRED; Principal Assignment resource name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of resource, Microsoft.Synapse/workspaces/kustoPools/databases/principalAssignments.
	Type *string `json:"type,omitempty"`
}

// DatabasePrincipalAssignmentListResult - The list Kusto database principal assignments operation response.
type DatabasePrincipalAssignmentListResult struct {
	// The list of Kusto database principal assignments.
	Value []*DatabasePrincipalAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabasePrincipalAssignmentListResult.
func (d DatabasePrincipalAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DatabasePrincipalProperties - A class representing database principal property.
type DatabasePrincipalProperties struct {
	// REQUIRED; The principal ID assigned to the database principal. It can be a user email, application ID, or security group name.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; Principal type.
	PrincipalType *PrincipalType `json:"principalType,omitempty"`

	// REQUIRED; Database principal role.
	Role *DatabasePrincipalRole `json:"role,omitempty"`

	// The tenant id of the principal
	TenantID *string `json:"tenantId,omitempty"`

	// READ-ONLY; The principal name
	PrincipalName *string `json:"principalName,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The tenant name of the principal
	TenantName *string `json:"tenantName,omitempty" azure:"ro"`
}

// DatabaseStatistics - A class that contains database statistics information.
type DatabaseStatistics struct {
	// The database size - the total size of compressed data and index in bytes.
	Size *float32 `json:"size,omitempty"`
}

// DynamicExecutorAllocation - Dynamic Executor Allocation Properties
type DynamicExecutorAllocation struct {
	// Indicates whether Dynamic Executor Allocation is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

// EncryptionDetails - Details of the encryption associated with the workspace
type EncryptionDetails struct {
	// Customer Managed Key Details
	Cmk *CustomerManagedKeyDetails `json:"cmk,omitempty"`

	// READ-ONLY; Double Encryption enabled
	DoubleEncryptionEnabled *bool `json:"doubleEncryptionEnabled,omitempty" azure:"ro"`
}

// EncryptionProtector - The server encryption protector.
type EncryptionProtector struct {
	ProxyResource
	// Resource properties.
	Properties *EncryptionProtectorProperties `json:"properties,omitempty"`

	// READ-ONLY; Kind of encryption protector. This is metadata used for the Azure portal experience.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; Resource location.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionProtector.
func (e EncryptionProtector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", e.Kind)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionProtector.
func (e *EncryptionProtector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &e.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &e.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncryptionProtectorListResult - A list of server encryption protectors.
type EncryptionProtectorListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*EncryptionProtector `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionProtectorListResult.
func (e EncryptionProtectorListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EncryptionProtectorProperties - Properties for an encryption protector execution.
type EncryptionProtectorProperties struct {
	// REQUIRED; The encryption protector type like 'ServiceManaged', 'AzureKeyVault'.
	ServerKeyType *ServerKeyType `json:"serverKeyType,omitempty"`

	// The name of the server key.
	ServerKeyName *string `json:"serverKeyName,omitempty"`

	// READ-ONLY; Subregion of the encryption protector.
	Subregion *string `json:"subregion,omitempty" azure:"ro"`

	// READ-ONLY; Thumbprint of the server key.
	Thumbprint *string `json:"thumbprint,omitempty" azure:"ro"`

	// READ-ONLY; The URI of the server key.
	URI *string `json:"uri,omitempty" azure:"ro"`
}

// EntityReference - The entity reference.
type EntityReference struct {
	// The name of this referenced entity.
	ReferenceName *string `json:"referenceName,omitempty"`

	// The type of this referenced entity.
	Type *IntegrationRuntimeEntityReferenceType `json:"type,omitempty"`
}

// EnvironmentVariableSetup - The custom setup of setting environment variable.
type EnvironmentVariableSetup struct {
	CustomSetupBase
	// REQUIRED; Add environment variable type properties.
	TypeProperties *EnvironmentVariableSetupTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableSetup.
func (e EnvironmentVariableSetup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.CustomSetupBase.marshalInternal(objectMap, "EnvironmentVariableSetup")
	populate(objectMap, "typeProperties", e.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableSetup.
func (e *EnvironmentVariableSetup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &e.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.CustomSetupBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EnvironmentVariableSetupTypeProperties - Environment variable custom setup type properties.
type EnvironmentVariableSetupTypeProperties struct {
	// REQUIRED; The name of the environment variable.
	VariableName *string `json:"variableName,omitempty"`

	// REQUIRED; The value of the environment variable.
	VariableValue *string `json:"variableValue,omitempty"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// EventGridConnectionProperties - Class representing the Kusto event grid connection properties.
type EventGridConnectionProperties struct {
	// REQUIRED; The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// REQUIRED; The resource ID where the event grid is configured to send events.
	EventHubResourceID *string `json:"eventHubResourceId,omitempty"`

	// REQUIRED; The resource ID of the storage account where the data resides.
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`

	// The name of blob storage event type to process.
	BlobStorageEventType *BlobStorageEventType `json:"blobStorageEventType,omitempty"`

	// The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventGridDataFormat `json:"dataFormat,omitempty"`

	// A Boolean value that, if set to true, indicates that ingestion should ignore the first record of every file
	IgnoreFirstRecord *bool `json:"ignoreFirstRecord,omitempty"`

	// The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// EventGridDataConnection - Class representing an Event Grid data connection.
type EventGridDataConnection struct {
	DataConnection
	// The properties of the Event Grid data connection.
	Properties *EventGridConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventGridDataConnection.
func (e EventGridDataConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.DataConnection.marshalInternal(objectMap, DataConnectionKindEventGrid)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventGridDataConnection.
func (e *EventGridDataConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.DataConnection.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EventHubConnectionProperties - Class representing the Kusto event hub connection properties.
type EventHubConnectionProperties struct {
	// REQUIRED; The event hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// REQUIRED; The resource ID of the event hub to be used to create a data connection.
	EventHubResourceID *string `json:"eventHubResourceId,omitempty"`

	// The event hub messages compression type
	Compression *Compression `json:"compression,omitempty"`

	// The data format of the message. Optionally the data format can be added to each message.
	DataFormat *EventHubDataFormat `json:"dataFormat,omitempty"`

	// System properties of the event hub
	EventSystemProperties []*string `json:"eventSystemProperties,omitempty"`

	// The resource ID of a managed identity (system or user assigned) to be used to authenticate with event hub.
	ManagedIdentityResourceID *string `json:"managedIdentityResourceId,omitempty"`

	// The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubConnectionProperties.
func (e EventHubConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compression", e.Compression)
	populate(objectMap, "consumerGroup", e.ConsumerGroup)
	populate(objectMap, "dataFormat", e.DataFormat)
	populate(objectMap, "eventHubResourceId", e.EventHubResourceID)
	populate(objectMap, "eventSystemProperties", e.EventSystemProperties)
	populate(objectMap, "managedIdentityResourceId", e.ManagedIdentityResourceID)
	populate(objectMap, "mappingRuleName", e.MappingRuleName)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "tableName", e.TableName)
	return json.Marshal(objectMap)
}

// EventHubDataConnection - Class representing an event hub data connection.
type EventHubDataConnection struct {
	DataConnection
	// The Event Hub data connection properties to validate.
	Properties *EventHubConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubDataConnection.
func (e EventHubDataConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.DataConnection.marshalInternal(objectMap, DataConnectionKindEventHub)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventHubDataConnection.
func (e *EventHubDataConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.DataConnection.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ExtendedSQLPoolBlobAuditingPoliciesCreateOrUpdateOptions contains the optional parameters for the ExtendedSQLPoolBlobAuditingPolicies.CreateOrUpdate
// method.
type ExtendedSQLPoolBlobAuditingPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ExtendedSQLPoolBlobAuditingPoliciesGetOptions contains the optional parameters for the ExtendedSQLPoolBlobAuditingPolicies.Get method.
type ExtendedSQLPoolBlobAuditingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolOptions contains the optional parameters for the ExtendedSQLPoolBlobAuditingPolicies.ListBySQLPool method.
type ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolOptions struct {
	// placeholder for future optional parameters
}

// ExtendedSQLPoolBlobAuditingPolicy - An extended Sql pool blob auditing policy.
type ExtendedSQLPoolBlobAuditingPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *ExtendedSQLPoolBlobAuditingPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedSQLPoolBlobAuditingPolicy.
func (e ExtendedSQLPoolBlobAuditingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedSQLPoolBlobAuditingPolicy.
func (e *ExtendedSQLPoolBlobAuditingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ExtendedSQLPoolBlobAuditingPolicyListResult - A list of sql pool extended auditing settings.
type ExtendedSQLPoolBlobAuditingPolicyListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*ExtendedSQLPoolBlobAuditingPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedSQLPoolBlobAuditingPolicyListResult.
func (e ExtendedSQLPoolBlobAuditingPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExtendedSQLPoolBlobAuditingPolicyProperties - Properties of an extended Sql pool blob auditing policy.
type ExtendedSQLPoolBlobAuditingPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
	State *BlobAuditingPolicyState `json:"state,omitempty"`

	// Specifies the Actions-Groups and Actions to audit.
	// The recommended set of action groups to use is the following combination - this will audit all the queries and stored procedures executed against the
	// database, as well as successful and failed logins:
	// BATCHCOMPLETEDGROUP, SUCCESSFULDATABASEAUTHENTICATIONGROUP, FAILEDDATABASEAUTHENTICATIONGROUP.
	// This above combination is also the set that is configured by default when enabling auditing from the Azure portal.
	// The supported action groups to audit are (note: choose only specific groups that cover your auditing needs. Using unnecessary groups could lead to very
	// large quantities of audit records):
	// APPLICATIONROLECHANGEPASSWORDGROUP BACKUPRESTOREGROUP DATABASELOGOUTGROUP DATABASEOBJECTCHANGEGROUP DATABASEOBJECTOWNERSHIPCHANGEGROUP DATABASEOBJECTPERMISSIONCHANGEGROUP
	// DATABASEOPERATIONGROUP
	// DATABASEPERMISSIONCHANGEGROUP DATABASEPRINCIPALCHANGEGROUP DATABASEPRINCIPALIMPERSONATIONGROUP DATABASEROLEMEMBERCHANGEGROUP FAILEDDATABASEAUTHENTICATIONGROUP
	// SCHEMAOBJECTACCESSGROUP SCHEMAOBJECT
	// CHANGEGROUP SCHEMAOBJECTOWNERSHIPCHANGEGROUP SCHEMAOBJECTPERMISSIONCHANGEGROUP SUCCESSFULDATABASEAUTHENTICATIONGROUP USERCHANGEPASSWORDGROUP BATCHSTARTEDGROUP
	// BATCHCOMPLETED_GROUP
	// These are groups that cover all sql statements and stored procedures executed against the database, and should not be used in combination with other
	// groups as this will result in duplicate audit logs.
	// For more information, see Database-Level Audit Action Groups
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-action-groups].
	// For Database auditing policy, specific Actions can also be specified (note that Actions cannot be specified for Server auditing policy). The supported
	// actions to audit are: SELECT UPDATE INSERT DELETE
	// EXECUTE RECEIVE REFERENCES
	// The general form for defining an action to be audited is: {action} ON {object} BY {principal}
	// Note that in the above format can refer to an object like a table, view, or stored procedure, or an entire database or schema. For the latter cases,
	// the forms DATABASE::{dbname} and SCHEMA::{schema
	// name} are used, respectively.
	// For example: SELECT on dbo.myTable by public SELECT on DATABASE::myDatabase by public SELECT on SCHEMA::mySchema by public
	// For more information, see Database-Level Audit Actions
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-actions]
	AuditActionsAndGroups []*string `json:"auditActionsAndGroups,omitempty"`

	// Specifies whether audit events are sent to Azure Monitor. In order to send the events to Azure Monitor, specify 'state' as 'Enabled' and 'isAzureMonitorTargetEnabled'
	// as true.
	// When using REST API to configure auditing, Diagnostic Settings with 'SQLSecurityAuditEvents' diagnostic logs category on the database should be also
	// created. Note that for server level audit you
	// should use the 'master' database as {databaseName}.
	// Diagnostic Settings URI format: PUT
	// https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/providers/microsoft.insights/diagnosticSettings/{settingsName}?api-version=2017-05-01-preview
	// For more information, see Diagnostic Settings REST API [https://go.microsoft.com/fwlink/?linkid=2033207]or Diagnostic Settings PowerShell [https://go.microsoft.com/fwlink/?linkid=2033043]
	IsAzureMonitorTargetEnabled *bool `json:"isAzureMonitorTargetEnabled,omitempty"`

	// Specifies whether storageAccountAccessKey value is the storage's secondary key.
	IsStorageSecondaryKeyInUse *bool `json:"isStorageSecondaryKeyInUse,omitempty"`

	// Specifies condition of where clause when creating an audit.
	PredicateExpression *string `json:"predicateExpression,omitempty"`

	// Specifies the amount of time in milliseconds that can elapse before audit actions are forced to be processed. The default minimum value is 1000 (1 second).
	// The maximum is 2,147,483,647.
	QueueDelayMs *int32 `json:"queueDelayMs,omitempty"`

	// Specifies the number of days to keep in the audit logs in the storage account.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the auditing storage account. If state is Enabled and storageEndpoint is specified, not specifying the storageAccountAccessKey
	// will use SQL server system-assigned
	// managed identity to access the storage. Prerequisites for using managed identity authentication:
	// 1. Assign SQL Server a system-assigned managed identity in Azure Active Directory (AAD).
	// 2. Grant SQL Server identity access to the storage account by adding 'Storage Blob Data Contributor' RBAC role to the server identity. For more information,
	// see Auditing to storage using Managed
	// Identity authentication [https://go.microsoft.com/fwlink/?linkid=2114355]
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage subscription Id.
	StorageAccountSubscriptionID *string `json:"storageAccountSubscriptionId,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled
	// is required.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedSQLPoolBlobAuditingPolicyProperties.
func (e ExtendedSQLPoolBlobAuditingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "auditActionsAndGroups", e.AuditActionsAndGroups)
	populate(objectMap, "isAzureMonitorTargetEnabled", e.IsAzureMonitorTargetEnabled)
	populate(objectMap, "isStorageSecondaryKeyInUse", e.IsStorageSecondaryKeyInUse)
	populate(objectMap, "predicateExpression", e.PredicateExpression)
	populate(objectMap, "queueDelayMs", e.QueueDelayMs)
	populate(objectMap, "retentionDays", e.RetentionDays)
	populate(objectMap, "state", e.State)
	populate(objectMap, "storageAccountAccessKey", e.StorageAccountAccessKey)
	populate(objectMap, "storageAccountSubscriptionId", e.StorageAccountSubscriptionID)
	populate(objectMap, "storageEndpoint", e.StorageEndpoint)
	return json.Marshal(objectMap)
}

// ExtendedServerBlobAuditingPolicy - An extended server blob auditing policy.
type ExtendedServerBlobAuditingPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *ExtendedServerBlobAuditingPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedServerBlobAuditingPolicy.
func (e ExtendedServerBlobAuditingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedServerBlobAuditingPolicy.
func (e *ExtendedServerBlobAuditingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ExtendedServerBlobAuditingPolicyListResult - A list of server extended auditing settings.
type ExtendedServerBlobAuditingPolicyListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*ExtendedServerBlobAuditingPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedServerBlobAuditingPolicyListResult.
func (e ExtendedServerBlobAuditingPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// ExtendedServerBlobAuditingPolicyProperties - Properties of an extended server blob auditing policy.
type ExtendedServerBlobAuditingPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
	State *BlobAuditingPolicyState `json:"state,omitempty"`

	// Specifies the Actions-Groups and Actions to audit.
	// The recommended set of action groups to use is the following combination - this will audit all the queries and stored procedures executed against the
	// database, as well as successful and failed logins:
	// BATCHCOMPLETEDGROUP, SUCCESSFULDATABASEAUTHENTICATIONGROUP, FAILEDDATABASEAUTHENTICATIONGROUP.
	// This above combination is also the set that is configured by default when enabling auditing from the Azure portal.
	// The supported action groups to audit are (note: choose only specific groups that cover your auditing needs. Using unnecessary groups could lead to very
	// large quantities of audit records):
	// APPLICATIONROLECHANGEPASSWORDGROUP BACKUPRESTOREGROUP DATABASELOGOUTGROUP DATABASEOBJECTCHANGEGROUP DATABASEOBJECTOWNERSHIPCHANGEGROUP DATABASEOBJECTPERMISSIONCHANGEGROUP
	// DATABASEOPERATIONGROUP
	// DATABASEPERMISSIONCHANGEGROUP DATABASEPRINCIPALCHANGEGROUP DATABASEPRINCIPALIMPERSONATIONGROUP DATABASEROLEMEMBERCHANGEGROUP FAILEDDATABASEAUTHENTICATIONGROUP
	// SCHEMAOBJECTACCESSGROUP SCHEMAOBJECT
	// CHANGEGROUP SCHEMAOBJECTOWNERSHIPCHANGEGROUP SCHEMAOBJECTPERMISSIONCHANGEGROUP SUCCESSFULDATABASEAUTHENTICATIONGROUP USERCHANGEPASSWORDGROUP BATCHSTARTEDGROUP
	// BATCHCOMPLETED_GROUP
	// These are groups that cover all sql statements and stored procedures executed against the database, and should not be used in combination with other
	// groups as this will result in duplicate audit logs.
	// For more information, see Database-Level Audit Action Groups
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-action-groups].
	// For Database auditing policy, specific Actions can also be specified (note that Actions cannot be specified for Server auditing policy). The supported
	// actions to audit are: SELECT UPDATE INSERT DELETE
	// EXECUTE RECEIVE REFERENCES
	// The general form for defining an action to be audited is: {action} ON {object} BY {principal}
	// Note that in the above format can refer to an object like a table, view, or stored procedure, or an entire database or schema. For the latter cases,
	// the forms DATABASE::{dbname} and SCHEMA::{schema
	// name} are used, respectively.
	// For example: SELECT on dbo.myTable by public SELECT on DATABASE::myDatabase by public SELECT on SCHEMA::mySchema by public
	// For more information, see Database-Level Audit Actions
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-actions]
	AuditActionsAndGroups []*string `json:"auditActionsAndGroups,omitempty"`

	// Specifies whether audit events are sent to Azure Monitor. In order to send the events to Azure Monitor, specify 'state' as 'Enabled' and 'isAzureMonitorTargetEnabled'
	// as true.
	// When using REST API to configure auditing, Diagnostic Settings with 'SQLSecurityAuditEvents' diagnostic logs category on the database should be also
	// created. Note that for server level audit you
	// should use the 'master' database as {databaseName}.
	// Diagnostic Settings URI format: PUT
	// https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/providers/microsoft.insights/diagnosticSettings/{settingsName}?api-version=2017-05-01-preview
	// For more information, see Diagnostic Settings REST API [https://go.microsoft.com/fwlink/?linkid=2033207]or Diagnostic Settings PowerShell [https://go.microsoft.com/fwlink/?linkid=2033043]
	IsAzureMonitorTargetEnabled *bool `json:"isAzureMonitorTargetEnabled,omitempty"`

	// Specifies whether storageAccountAccessKey value is the storage's secondary key.
	IsStorageSecondaryKeyInUse *bool `json:"isStorageSecondaryKeyInUse,omitempty"`

	// Specifies condition of where clause when creating an audit.
	PredicateExpression *string `json:"predicateExpression,omitempty"`

	// Specifies the amount of time in milliseconds that can elapse before audit actions are forced to be processed. The default minimum value is 1000 (1 second).
	// The maximum is 2,147,483,647.
	QueueDelayMs *int32 `json:"queueDelayMs,omitempty"`

	// Specifies the number of days to keep in the audit logs in the storage account.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the auditing storage account. If state is Enabled and storageEndpoint is specified, not specifying the storageAccountAccessKey
	// will use SQL server system-assigned
	// managed identity to access the storage. Prerequisites for using managed identity authentication:
	// 1. Assign SQL Server a system-assigned managed identity in Azure Active Directory (AAD).
	// 2. Grant SQL Server identity access to the storage account by adding 'Storage Blob Data Contributor' RBAC role to the server identity. For more information,
	// see Auditing to storage using Managed
	// Identity authentication [https://go.microsoft.com/fwlink/?linkid=2114355]
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage subscription Id.
	StorageAccountSubscriptionID *string `json:"storageAccountSubscriptionId,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled
	// is required.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedServerBlobAuditingPolicyProperties.
func (e ExtendedServerBlobAuditingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "auditActionsAndGroups", e.AuditActionsAndGroups)
	populate(objectMap, "isAzureMonitorTargetEnabled", e.IsAzureMonitorTargetEnabled)
	populate(objectMap, "isStorageSecondaryKeyInUse", e.IsStorageSecondaryKeyInUse)
	populate(objectMap, "predicateExpression", e.PredicateExpression)
	populate(objectMap, "queueDelayMs", e.QueueDelayMs)
	populate(objectMap, "retentionDays", e.RetentionDays)
	populate(objectMap, "state", e.State)
	populate(objectMap, "storageAccountAccessKey", e.StorageAccountAccessKey)
	populate(objectMap, "storageAccountSubscriptionId", e.StorageAccountSubscriptionID)
	populate(objectMap, "storageEndpoint", e.StorageEndpoint)
	return json.Marshal(objectMap)
}

// FollowerDatabaseDefinition - A class representing follower database request.
type FollowerDatabaseDefinition struct {
	// REQUIRED; Resource name of the attached database configuration in the follower cluster.
	AttachedDatabaseConfigurationName *string `json:"attachedDatabaseConfigurationName,omitempty"`

	// REQUIRED; Resource id of the cluster that follows a database owned by this cluster.
	KustoPoolResourceID *string `json:"clusterResourceId,omitempty"`

	// READ-ONLY; The database name owned by this cluster that was followed. * in case following all databases.
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`
}

// FollowerDatabaseListResult - The list Kusto database principals operation response.
type FollowerDatabaseListResult struct {
	// The list of follower database result.
	Value []*FollowerDatabaseDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FollowerDatabaseListResult.
func (f FollowerDatabaseListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// GeoBackupPolicy - A database geo backup policy.
type GeoBackupPolicy struct {
	ProxyResource
	// REQUIRED; The properties of the geo backup policy.
	Properties *GeoBackupPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; Kind of geo backup policy. This is metadata used for the Azure portal experience.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; Backup policy location.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoBackupPolicy.
func (g GeoBackupPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", g.Kind)
	populate(objectMap, "location", g.Location)
	populate(objectMap, "properties", g.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoBackupPolicy.
func (g *GeoBackupPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &g.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &g.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &g.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GeoBackupPolicyListResult - The response to a list geo backup policies request.
type GeoBackupPolicyListResult struct {
	// The list of geo backup policies.
	Value []*GeoBackupPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoBackupPolicyListResult.
func (g GeoBackupPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// GeoBackupPolicyProperties - The properties of the geo backup policy.
type GeoBackupPolicyProperties struct {
	// REQUIRED; The state of the geo backup policy.
	State *GeoBackupPolicyState `json:"state,omitempty"`

	// READ-ONLY; The storage type of the geo backup policy.
	StorageType *string `json:"storageType,omitempty" azure:"ro"`
}

// GetSsisObjectMetadataRequest - The request payload of get SSIS object metadata.
type GetSsisObjectMetadataRequest struct {
	// Metadata path.
	MetadataPath *string `json:"metadataPath,omitempty"`
}

// IPFirewallRuleInfo - IP firewall rule
type IPFirewallRuleInfo struct {
	ProxyResource
	// IP firewall rule properties
	Properties *IPFirewallRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPFirewallRuleInfo.
func (i IPFirewallRuleInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPFirewallRuleInfo.
func (i *IPFirewallRuleInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// IPFirewallRuleInfoListResult - List of IP firewall rules
type IPFirewallRuleInfoListResult struct {
	// Link to next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of IP firewall rules
	Value []*IPFirewallRuleInfo `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPFirewallRuleInfoListResult.
func (i IPFirewallRuleInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IPFirewallRuleProperties - IP firewall rule properties
type IPFirewallRuleProperties struct {
	// The end IP address of the firewall rule. Must be IPv4 format. Must be greater than or equal to startIpAddress
	EndIPAddress *string `json:"endIpAddress,omitempty"`

	// The start IP address of the firewall rule. Must be IPv4 format
	StartIPAddress *string `json:"startIpAddress,omitempty"`

	// READ-ONLY; Resource provisioning state
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// IPFirewallRulesBeginCreateOrUpdateOptions contains the optional parameters for the IPFirewallRules.BeginCreateOrUpdate method.
type IPFirewallRulesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// IPFirewallRulesBeginDeleteOptions contains the optional parameters for the IPFirewallRules.BeginDelete method.
type IPFirewallRulesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// IPFirewallRulesBeginReplaceAllOptions contains the optional parameters for the IPFirewallRules.BeginReplaceAll method.
type IPFirewallRulesBeginReplaceAllOptions struct {
	// placeholder for future optional parameters
}

// IPFirewallRulesGetOptions contains the optional parameters for the IPFirewallRules.Get method.
type IPFirewallRulesGetOptions struct {
	// placeholder for future optional parameters
}

// IPFirewallRulesListByWorkspaceOptions contains the optional parameters for the IPFirewallRules.ListByWorkspace method.
type IPFirewallRulesListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeClassification provides polymorphic access to related types.
// Call the interface's GetIntegrationRuntime() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *IntegrationRuntime, *ManagedIntegrationRuntime, *SelfHostedIntegrationRuntime
type IntegrationRuntimeClassification interface {
	// GetIntegrationRuntime returns the IntegrationRuntime content of the underlying type.
	GetIntegrationRuntime() *IntegrationRuntime
}

// IntegrationRuntime - Azure Synapse nested object which serves as a compute resource for activities.
type IntegrationRuntime struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Integration runtime description.
	Description *string `json:"description,omitempty"`
}

// GetIntegrationRuntime implements the IntegrationRuntimeClassification interface for type IntegrationRuntime.
func (i *IntegrationRuntime) GetIntegrationRuntime() *IntegrationRuntime { return i }

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntime.
func (i *IntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i IntegrationRuntime) marshalInternal(objectMap map[string]interface{}, discValue IntegrationRuntimeType) {
	populate(objectMap, "description", i.Description)
	i.Type = &discValue
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
}

func (i *IntegrationRuntime) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &i.Description)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeAuthKeys - The integration runtime authentication keys.
type IntegrationRuntimeAuthKeys struct {
	// The primary integration runtime authentication key.
	AuthKey1 *string `json:"authKey1,omitempty"`

	// The secondary integration runtime authentication key.
	AuthKey2 *string `json:"authKey2,omitempty"`
}

// IntegrationRuntimeAuthKeysListOptions contains the optional parameters for the IntegrationRuntimeAuthKeys.List method.
type IntegrationRuntimeAuthKeysListOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeAuthKeysRegenerateOptions contains the optional parameters for the IntegrationRuntimeAuthKeys.Regenerate method.
type IntegrationRuntimeAuthKeysRegenerateOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeComputeProperties - The compute resource properties for managed integration runtime.
type IntegrationRuntimeComputeProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Data flow properties for managed integration runtime.
	DataFlowProperties *IntegrationRuntimeDataFlowProperties `json:"dataFlowProperties,omitempty"`

	// The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
	Location *string `json:"location,omitempty"`

	// Maximum parallel executions count per node for managed integration runtime.
	MaxParallelExecutionsPerNode *int32 `json:"maxParallelExecutionsPerNode,omitempty"`

	// The node size requirement to managed integration runtime.
	NodeSize *string `json:"nodeSize,omitempty"`

	// The required number of nodes for managed integration runtime.
	NumberOfNodes *int32 `json:"numberOfNodes,omitempty"`

	// VNet properties for managed integration runtime.
	VNetProperties *IntegrationRuntimeVNetProperties `json:"vNetProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeComputeProperties.
func (i IntegrationRuntimeComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataFlowProperties", i.DataFlowProperties)
	populate(objectMap, "location", i.Location)
	populate(objectMap, "maxParallelExecutionsPerNode", i.MaxParallelExecutionsPerNode)
	populate(objectMap, "nodeSize", i.NodeSize)
	populate(objectMap, "numberOfNodes", i.NumberOfNodes)
	populate(objectMap, "vNetProperties", i.VNetProperties)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeComputeProperties.
func (i *IntegrationRuntimeComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlowProperties":
			err = unpopulate(val, &i.DataFlowProperties)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &i.Location)
			delete(rawMsg, key)
		case "maxParallelExecutionsPerNode":
			err = unpopulate(val, &i.MaxParallelExecutionsPerNode)
			delete(rawMsg, key)
		case "nodeSize":
			err = unpopulate(val, &i.NodeSize)
			delete(rawMsg, key)
		case "numberOfNodes":
			err = unpopulate(val, &i.NumberOfNodes)
			delete(rawMsg, key)
		case "vNetProperties":
			err = unpopulate(val, &i.VNetProperties)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeConnectionInfo - Connection information for encrypting the on-premises data source credentials.
type IntegrationRuntimeConnectionInfo struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The on-premises integration runtime host URL.
	HostServiceURI *string `json:"hostServiceUri,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime SSL certificate thumbprint. Click-Once application uses it to do server validation.
	IdentityCertThumbprint *string `json:"identityCertThumbprint,omitempty" azure:"ro"`

	// READ-ONLY; Whether the identity certificate is expired.
	IsIdentityCertExprired *bool `json:"isIdentityCertExprired,omitempty" azure:"ro"`

	// READ-ONLY; The public key for encrypting a credential when transferring the credential to the integration runtime.
	PublicKey *string `json:"publicKey,omitempty" azure:"ro"`

	// READ-ONLY; The token generated in service. Callers use this token to authenticate to integration runtime.
	ServiceToken *string `json:"serviceToken,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime version.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeConnectionInfo.
func (i IntegrationRuntimeConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostServiceUri", i.HostServiceURI)
	populate(objectMap, "identityCertThumbprint", i.IdentityCertThumbprint)
	populate(objectMap, "isIdentityCertExprired", i.IsIdentityCertExprired)
	populate(objectMap, "publicKey", i.PublicKey)
	populate(objectMap, "serviceToken", i.ServiceToken)
	populate(objectMap, "version", i.Version)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeConnectionInfo.
func (i *IntegrationRuntimeConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostServiceUri":
			err = unpopulate(val, &i.HostServiceURI)
			delete(rawMsg, key)
		case "identityCertThumbprint":
			err = unpopulate(val, &i.IdentityCertThumbprint)
			delete(rawMsg, key)
		case "isIdentityCertExprired":
			err = unpopulate(val, &i.IsIdentityCertExprired)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, &i.PublicKey)
			delete(rawMsg, key)
		case "serviceToken":
			err = unpopulate(val, &i.ServiceToken)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &i.Version)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeConnectionInfosGetOptions contains the optional parameters for the IntegrationRuntimeConnectionInfos.Get method.
type IntegrationRuntimeConnectionInfosGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeCredentialsSyncOptions contains the optional parameters for the IntegrationRuntimeCredentials.Sync method.
type IntegrationRuntimeCredentialsSyncOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeCustomSetupScriptProperties - Custom setup script properties for a managed dedicated integration runtime.
type IntegrationRuntimeCustomSetupScriptProperties struct {
	// The URI of the Azure blob container that contains the custom setup script.
	BlobContainerURI *string `json:"blobContainerUri,omitempty"`

	// The SAS token of the Azure blob container.
	SasToken *SecureString `json:"sasToken,omitempty"`
}

// IntegrationRuntimeDataFlowProperties - Data flow properties for managed integration runtime.
type IntegrationRuntimeDataFlowProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Cluster will not be recycled and it will be used in next data flow activity run until TTL (time to live) is reached if this is set as false. Default
	// is true.
	Cleanup *bool `json:"cleanup,omitempty"`

	// Compute type of the cluster which will execute data flow job.
	ComputeType *DataFlowComputeType `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job.
	TimeToLive *int32 `json:"timeToLive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i IntegrationRuntimeDataFlowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cleanup", i.Cleanup)
	populate(objectMap, "computeType", i.ComputeType)
	populate(objectMap, "coreCount", i.CoreCount)
	populate(objectMap, "timeToLive", i.TimeToLive)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i *IntegrationRuntimeDataFlowProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanup":
			err = unpopulate(val, &i.Cleanup)
			delete(rawMsg, key)
		case "computeType":
			err = unpopulate(val, &i.ComputeType)
			delete(rawMsg, key)
		case "coreCount":
			err = unpopulate(val, &i.CoreCount)
			delete(rawMsg, key)
		case "timeToLive":
			err = unpopulate(val, &i.TimeToLive)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeDataProxyProperties - Data proxy properties for a managed dedicated integration runtime.
type IntegrationRuntimeDataProxyProperties struct {
	// The self-hosted integration runtime reference.
	ConnectVia *EntityReference `json:"connectVia,omitempty"`

	// The path to contain the staged data in the Blob storage.
	Path *string `json:"path,omitempty"`

	// The staging linked service reference.
	StagingLinkedService *EntityReference `json:"stagingLinkedService,omitempty"`
}

// IntegrationRuntimeListResponse - A list of integration runtime resources.
type IntegrationRuntimeListResponse struct {
	// REQUIRED; List of integration runtimes.
	Value []*IntegrationRuntimeResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeListResponse.
func (i IntegrationRuntimeListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeMonitoringData - Get monitoring data response.
type IntegrationRuntimeMonitoringData struct {
	// Integration runtime name.
	Name *string `json:"name,omitempty"`

	// Integration runtime node monitoring data.
	Nodes []*IntegrationRuntimeNodeMonitoringData `json:"nodes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeMonitoringData.
func (i IntegrationRuntimeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "nodes", i.Nodes)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeMonitoringDataListOptions contains the optional parameters for the IntegrationRuntimeMonitoringData.List method.
type IntegrationRuntimeMonitoringDataListOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodeIPAddress - The IP address of self-hosted integration runtime node.
type IntegrationRuntimeNodeIPAddress struct {
	// READ-ONLY; The IP address of self-hosted integration runtime node.
	IPAddress *string `json:"ipAddress,omitempty" azure:"ro"`
}

// IntegrationRuntimeNodeIPAddressGetOptions contains the optional parameters for the IntegrationRuntimeNodeIPAddress.Get method.
type IntegrationRuntimeNodeIPAddressGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodeMonitoringData - Monitoring data for integration runtime node.
type IntegrationRuntimeNodeMonitoringData struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Available memory (MB) on the integration runtime node.
	AvailableMemoryInMB *int32 `json:"availableMemoryInMB,omitempty" azure:"ro"`

	// READ-ONLY; CPU percentage on the integration runtime node.
	CPUUtilization *int32 `json:"cpuUtilization,omitempty" azure:"ro"`

	// READ-ONLY; Maximum concurrent jobs on the integration runtime node.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The number of jobs currently running on the integration runtime node.
	ConcurrentJobsRunning *int32 `json:"concurrentJobsRunning,omitempty" azure:"ro"`

	// READ-ONLY; The maximum concurrent jobs in this integration runtime.
	MaxConcurrentJobs *int32 `json:"maxConcurrentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Name of the integration runtime node.
	NodeName *string `json:"nodeName,omitempty" azure:"ro"`

	// READ-ONLY; Received bytes on the integration runtime node.
	ReceivedBytes *float32 `json:"receivedBytes,omitempty" azure:"ro"`

	// READ-ONLY; Sent bytes on the integration runtime node.
	SentBytes *float32 `json:"sentBytes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i IntegrationRuntimeNodeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availableMemoryInMB", i.AvailableMemoryInMB)
	populate(objectMap, "cpuUtilization", i.CPUUtilization)
	populate(objectMap, "concurrentJobsLimit", i.ConcurrentJobsLimit)
	populate(objectMap, "concurrentJobsRunning", i.ConcurrentJobsRunning)
	populate(objectMap, "maxConcurrentJobs", i.MaxConcurrentJobs)
	populate(objectMap, "nodeName", i.NodeName)
	populate(objectMap, "receivedBytes", i.ReceivedBytes)
	populate(objectMap, "sentBytes", i.SentBytes)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeNodeMonitoringData.
func (i *IntegrationRuntimeNodeMonitoringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableMemoryInMB":
			err = unpopulate(val, &i.AvailableMemoryInMB)
			delete(rawMsg, key)
		case "cpuUtilization":
			err = unpopulate(val, &i.CPUUtilization)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, &i.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "concurrentJobsRunning":
			err = unpopulate(val, &i.ConcurrentJobsRunning)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, &i.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, &i.NodeName)
			delete(rawMsg, key)
		case "receivedBytes":
			err = unpopulate(val, &i.ReceivedBytes)
			delete(rawMsg, key)
		case "sentBytes":
			err = unpopulate(val, &i.SentBytes)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeNodesDeleteOptions contains the optional parameters for the IntegrationRuntimeNodes.Delete method.
type IntegrationRuntimeNodesDeleteOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodesGetOptions contains the optional parameters for the IntegrationRuntimeNodes.Get method.
type IntegrationRuntimeNodesGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeNodesUpdateOptions contains the optional parameters for the IntegrationRuntimeNodes.Update method.
type IntegrationRuntimeNodesUpdateOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeObjectMetadataBeginRefreshOptions contains the optional parameters for the IntegrationRuntimeObjectMetadata.BeginRefresh method.
type IntegrationRuntimeObjectMetadataBeginRefreshOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeObjectMetadataListOptions contains the optional parameters for the IntegrationRuntimeObjectMetadata.List method.
type IntegrationRuntimeObjectMetadataListOptions struct {
	// The parameters for getting a SSIS object metadata.
	GetMetadataRequest *GetSsisObjectMetadataRequest
}

// IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint - Azure-SSIS integration runtime outbound network dependency endpoints for one category.
type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint struct {
	// The category of outbound network dependency.
	Category *string `json:"category,omitempty"`

	// The endpoints for outbound network dependency.
	Endpoints []*IntegrationRuntimeOutboundNetworkDependenciesEndpoint `json:"endpoints,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", i.Category)
	populate(objectMap, "endpoints", i.Endpoints)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpoint - The endpoint for Azure-SSIS integration runtime outbound network dependency.
type IntegrationRuntimeOutboundNetworkDependenciesEndpoint struct {
	// The domain name of endpoint.
	DomainName *string `json:"domainName,omitempty"`

	// The details of endpoint.
	EndpointDetails []*IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails `json:"endpointDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpoint.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "domainName", i.DomainName)
	populate(objectMap, "endpointDetails", i.EndpointDetails)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails - The details of Azure-SSIS integration runtime outbound network dependency endpoint.
type IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails struct {
	// The port of endpoint.
	Port *int32 `json:"port,omitempty"`
}

// IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse - Azure-SSIS integration runtime outbound network dependency endpoints.
type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse struct {
	// The list of outbound network dependency endpoints.
	Value []*IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse.
func (i IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IntegrationRuntimeRegenerateKeyParameters - Parameters to regenerate the authentication key.
type IntegrationRuntimeRegenerateKeyParameters struct {
	// The name of the authentication key to regenerate.
	KeyName *IntegrationRuntimeAuthKeyName `json:"keyName,omitempty"`
}

// IntegrationRuntimeResource - Integration runtime resource type.
type IntegrationRuntimeResource struct {
	SubResource
	// REQUIRED; Integration runtime properties.
	Properties IntegrationRuntimeClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeResource.
func (i IntegrationRuntimeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.SubResource.marshalInternal(objectMap)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeResource.
func (i *IntegrationRuntimeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.SubResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// IntegrationRuntimeSsisCatalogInfo - Catalog information for managed dedicated integration runtime.
type IntegrationRuntimeSsisCatalogInfo struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The password of the administrator user account of the catalog database.
	CatalogAdminPassword *SecureString `json:"catalogAdminPassword,omitempty"`

	// The administrator user name of catalog database.
	CatalogAdminUserName *string `json:"catalogAdminUserName,omitempty"`

	// The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
	CatalogPricingTier *IntegrationRuntimeSsisCatalogPricingTier `json:"catalogPricingTier,omitempty"`

	// The catalog database server URL.
	CatalogServerEndpoint *string `json:"catalogServerEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i IntegrationRuntimeSsisCatalogInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogAdminPassword", i.CatalogAdminPassword)
	populate(objectMap, "catalogAdminUserName", i.CatalogAdminUserName)
	populate(objectMap, "catalogPricingTier", i.CatalogPricingTier)
	populate(objectMap, "catalogServerEndpoint", i.CatalogServerEndpoint)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i *IntegrationRuntimeSsisCatalogInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogAdminPassword":
			err = unpopulate(val, &i.CatalogAdminPassword)
			delete(rawMsg, key)
		case "catalogAdminUserName":
			err = unpopulate(val, &i.CatalogAdminUserName)
			delete(rawMsg, key)
		case "catalogPricingTier":
			err = unpopulate(val, &i.CatalogPricingTier)
			delete(rawMsg, key)
		case "catalogServerEndpoint":
			err = unpopulate(val, &i.CatalogServerEndpoint)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeSsisProperties - SSIS properties for managed integration runtime.
type IntegrationRuntimeSsisProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Catalog information for managed dedicated integration runtime.
	CatalogInfo *IntegrationRuntimeSsisCatalogInfo `json:"catalogInfo,omitempty"`

	// Custom setup script properties for a managed dedicated integration runtime.
	CustomSetupScriptProperties *IntegrationRuntimeCustomSetupScriptProperties `json:"customSetupScriptProperties,omitempty"`

	// Data proxy properties for a managed dedicated integration runtime.
	DataProxyProperties *IntegrationRuntimeDataProxyProperties `json:"dataProxyProperties,omitempty"`

	// The edition for the SSIS Integration Runtime
	Edition *IntegrationRuntimeEdition `json:"edition,omitempty"`

	// Custom setup without script properties for a SSIS integration runtime.
	ExpressCustomSetupProperties []CustomSetupBaseClassification `json:"expressCustomSetupProperties,omitempty"`

	// License type for bringing your own license scenario.
	LicenseType *IntegrationRuntimeLicenseType `json:"licenseType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisProperties.
func (i IntegrationRuntimeSsisProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "catalogInfo", i.CatalogInfo)
	populate(objectMap, "customSetupScriptProperties", i.CustomSetupScriptProperties)
	populate(objectMap, "dataProxyProperties", i.DataProxyProperties)
	populate(objectMap, "edition", i.Edition)
	populate(objectMap, "expressCustomSetupProperties", i.ExpressCustomSetupProperties)
	populate(objectMap, "licenseType", i.LicenseType)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisProperties.
func (i *IntegrationRuntimeSsisProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogInfo":
			err = unpopulate(val, &i.CatalogInfo)
			delete(rawMsg, key)
		case "customSetupScriptProperties":
			err = unpopulate(val, &i.CustomSetupScriptProperties)
			delete(rawMsg, key)
		case "dataProxyProperties":
			err = unpopulate(val, &i.DataProxyProperties)
			delete(rawMsg, key)
		case "edition":
			err = unpopulate(val, &i.Edition)
			delete(rawMsg, key)
		case "expressCustomSetupProperties":
			i.ExpressCustomSetupProperties, err = unmarshalCustomSetupBaseClassificationArray(val)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &i.LicenseType)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeStatusClassification provides polymorphic access to related types.
// Call the interface's GetIntegrationRuntimeStatus() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *IntegrationRuntimeStatus, *ManagedIntegrationRuntimeStatus, *SelfHostedIntegrationRuntimeStatus
type IntegrationRuntimeStatusClassification interface {
	// GetIntegrationRuntimeStatus returns the IntegrationRuntimeStatus content of the underlying type.
	GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus
}

// IntegrationRuntimeStatus - Integration runtime status.
type IntegrationRuntimeStatus struct {
	// REQUIRED; Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`

	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The workspace name which the integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The state of integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// GetIntegrationRuntimeStatus implements the IntegrationRuntimeStatusClassification interface for type IntegrationRuntimeStatus.
func (i *IntegrationRuntimeStatus) GetIntegrationRuntimeStatus() *IntegrationRuntimeStatus { return i }

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatus.
func (i *IntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i IntegrationRuntimeStatus) marshalInternal(objectMap map[string]interface{}, discValue IntegrationRuntimeType) {
	populate(objectMap, "dataFactoryName", i.DataFactoryName)
	populate(objectMap, "state", i.State)
	i.Type = &discValue
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
}

func (i *IntegrationRuntimeStatus) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFactoryName":
			err = unpopulate(val, &i.DataFactoryName)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &i.State)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeStatusGetOptions contains the optional parameters for the IntegrationRuntimeStatus.Get method.
type IntegrationRuntimeStatusGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimeStatusResponse - Integration runtime status response.
type IntegrationRuntimeStatusResponse struct {
	// REQUIRED; Integration runtime properties.
	Properties IntegrationRuntimeStatusClassification `json:"properties,omitempty"`

	// READ-ONLY; The integration runtime name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeStatusResponse.
func (i IntegrationRuntimeStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeStatusResponse.
func (i *IntegrationRuntimeStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalIntegrationRuntimeStatusClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeVNetProperties - VNet properties for managed integration runtime.
type IntegrationRuntimeVNetProperties struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// Resource IDs of the public IP addresses that this integration runtime will use.
	PublicIPs []*string `json:"publicIPs,omitempty"`

	// The name of the subnet this integration runtime will join.
	Subnet *string `json:"subnet,omitempty"`

	// The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
	SubnetID *string `json:"subnetId,omitempty"`

	// The ID of the VNet that this integration runtime will join.
	VNetID *string `json:"vNetId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeVNetProperties.
func (i IntegrationRuntimeVNetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "publicIPs", i.PublicIPs)
	populate(objectMap, "subnet", i.Subnet)
	populate(objectMap, "subnetId", i.SubnetID)
	populate(objectMap, "vNetId", i.VNetID)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeVNetProperties.
func (i *IntegrationRuntimeVNetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publicIPs":
			err = unpopulate(val, &i.PublicIPs)
			delete(rawMsg, key)
		case "subnet":
			err = unpopulate(val, &i.Subnet)
			delete(rawMsg, key)
		case "subnetId":
			err = unpopulate(val, &i.SubnetID)
			delete(rawMsg, key)
		case "vNetId":
			err = unpopulate(val, &i.VNetID)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimesBeginCreateOptions contains the optional parameters for the IntegrationRuntimes.BeginCreate method.
type IntegrationRuntimesBeginCreateOptions struct {
	// ETag of the integration runtime entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional
	// update.
	IfMatch *string
}

// IntegrationRuntimesBeginDeleteOptions contains the optional parameters for the IntegrationRuntimes.BeginDelete method.
type IntegrationRuntimesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesBeginDisableInteractiveQueryOptions contains the optional parameters for the IntegrationRuntimes.BeginDisableInteractiveQuery method.
type IntegrationRuntimesBeginDisableInteractiveQueryOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesBeginEnableInteractiveQueryOptions contains the optional parameters for the IntegrationRuntimes.BeginEnableInteractiveQuery method.
type IntegrationRuntimesBeginEnableInteractiveQueryOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesBeginStartOptions contains the optional parameters for the IntegrationRuntimes.BeginStart method.
type IntegrationRuntimesBeginStartOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesBeginStopOptions contains the optional parameters for the IntegrationRuntimes.BeginStop method.
type IntegrationRuntimesBeginStopOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesGetOptions contains the optional parameters for the IntegrationRuntimes.Get method.
type IntegrationRuntimesGetOptions struct {
	// ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no
	// content will be returned.
	IfNoneMatch *string
}

// IntegrationRuntimesListByWorkspaceOptions contains the optional parameters for the IntegrationRuntimes.ListByWorkspace method.
type IntegrationRuntimesListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesListOutboundNetworkDependenciesEndpointsOptions contains the optional parameters for the IntegrationRuntimes.ListOutboundNetworkDependenciesEndpoints
// method.
type IntegrationRuntimesListOutboundNetworkDependenciesEndpointsOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesUpdateOptions contains the optional parameters for the IntegrationRuntimes.Update method.
type IntegrationRuntimesUpdateOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesUpgradeOptions contains the optional parameters for the IntegrationRuntimes.Upgrade method.
type IntegrationRuntimesUpgradeOptions struct {
	// placeholder for future optional parameters
}

// IotHubConnectionProperties - Class representing the Kusto Iot hub connection properties.
type IotHubConnectionProperties struct {
	// REQUIRED; The iot hub consumer group.
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// REQUIRED; The resource ID of the Iot hub to be used to create a data connection.
	IotHubResourceID *string `json:"iotHubResourceId,omitempty"`

	// REQUIRED; The name of the share access policy
	SharedAccessPolicyName *string `json:"sharedAccessPolicyName,omitempty"`

	// The data format of the message. Optionally the data format can be added to each message.
	DataFormat *IotHubDataFormat `json:"dataFormat,omitempty"`

	// System properties of the iot hub
	EventSystemProperties []*string `json:"eventSystemProperties,omitempty"`

	// The mapping rule to be used to ingest the data. Optionally the mapping information can be added to each message.
	MappingRuleName *string `json:"mappingRuleName,omitempty"`

	// The table where the data should be ingested. Optionally the table information can be added to each message.
	TableName *string `json:"tableName,omitempty"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IotHubConnectionProperties.
func (i IotHubConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "consumerGroup", i.ConsumerGroup)
	populate(objectMap, "dataFormat", i.DataFormat)
	populate(objectMap, "eventSystemProperties", i.EventSystemProperties)
	populate(objectMap, "iotHubResourceId", i.IotHubResourceID)
	populate(objectMap, "mappingRuleName", i.MappingRuleName)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	populate(objectMap, "sharedAccessPolicyName", i.SharedAccessPolicyName)
	populate(objectMap, "tableName", i.TableName)
	return json.Marshal(objectMap)
}

// IotHubDataConnection - Class representing an iot hub data connection.
type IotHubDataConnection struct {
	DataConnection
	// The Iot Hub data connection properties.
	Properties *IotHubConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IotHubDataConnection.
func (i IotHubDataConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.DataConnection.marshalInternal(objectMap, DataConnectionKindIotHub)
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IotHubDataConnection.
func (i *IotHubDataConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &i.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.DataConnection.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// KekIdentityProperties - Key encryption key properties
type KekIdentityProperties struct {
	// Boolean specifying whether to use system assigned identity or not
	UseSystemAssignedIdentity interface{} `json:"useSystemAssignedIdentity,omitempty"`

	// User assigned identity resource Id
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// Key - A workspace key
type Key struct {
	ProxyResource
	// Keys resource properties
	Properties *KeyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Key.
func (k Key) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", k.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Key.
func (k *Key) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := k.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// KeyInfoListResult - List of keys
type KeyInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of keys
	Value []*Key `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyInfoListResult.
func (k KeyInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", k.NextLink)
	populate(objectMap, "value", k.Value)
	return json.Marshal(objectMap)
}

// KeyProperties - Key properties
type KeyProperties struct {
	// Used to activate the workspace after a customer managed key is provided.
	IsActiveCMK *bool `json:"isActiveCMK,omitempty"`

	// The Key Vault Url of the workspace key.
	KeyVaultURL *string `json:"keyVaultUrl,omitempty"`
}

// KeysCreateOrUpdateOptions contains the optional parameters for the Keys.CreateOrUpdate method.
type KeysCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KeysDeleteOptions contains the optional parameters for the Keys.Delete method.
type KeysDeleteOptions struct {
	// placeholder for future optional parameters
}

// KeysGetOptions contains the optional parameters for the Keys.Get method.
type KeysGetOptions struct {
	// placeholder for future optional parameters
}

// KeysListByWorkspaceOptions contains the optional parameters for the Keys.ListByWorkspace method.
type KeysListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// KustoOperationsListOptions contains the optional parameters for the KustoOperations.List method.
type KustoOperationsListOptions struct {
	// placeholder for future optional parameters
}

// KustoPool - Class representing a Kusto kusto pool.
type KustoPool struct {
	TrackedResource
	// REQUIRED; The SKU of the kusto pool.
	SKU *AzureSKU `json:"sku,omitempty"`

	// The kusto pool properties.
	Properties *KustoPoolProperties `json:"properties,omitempty"`

	// READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KustoPool.
func (k KustoPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "etag", k.Etag)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "sku", k.SKU)
	populate(objectMap, "systemData", k.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KustoPool.
func (k *KustoPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &k.Etag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &k.SKU)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &k.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := k.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// KustoPoolAttachedDatabaseConfigurationsBeginCreateOrUpdateOptions contains the optional parameters for the KustoPoolAttachedDatabaseConfigurations.BeginCreateOrUpdate
// method.
type KustoPoolAttachedDatabaseConfigurationsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolAttachedDatabaseConfigurationsBeginDeleteOptions contains the optional parameters for the KustoPoolAttachedDatabaseConfigurations.BeginDelete
// method.
type KustoPoolAttachedDatabaseConfigurationsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolAttachedDatabaseConfigurationsGetOptions contains the optional parameters for the KustoPoolAttachedDatabaseConfigurations.Get method.
type KustoPoolAttachedDatabaseConfigurationsGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolAttachedDatabaseConfigurationsListByKustoPoolOptions contains the optional parameters for the KustoPoolAttachedDatabaseConfigurations.ListByKustoPool
// method.
type KustoPoolAttachedDatabaseConfigurationsListByKustoPoolOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolCheckNameRequest - The object sent for a kusto pool check name availability request.
type KustoPoolCheckNameRequest struct {
	// REQUIRED; Kusto Pool name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The type of resource, Microsoft.Synapse/workspaces/kustoPools.
	Type *string `json:"type,omitempty"`
}

// KustoPoolChildResourceCheckNameAvailabilityOptions contains the optional parameters for the KustoPoolChildResource.CheckNameAvailability method.
type KustoPoolChildResourceCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsBeginCreateOrUpdateOptions contains the optional parameters for the KustoPoolDataConnections.BeginCreateOrUpdate method.
type KustoPoolDataConnectionsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsBeginDataConnectionValidationOptions contains the optional parameters for the KustoPoolDataConnections.BeginDataConnectionValidation
// method.
type KustoPoolDataConnectionsBeginDataConnectionValidationOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsBeginDeleteOptions contains the optional parameters for the KustoPoolDataConnections.BeginDelete method.
type KustoPoolDataConnectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsBeginUpdateOptions contains the optional parameters for the KustoPoolDataConnections.BeginUpdate method.
type KustoPoolDataConnectionsBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsCheckNameAvailabilityOptions contains the optional parameters for the KustoPoolDataConnections.CheckNameAvailability method.
type KustoPoolDataConnectionsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsGetOptions contains the optional parameters for the KustoPoolDataConnections.Get method.
type KustoPoolDataConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDataConnectionsListByDatabaseOptions contains the optional parameters for the KustoPoolDataConnections.ListByDatabase method.
type KustoPoolDataConnectionsListByDatabaseOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasePrincipalAssignmentsBeginCreateOrUpdateOptions contains the optional parameters for the KustoPoolDatabasePrincipalAssignments.BeginCreateOrUpdate
// method.
type KustoPoolDatabasePrincipalAssignmentsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasePrincipalAssignmentsBeginDeleteOptions contains the optional parameters for the KustoPoolDatabasePrincipalAssignments.BeginDelete method.
type KustoPoolDatabasePrincipalAssignmentsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasePrincipalAssignmentsCheckNameAvailabilityOptions contains the optional parameters for the KustoPoolDatabasePrincipalAssignments.CheckNameAvailability
// method.
type KustoPoolDatabasePrincipalAssignmentsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasePrincipalAssignmentsGetOptions contains the optional parameters for the KustoPoolDatabasePrincipalAssignments.Get method.
type KustoPoolDatabasePrincipalAssignmentsGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasePrincipalAssignmentsListOptions contains the optional parameters for the KustoPoolDatabasePrincipalAssignments.List method.
type KustoPoolDatabasePrincipalAssignmentsListOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasesBeginCreateOrUpdateOptions contains the optional parameters for the KustoPoolDatabases.BeginCreateOrUpdate method.
type KustoPoolDatabasesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasesBeginDeleteOptions contains the optional parameters for the KustoPoolDatabases.BeginDelete method.
type KustoPoolDatabasesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasesBeginUpdateOptions contains the optional parameters for the KustoPoolDatabases.BeginUpdate method.
type KustoPoolDatabasesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasesGetOptions contains the optional parameters for the KustoPoolDatabases.Get method.
type KustoPoolDatabasesGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolDatabasesListByKustoPoolOptions contains the optional parameters for the KustoPoolDatabases.ListByKustoPool method.
type KustoPoolDatabasesListByKustoPoolOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolListResult - The list Kusto pools operation response.
type KustoPoolListResult struct {
	// The list of Kusto pools.
	Value []*KustoPool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KustoPoolListResult.
func (k KustoPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", k.Value)
	return json.Marshal(objectMap)
}

// KustoPoolPrincipalAssignmentsBeginCreateOrUpdateOptions contains the optional parameters for the KustoPoolPrincipalAssignments.BeginCreateOrUpdate method.
type KustoPoolPrincipalAssignmentsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolPrincipalAssignmentsBeginDeleteOptions contains the optional parameters for the KustoPoolPrincipalAssignments.BeginDelete method.
type KustoPoolPrincipalAssignmentsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolPrincipalAssignmentsCheckNameAvailabilityOptions contains the optional parameters for the KustoPoolPrincipalAssignments.CheckNameAvailability
// method.
type KustoPoolPrincipalAssignmentsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolPrincipalAssignmentsGetOptions contains the optional parameters for the KustoPoolPrincipalAssignments.Get method.
type KustoPoolPrincipalAssignmentsGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolPrincipalAssignmentsListOptions contains the optional parameters for the KustoPoolPrincipalAssignments.List method.
type KustoPoolPrincipalAssignmentsListOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolProperties - Class representing the Kusto pool properties.
type KustoPoolProperties struct {
	// A boolean value that indicates if the purge operations are enabled.
	EnablePurge *bool `json:"enablePurge,omitempty"`

	// A boolean value that indicates if the streaming ingest is enabled.
	EnableStreamingIngest *bool `json:"enableStreamingIngest,omitempty"`

	// Optimized auto scale definition.
	OptimizedAutoscale *OptimizedAutoscale `json:"optimizedAutoscale,omitempty"`

	// The workspace unique identifier.
	WorkspaceUID *string `json:"workspaceUID,omitempty"`

	// READ-ONLY; The Kusto Pool data ingestion URI.
	DataIngestionURI *string `json:"dataIngestionUri,omitempty" azure:"ro"`

	// READ-ONLY; List of the Kusto Pool's language extensions.
	LanguageExtensions *LanguageExtensionsList `json:"languageExtensions,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The state of the resource.
	State *State `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; The reason for the Kusto Pool's current state.
	StateReason *string `json:"stateReason,omitempty" azure:"ro"`

	// READ-ONLY; The Kusto Pool URI.
	URI *string `json:"uri,omitempty" azure:"ro"`
}

// KustoPoolUpdate - Class representing an update to a Kusto kusto pool.
type KustoPoolUpdate struct {
	Resource
	// The kusto pool properties.
	Properties *KustoPoolProperties `json:"properties,omitempty"`

	// The SKU of the kusto pool.
	SKU *AzureSKU `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KustoPoolUpdate.
func (k KustoPoolUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	k.Resource.marshalInternal(objectMap)
	populate(objectMap, "properties", k.Properties)
	populate(objectMap, "sku", k.SKU)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KustoPoolUpdate.
func (k *KustoPoolUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &k.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &k.SKU)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &k.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := k.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// KustoPoolsBeginAddLanguageExtensionsOptions contains the optional parameters for the KustoPools.BeginAddLanguageExtensions method.
type KustoPoolsBeginAddLanguageExtensionsOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginCreateOrUpdateOptions contains the optional parameters for the KustoPools.BeginCreateOrUpdate method.
type KustoPoolsBeginCreateOrUpdateOptions struct {
	// The ETag of the Kusto Pool. Omit this value to always overwrite the current Kusto Pool. Specify the last-seen ETag value to prevent accidentally overwriting
	// concurrent changes.
	IfMatch *string
	// Set to '*' to allow a new Kusto Pool to be created, but to prevent updating an existing Kusto Pool. Other values will result in a 412 Pre-condition Failed
	// response.
	IfNoneMatch *string
}

// KustoPoolsBeginDeleteOptions contains the optional parameters for the KustoPools.BeginDelete method.
type KustoPoolsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginDetachFollowerDatabasesOptions contains the optional parameters for the KustoPools.BeginDetachFollowerDatabases method.
type KustoPoolsBeginDetachFollowerDatabasesOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginRemoveLanguageExtensionsOptions contains the optional parameters for the KustoPools.BeginRemoveLanguageExtensions method.
type KustoPoolsBeginRemoveLanguageExtensionsOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginStartOptions contains the optional parameters for the KustoPools.BeginStart method.
type KustoPoolsBeginStartOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginStopOptions contains the optional parameters for the KustoPools.BeginStop method.
type KustoPoolsBeginStopOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsBeginUpdateOptions contains the optional parameters for the KustoPools.BeginUpdate method.
type KustoPoolsBeginUpdateOptions struct {
	// The ETag of the Kusto Pool. Omit this value to always overwrite the current Kusto Pool. Specify the last-seen ETag value to prevent accidentally overwriting
	// concurrent changes.
	IfMatch *string
}

// KustoPoolsCheckNameAvailabilityOptions contains the optional parameters for the KustoPools.CheckNameAvailability method.
type KustoPoolsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsGetOptions contains the optional parameters for the KustoPools.Get method.
type KustoPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsListByWorkspaceOptions contains the optional parameters for the KustoPools.ListByWorkspace method.
type KustoPoolsListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsListFollowerDatabasesOptions contains the optional parameters for the KustoPools.ListFollowerDatabases method.
type KustoPoolsListFollowerDatabasesOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsListLanguageExtensionsOptions contains the optional parameters for the KustoPools.ListLanguageExtensions method.
type KustoPoolsListLanguageExtensionsOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsListSKUsByResourceOptions contains the optional parameters for the KustoPools.ListSKUsByResource method.
type KustoPoolsListSKUsByResourceOptions struct {
	// placeholder for future optional parameters
}

// KustoPoolsListSKUsOptions contains the optional parameters for the KustoPools.ListSKUs method.
type KustoPoolsListSKUsOptions struct {
	// placeholder for future optional parameters
}

// LanguageExtension - The language extension object.
type LanguageExtension struct {
	// The language extension name.
	LanguageExtensionName *LanguageExtensionName `json:"languageExtensionName,omitempty"`
}

// LanguageExtensionsList - The list of language extension objects.
type LanguageExtensionsList struct {
	// The list of language extensions.
	Value []*LanguageExtension `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LanguageExtensionsList.
func (l LanguageExtensionsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LibrariesListByWorkspaceOptions contains the optional parameters for the Libraries.ListByWorkspace method.
type LibrariesListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// LibraryGetOptions contains the optional parameters for the Library.Get method.
type LibraryGetOptions struct {
	// placeholder for future optional parameters
}

// LibraryInfo - Library/package information of a Big Data pool powered by Apache Spark
type LibraryInfo struct {
	// Storage blob container name.
	ContainerName *string `json:"containerName,omitempty"`

	// Name of the library.
	Name *string `json:"name,omitempty"`

	// Storage blob path of library.
	Path *string `json:"path,omitempty"`

	// Type of the library.
	Type *string `json:"type,omitempty"`

	// The last update time of the library.
	UploadedTimestamp *time.Time `json:"uploadedTimestamp,omitempty"`

	// READ-ONLY; Creator Id of the library/package.
	CreatorID *string `json:"creatorId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning status of the library/package.
	ProvisioningStatus *string `json:"provisioningStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryInfo.
func (l LibraryInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerName", l.ContainerName)
	populate(objectMap, "creatorId", l.CreatorID)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "path", l.Path)
	populate(objectMap, "provisioningStatus", l.ProvisioningStatus)
	populate(objectMap, "type", l.Type)
	populateTimeRFC3339(objectMap, "uploadedTimestamp", l.UploadedTimestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LibraryInfo.
func (l *LibraryInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerName":
			err = unpopulate(val, &l.ContainerName)
			delete(rawMsg, key)
		case "creatorId":
			err = unpopulate(val, &l.CreatorID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &l.Path)
			delete(rawMsg, key)
		case "provisioningStatus":
			err = unpopulate(val, &l.ProvisioningStatus)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &l.Type)
			delete(rawMsg, key)
		case "uploadedTimestamp":
			err = unpopulateTimeRFC3339(val, &l.UploadedTimestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LibraryListResponse - A list of Library resources.
type LibraryListResponse struct {
	// REQUIRED; List of Library.
	Value []*LibraryResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryListResponse.
func (l LibraryListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// LibraryRequirements - Library requirements for a Big Data pool powered by Apache Spark
type LibraryRequirements struct {
	// The library requirements.
	Content *string `json:"content,omitempty"`

	// The filename of the library requirements file.
	Filename *string `json:"filename,omitempty"`

	// READ-ONLY; The last update time of the library requirements file.
	Time *time.Time `json:"time,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryRequirements.
func (l LibraryRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", l.Content)
	populate(objectMap, "filename", l.Filename)
	populateTimeRFC3339(objectMap, "time", l.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LibraryRequirements.
func (l *LibraryRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, &l.Content)
			delete(rawMsg, key)
		case "filename":
			err = unpopulate(val, &l.Filename)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &l.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LibraryResource - Library response details
type LibraryResource struct {
	SubResource
	// REQUIRED; Library/package properties.
	Properties *LibraryInfo `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryResource.
func (l LibraryResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.SubResource.marshalInternal(objectMap)
	populate(objectMap, "properties", l.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LibraryResource.
func (l *LibraryResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &l.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.SubResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LicensedComponentSetupTypeProperties - Installation of licensed component setup type properties.
type LicensedComponentSetupTypeProperties struct {
	// REQUIRED; The name of the 3rd party component.
	ComponentName *string `json:"componentName,omitempty"`

	// The license key to activate the component.
	LicenseKey SecretBaseClassification `json:"licenseKey,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LicensedComponentSetupTypeProperties.
func (l LicensedComponentSetupTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "componentName", l.ComponentName)
	populate(objectMap, "licenseKey", l.LicenseKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LicensedComponentSetupTypeProperties.
func (l *LicensedComponentSetupTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "componentName":
			err = unpopulate(val, &l.ComponentName)
			delete(rawMsg, key)
		case "licenseKey":
			l.LicenseKey, err = unmarshalSecretBaseClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntime - The linked integration runtime information.
type LinkedIntegrationRuntime struct {
	// READ-ONLY; The creating time of the linked integration runtime.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; The location of the workspace for which the linked integration runtime belong to.
	DataFactoryLocation *string `json:"dataFactoryLocation,omitempty" azure:"ro"`

	// READ-ONLY; The name of the workspace for which the linked integration runtime belong to.
	DataFactoryName *string `json:"dataFactoryName,omitempty" azure:"ro"`

	// READ-ONLY; The name of the linked integration runtime.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The subscription ID for which the linked integration runtime belong to.
	SubscriptionID *string `json:"subscriptionId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntime.
func (l LinkedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createTime", l.CreateTime)
	populate(objectMap, "dataFactoryLocation", l.DataFactoryLocation)
	populate(objectMap, "dataFactoryName", l.DataFactoryName)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "subscriptionId", l.SubscriptionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntime.
func (l *LinkedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateTimeRFC3339(val, &l.CreateTime)
			delete(rawMsg, key)
		case "dataFactoryLocation":
			err = unpopulate(val, &l.DataFactoryLocation)
			delete(rawMsg, key)
		case "dataFactoryName":
			err = unpopulate(val, &l.DataFactoryName)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &l.Name)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, &l.SubscriptionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedIntegrationRuntimeKeyAuthorization - The key authorization type integration runtime.
type LinkedIntegrationRuntimeKeyAuthorization struct {
	LinkedIntegrationRuntimeType
	// REQUIRED; The key used for authorization.
	Key *SecureString `json:"key,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l LinkedIntegrationRuntimeKeyAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.LinkedIntegrationRuntimeType.marshalInternal(objectMap, "Key")
	populate(objectMap, "key", l.Key)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l *LinkedIntegrationRuntimeKeyAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			err = unpopulate(val, &l.Key)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.LinkedIntegrationRuntimeType.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LinkedIntegrationRuntimeRbacAuthorization - The role based access control (RBAC) authorization type integration runtime.
type LinkedIntegrationRuntimeRbacAuthorization struct {
	LinkedIntegrationRuntimeType
	// REQUIRED; The resource identifier of the integration runtime to be shared.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l LinkedIntegrationRuntimeRbacAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	l.LinkedIntegrationRuntimeType.marshalInternal(objectMap, "RBAC")
	populate(objectMap, "resourceId", l.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l *LinkedIntegrationRuntimeRbacAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			err = unpopulate(val, &l.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := l.LinkedIntegrationRuntimeType.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// LinkedIntegrationRuntimeTypeClassification provides polymorphic access to related types.
// Call the interface's GetLinkedIntegrationRuntimeType() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LinkedIntegrationRuntimeKeyAuthorization, *LinkedIntegrationRuntimeRbacAuthorization, *LinkedIntegrationRuntimeType
type LinkedIntegrationRuntimeTypeClassification interface {
	// GetLinkedIntegrationRuntimeType returns the LinkedIntegrationRuntimeType content of the underlying type.
	GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType
}

// LinkedIntegrationRuntimeType - The base definition of a linked integration runtime.
type LinkedIntegrationRuntimeType struct {
	// REQUIRED; The authorization type for integration runtime sharing.
	AuthorizationType *string `json:"authorizationType,omitempty"`
}

// GetLinkedIntegrationRuntimeType implements the LinkedIntegrationRuntimeTypeClassification interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType {
	return l
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return l.unmarshalInternal(rawMsg)
}

func (l LinkedIntegrationRuntimeType) marshalInternal(objectMap map[string]interface{}, discValue string) {
	l.AuthorizationType = &discValue
	objectMap["authorizationType"] = l.AuthorizationType
}

func (l *LinkedIntegrationRuntimeType) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			err = unpopulate(val, &l.AuthorizationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ListResourceSKUsResult - List of available SKUs for a Kusto Pool.
type ListResourceSKUsResult struct {
	// The collection of available SKUs for an existing resource.
	Value []*AzureResourceSKU `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListResourceSKUsResult.
func (l ListResourceSKUsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// ListSQLPoolSecurityAlertPolicies - A list of SQL pool security alert policies.
type ListSQLPoolSecurityAlertPolicies struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolSecurityAlertPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ListSQLPoolSecurityAlertPolicies.
func (l ListSQLPoolSecurityAlertPolicies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// MaintenanceWindowOptions - Maintenance window options.
type MaintenanceWindowOptions struct {
	ProxyResource
	// Resource properties.
	Properties *MaintenanceWindowOptionsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindowOptions.
func (m MaintenanceWindowOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceWindowOptions.
func (m *MaintenanceWindowOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MaintenanceWindowOptionsProperties - Maintenance window options properties.
type MaintenanceWindowOptionsProperties struct {
	// Whether we allow multiple maintenance windows per cycle.
	AllowMultipleMaintenanceWindowsPerCycle *bool `json:"allowMultipleMaintenanceWindowsPerCycle,omitempty"`

	// Default duration for maintenance window.
	DefaultDurationInMinutes *int32 `json:"defaultDurationInMinutes,omitempty"`

	// Whether maintenance windows are enabled for the database.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Available maintenance cycles e.g. {Saturday, 0, 4860}, {Wednesday, 0, 2460}.
	MaintenanceWindowCycles []*MaintenanceWindowTimeRange `json:"maintenanceWindowCycles,omitempty"`

	// Minimum number of maintenance windows cycles to be set on the database.
	MinCycles *int32 `json:"minCycles,omitempty"`

	// Minimum duration of maintenance window.
	MinDurationInMinutes *int32 `json:"minDurationInMinutes,omitempty"`

	// Time granularity in minutes for maintenance windows.
	TimeGranularityInMinutes *int32 `json:"timeGranularityInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindowOptionsProperties.
func (m MaintenanceWindowOptionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowMultipleMaintenanceWindowsPerCycle", m.AllowMultipleMaintenanceWindowsPerCycle)
	populate(objectMap, "defaultDurationInMinutes", m.DefaultDurationInMinutes)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "maintenanceWindowCycles", m.MaintenanceWindowCycles)
	populate(objectMap, "minCycles", m.MinCycles)
	populate(objectMap, "minDurationInMinutes", m.MinDurationInMinutes)
	populate(objectMap, "timeGranularityInMinutes", m.TimeGranularityInMinutes)
	return json.Marshal(objectMap)
}

// MaintenanceWindowTimeRange - Maintenance window time range.
type MaintenanceWindowTimeRange struct {
	// Day of maintenance window.
	DayOfWeek *DayOfWeek `json:"dayOfWeek,omitempty"`

	// Duration of maintenance window in minutes.
	Duration *string `json:"duration,omitempty"`

	// Start time minutes offset from 12am.
	StartTime *string `json:"startTime,omitempty"`
}

// MaintenanceWindows - Maintenance windows.
type MaintenanceWindows struct {
	ProxyResource
	// Resource properties.
	Properties *MaintenanceWindowsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindows.
func (m MaintenanceWindows) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceWindows.
func (m *MaintenanceWindows) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MaintenanceWindowsProperties - Maintenance windows resource properties.
type MaintenanceWindowsProperties struct {
	TimeRanges []*MaintenanceWindowTimeRange `json:"timeRanges,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceWindowsProperties.
func (m MaintenanceWindowsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "timeRanges", m.TimeRanges)
	return json.Marshal(objectMap)
}

// ManagedIdentity - The workspace managed identity
type ManagedIdentity struct {
	// The type of managed identity for the workspace
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The user assigned managed identities.
	UserAssignedIdentities map[string]*UserAssignedManagedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal ID of the workspace managed identity
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of the workspace managed identity
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentity.
func (m ManagedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// ManagedIdentitySQLControlSettingsModel - Sql Control Settings for workspace managed identity
type ManagedIdentitySQLControlSettingsModel struct {
	ProxyResource
	// Sql Control Settings for workspace managed identity
	Properties *ManagedIdentitySQLControlSettingsModelProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIdentitySQLControlSettingsModel.
func (m ManagedIdentitySQLControlSettingsModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIdentitySQLControlSettingsModel.
func (m *ManagedIdentitySQLControlSettingsModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ManagedIdentitySQLControlSettingsModelProperties - Sql Control Settings for workspace managed identity
type ManagedIdentitySQLControlSettingsModelProperties struct {
	// Grant sql control to managed identity
	GrantSQLControlToManagedIdentity *ManagedIdentitySQLControlSettingsModelPropertiesGrantSQLControlToManagedIdentity `json:"grantSqlControlToManagedIdentity,omitempty"`
}

// ManagedIdentitySQLControlSettingsModelPropertiesGrantSQLControlToManagedIdentity - Grant sql control to managed identity
type ManagedIdentitySQLControlSettingsModelPropertiesGrantSQLControlToManagedIdentity struct {
	// Desired state
	DesiredState *ManagedIdentitySQLControlSettingsModelPropertiesGrantSQLControlToManagedIdentityDesiredState `json:"desiredState,omitempty"`

	// READ-ONLY; Actual state
	ActualState *ManagedIdentitySQLControlSettingsModelPropertiesGrantSQLControlToManagedIdentityActualState `json:"actualState,omitempty" azure:"ro"`
}

// ManagedIntegrationRuntime - Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
type ManagedIntegrationRuntime struct {
	IntegrationRuntime
	// REQUIRED; Managed integration runtime properties.
	TypeProperties *ManagedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`

	// READ-ONLY; Integration runtime state, only valid for managed dedicated integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntime.
func (m ManagedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.IntegrationRuntime.marshalInternal(objectMap, IntegrationRuntimeTypeManaged)
	populate(objectMap, "state", m.State)
	populate(objectMap, "typeProperties", m.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntime.
func (m *ManagedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.IntegrationRuntime.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ManagedIntegrationRuntimeError - Error definition for managed integration runtime.
type ManagedIntegrationRuntimeError struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Managed integration runtime error parameters.
	Parameters []*string `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The time when the error occurred.
	Time *time.Time `json:"time,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeError.
func (m ManagedIntegrationRuntimeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", m.Code)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "parameters", m.Parameters)
	populateTimeRFC3339(objectMap, "time", m.Time)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeError.
func (m *ManagedIntegrationRuntimeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &m.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &m.Time)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeNode - Properties of integration runtime node.
type ManagedIntegrationRuntimeNode struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// The errors that occurred on this integration runtime node.
	Errors []*ManagedIntegrationRuntimeError `json:"errors,omitempty"`

	// READ-ONLY; The managed integration runtime node id.
	NodeID *string `json:"nodeId,omitempty" azure:"ro"`

	// READ-ONLY; The managed integration runtime node status.
	Status *ManagedIntegrationRuntimeNodeStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeNode.
func (m ManagedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "nodeId", m.NodeID)
	populate(objectMap, "status", m.Status)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeNode.
func (m *ManagedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "nodeId":
			err = unpopulate(val, &m.NodeID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeOperationResult - Properties of managed integration runtime operation result.
type ManagedIntegrationRuntimeOperationResult struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The activity id for the operation request.
	ActivityID *string `json:"activityId,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	ErrorCode *string `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; Managed integration runtime error parameters.
	Parameters []*string `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; The operation result.
	Result *string `json:"result,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the operation.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The operation type. Could be start or stop.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m ManagedIntegrationRuntimeOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activityId", m.ActivityID)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "parameters", m.Parameters)
	populate(objectMap, "result", m.Result)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "type", m.Type)
	if m.AdditionalProperties != nil {
		for key, val := range m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeOperationResult.
func (m *ManagedIntegrationRuntimeOperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, &m.ActivityID)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, &m.ErrorCode)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &m.Parameters)
			delete(rawMsg, key)
		case "result":
			err = unpopulate(val, &m.Result)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &m.StartTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				m.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeStatus - Managed integration runtime status.
type ManagedIntegrationRuntimeStatus struct {
	IntegrationRuntimeStatus
	// REQUIRED; Managed integration runtime status type properties.
	TypeProperties *ManagedIntegrationRuntimeStatusTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatus.
func (m ManagedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.IntegrationRuntimeStatus.marshalInternal(objectMap, IntegrationRuntimeTypeManaged)
	populate(objectMap, "typeProperties", m.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatus.
func (m *ManagedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &m.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.IntegrationRuntimeStatus.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ManagedIntegrationRuntimeStatusTypeProperties - Managed integration runtime status type properties.
type ManagedIntegrationRuntimeStatusTypeProperties struct {
	// READ-ONLY; The time at which the integration runtime was created, in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; The last operation result that occurred on this integration runtime.
	LastOperation *ManagedIntegrationRuntimeOperationResult `json:"lastOperation,omitempty" azure:"ro"`

	// READ-ONLY; The list of nodes for managed integration runtime.
	Nodes []*ManagedIntegrationRuntimeNode `json:"nodes,omitempty" azure:"ro"`

	// READ-ONLY; The errors that occurred on this integration runtime.
	OtherErrors []*ManagedIntegrationRuntimeError `json:"otherErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m ManagedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createTime", m.CreateTime)
	populate(objectMap, "lastOperation", m.LastOperation)
	populate(objectMap, "nodes", m.Nodes)
	populate(objectMap, "otherErrors", m.OtherErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntimeStatusTypeProperties.
func (m *ManagedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createTime":
			err = unpopulateTimeRFC3339(val, &m.CreateTime)
			delete(rawMsg, key)
		case "lastOperation":
			err = unpopulate(val, &m.LastOperation)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, &m.Nodes)
			delete(rawMsg, key)
		case "otherErrors":
			err = unpopulate(val, &m.OtherErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedIntegrationRuntimeTypeProperties - Managed integration runtime type properties.
type ManagedIntegrationRuntimeTypeProperties struct {
	// The compute resource for managed integration runtime.
	ComputeProperties *IntegrationRuntimeComputeProperties `json:"computeProperties,omitempty"`

	// SSIS properties for managed integration runtime.
	SsisProperties *IntegrationRuntimeSsisProperties `json:"ssisProperties,omitempty"`
}

// ManagedVirtualNetworkSettings - Managed Virtual Network Settings
type ManagedVirtualNetworkSettings struct {
	// Allowed Aad Tenant Ids For Linking
	AllowedAADTenantIDsForLinking []*string `json:"allowedAadTenantIdsForLinking,omitempty"`

	// Linked Access Check On Target Resource
	LinkedAccessCheckOnTargetResource *bool `json:"linkedAccessCheckOnTargetResource,omitempty"`

	// Prevent Data Exfiltration
	PreventDataExfiltration *bool `json:"preventDataExfiltration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedVirtualNetworkSettings.
func (m ManagedVirtualNetworkSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedAadTenantIdsForLinking", m.AllowedAADTenantIDsForLinking)
	populate(objectMap, "linkedAccessCheckOnTargetResource", m.LinkedAccessCheckOnTargetResource)
	populate(objectMap, "preventDataExfiltration", m.PreventDataExfiltration)
	return json.Marshal(objectMap)
}

// MetadataSyncConfig - Configuration for metadata sync
type MetadataSyncConfig struct {
	ProxyResource
	// Metadata Sync Config properties
	Properties *MetadataSyncConfigProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetadataSyncConfig.
func (m MetadataSyncConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataSyncConfig.
func (m *MetadataSyncConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MetadataSyncConfigProperties - Metadata Sync Config properties
type MetadataSyncConfigProperties struct {
	// Indicates whether the metadata sync is enabled or disabled
	Enabled *bool `json:"enabled,omitempty"`

	// The Sync Interval in minutes.
	SyncIntervalInMinutes *int32 `json:"syncIntervalInMinutes,omitempty"`
}

// Operation - A REST API operation
type Operation struct {
	// The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// This is of the format {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`

	// The intended executor of the operation.
	Origin *string `json:"origin,omitempty"`

	// Any object
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// OperationDisplay - The object that describes the operation.
type OperationDisplay struct {
	// The friendly name of the operation.
	Description *string `json:"description,omitempty"`

	// For example: read, write, delete.
	Operation *string `json:"operation,omitempty"`

	// Friendly name of the resource provider.
	Provider *string `json:"provider,omitempty"`

	// The resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationListResult - Result of the request to list REST API operations. It contains a list of operations and a URL nextLink to get the next set of results.
type OperationListResult struct {
	// The list of operations supported by the resource provider.
	Value []*Operation `json:"value,omitempty"`

	// READ-ONLY; The URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationMetaLogSpecification - What is this?
type OperationMetaLogSpecification struct {
	// Time range the log covers
	BlobDuration *string `json:"blobDuration,omitempty"`

	// Log display name
	DisplayName *string `json:"displayName,omitempty"`

	// Log unique name
	Name *string `json:"name,omitempty"`
}

// OperationMetaMetricDimensionSpecification - What is this?
type OperationMetaMetricDimensionSpecification struct {
	// Dimension display name
	DisplayName *string `json:"displayName,omitempty"`

	// Dimension unique name
	Name *string `json:"name,omitempty"`

	// Whether this metric should be exported for Shoebox
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty"`
}

// OperationMetaMetricSpecification - What is this?
type OperationMetaMetricSpecification struct {
	// Metric aggregation type
	AggregationType *string `json:"aggregationType,omitempty"`

	// Metric dimensions
	Dimensions []*OperationMetaMetricDimensionSpecification `json:"dimensions,omitempty"`

	// Metric description
	DisplayDescription *string `json:"displayDescription,omitempty"`

	// Metric display name
	DisplayName *string `json:"displayName,omitempty"`

	// Whether the regional MDM account is enabled
	EnableRegionalMdmAccount *bool `json:"enableRegionalMdmAccount,omitempty"`

	// Metric filter
	MetricFilterPattern *string `json:"metricFilterPattern,omitempty"`

	// Metric unique name
	Name *string `json:"name,omitempty"`

	// The source MDM account
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty"`

	// The source MDM namespace
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty"`

	// Whether the metric supports instance-level aggregation
	SupportsInstanceLevelAggregation *bool `json:"supportsInstanceLevelAggregation,omitempty"`

	// Metric units
	Unit *string `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetaMetricSpecification.
func (o OperationMetaMetricSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationType", o.AggregationType)
	populate(objectMap, "dimensions", o.Dimensions)
	populate(objectMap, "displayDescription", o.DisplayDescription)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "enableRegionalMdmAccount", o.EnableRegionalMdmAccount)
	populate(objectMap, "metricFilterPattern", o.MetricFilterPattern)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "sourceMdmAccount", o.SourceMdmAccount)
	populate(objectMap, "sourceMdmNamespace", o.SourceMdmNamespace)
	populate(objectMap, "supportsInstanceLevelAggregation", o.SupportsInstanceLevelAggregation)
	populate(objectMap, "unit", o.Unit)
	return json.Marshal(objectMap)
}

// OperationMetaPropertyInfo - What is this?
type OperationMetaPropertyInfo struct {
	// Operation service specification
	ServiceSpecification *OperationMetaServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationMetaServiceSpecification - What is this?
type OperationMetaServiceSpecification struct {
	// Service log specifications
	LogSpecifications []*OperationMetaLogSpecification `json:"logSpecifications,omitempty"`

	// Service metric specifications
	MetricSpecifications []*OperationMetaMetricSpecification `json:"metricSpecifications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationMetaServiceSpecification.
func (o OperationMetaServiceSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "logSpecifications", o.LogSpecifications)
	populate(objectMap, "metricSpecifications", o.MetricSpecifications)
	return json.Marshal(objectMap)
}

// OperationResource - An operation
type OperationResource struct {
	// Operation start time
	EndTime *time.Time `json:"endTime,omitempty"`

	// Errors from the operation
	Error *ErrorDetail `json:"error,omitempty"`

	// Operation ID
	ID *string `json:"id,omitempty"`

	// Operation name
	Name *string `json:"name,omitempty"`

	// Completion percentage of the operation
	PercentComplete *float32 `json:"percentComplete,omitempty"`

	// Operation properties
	Properties map[string]interface{} `json:"properties,omitempty"`

	// Operation start time
	StartTime *time.Time `json:"startTime,omitempty"`

	// Operation status
	Status *OperationStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationResource.
func (o OperationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", o.EndTime)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "percentComplete", o.PercentComplete)
	populate(objectMap, "properties", o.Properties)
	populateTimeRFC3339(objectMap, "startTime", o.StartTime)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationResource.
func (o *OperationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &o.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &o.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &o.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &o.Name)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, &o.PercentComplete)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &o.Properties)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &o.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OperationsCheckNameAvailabilityOptions contains the optional parameters for the Operations.CheckNameAvailability method.
type OperationsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// OperationsGetAzureAsyncHeaderResultOptions contains the optional parameters for the Operations.GetAzureAsyncHeaderResult method.
type OperationsGetAzureAsyncHeaderResultOptions struct {
	// placeholder for future optional parameters
}

// OperationsGetLocationHeaderResultOptions contains the optional parameters for the Operations.GetLocationHeaderResult method.
type OperationsGetLocationHeaderResultOptions struct {
	// placeholder for future optional parameters
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OptimizedAutoscale - A class that contains the optimized auto scale definition.
type OptimizedAutoscale struct {
	// REQUIRED; A boolean value that indicate if the optimized autoscale feature is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// REQUIRED; Maximum allowed instances count.
	Maximum *int32 `json:"maximum,omitempty"`

	// REQUIRED; Minimum allowed instances count.
	Minimum *int32 `json:"minimum,omitempty"`

	// REQUIRED; The version of the template defined, for instance 1.
	Version *int32 `json:"version,omitempty"`
}

// PrivateEndpoint - Private endpoint details
type PrivateEndpoint struct {
	// READ-ONLY; Resource id of the private endpoint.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - A private endpoint connection
type PrivateEndpointConnection struct {
	ProxyResource
	// Private endpoint connection properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnection.
func (p *PrivateEndpointConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type PrivateEndpointConnectionForPrivateLinkHub struct {
	PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
}

// PrivateEndpointConnectionForPrivateLinkHubBasic - Private Endpoint Connection For Private Link Hub - Basic
type PrivateEndpointConnectionForPrivateLinkHubBasic struct {
	// Properties of private endpoint connection for private link hub
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

type PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated struct {
	ID *string `json:"id,omitempty"`

	// Properties of a private endpoint connection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

type PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse struct {
	NextLink *string                                       `json:"nextLink,omitempty"`
	Value    []*PrivateEndpointConnectionForPrivateLinkHub `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse.
func (p PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionList - A list of private endpoint connections
type PrivateEndpointConnectionList struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*PrivateEndpointConnection `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionList.
func (p PrivateEndpointConnectionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of a private endpoint connection.
type PrivateEndpointConnectionProperties struct {
	// The private endpoint which the connection belongs to.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Connection state of the private endpoint connection.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY; Provisioning state of the private endpoint connection.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionsBeginCreateOptions contains the optional parameters for the PrivateEndpointConnections.BeginCreate method.
type PrivateEndpointConnectionsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnections.BeginDelete method.
type PrivateEndpointConnectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsPrivateLinkHubGetOptions contains the optional parameters for the PrivateEndpointConnectionsPrivateLinkHub.Get method.
type PrivateEndpointConnectionsPrivateLinkHubGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsPrivateLinkHubListOptions contains the optional parameters for the PrivateEndpointConnectionsPrivateLinkHub.List method.
type PrivateEndpointConnectionsPrivateLinkHubListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHub - A privateLinkHub
type PrivateLinkHub struct {
	TrackedResource
	// PrivateLinkHub resource properties
	Properties *PrivateLinkHubProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkHub.
func (p PrivateLinkHub) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkHub.
func (p *PrivateLinkHub) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PrivateLinkHubInfoListResult - List of privateLinkHubs
type PrivateLinkHubInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of privateLinkHubs
	Value []*PrivateLinkHub `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkHubInfoListResult.
func (p PrivateLinkHubInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkHubPatchInfo - PrivateLinkHub patch details
type PrivateLinkHubPatchInfo struct {
	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkHubPatchInfo.
func (p PrivateLinkHubPatchInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// PrivateLinkHubPrivateLinkResourcesGetOptions contains the optional parameters for the PrivateLinkHubPrivateLinkResources.Get method.
type PrivateLinkHubPrivateLinkResourcesGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubPrivateLinkResourcesListOptions contains the optional parameters for the PrivateLinkHubPrivateLinkResources.List method.
type PrivateLinkHubPrivateLinkResourcesListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubProperties - PrivateLinkHub properties
type PrivateLinkHubProperties struct {
	// PrivateLinkHub provisioning state
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// READ-ONLY; List of private endpoint connections
	PrivateEndpointConnections []*PrivateEndpointConnectionForPrivateLinkHubBasic `json:"privateEndpointConnections,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkHubProperties.
func (p PrivateLinkHubProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "privateEndpointConnections", p.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	return json.Marshal(objectMap)
}

// PrivateLinkHubsBeginDeleteOptions contains the optional parameters for the PrivateLinkHubs.BeginDelete method.
type PrivateLinkHubsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubsCreateOrUpdateOptions contains the optional parameters for the PrivateLinkHubs.CreateOrUpdate method.
type PrivateLinkHubsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubsGetOptions contains the optional parameters for the PrivateLinkHubs.Get method.
type PrivateLinkHubsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubsListByResourceGroupOptions contains the optional parameters for the PrivateLinkHubs.ListByResourceGroup method.
type PrivateLinkHubsListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubsListOptions contains the optional parameters for the PrivateLinkHubs.List method.
type PrivateLinkHubsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkHubsUpdateOptions contains the optional parameters for the PrivateLinkHubs.Update method.
type PrivateLinkHubsUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	ProxyResource
	// READ-ONLY; The private link resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResource.
func (p PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateLinkResource.
func (p *PrivateLinkResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*PrivateLinkResource `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`

	// READ-ONLY; Required DNS zone names of the the private link resource.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesGetOptions contains the optional parameters for the PrivateLinkResources.Get method.
type PrivateLinkResourcesGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesListOptions contains the optional parameters for the PrivateLinkResources.List method.
type PrivateLinkResourcesListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkServiceConnectionState - Connection state details of the private endpoint
type PrivateLinkServiceConnectionState struct {
	// The private link service connection description.
	Description *string `json:"description,omitempty"`

	// The private link service connection status.
	Status *string `json:"status,omitempty"`

	// READ-ONLY; The actions required for private link service connection.
	ActionsRequired *string `json:"actionsRequired,omitempty" azure:"ro"`
}

// ProxyResource - The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location
type ProxyResource struct {
	Resource
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	p.Resource.marshalInternal(objectMap)
}

func (p *ProxyResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// PurviewConfiguration - Purview Configuration
type PurviewConfiguration struct {
	// Purview Resource ID
	PurviewResourceID *string `json:"purviewResourceId,omitempty"`
}

// QueryInterval - A database query.
type QueryInterval struct {
	// READ-ONLY; The number of times the query was executed during this interval.
	ExecutionCount *int32 `json:"executionCount,omitempty" azure:"ro"`

	// READ-ONLY; The start time of the measurement interval (ISO8601 format).
	IntervalStartTime *time.Time `json:"intervalStartTime,omitempty" azure:"ro"`

	// READ-ONLY; The list of query metrics during this interval.
	Metrics []*QueryMetric `json:"metrics,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryInterval.
func (q QueryInterval) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "executionCount", q.ExecutionCount)
	populateTimeRFC3339(objectMap, "intervalStartTime", q.IntervalStartTime)
	populate(objectMap, "metrics", q.Metrics)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueryInterval.
func (q *QueryInterval) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionCount":
			err = unpopulate(val, &q.ExecutionCount)
			delete(rawMsg, key)
		case "intervalStartTime":
			err = unpopulateTimeRFC3339(val, &q.IntervalStartTime)
			delete(rawMsg, key)
		case "metrics":
			err = unpopulate(val, &q.Metrics)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QueryMetric - A database query.
type QueryMetric struct {
	// READ-ONLY; The name of the metric for display in user interface
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The name of the metric
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The unit of measurement
	Unit *QueryMetricUnit `json:"unit,omitempty" azure:"ro"`

	// READ-ONLY; The measured value
	Value *float64 `json:"value,omitempty" azure:"ro"`
}

// QueryStatistic - A database query.
type QueryStatistic struct {
	// READ-ONLY; The list of query intervals.
	Intervals []*QueryInterval `json:"intervals,omitempty" azure:"ro"`

	// READ-ONLY; The id of the query
	QueryID *string `json:"queryId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type QueryStatistic.
func (q QueryStatistic) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "intervals", q.Intervals)
	populate(objectMap, "queryId", q.QueryID)
	return json.Marshal(objectMap)
}

// ReadWriteDatabase - Class representing a read write database.
type ReadWriteDatabase struct {
	Database
	// The database properties.
	Properties *ReadWriteDatabaseProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReadWriteDatabase.
func (r ReadWriteDatabase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.Database.marshalInternal(objectMap, KindReadWrite)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReadWriteDatabase.
func (r *ReadWriteDatabase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.Database.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReadWriteDatabaseProperties - Class representing the Kusto database properties.
type ReadWriteDatabaseProperties struct {
	// The time the data should be kept in cache for fast queries in TimeSpan.
	HotCachePeriod *string `json:"hotCachePeriod,omitempty"`

	// The time the data should be kept before it stops being accessible to queries in TimeSpan.
	SoftDeletePeriod *string `json:"softDeletePeriod,omitempty"`

	// READ-ONLY; Indicates whether the database is followed.
	IsFollowed *bool `json:"isFollowed,omitempty" azure:"ro"`

	// READ-ONLY; The provisioned state of the resource.
	ProvisioningState *ResourceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The statistics of the database.
	Statistics *DatabaseStatistics `json:"statistics,omitempty" azure:"ro"`
}

// RecommendedSensitivityLabelUpdate - A recommended sensitivity label update operation.
type RecommendedSensitivityLabelUpdate struct {
	ProxyResource
	// Resource properties.
	Properties *RecommendedSensitivityLabelUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecommendedSensitivityLabelUpdate.
func (r RecommendedSensitivityLabelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecommendedSensitivityLabelUpdate.
func (r *RecommendedSensitivityLabelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RecommendedSensitivityLabelUpdateList - A list of recommended sensitivity label update operations.
type RecommendedSensitivityLabelUpdateList struct {
	Operations []*RecommendedSensitivityLabelUpdate `json:"operations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecommendedSensitivityLabelUpdateList.
func (r RecommendedSensitivityLabelUpdateList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operations", r.Operations)
	return json.Marshal(objectMap)
}

// RecommendedSensitivityLabelUpdateProperties - Properties of an operation executed on a recommended sensitivity label.
type RecommendedSensitivityLabelUpdateProperties struct {
	// REQUIRED; Column name to update.
	Column *string `json:"column,omitempty"`

	// REQUIRED
	Op *RecommendedSensitivityLabelUpdateKind `json:"op,omitempty"`

	// REQUIRED; Schema name of the column to update.
	Schema *string `json:"schema,omitempty"`

	// REQUIRED; Table name of the column to update.
	Table *string `json:"table,omitempty"`
}

// RecoverableSQLPool - A recoverable sql pool
type RecoverableSQLPool struct {
	ProxyResource
	// The properties of a recoverable sql pool
	Properties *RecoverableSQLPoolProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecoverableSQLPool.
func (r RecoverableSQLPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoverableSQLPool.
func (r *RecoverableSQLPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RecoverableSQLPoolListResult - The response to a list recoverable sql pools request
type RecoverableSQLPoolListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A list of recoverable sql pool
	Value []*RecoverableSQLPool `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RecoverableSQLPoolListResult.
func (r RecoverableSQLPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RecoverableSQLPoolProperties - The properties of a recoverable sql pool
type RecoverableSQLPoolProperties struct {
	// READ-ONLY; The edition of the database
	Edition *string `json:"edition,omitempty" azure:"ro"`

	// READ-ONLY; The elastic pool name of the database
	ElasticPoolName *string `json:"elasticPoolName,omitempty" azure:"ro"`

	// READ-ONLY; The last available backup date of the database (ISO8601 format)
	LastAvailableBackupDate *time.Time `json:"lastAvailableBackupDate,omitempty" azure:"ro"`

	// READ-ONLY; The service level objective name of the database
	ServiceLevelObjective *string `json:"serviceLevelObjective,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RecoverableSQLPoolProperties.
func (r RecoverableSQLPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "edition", r.Edition)
	populate(objectMap, "elasticPoolName", r.ElasticPoolName)
	populateTimeRFC3339(objectMap, "lastAvailableBackupDate", r.LastAvailableBackupDate)
	populate(objectMap, "serviceLevelObjective", r.ServiceLevelObjective)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoverableSQLPoolProperties.
func (r *RecoverableSQLPoolProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "edition":
			err = unpopulate(val, &r.Edition)
			delete(rawMsg, key)
		case "elasticPoolName":
			err = unpopulate(val, &r.ElasticPoolName)
			delete(rawMsg, key)
		case "lastAvailableBackupDate":
			err = unpopulateTimeRFC3339(val, &r.LastAvailableBackupDate)
			delete(rawMsg, key)
		case "serviceLevelObjective":
			err = unpopulate(val, &r.ServiceLevelObjective)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ReplaceAllFirewallRulesOperationResponse - An existing operation for replacing the firewall rules
type ReplaceAllFirewallRulesOperationResponse struct {
	// The operation ID
	OperationID *string `json:"operationId,omitempty"`
}

// ReplaceAllIPFirewallRulesRequest - Replace all IP firewall rules request
type ReplaceAllIPFirewallRulesRequest struct {
	// IP firewall rule properties
	IPFirewallRules map[string]*IPFirewallRuleProperties `json:"ipFirewallRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplaceAllIPFirewallRulesRequest.
func (r ReplaceAllIPFirewallRulesRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ipFirewallRules", r.IPFirewallRules)
	return json.Marshal(objectMap)
}

// ReplicationLink - Represents a Sql pool replication link.
type ReplicationLink struct {
	ProxyResource
	// The properties representing the resource.
	Properties *ReplicationLinkProperties `json:"properties,omitempty"`

	// READ-ONLY; Location of the workspace that contains this firewall rule.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationLink.
func (r ReplicationLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationLink.
func (r *ReplicationLink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &r.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ReplicationLinkListResult - Represents the response to a List Sql pool replication link request.
type ReplicationLinkListResult struct {
	// The list of Sql pool replication links housed in the Sql pool.
	Value []*ReplicationLink `json:"value,omitempty"`

	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationLinkListResult.
func (r ReplicationLinkListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// ReplicationLinkProperties - Represents the properties of a Sql pool replication link.
type ReplicationLinkProperties struct {
	// READ-ONLY; Legacy value indicating whether termination is allowed. Currently always returns true.
	IsTerminationAllowed *bool `json:"isTerminationAllowed,omitempty" azure:"ro"`

	// READ-ONLY; The name of the partner Sql pool.
	PartnerDatabase *string `json:"partnerDatabase,omitempty" azure:"ro"`

	// READ-ONLY; The Azure Region of the partner Sql pool.
	PartnerLocation *string `json:"partnerLocation,omitempty" azure:"ro"`

	// READ-ONLY; The role of the partner Sql pool in the replication link.
	PartnerRole *ReplicationRole `json:"partnerRole,omitempty" azure:"ro"`

	// READ-ONLY; The name of the workspace hosting the partner Sql pool.
	PartnerServer *string `json:"partnerServer,omitempty" azure:"ro"`

	// READ-ONLY; The percentage of seeding complete for the replication link.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`

	// READ-ONLY; Replication mode of this replication link.
	ReplicationMode *string `json:"replicationMode,omitempty" azure:"ro"`

	// READ-ONLY; The replication state for the replication link.
	ReplicationState *ReplicationState `json:"replicationState,omitempty" azure:"ro"`

	// READ-ONLY; The role of the Sql pool in the replication link.
	Role *ReplicationRole `json:"role,omitempty" azure:"ro"`

	// READ-ONLY; The start time for the replication link.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ReplicationLinkProperties.
func (r ReplicationLinkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isTerminationAllowed", r.IsTerminationAllowed)
	populate(objectMap, "partnerDatabase", r.PartnerDatabase)
	populate(objectMap, "partnerLocation", r.PartnerLocation)
	populate(objectMap, "partnerRole", r.PartnerRole)
	populate(objectMap, "partnerServer", r.PartnerServer)
	populate(objectMap, "percentComplete", r.PercentComplete)
	populate(objectMap, "replicationMode", r.ReplicationMode)
	populate(objectMap, "replicationState", r.ReplicationState)
	populate(objectMap, "role", r.Role)
	populateTimeRFC3339(objectMap, "startTime", r.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReplicationLinkProperties.
func (r *ReplicationLinkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isTerminationAllowed":
			err = unpopulate(val, &r.IsTerminationAllowed)
			delete(rawMsg, key)
		case "partnerDatabase":
			err = unpopulate(val, &r.PartnerDatabase)
			delete(rawMsg, key)
		case "partnerLocation":
			err = unpopulate(val, &r.PartnerLocation)
			delete(rawMsg, key)
		case "partnerRole":
			err = unpopulate(val, &r.PartnerRole)
			delete(rawMsg, key)
		case "partnerServer":
			err = unpopulate(val, &r.PartnerServer)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, &r.PercentComplete)
			delete(rawMsg, key)
		case "replicationMode":
			err = unpopulate(val, &r.ReplicationMode)
			delete(rawMsg, key)
		case "replicationState":
			err = unpopulate(val, &r.ReplicationState)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, &r.Role)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &r.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceMoveDefinition - Contains the information necessary to perform a resource move (rename).
type ResourceMoveDefinition struct {
	// REQUIRED; The target ID for the resource
	ID *string `json:"id,omitempty"`
}

// RestorableDroppedSQLPool - A restorable dropped Sql pool
type RestorableDroppedSQLPool struct {
	ProxyResource
	// The properties of a restorable dropped Sql pool
	Properties *RestorableDroppedSQLPoolProperties `json:"properties,omitempty"`

	// READ-ONLY; The geo-location where the resource lives
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorableDroppedSQLPool.
func (r RestorableDroppedSQLPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorableDroppedSQLPool.
func (r *RestorableDroppedSQLPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &r.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RestorableDroppedSQLPoolListResult - The response to a list restorable dropped Sql pools request
type RestorableDroppedSQLPoolListResult struct {
	// REQUIRED; A list of restorable dropped Sql pools
	Value []*RestorableDroppedSQLPool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorableDroppedSQLPoolListResult.
func (r RestorableDroppedSQLPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RestorableDroppedSQLPoolProperties - The properties of a restorable dropped Sql pool
type RestorableDroppedSQLPoolProperties struct {
	// READ-ONLY; The creation date of the database (ISO8601 format)
	CreationDate *time.Time `json:"creationDate,omitempty" azure:"ro"`

	// READ-ONLY; The name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; The deletion date of the database (ISO8601 format)
	DeletionDate *time.Time `json:"deletionDate,omitempty" azure:"ro"`

	// READ-ONLY; The earliest restore date of the database (ISO8601 format)
	EarliestRestoreDate *time.Time `json:"earliestRestoreDate,omitempty" azure:"ro"`

	// READ-ONLY; The edition of the database
	Edition *string `json:"edition,omitempty" azure:"ro"`

	// READ-ONLY; The elastic pool name of the database
	ElasticPoolName *string `json:"elasticPoolName,omitempty" azure:"ro"`

	// READ-ONLY; The max size in bytes of the database
	MaxSizeBytes *string `json:"maxSizeBytes,omitempty" azure:"ro"`

	// READ-ONLY; The service level objective name of the database
	ServiceLevelObjective *string `json:"serviceLevelObjective,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorableDroppedSQLPoolProperties.
func (r RestorableDroppedSQLPoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationDate", r.CreationDate)
	populate(objectMap, "databaseName", r.DatabaseName)
	populateTimeRFC3339(objectMap, "deletionDate", r.DeletionDate)
	populateTimeRFC3339(objectMap, "earliestRestoreDate", r.EarliestRestoreDate)
	populate(objectMap, "edition", r.Edition)
	populate(objectMap, "elasticPoolName", r.ElasticPoolName)
	populate(objectMap, "maxSizeBytes", r.MaxSizeBytes)
	populate(objectMap, "serviceLevelObjective", r.ServiceLevelObjective)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorableDroppedSQLPoolProperties.
func (r *RestorableDroppedSQLPoolProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &r.CreationDate)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &r.DatabaseName)
			delete(rawMsg, key)
		case "deletionDate":
			err = unpopulateTimeRFC3339(val, &r.DeletionDate)
			delete(rawMsg, key)
		case "earliestRestoreDate":
			err = unpopulateTimeRFC3339(val, &r.EarliestRestoreDate)
			delete(rawMsg, key)
		case "edition":
			err = unpopulate(val, &r.Edition)
			delete(rawMsg, key)
		case "elasticPoolName":
			err = unpopulate(val, &r.ElasticPoolName)
			delete(rawMsg, key)
		case "maxSizeBytes":
			err = unpopulate(val, &r.MaxSizeBytes)
			delete(rawMsg, key)
		case "serviceLevelObjective":
			err = unpopulate(val, &r.ServiceLevelObjective)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RestorableDroppedSQLPoolsGetOptions contains the optional parameters for the RestorableDroppedSQLPools.Get method.
type RestorableDroppedSQLPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// RestorableDroppedSQLPoolsListByWorkspaceOptions contains the optional parameters for the RestorableDroppedSQLPools.ListByWorkspace method.
type RestorableDroppedSQLPoolsListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// RestorePoint - Database restore points.
type RestorePoint struct {
	ProxyResource
	// Resource properties.
	Properties *RestorePointProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource location.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorePoint.
func (r RestorePoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorePoint.
func (r *RestorePoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &r.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &r.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RestorePointListResult - A list of long term retention backups.
type RestorePointListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*RestorePoint `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorePointListResult.
func (r RestorePointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RestorePointProperties - Properties of a database restore point
type RestorePointProperties struct {
	// READ-ONLY; The earliest time to which this database can be restored
	EarliestRestoreDate *time.Time `json:"earliestRestoreDate,omitempty" azure:"ro"`

	// READ-ONLY; The time the backup was taken
	RestorePointCreationDate *time.Time `json:"restorePointCreationDate,omitempty" azure:"ro"`

	// READ-ONLY; The label of restore point for backup request by user
	RestorePointLabel *string `json:"restorePointLabel,omitempty" azure:"ro"`

	// READ-ONLY; The type of restore point
	RestorePointType *RestorePointType `json:"restorePointType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type RestorePointProperties.
func (r RestorePointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "earliestRestoreDate", r.EarliestRestoreDate)
	populateTimeRFC3339(objectMap, "restorePointCreationDate", r.RestorePointCreationDate)
	populate(objectMap, "restorePointLabel", r.RestorePointLabel)
	populate(objectMap, "restorePointType", r.RestorePointType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestorePointProperties.
func (r *RestorePointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "earliestRestoreDate":
			err = unpopulateTimeRFC3339(val, &r.EarliestRestoreDate)
			delete(rawMsg, key)
		case "restorePointCreationDate":
			err = unpopulateTimeRFC3339(val, &r.RestorePointCreationDate)
			delete(rawMsg, key)
		case "restorePointLabel":
			err = unpopulate(val, &r.RestorePointLabel)
			delete(rawMsg, key)
		case "restorePointType":
			err = unpopulate(val, &r.RestorePointType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SKU - SQL pool SKU
type SKU struct {
	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`

	// The SKU name
	Name *string `json:"name,omitempty"`

	// The service tier
	Tier *string `json:"tier,omitempty"`
}

// SKUDescription - The Kusto SKU description of given resource type
type SKUDescription struct {
	// READ-ONLY; Locations and zones
	LocationInfo []*SKULocationInfoItem `json:"locationInfo,omitempty" azure:"ro"`

	// READ-ONLY; The set of locations that the SKU is available
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY; The name of the SKU
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; The restrictions because of which SKU cannot be used
	Restrictions []map[string]interface{} `json:"restrictions,omitempty" azure:"ro"`

	// READ-ONLY; The size of the SKU
	Size *string `json:"size,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUDescription.
func (s SKUDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "locationInfo", s.LocationInfo)
	populate(objectMap, "locations", s.Locations)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "resourceType", s.ResourceType)
	populate(objectMap, "restrictions", s.Restrictions)
	populate(objectMap, "size", s.Size)
	return json.Marshal(objectMap)
}

// SKUDescriptionList - The list of the SKU descriptions
type SKUDescriptionList struct {
	// READ-ONLY; SKU descriptions
	Value []*SKUDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SKUDescriptionList.
func (s SKUDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SKULocationInfoItem - The locations and zones info for SKU.
type SKULocationInfoItem struct {
	// REQUIRED; The available location of the SKU.
	Location *string `json:"location,omitempty"`

	// The available zone of the SKU.
	Zones []*string `json:"zones,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SKULocationInfoItem.
func (s SKULocationInfoItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", s.Location)
	populate(objectMap, "zones", s.Zones)
	return json.Marshal(objectMap)
}

// SQLPool - A SQL Analytics pool
type SQLPool struct {
	TrackedResource
	// SQL pool properties
	Properties *SQLPoolResourceProperties `json:"properties,omitempty"`

	// SQL pool SKU
	SKU *SKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPool.
func (s SQLPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPool.
func (s *SQLPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &s.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolBlobAuditingPoliciesCreateOrUpdateOptions contains the optional parameters for the SQLPoolBlobAuditingPolicies.CreateOrUpdate method.
type SQLPoolBlobAuditingPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolBlobAuditingPoliciesGetOptions contains the optional parameters for the SQLPoolBlobAuditingPolicies.Get method.
type SQLPoolBlobAuditingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolBlobAuditingPoliciesListBySQLPoolOptions contains the optional parameters for the SQLPoolBlobAuditingPolicies.ListBySQLPool method.
type SQLPoolBlobAuditingPoliciesListBySQLPoolOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolBlobAuditingPolicy - A Sql pool blob auditing policy.
type SQLPoolBlobAuditingPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolBlobAuditingPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolBlobAuditingPolicy.
func (s SQLPoolBlobAuditingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolBlobAuditingPolicy.
func (s *SQLPoolBlobAuditingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolBlobAuditingPolicyListResult - A list of Sql pool auditing settings.
type SQLPoolBlobAuditingPolicyListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolBlobAuditingPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolBlobAuditingPolicyListResult.
func (s SQLPoolBlobAuditingPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolBlobAuditingPolicyProperties - Properties of a Sql pool blob auditing policy.
type SQLPoolBlobAuditingPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
	State *BlobAuditingPolicyState `json:"state,omitempty"`

	// Specifies the Actions-Groups and Actions to audit.
	// The recommended set of action groups to use is the following combination - this will audit all the queries and stored procedures executed against the
	// database, as well as successful and failed logins:
	// BATCHCOMPLETEDGROUP, SUCCESSFULDATABASEAUTHENTICATIONGROUP, FAILEDDATABASEAUTHENTICATIONGROUP.
	// This above combination is also the set that is configured by default when enabling auditing from the Azure portal.
	// The supported action groups to audit are (note: choose only specific groups that cover your auditing needs. Using unnecessary groups could lead to very
	// large quantities of audit records):
	// APPLICATIONROLECHANGEPASSWORDGROUP BACKUPRESTOREGROUP DATABASELOGOUTGROUP DATABASEOBJECTCHANGEGROUP DATABASEOBJECTOWNERSHIPCHANGEGROUP DATABASEOBJECTPERMISSIONCHANGEGROUP
	// DATABASEOPERATIONGROUP
	// DATABASEPERMISSIONCHANGEGROUP DATABASEPRINCIPALCHANGEGROUP DATABASEPRINCIPALIMPERSONATIONGROUP DATABASEROLEMEMBERCHANGEGROUP FAILEDDATABASEAUTHENTICATIONGROUP
	// SCHEMAOBJECTACCESSGROUP SCHEMAOBJECT
	// CHANGEGROUP SCHEMAOBJECTOWNERSHIPCHANGEGROUP SCHEMAOBJECTPERMISSIONCHANGEGROUP SUCCESSFULDATABASEAUTHENTICATIONGROUP USERCHANGEPASSWORDGROUP BATCHSTARTEDGROUP
	// BATCHCOMPLETED_GROUP
	// These are groups that cover all sql statements and stored procedures executed against the database, and should not be used in combination with other
	// groups as this will result in duplicate audit logs.
	// For more information, see Database-Level Audit Action Groups
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-action-groups].
	// For Database auditing policy, specific Actions can also be specified (note that Actions cannot be specified for Server auditing policy). The supported
	// actions to audit are: SELECT UPDATE INSERT DELETE
	// EXECUTE RECEIVE REFERENCES
	// The general form for defining an action to be audited is: {action} ON {object} BY {principal}
	// Note that in the above format can refer to an object like a table, view, or stored procedure, or an entire database or schema. For the latter cases,
	// the forms DATABASE::{dbname} and SCHEMA::{schema
	// name} are used, respectively.
	// For example: SELECT on dbo.myTable by public SELECT on DATABASE::myDatabase by public SELECT on SCHEMA::mySchema by public
	// For more information, see Database-Level Audit Actions
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-actions]
	AuditActionsAndGroups []*string `json:"auditActionsAndGroups,omitempty"`

	// Specifies whether audit events are sent to Azure Monitor. In order to send the events to Azure Monitor, specify 'state' as 'Enabled' and 'isAzureMonitorTargetEnabled'
	// as true.
	// When using REST API to configure auditing, Diagnostic Settings with 'SQLSecurityAuditEvents' diagnostic logs category on the database should be also
	// created. Note that for server level audit you
	// should use the 'master' database as {databaseName}.
	// Diagnostic Settings URI format: PUT
	// https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/providers/microsoft.insights/diagnosticSettings/{settingsName}?api-version=2017-05-01-preview
	// For more information, see Diagnostic Settings REST API [https://go.microsoft.com/fwlink/?linkid=2033207]or Diagnostic Settings PowerShell [https://go.microsoft.com/fwlink/?linkid=2033043]
	IsAzureMonitorTargetEnabled *bool `json:"isAzureMonitorTargetEnabled,omitempty"`

	// Specifies whether storageAccountAccessKey value is the storage's secondary key.
	IsStorageSecondaryKeyInUse *bool `json:"isStorageSecondaryKeyInUse,omitempty"`

	// Specifies the number of days to keep in the audit logs in the storage account.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the auditing storage account. If state is Enabled and storageEndpoint is specified, storageAccountAccessKey is required.
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage subscription Id.
	StorageAccountSubscriptionID *string `json:"storageAccountSubscriptionId,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). If state is Enabled, storageEndpoint is required.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolBlobAuditingPolicyProperties.
func (s SQLPoolBlobAuditingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "auditActionsAndGroups", s.AuditActionsAndGroups)
	populate(objectMap, "isAzureMonitorTargetEnabled", s.IsAzureMonitorTargetEnabled)
	populate(objectMap, "isStorageSecondaryKeyInUse", s.IsStorageSecondaryKeyInUse)
	populate(objectMap, "retentionDays", s.RetentionDays)
	populate(objectMap, "state", s.State)
	populate(objectMap, "storageAccountAccessKey", s.StorageAccountAccessKey)
	populate(objectMap, "storageAccountSubscriptionId", s.StorageAccountSubscriptionID)
	populate(objectMap, "storageEndpoint", s.StorageEndpoint)
	return json.Marshal(objectMap)
}

// SQLPoolBlobAuditingPolicySQLPoolOperationListResult - The response to a list Sql pool operations request
type SQLPoolBlobAuditingPolicySQLPoolOperationListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolOperation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolBlobAuditingPolicySQLPoolOperationListResult.
func (s SQLPoolBlobAuditingPolicySQLPoolOperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolColumn - A Sql pool column resource.
type SQLPoolColumn struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolColumnProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolColumn.
func (s SQLPoolColumn) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolColumn.
func (s *SQLPoolColumn) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolColumnListResult - A list of Sql pool columns.
type SQLPoolColumnListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolColumn `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolColumnListResult.
func (s SQLPoolColumnListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolColumnProperties - Sql pool column properties.
type SQLPoolColumnProperties struct {
	// The column data type.
	ColumnType *ColumnDataType `json:"columnType,omitempty"`

	// READ-ONLY; Indicates whether column value is computed or not
	IsComputed *bool `json:"isComputed,omitempty" azure:"ro"`
}

// SQLPoolColumnsGetOptions contains the optional parameters for the SQLPoolColumns.Get method.
type SQLPoolColumnsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolConnectionPoliciesGetOptions contains the optional parameters for the SQLPoolConnectionPolicies.Get method.
type SQLPoolConnectionPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolConnectionPolicy - A Sql pool connection policy.
type SQLPoolConnectionPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolConnectionPolicyProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource kind.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; Resource location.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolConnectionPolicy.
func (s SQLPoolConnectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolConnectionPolicy.
func (s *SQLPoolConnectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, &s.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolConnectionPolicyProperties - Properties of a Sql pool connection policy.
type SQLPoolConnectionPolicyProperties struct {
	// The fully qualified host name of the auditing proxy.
	ProxyDNSName *string `json:"proxyDnsName,omitempty"`

	// The port number of the auditing proxy.
	ProxyPort *string `json:"proxyPort,omitempty"`

	// The state of proxy redirection.
	RedirectionState *string `json:"redirectionState,omitempty"`

	// The state of security access.
	SecurityEnabledAccess *string `json:"securityEnabledAccess,omitempty"`

	// The connection policy state.
	State *string `json:"state,omitempty"`

	// Whether server default is enabled or disabled.
	UseServerDefault *string `json:"useServerDefault,omitempty"`

	// The visibility of the auditing proxy.
	Visibility *string `json:"visibility,omitempty"`
}

// SQLPoolDataWarehouseUserActivitiesGetOptions contains the optional parameters for the SQLPoolDataWarehouseUserActivities.Get method.
type SQLPoolDataWarehouseUserActivitiesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolGeoBackupPoliciesCreateOrUpdateOptions contains the optional parameters for the SQLPoolGeoBackupPolicies.CreateOrUpdate method.
type SQLPoolGeoBackupPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolGeoBackupPoliciesGetOptions contains the optional parameters for the SQLPoolGeoBackupPolicies.Get method.
type SQLPoolGeoBackupPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolGeoBackupPoliciesListOptions contains the optional parameters for the SQLPoolGeoBackupPolicies.List method.
type SQLPoolGeoBackupPoliciesListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolInfoListResult - List of SQL pools
type SQLPoolInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of SQL pools
	Value []*SQLPool `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolInfoListResult.
func (s SQLPoolInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolMaintenanceWindowOptionsGetOptions contains the optional parameters for the SQLPoolMaintenanceWindowOptions.Get method.
type SQLPoolMaintenanceWindowOptionsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolMaintenanceWindowsCreateOrUpdateOptions contains the optional parameters for the SQLPoolMaintenanceWindows.CreateOrUpdate method.
type SQLPoolMaintenanceWindowsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolMaintenanceWindowsGetOptions contains the optional parameters for the SQLPoolMaintenanceWindows.Get method.
type SQLPoolMaintenanceWindowsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolMetadataSyncConfigsCreateOptions contains the optional parameters for the SQLPoolMetadataSyncConfigs.Create method.
type SQLPoolMetadataSyncConfigsCreateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolMetadataSyncConfigsGetOptions contains the optional parameters for the SQLPoolMetadataSyncConfigs.Get method.
type SQLPoolMetadataSyncConfigsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolOperation - A Sql pool operation.
type SQLPoolOperation struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolOperationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolOperation.
func (s SQLPoolOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolOperation.
func (s *SQLPoolOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolOperationProperties - The properties of a Sql pool operation.
type SQLPoolOperationProperties struct {
	// READ-ONLY; The name of the Sql pool the operation is being performed on.
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; The operation description.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The operation error code.
	ErrorCode *int32 `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; The operation error description.
	ErrorDescription *string `json:"errorDescription,omitempty" azure:"ro"`

	// READ-ONLY; The operation error severity.
	ErrorSeverity *int32 `json:"errorSeverity,omitempty" azure:"ro"`

	// READ-ONLY; The estimated completion time of the operation.
	EstimatedCompletionTime *time.Time `json:"estimatedCompletionTime,omitempty" azure:"ro"`

	// READ-ONLY; Whether the operation can be cancelled.
	IsCancellable *bool `json:"isCancellable,omitempty" azure:"ro"`

	// READ-ONLY; Whether or not the error is a user error.
	IsUserError *bool `json:"isUserError,omitempty" azure:"ro"`

	// READ-ONLY; The name of operation.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; The friendly name of operation.
	OperationFriendlyName *string `json:"operationFriendlyName,omitempty" azure:"ro"`

	// READ-ONLY; The percentage of the operation completed.
	PercentComplete *int32 `json:"percentComplete,omitempty" azure:"ro"`

	// READ-ONLY; The name of the server.
	ServerName *string `json:"serverName,omitempty" azure:"ro"`

	// READ-ONLY; The operation start time.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The operation state.
	State *ManagementOperationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolOperationProperties.
func (s SQLPoolOperationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", s.DatabaseName)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "errorCode", s.ErrorCode)
	populate(objectMap, "errorDescription", s.ErrorDescription)
	populate(objectMap, "errorSeverity", s.ErrorSeverity)
	populateTimeRFC3339(objectMap, "estimatedCompletionTime", s.EstimatedCompletionTime)
	populate(objectMap, "isCancellable", s.IsCancellable)
	populate(objectMap, "isUserError", s.IsUserError)
	populate(objectMap, "operation", s.Operation)
	populate(objectMap, "operationFriendlyName", s.OperationFriendlyName)
	populate(objectMap, "percentComplete", s.PercentComplete)
	populate(objectMap, "serverName", s.ServerName)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "state", s.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolOperationProperties.
func (s *SQLPoolOperationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &s.DatabaseName)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "errorCode":
			err = unpopulate(val, &s.ErrorCode)
			delete(rawMsg, key)
		case "errorDescription":
			err = unpopulate(val, &s.ErrorDescription)
			delete(rawMsg, key)
		case "errorSeverity":
			err = unpopulate(val, &s.ErrorSeverity)
			delete(rawMsg, key)
		case "estimatedCompletionTime":
			err = unpopulateTimeRFC3339(val, &s.EstimatedCompletionTime)
			delete(rawMsg, key)
		case "isCancellable":
			err = unpopulate(val, &s.IsCancellable)
			delete(rawMsg, key)
		case "isUserError":
			err = unpopulate(val, &s.IsUserError)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, &s.Operation)
			delete(rawMsg, key)
		case "operationFriendlyName":
			err = unpopulate(val, &s.OperationFriendlyName)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, &s.PercentComplete)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &s.ServerName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &s.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLPoolOperationResultsGetLocationHeaderResultOptions contains the optional parameters for the SQLPoolOperationResults.GetLocationHeaderResult method.
type SQLPoolOperationResultsGetLocationHeaderResultOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolOperationsListOptions contains the optional parameters for the SQLPoolOperations.List method.
type SQLPoolOperationsListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolPatchInfo - A SQL Analytics pool patch info
type SQLPoolPatchInfo struct {
	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// SQL pool properties
	Properties *SQLPoolResourceProperties `json:"properties,omitempty"`

	// SQL pool SKU
	SKU *SKU `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolPatchInfo.
func (s SQLPoolPatchInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "location", s.Location)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SQLPoolRecommendedSensitivityLabelsUpdateOptions contains the optional parameters for the SQLPoolRecommendedSensitivityLabels.Update method.
type SQLPoolRecommendedSensitivityLabelsUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolReplicationLinksGetByNameOptions contains the optional parameters for the SQLPoolReplicationLinks.GetByName method.
type SQLPoolReplicationLinksGetByNameOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolReplicationLinksListOptions contains the optional parameters for the SQLPoolReplicationLinks.List method.
type SQLPoolReplicationLinksListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolResourceProperties - Properties of a SQL Analytics pool
type SQLPoolResourceProperties struct {
	// Collation mode
	Collation *string `json:"collation,omitempty"`

	// Specifies the mode of sql pool creation.
	// Default: regular sql pool creation.
	// PointInTimeRestore: Creates a sql pool by restoring a point in time backup of an existing sql pool. sourceDatabaseId must be specified as the resource
	// ID of the existing sql pool, and
	// restorePointInTime must be specified.
	// Recovery: Creates a sql pool by a geo-replicated backup. sourceDatabaseId must be specified as the recoverableDatabaseId to restore.
	// Restore: Creates a sql pool by restoring a backup of a deleted sql pool. SourceDatabaseId should be the sql pool's original resource ID. SourceDatabaseId
	// and sourceDatabaseDeletionDate must be
	// specified.
	CreateMode *CreateMode `json:"createMode,omitempty"`

	// Date the SQL pool was created
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Maximum size in bytes
	MaxSizeBytes *int64 `json:"maxSizeBytes,omitempty"`

	// Resource state
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Backup database to restore from
	RecoverableDatabaseID *string `json:"recoverableDatabaseId,omitempty"`

	// Snapshot time to restore
	RestorePointInTime *time.Time `json:"restorePointInTime,omitempty"`

	// Specifies the time that the sql pool was deleted
	SourceDatabaseDeletionDate *time.Time `json:"sourceDatabaseDeletionDate,omitempty"`

	// Source database to create from
	SourceDatabaseID *string `json:"sourceDatabaseId,omitempty"`

	// Resource status
	Status *string `json:"status,omitempty"`

	// The storage account type used to store backups for this sql pool.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolResourceProperties.
func (s SQLPoolResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collation", s.Collation)
	populate(objectMap, "createMode", s.CreateMode)
	populateTimeRFC3339(objectMap, "creationDate", s.CreationDate)
	populate(objectMap, "maxSizeBytes", s.MaxSizeBytes)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "recoverableDatabaseId", s.RecoverableDatabaseID)
	populateTimeRFC3339(objectMap, "restorePointInTime", s.RestorePointInTime)
	populateTimeRFC3339(objectMap, "sourceDatabaseDeletionDate", s.SourceDatabaseDeletionDate)
	populate(objectMap, "sourceDatabaseId", s.SourceDatabaseID)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "storageAccountType", s.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolResourceProperties.
func (s *SQLPoolResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collation":
			err = unpopulate(val, &s.Collation)
			delete(rawMsg, key)
		case "createMode":
			err = unpopulate(val, &s.CreateMode)
			delete(rawMsg, key)
		case "creationDate":
			err = unpopulateTimeRFC3339(val, &s.CreationDate)
			delete(rawMsg, key)
		case "maxSizeBytes":
			err = unpopulate(val, &s.MaxSizeBytes)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "recoverableDatabaseId":
			err = unpopulate(val, &s.RecoverableDatabaseID)
			delete(rawMsg, key)
		case "restorePointInTime":
			err = unpopulateTimeRFC3339(val, &s.RestorePointInTime)
			delete(rawMsg, key)
		case "sourceDatabaseDeletionDate":
			err = unpopulateTimeRFC3339(val, &s.SourceDatabaseDeletionDate)
			delete(rawMsg, key)
		case "sourceDatabaseId":
			err = unpopulate(val, &s.SourceDatabaseID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "storageAccountType":
			err = unpopulate(val, &s.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLPoolRestorePointsBeginCreateOptions contains the optional parameters for the SQLPoolRestorePoints.BeginCreate method.
type SQLPoolRestorePointsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolRestorePointsDeleteOptions contains the optional parameters for the SQLPoolRestorePoints.Delete method.
type SQLPoolRestorePointsDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolRestorePointsGetOptions contains the optional parameters for the SQLPoolRestorePoints.Get method.
type SQLPoolRestorePointsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolRestorePointsListOptions contains the optional parameters for the SQLPoolRestorePoints.List method.
type SQLPoolRestorePointsListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSchema - A Sql pool schema resource.
type SQLPoolSchema struct {
	ProxyResource
}

// SQLPoolSchemaListResult - A list of Sql pool schemas.
type SQLPoolSchemaListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolSchema `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolSchemaListResult.
func (s SQLPoolSchemaListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolSchemasGetOptions contains the optional parameters for the SQLPoolSchemas.Get method.
type SQLPoolSchemasGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSchemasListOptions contains the optional parameters for the SQLPoolSchemas.List method.
type SQLPoolSchemasListOptions struct {
	// An OData filter expression that filters elements in the collection.
	Filter *string
}

// SQLPoolSecurityAlertPoliciesCreateOrUpdateOptions contains the optional parameters for the SQLPoolSecurityAlertPolicies.CreateOrUpdate method.
type SQLPoolSecurityAlertPoliciesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSecurityAlertPoliciesGetOptions contains the optional parameters for the SQLPoolSecurityAlertPolicies.Get method.
type SQLPoolSecurityAlertPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSecurityAlertPoliciesListOptions contains the optional parameters for the SQLPoolSecurityAlertPolicies.List method.
type SQLPoolSecurityAlertPoliciesListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSecurityAlertPolicy - A Sql pool security alert policy.
type SQLPoolSecurityAlertPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *SecurityAlertPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolSecurityAlertPolicy.
func (s SQLPoolSecurityAlertPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolSecurityAlertPolicy.
func (s *SQLPoolSecurityAlertPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolSensitivityLabelsCreateOrUpdateOptions contains the optional parameters for the SQLPoolSensitivityLabels.CreateOrUpdate method.
type SQLPoolSensitivityLabelsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSensitivityLabelsDeleteOptions contains the optional parameters for the SQLPoolSensitivityLabels.Delete method.
type SQLPoolSensitivityLabelsDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSensitivityLabelsDisableRecommendationOptions contains the optional parameters for the SQLPoolSensitivityLabels.DisableRecommendation method.
type SQLPoolSensitivityLabelsDisableRecommendationOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSensitivityLabelsEnableRecommendationOptions contains the optional parameters for the SQLPoolSensitivityLabels.EnableRecommendation method.
type SQLPoolSensitivityLabelsEnableRecommendationOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSensitivityLabelsGetOptions contains the optional parameters for the SQLPoolSensitivityLabels.Get method.
type SQLPoolSensitivityLabelsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolSensitivityLabelsListCurrentOptions contains the optional parameters for the SQLPoolSensitivityLabels.ListCurrent method.
type SQLPoolSensitivityLabelsListCurrentOptions struct {
	// An OData filter expression that filters elements in the collection.
	Filter *string
}

// SQLPoolSensitivityLabelsListRecommendedOptions contains the optional parameters for the SQLPoolSensitivityLabels.ListRecommended method.
type SQLPoolSensitivityLabelsListRecommendedOptions struct {
	// An OData filter expression that filters elements in the collection.
	Filter *string
	// Specifies whether to include disabled recommendations or not.
	IncludeDisabledRecommendations *bool
	// An OData query option to indicate how many elements to skip in the collection.
	SkipToken *string
}

// SQLPoolSensitivityLabelsUpdateOptions contains the optional parameters for the SQLPoolSensitivityLabels.Update method.
type SQLPoolSensitivityLabelsUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolTable - A Sql pool table resource.
type SQLPoolTable struct {
	ProxyResource
}

// SQLPoolTableColumnsListByTableNameOptions contains the optional parameters for the SQLPoolTableColumns.ListByTableName method.
type SQLPoolTableColumnsListByTableNameOptions struct {
	// An OData filter expression that filters elements in the collection.
	Filter *string
}

// SQLPoolTableListResult - A list of Sql pool tables.
type SQLPoolTableListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolTable `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolTableListResult.
func (s SQLPoolTableListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolTablesGetOptions contains the optional parameters for the SQLPoolTables.Get method.
type SQLPoolTablesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolTablesListBySchemaOptions contains the optional parameters for the SQLPoolTables.ListBySchema method.
type SQLPoolTablesListBySchemaOptions struct {
	// An OData filter expression that filters elements in the collection.
	Filter *string
}

// SQLPoolTransparentDataEncryptionsCreateOrUpdateOptions contains the optional parameters for the SQLPoolTransparentDataEncryptions.CreateOrUpdate method.
type SQLPoolTransparentDataEncryptionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolTransparentDataEncryptionsGetOptions contains the optional parameters for the SQLPoolTransparentDataEncryptions.Get method.
type SQLPoolTransparentDataEncryptionsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolTransparentDataEncryptionsListOptions contains the optional parameters for the SQLPoolTransparentDataEncryptions.List method.
type SQLPoolTransparentDataEncryptionsListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolUsage - The Sql pool usages.
type SQLPoolUsage struct {
	// READ-ONLY; The current value of the usage metric.
	CurrentValue *float64 `json:"currentValue,omitempty" azure:"ro"`

	// READ-ONLY; The usage metric display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The current limit of the usage metric.
	Limit *float64 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; The name of the usage metric.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The next reset time for the usage metric (ISO8601 format).
	NextResetTime *time.Time `json:"nextResetTime,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	ResourceName *string `json:"resourceName,omitempty" azure:"ro"`

	// READ-ONLY; The units of the usage metric.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolUsage.
func (s SQLPoolUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentValue", s.CurrentValue)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "limit", s.Limit)
	populate(objectMap, "name", s.Name)
	populateTimeRFC3339(objectMap, "nextResetTime", s.NextResetTime)
	populate(objectMap, "resourceName", s.ResourceName)
	populate(objectMap, "unit", s.Unit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolUsage.
func (s *SQLPoolUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentValue":
			err = unpopulate(val, &s.CurrentValue)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &s.DisplayName)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, &s.Limit)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "nextResetTime":
			err = unpopulateTimeRFC3339(val, &s.NextResetTime)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, &s.ResourceName)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, &s.Unit)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLPoolUsageListResult - The response to a list Sql pool usages request.
type SQLPoolUsageListResult struct {
	// REQUIRED; The list of usages for the Sql pool.
	Value []*SQLPoolUsage `json:"value,omitempty"`

	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolUsageListResult.
func (s SQLPoolUsageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolUsagesListOptions contains the optional parameters for the SQLPoolUsages.List method.
type SQLPoolUsagesListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessment - A Sql pool vulnerability assessment.
type SQLPoolVulnerabilityAssessment struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolVulnerabilityAssessmentProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessment.
func (s SQLPoolVulnerabilityAssessment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolVulnerabilityAssessment.
func (s *SQLPoolVulnerabilityAssessment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolVulnerabilityAssessmentListResult - A list of the Sql pool's vulnerability assessments.
type SQLPoolVulnerabilityAssessmentListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SQLPoolVulnerabilityAssessment `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessmentListResult.
func (s SQLPoolVulnerabilityAssessmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLPoolVulnerabilityAssessmentProperties - Properties of a Sql pool Vulnerability Assessment.
type SQLPoolVulnerabilityAssessmentProperties struct {
	// The recurring scans settings
	RecurringScans *VulnerabilityAssessmentRecurringScansProperties `json:"recurringScans,omitempty"`

	// Specifies the identifier key of the storage account for vulnerability assessment scan results. If 'StorageContainerSasKey' isn't specified, storageAccountAccessKey
	// is required.
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// A blob storage container path to hold the scan results (e.g. https://myStorage.blob.core.windows.net/VaScans/). It is required if server level vulnerability
	// assessment policy doesn't set
	StorageContainerPath *string `json:"storageContainerPath,omitempty"`

	// A shared access signature (SAS Key) that has write access to the blob container specified in 'storageContainerPath' parameter. If 'storageAccountAccessKey'
	// isn't specified, StorageContainerSasKey is
	// required.
	StorageContainerSasKey *string `json:"storageContainerSasKey,omitempty"`
}

// SQLPoolVulnerabilityAssessmentRuleBaseline - A Sql pool vulnerability assessment rule baseline.
type SQLPoolVulnerabilityAssessmentRuleBaseline struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolVulnerabilityAssessmentRuleBaselineProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessmentRuleBaseline.
func (s SQLPoolVulnerabilityAssessmentRuleBaseline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolVulnerabilityAssessmentRuleBaseline.
func (s *SQLPoolVulnerabilityAssessmentRuleBaseline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolVulnerabilityAssessmentRuleBaselineItem - Properties for an Sql pool vulnerability assessment rule baseline's result.
type SQLPoolVulnerabilityAssessmentRuleBaselineItem struct {
	// REQUIRED; The rule baseline result
	Result []*string `json:"result,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessmentRuleBaselineItem.
func (s SQLPoolVulnerabilityAssessmentRuleBaselineItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "result", s.Result)
	return json.Marshal(objectMap)
}

// SQLPoolVulnerabilityAssessmentRuleBaselineProperties - Properties of a Sql pool vulnerability assessment rule baseline.
type SQLPoolVulnerabilityAssessmentRuleBaselineProperties struct {
	// REQUIRED; The rule baseline result
	BaselineResults []*SQLPoolVulnerabilityAssessmentRuleBaselineItem `json:"baselineResults,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessmentRuleBaselineProperties.
func (s SQLPoolVulnerabilityAssessmentRuleBaselineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baselineResults", s.BaselineResults)
	return json.Marshal(objectMap)
}

// SQLPoolVulnerabilityAssessmentRuleBaselinesCreateOrUpdateOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentRuleBaselines.CreateOrUpdate
// method.
type SQLPoolVulnerabilityAssessmentRuleBaselinesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentRuleBaselinesDeleteOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentRuleBaselines.Delete
// method.
type SQLPoolVulnerabilityAssessmentRuleBaselinesDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentRuleBaselinesGetOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentRuleBaselines.Get method.
type SQLPoolVulnerabilityAssessmentRuleBaselinesGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentScanExportProperties - Properties of the export operation's result.
type SQLPoolVulnerabilityAssessmentScanExportProperties struct {
	// READ-ONLY; Location of the exported report (e.g. https://myStorage.blob.core.windows.net/VaScans/scans/serverName/databaseName/scan_scanId.xlsx).
	ExportedReportLocation *string `json:"exportedReportLocation,omitempty" azure:"ro"`
}

// SQLPoolVulnerabilityAssessmentScansBeginInitiateScanOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentScans.BeginInitiateScan
// method.
type SQLPoolVulnerabilityAssessmentScansBeginInitiateScanOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentScansExport - A Sql pool Vulnerability Assessment scan export resource.
type SQLPoolVulnerabilityAssessmentScansExport struct {
	ProxyResource
	// Resource properties.
	Properties *SQLPoolVulnerabilityAssessmentScanExportProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolVulnerabilityAssessmentScansExport.
func (s SQLPoolVulnerabilityAssessmentScansExport) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolVulnerabilityAssessmentScansExport.
func (s *SQLPoolVulnerabilityAssessmentScansExport) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLPoolVulnerabilityAssessmentScansExportOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentScans.Export method.
type SQLPoolVulnerabilityAssessmentScansExportOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentScansGetOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentScans.Get method.
type SQLPoolVulnerabilityAssessmentScansGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentScansListOptions contains the optional parameters for the SQLPoolVulnerabilityAssessmentScans.List method.
type SQLPoolVulnerabilityAssessmentScansListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentsCreateOrUpdateOptions contains the optional parameters for the SQLPoolVulnerabilityAssessments.CreateOrUpdate method.
type SQLPoolVulnerabilityAssessmentsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentsDeleteOptions contains the optional parameters for the SQLPoolVulnerabilityAssessments.Delete method.
type SQLPoolVulnerabilityAssessmentsDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentsGetOptions contains the optional parameters for the SQLPoolVulnerabilityAssessments.Get method.
type SQLPoolVulnerabilityAssessmentsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolVulnerabilityAssessmentsListOptions contains the optional parameters for the SQLPoolVulnerabilityAssessments.List method.
type SQLPoolVulnerabilityAssessmentsListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadClassifierBeginCreateOrUpdateOptions contains the optional parameters for the SQLPoolWorkloadClassifier.BeginCreateOrUpdate method.
type SQLPoolWorkloadClassifierBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadClassifierBeginDeleteOptions contains the optional parameters for the SQLPoolWorkloadClassifier.BeginDelete method.
type SQLPoolWorkloadClassifierBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadClassifierGetOptions contains the optional parameters for the SQLPoolWorkloadClassifier.Get method.
type SQLPoolWorkloadClassifierGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadClassifierListOptions contains the optional parameters for the SQLPoolWorkloadClassifier.List method.
type SQLPoolWorkloadClassifierListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadGroupBeginCreateOrUpdateOptions contains the optional parameters for the SQLPoolWorkloadGroup.BeginCreateOrUpdate method.
type SQLPoolWorkloadGroupBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadGroupBeginDeleteOptions contains the optional parameters for the SQLPoolWorkloadGroup.BeginDelete method.
type SQLPoolWorkloadGroupBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadGroupGetOptions contains the optional parameters for the SQLPoolWorkloadGroup.Get method.
type SQLPoolWorkloadGroupGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolWorkloadGroupListOptions contains the optional parameters for the SQLPoolWorkloadGroup.List method.
type SQLPoolWorkloadGroupListOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsBeginCreateOptions contains the optional parameters for the SQLPools.BeginCreate method.
type SQLPoolsBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsBeginDeleteOptions contains the optional parameters for the SQLPools.BeginDelete method.
type SQLPoolsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsBeginPauseOptions contains the optional parameters for the SQLPools.BeginPause method.
type SQLPoolsBeginPauseOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsBeginResumeOptions contains the optional parameters for the SQLPools.BeginResume method.
type SQLPoolsBeginResumeOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsGetOptions contains the optional parameters for the SQLPools.Get method.
type SQLPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsListByWorkspaceOptions contains the optional parameters for the SQLPools.ListByWorkspace method.
type SQLPoolsListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsRenameOptions contains the optional parameters for the SQLPools.Rename method.
type SQLPoolsRenameOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsUpdateOptions contains the optional parameters for the SQLPools.Update method.
type SQLPoolsUpdateOptions struct {
	// placeholder for future optional parameters
}

// SecretBaseClassification provides polymorphic access to related types.
// Call the interface's GetSecretBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SecretBase, *SecureString
type SecretBaseClassification interface {
	// GetSecretBase returns the SecretBase content of the underlying type.
	GetSecretBase() *SecretBase
}

// SecretBase - The base definition of a secret type.
type SecretBase struct {
	// REQUIRED; Type of the secret.
	Type *string `json:"type,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type SecretBase.
func (s *SecretBase) GetSecretBase() *SecretBase { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretBase.
func (s *SecretBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SecretBase) marshalInternal(objectMap map[string]interface{}, discValue string) {
	s.Type = &discValue
	objectMap["type"] = s.Type
}

func (s *SecretBase) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SecureString - Azure Synapse secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
type SecureString struct {
	SecretBase
	// REQUIRED; Value of secure string.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecureString.
func (s SecureString) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SecretBase.marshalInternal(objectMap, "SecureString")
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureString.
func (s *SecureString) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SecretBase.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SecurityAlertPolicyProperties - Properties of a security alert policy.
type SecurityAlertPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy, whether it is enabled or disabled or a policy has not been applied yet on the specific Sql pool.
	State *SecurityAlertPolicyState `json:"state,omitempty"`

	// Specifies an array of alerts that are disabled. Allowed values are: SqlInjection, SqlInjectionVulnerability, AccessAnomaly, DataExfiltration, UnsafeAction
	DisabledAlerts []*string `json:"disabledAlerts,omitempty"`

	// Specifies that the alert is sent to the account administrators.
	EmailAccountAdmins *bool `json:"emailAccountAdmins,omitempty"`

	// Specifies an array of e-mail addresses to which the alert is sent.
	EmailAddresses []*string `json:"emailAddresses,omitempty"`

	// Specifies the number of days to keep in the Threat Detection audit logs.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the Threat Detection audit storage account.
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`

	// READ-ONLY; Specifies the UTC creation time of the policy.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityAlertPolicyProperties.
func (s SecurityAlertPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationTime", s.CreationTime)
	populate(objectMap, "disabledAlerts", s.DisabledAlerts)
	populate(objectMap, "emailAccountAdmins", s.EmailAccountAdmins)
	populate(objectMap, "emailAddresses", s.EmailAddresses)
	populate(objectMap, "retentionDays", s.RetentionDays)
	populate(objectMap, "state", s.State)
	populate(objectMap, "storageAccountAccessKey", s.StorageAccountAccessKey)
	populate(objectMap, "storageEndpoint", s.StorageEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityAlertPolicyProperties.
func (s *SecurityAlertPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &s.CreationTime)
			delete(rawMsg, key)
		case "disabledAlerts":
			err = unpopulate(val, &s.DisabledAlerts)
			delete(rawMsg, key)
		case "emailAccountAdmins":
			err = unpopulate(val, &s.EmailAccountAdmins)
			delete(rawMsg, key)
		case "emailAddresses":
			err = unpopulate(val, &s.EmailAddresses)
			delete(rawMsg, key)
		case "retentionDays":
			err = unpopulate(val, &s.RetentionDays)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &s.State)
			delete(rawMsg, key)
		case "storageAccountAccessKey":
			err = unpopulate(val, &s.StorageAccountAccessKey)
			delete(rawMsg, key)
		case "storageEndpoint":
			err = unpopulate(val, &s.StorageEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntime - Self-hosted integration runtime.
type SelfHostedIntegrationRuntime struct {
	IntegrationRuntime
	// When this property is not null, means this is a linked integration runtime. The property is used to access original integration runtime.
	TypeProperties *SelfHostedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntime.
func (s SelfHostedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.IntegrationRuntime.marshalInternal(objectMap, IntegrationRuntimeTypeSelfHosted)
	populate(objectMap, "typeProperties", s.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntime.
func (s *SelfHostedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.IntegrationRuntime.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SelfHostedIntegrationRuntimeNode - Properties of Self-hosted integration runtime node.
type SelfHostedIntegrationRuntimeNode struct {
	// OPTIONAL; Contains additional key/value pairs not defined in the schema.
	AdditionalProperties map[string]map[string]interface{}

	// READ-ONLY; The integration runtime capabilities dictionary
	Capabilities map[string]*string `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; Maximum concurrent jobs on the integration runtime node.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime will expire in ISO8601 format.
	ExpiryTime *time.Time `json:"expiryTime,omitempty" azure:"ro"`

	// READ-ONLY; URI for the host machine of the integration runtime.
	HostServiceURI *string `json:"hostServiceUri,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether this node is the active dispatcher for integration runtime requests.
	IsActiveDispatcher *bool `json:"isActiveDispatcher,omitempty" azure:"ro"`

	// READ-ONLY; The most recent time at which the integration runtime was connected in ISO8601 format.
	LastConnectTime *time.Time `json:"lastConnectTime,omitempty" azure:"ro"`

	// READ-ONLY; The last time for the integration runtime node update end.
	LastEndUpdateTime *time.Time `json:"lastEndUpdateTime,omitempty" azure:"ro"`

	// READ-ONLY; The time the node last started up.
	LastStartTime *time.Time `json:"lastStartTime,omitempty" azure:"ro"`

	// READ-ONLY; The last time for the integration runtime node update start.
	LastStartUpdateTime *time.Time `json:"lastStartUpdateTime,omitempty" azure:"ro"`

	// READ-ONLY; The integration runtime node last stop time.
	LastStopTime *time.Time `json:"lastStopTime,omitempty" azure:"ro"`

	// READ-ONLY; The result of the last integration runtime node update.
	LastUpdateResult *IntegrationRuntimeUpdateResult `json:"lastUpdateResult,omitempty" azure:"ro"`

	// READ-ONLY; Machine name of the integration runtime node.
	MachineName *string `json:"machineName,omitempty" azure:"ro"`

	// READ-ONLY; The maximum concurrent jobs in this integration runtime.
	MaxConcurrentJobs *int32 `json:"maxConcurrentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Name of the integration runtime node.
	NodeName *string `json:"nodeName,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime node was registered in ISO8601 format.
	RegisterTime *time.Time `json:"registerTime,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime node.
	Status *SelfHostedIntegrationRuntimeNodeStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Version of the integration runtime node.
	Version *string `json:"version,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime node version.
	VersionStatus *string `json:"versionStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s SelfHostedIntegrationRuntimeNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", s.Capabilities)
	populate(objectMap, "concurrentJobsLimit", s.ConcurrentJobsLimit)
	populateTimeRFC3339(objectMap, "expiryTime", s.ExpiryTime)
	populate(objectMap, "hostServiceUri", s.HostServiceURI)
	populate(objectMap, "isActiveDispatcher", s.IsActiveDispatcher)
	populateTimeRFC3339(objectMap, "lastConnectTime", s.LastConnectTime)
	populateTimeRFC3339(objectMap, "lastEndUpdateTime", s.LastEndUpdateTime)
	populateTimeRFC3339(objectMap, "lastStartTime", s.LastStartTime)
	populateTimeRFC3339(objectMap, "lastStartUpdateTime", s.LastStartUpdateTime)
	populateTimeRFC3339(objectMap, "lastStopTime", s.LastStopTime)
	populate(objectMap, "lastUpdateResult", s.LastUpdateResult)
	populate(objectMap, "machineName", s.MachineName)
	populate(objectMap, "maxConcurrentJobs", s.MaxConcurrentJobs)
	populate(objectMap, "nodeName", s.NodeName)
	populateTimeRFC3339(objectMap, "registerTime", s.RegisterTime)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeNode.
func (s *SelfHostedIntegrationRuntimeNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capabilities":
			err = unpopulate(val, &s.Capabilities)
			delete(rawMsg, key)
		case "concurrentJobsLimit":
			err = unpopulate(val, &s.ConcurrentJobsLimit)
			delete(rawMsg, key)
		case "expiryTime":
			err = unpopulateTimeRFC3339(val, &s.ExpiryTime)
			delete(rawMsg, key)
		case "hostServiceUri":
			err = unpopulate(val, &s.HostServiceURI)
			delete(rawMsg, key)
		case "isActiveDispatcher":
			err = unpopulate(val, &s.IsActiveDispatcher)
			delete(rawMsg, key)
		case "lastConnectTime":
			err = unpopulateTimeRFC3339(val, &s.LastConnectTime)
			delete(rawMsg, key)
		case "lastEndUpdateTime":
			err = unpopulateTimeRFC3339(val, &s.LastEndUpdateTime)
			delete(rawMsg, key)
		case "lastStartTime":
			err = unpopulateTimeRFC3339(val, &s.LastStartTime)
			delete(rawMsg, key)
		case "lastStartUpdateTime":
			err = unpopulateTimeRFC3339(val, &s.LastStartUpdateTime)
			delete(rawMsg, key)
		case "lastStopTime":
			err = unpopulateTimeRFC3339(val, &s.LastStopTime)
			delete(rawMsg, key)
		case "lastUpdateResult":
			err = unpopulate(val, &s.LastUpdateResult)
			delete(rawMsg, key)
		case "machineName":
			err = unpopulate(val, &s.MachineName)
			delete(rawMsg, key)
		case "maxConcurrentJobs":
			err = unpopulate(val, &s.MaxConcurrentJobs)
			delete(rawMsg, key)
		case "nodeName":
			err = unpopulate(val, &s.NodeName)
			delete(rawMsg, key)
		case "registerTime":
			err = unpopulateTimeRFC3339(val, &s.RegisterTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, &s.VersionStatus)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]map[string]interface{}{}
			}
			if val != nil {
				var aux map[string]interface{}
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeStatus - Self-hosted integration runtime status.
type SelfHostedIntegrationRuntimeStatus struct {
	IntegrationRuntimeStatus
	// REQUIRED; Self-hosted integration runtime status type properties.
	TypeProperties *SelfHostedIntegrationRuntimeStatusTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s SelfHostedIntegrationRuntimeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.IntegrationRuntimeStatus.marshalInternal(objectMap, IntegrationRuntimeTypeSelfHosted)
	populate(objectMap, "typeProperties", s.TypeProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatus.
func (s *SelfHostedIntegrationRuntimeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			err = unpopulate(val, &s.TypeProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.IntegrationRuntimeStatus.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SelfHostedIntegrationRuntimeStatusTypeProperties - Self-hosted integration runtime status type properties.
type SelfHostedIntegrationRuntimeStatusTypeProperties struct {
	// The list of linked integration runtimes that are created to share with this integration runtime.
	Links []*LinkedIntegrationRuntime `json:"links,omitempty"`

	// The list of nodes for this integration runtime.
	Nodes []*SelfHostedIntegrationRuntimeNode `json:"nodes,omitempty"`

	// READ-ONLY; Whether Self-hosted integration runtime auto update has been turned on.
	AutoUpdate *IntegrationRuntimeAutoUpdate `json:"autoUpdate,omitempty" azure:"ro"`

	// READ-ONLY; The estimated time when the self-hosted integration runtime will be updated.
	AutoUpdateETA *time.Time `json:"autoUpdateETA,omitempty" azure:"ro"`

	// READ-ONLY; Object with additional information about integration runtime capabilities.
	Capabilities map[string]*string `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; The time at which the integration runtime was created, in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// READ-ONLY; It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration runtime nodes exist).
	InternalChannelEncryption *IntegrationRuntimeInternalChannelEncryptionMode `json:"internalChannelEncryption,omitempty" azure:"ro"`

	// READ-ONLY; The latest version on download center.
	LatestVersion *string `json:"latestVersion,omitempty" azure:"ro"`

	// READ-ONLY; The local time zone offset in hours.
	LocalTimeZoneOffset *string `json:"localTimeZoneOffset,omitempty" azure:"ro"`

	// READ-ONLY; The node communication Channel encryption mode
	NodeCommunicationChannelEncryptionMode *string `json:"nodeCommunicationChannelEncryptionMode,omitempty" azure:"ro"`

	// READ-ONLY; The version that the integration runtime is going to update to.
	PushedVersion *string `json:"pushedVersion,omitempty" azure:"ro"`

	// READ-ONLY; The date at which the integration runtime will be scheduled to update, in ISO8601 format.
	ScheduledUpdateDate *time.Time `json:"scheduledUpdateDate,omitempty" azure:"ro"`

	// READ-ONLY; The URLs for the services used in integration runtime backend service.
	ServiceUrls []*string `json:"serviceUrls,omitempty" azure:"ro"`

	// READ-ONLY; The task queue id of the integration runtime.
	TaskQueueID *string `json:"taskQueueId,omitempty" azure:"ro"`

	// READ-ONLY; The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
	UpdateDelayOffset *string `json:"updateDelayOffset,omitempty" azure:"ro"`

	// READ-ONLY; Version of the integration runtime.
	Version *string `json:"version,omitempty" azure:"ro"`

	// READ-ONLY; Status of the integration runtime version.
	VersionStatus *string `json:"versionStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s SelfHostedIntegrationRuntimeStatusTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUpdate", s.AutoUpdate)
	populateTimeRFC3339(objectMap, "autoUpdateETA", s.AutoUpdateETA)
	populate(objectMap, "capabilities", s.Capabilities)
	populateTimeRFC3339(objectMap, "createTime", s.CreateTime)
	populate(objectMap, "internalChannelEncryption", s.InternalChannelEncryption)
	populate(objectMap, "latestVersion", s.LatestVersion)
	populate(objectMap, "links", s.Links)
	populate(objectMap, "localTimeZoneOffset", s.LocalTimeZoneOffset)
	populate(objectMap, "nodeCommunicationChannelEncryptionMode", s.NodeCommunicationChannelEncryptionMode)
	populate(objectMap, "nodes", s.Nodes)
	populate(objectMap, "pushedVersion", s.PushedVersion)
	populateTimeRFC3339(objectMap, "scheduledUpdateDate", s.ScheduledUpdateDate)
	populate(objectMap, "serviceUrls", s.ServiceUrls)
	populate(objectMap, "taskQueueId", s.TaskQueueID)
	populate(objectMap, "updateDelayOffset", s.UpdateDelayOffset)
	populate(objectMap, "version", s.Version)
	populate(objectMap, "versionStatus", s.VersionStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeStatusTypeProperties.
func (s *SelfHostedIntegrationRuntimeStatusTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpdate":
			err = unpopulate(val, &s.AutoUpdate)
			delete(rawMsg, key)
		case "autoUpdateETA":
			err = unpopulateTimeRFC3339(val, &s.AutoUpdateETA)
			delete(rawMsg, key)
		case "capabilities":
			err = unpopulate(val, &s.Capabilities)
			delete(rawMsg, key)
		case "createTime":
			err = unpopulateTimeRFC3339(val, &s.CreateTime)
			delete(rawMsg, key)
		case "internalChannelEncryption":
			err = unpopulate(val, &s.InternalChannelEncryption)
			delete(rawMsg, key)
		case "latestVersion":
			err = unpopulate(val, &s.LatestVersion)
			delete(rawMsg, key)
		case "links":
			err = unpopulate(val, &s.Links)
			delete(rawMsg, key)
		case "localTimeZoneOffset":
			err = unpopulate(val, &s.LocalTimeZoneOffset)
			delete(rawMsg, key)
		case "nodeCommunicationChannelEncryptionMode":
			err = unpopulate(val, &s.NodeCommunicationChannelEncryptionMode)
			delete(rawMsg, key)
		case "nodes":
			err = unpopulate(val, &s.Nodes)
			delete(rawMsg, key)
		case "pushedVersion":
			err = unpopulate(val, &s.PushedVersion)
			delete(rawMsg, key)
		case "scheduledUpdateDate":
			err = unpopulateTimeRFC3339(val, &s.ScheduledUpdateDate)
			delete(rawMsg, key)
		case "serviceUrls":
			err = unpopulate(val, &s.ServiceUrls)
			delete(rawMsg, key)
		case "taskQueueId":
			err = unpopulate(val, &s.TaskQueueID)
			delete(rawMsg, key)
		case "updateDelayOffset":
			err = unpopulate(val, &s.UpdateDelayOffset)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		case "versionStatus":
			err = unpopulate(val, &s.VersionStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SelfHostedIntegrationRuntimeTypeProperties - The self-hosted integration runtime properties.
type SelfHostedIntegrationRuntimeTypeProperties struct {
	// Linked integration runtime type from data factory
	LinkedInfo LinkedIntegrationRuntimeTypeClassification `json:"linkedInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s SelfHostedIntegrationRuntimeTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "linkedInfo", s.LinkedInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s *SelfHostedIntegrationRuntimeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedInfo":
			s.LinkedInfo, err = unmarshalLinkedIntegrationRuntimeTypeClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SensitivityLabel - A sensitivity label.
type SensitivityLabel struct {
	ProxyResource
	// Resource properties.
	Properties *SensitivityLabelProperties `json:"properties,omitempty"`

	// READ-ONLY; managed by
	ManagedBy *string `json:"managedBy,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SensitivityLabel.
func (s SensitivityLabel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "managedBy", s.ManagedBy)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SensitivityLabel.
func (s *SensitivityLabel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managedBy":
			err = unpopulate(val, &s.ManagedBy)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SensitivityLabelListResult - A list of sensitivity labels.
type SensitivityLabelListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*SensitivityLabel `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SensitivityLabelListResult.
func (s SensitivityLabelListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SensitivityLabelProperties - Properties of a sensitivity label.
type SensitivityLabelProperties struct {
	// The information type.
	InformationType *string `json:"informationType,omitempty"`

	// The information type ID.
	InformationTypeID *string `json:"informationTypeId,omitempty"`

	// The label ID.
	LabelID *string `json:"labelId,omitempty"`

	// The label name.
	LabelName *string               `json:"labelName,omitempty"`
	Rank      *SensitivityLabelRank `json:"rank,omitempty"`

	// READ-ONLY; The column name.
	ColumnName *string `json:"columnName,omitempty" azure:"ro"`

	// READ-ONLY; Is sensitivity recommendation disabled. Applicable for recommended sensitivity label only. Specifies whether the sensitivity recommendation
	// on this column is disabled (dismissed) or not.
	IsDisabled *bool `json:"isDisabled,omitempty" azure:"ro"`

	// READ-ONLY; The schema name.
	SchemaName *string `json:"schemaName,omitempty" azure:"ro"`

	// READ-ONLY; The table name.
	TableName *string `json:"tableName,omitempty" azure:"ro"`
}

// SensitivityLabelUpdate - A sensitivity label update operation.
type SensitivityLabelUpdate struct {
	ProxyResource
	// Resource properties.
	Properties *SensitivityLabelUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SensitivityLabelUpdate.
func (s SensitivityLabelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SensitivityLabelUpdate.
func (s *SensitivityLabelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SensitivityLabelUpdateList - A list of sensitivity label update operations.
type SensitivityLabelUpdateList struct {
	Operations []*SensitivityLabelUpdate `json:"operations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SensitivityLabelUpdateList.
func (s SensitivityLabelUpdateList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operations", s.Operations)
	return json.Marshal(objectMap)
}

// SensitivityLabelUpdateProperties - Properties of an operation executed on a sensitivity label.
type SensitivityLabelUpdateProperties struct {
	// REQUIRED; Column name to update.
	Column *string `json:"column,omitempty"`

	// REQUIRED
	Op *SensitivityLabelUpdateKind `json:"op,omitempty"`

	// REQUIRED; Schema name of the column to update.
	Schema *string `json:"schema,omitempty"`

	// REQUIRED; Table name of the column to update.
	Table *string `json:"table,omitempty"`

	// The sensitivity label information to apply on a column.
	SensitivityLabel *SensitivityLabel `json:"sensitivityLabel,omitempty"`
}

// ServerBlobAuditingPolicy - A server blob auditing policy.
type ServerBlobAuditingPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *ServerBlobAuditingPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerBlobAuditingPolicy.
func (s ServerBlobAuditingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerBlobAuditingPolicy.
func (s *ServerBlobAuditingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServerBlobAuditingPolicyListResult - A list of server auditing settings.
type ServerBlobAuditingPolicyListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*ServerBlobAuditingPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerBlobAuditingPolicyListResult.
func (s ServerBlobAuditingPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServerBlobAuditingPolicyProperties - Properties of a server blob auditing policy.
type ServerBlobAuditingPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
	State *BlobAuditingPolicyState `json:"state,omitempty"`

	// Specifies the Actions-Groups and Actions to audit.
	// The recommended set of action groups to use is the following combination - this will audit all the queries and stored procedures executed against the
	// database, as well as successful and failed logins:
	// BATCHCOMPLETEDGROUP, SUCCESSFULDATABASEAUTHENTICATIONGROUP, FAILEDDATABASEAUTHENTICATIONGROUP.
	// This above combination is also the set that is configured by default when enabling auditing from the Azure portal.
	// The supported action groups to audit are (note: choose only specific groups that cover your auditing needs. Using unnecessary groups could lead to very
	// large quantities of audit records):
	// APPLICATIONROLECHANGEPASSWORDGROUP BACKUPRESTOREGROUP DATABASELOGOUTGROUP DATABASEOBJECTCHANGEGROUP DATABASEOBJECTOWNERSHIPCHANGEGROUP DATABASEOBJECTPERMISSIONCHANGEGROUP
	// DATABASEOPERATIONGROUP
	// DATABASEPERMISSIONCHANGEGROUP DATABASEPRINCIPALCHANGEGROUP DATABASEPRINCIPALIMPERSONATIONGROUP DATABASEROLEMEMBERCHANGEGROUP FAILEDDATABASEAUTHENTICATIONGROUP
	// SCHEMAOBJECTACCESSGROUP SCHEMAOBJECT
	// CHANGEGROUP SCHEMAOBJECTOWNERSHIPCHANGEGROUP SCHEMAOBJECTPERMISSIONCHANGEGROUP SUCCESSFULDATABASEAUTHENTICATIONGROUP USERCHANGEPASSWORDGROUP BATCHSTARTEDGROUP
	// BATCHCOMPLETED_GROUP
	// These are groups that cover all sql statements and stored procedures executed against the database, and should not be used in combination with other
	// groups as this will result in duplicate audit logs.
	// For more information, see Database-Level Audit Action Groups
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-action-groups].
	// For Database auditing policy, specific Actions can also be specified (note that Actions cannot be specified for Server auditing policy). The supported
	// actions to audit are: SELECT UPDATE INSERT DELETE
	// EXECUTE RECEIVE REFERENCES
	// The general form for defining an action to be audited is: {action} ON {object} BY {principal}
	// Note that in the above format can refer to an object like a table, view, or stored procedure, or an entire database or schema. For the latter cases,
	// the forms DATABASE::{dbname} and SCHEMA::{schema
	// name} are used, respectively.
	// For example: SELECT on dbo.myTable by public SELECT on DATABASE::myDatabase by public SELECT on SCHEMA::mySchema by public
	// For more information, see Database-Level Audit Actions
	// [https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-actions]
	AuditActionsAndGroups []*string `json:"auditActionsAndGroups,omitempty"`

	// Specifies whether audit events are sent to Azure Monitor. In order to send the events to Azure Monitor, specify 'state' as 'Enabled' and 'isAzureMonitorTargetEnabled'
	// as true.
	// When using REST API to configure auditing, Diagnostic Settings with 'SQLSecurityAuditEvents' diagnostic logs category on the database should be also
	// created. Note that for server level audit you
	// should use the 'master' database as {databaseName}.
	// Diagnostic Settings URI format: PUT
	// https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/providers/microsoft.insights/diagnosticSettings/{settingsName}?api-version=2017-05-01-preview
	// For more information, see Diagnostic Settings REST API [https://go.microsoft.com/fwlink/?linkid=2033207]or Diagnostic Settings PowerShell [https://go.microsoft.com/fwlink/?linkid=2033043]
	IsAzureMonitorTargetEnabled *bool `json:"isAzureMonitorTargetEnabled,omitempty"`

	// Specifies whether storageAccountAccessKey value is the storage's secondary key.
	IsStorageSecondaryKeyInUse *bool `json:"isStorageSecondaryKeyInUse,omitempty"`

	// Specifies the amount of time in milliseconds that can elapse before audit actions are forced to be processed. The default minimum value is 1000 (1 second).
	// The maximum is 2,147,483,647.
	QueueDelayMs *int32 `json:"queueDelayMs,omitempty"`

	// Specifies the number of days to keep in the audit logs in the storage account.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the auditing storage account. If state is Enabled and storageEndpoint is specified, not specifying the storageAccountAccessKey
	// will use SQL server system-assigned
	// managed identity to access the storage. Prerequisites for using managed identity authentication:
	// 1. Assign SQL Server a system-assigned managed identity in Azure Active Directory (AAD).
	// 2. Grant SQL Server identity access to the storage account by adding 'Storage Blob Data Contributor' RBAC role to the server identity. For more information,
	// see Auditing to storage using Managed
	// Identity authentication [https://go.microsoft.com/fwlink/?linkid=2114355]
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage subscription Id.
	StorageAccountSubscriptionID *string `json:"storageAccountSubscriptionId,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled
	// is required.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerBlobAuditingPolicyProperties.
func (s ServerBlobAuditingPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "auditActionsAndGroups", s.AuditActionsAndGroups)
	populate(objectMap, "isAzureMonitorTargetEnabled", s.IsAzureMonitorTargetEnabled)
	populate(objectMap, "isStorageSecondaryKeyInUse", s.IsStorageSecondaryKeyInUse)
	populate(objectMap, "queueDelayMs", s.QueueDelayMs)
	populate(objectMap, "retentionDays", s.RetentionDays)
	populate(objectMap, "state", s.State)
	populate(objectMap, "storageAccountAccessKey", s.StorageAccountAccessKey)
	populate(objectMap, "storageAccountSubscriptionId", s.StorageAccountSubscriptionID)
	populate(objectMap, "storageEndpoint", s.StorageEndpoint)
	return json.Marshal(objectMap)
}

// ServerSecurityAlertPolicy - Workspace managed Sql server security alert policy.
type ServerSecurityAlertPolicy struct {
	ProxyResource
	// Resource properties.
	Properties *ServerSecurityAlertPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerSecurityAlertPolicy.
func (s ServerSecurityAlertPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerSecurityAlertPolicy.
func (s *ServerSecurityAlertPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServerSecurityAlertPolicyListResult - A list of the workspace managed sql server's security alert policies.
type ServerSecurityAlertPolicyListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*ServerSecurityAlertPolicy `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerSecurityAlertPolicyListResult.
func (s ServerSecurityAlertPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServerSecurityAlertPolicyProperties - Properties of a security alert policy.
type ServerSecurityAlertPolicyProperties struct {
	// REQUIRED; Specifies the state of the policy, whether it is enabled or disabled or a policy has not been applied yet on the specific server
	State *SecurityAlertPolicyState `json:"state,omitempty"`

	// Specifies an array of alerts that are disabled. Allowed values are: SqlInjection, SqlInjectionVulnerability, AccessAnomaly, DataExfiltration, UnsafeAction
	DisabledAlerts []*string `json:"disabledAlerts,omitempty"`

	// Specifies that the alert is sent to the account administrators.
	EmailAccountAdmins *bool `json:"emailAccountAdmins,omitempty"`

	// Specifies an array of e-mail addresses to which the alert is sent.
	EmailAddresses []*string `json:"emailAddresses,omitempty"`

	// Specifies the number of days to keep in the Threat Detection audit logs.
	RetentionDays *int32 `json:"retentionDays,omitempty"`

	// Specifies the identifier key of the Threat Detection audit storage account.
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs.
	StorageEndpoint *string `json:"storageEndpoint,omitempty"`

	// READ-ONLY; Specifies the UTC creation time of the policy.
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerSecurityAlertPolicyProperties.
func (s ServerSecurityAlertPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "creationTime", s.CreationTime)
	populate(objectMap, "disabledAlerts", s.DisabledAlerts)
	populate(objectMap, "emailAccountAdmins", s.EmailAccountAdmins)
	populate(objectMap, "emailAddresses", s.EmailAddresses)
	populate(objectMap, "retentionDays", s.RetentionDays)
	populate(objectMap, "state", s.State)
	populate(objectMap, "storageAccountAccessKey", s.StorageAccountAccessKey)
	populate(objectMap, "storageEndpoint", s.StorageEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerSecurityAlertPolicyProperties.
func (s *ServerSecurityAlertPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &s.CreationTime)
			delete(rawMsg, key)
		case "disabledAlerts":
			err = unpopulate(val, &s.DisabledAlerts)
			delete(rawMsg, key)
		case "emailAccountAdmins":
			err = unpopulate(val, &s.EmailAccountAdmins)
			delete(rawMsg, key)
		case "emailAddresses":
			err = unpopulate(val, &s.EmailAddresses)
			delete(rawMsg, key)
		case "retentionDays":
			err = unpopulate(val, &s.RetentionDays)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &s.State)
			delete(rawMsg, key)
		case "storageAccountAccessKey":
			err = unpopulate(val, &s.StorageAccountAccessKey)
			delete(rawMsg, key)
		case "storageEndpoint":
			err = unpopulate(val, &s.StorageEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServerUsage - Represents server metrics.
type ServerUsage struct {
	// READ-ONLY; The current value of the metric.
	CurrentValue *float64 `json:"currentValue,omitempty" azure:"ro"`

	// READ-ONLY; The metric display name.
	DisplayName *string `json:"displayName,omitempty" azure:"ro"`

	// READ-ONLY; The current limit of the metric.
	Limit *float64 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; Name of the server usage metric.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The next reset time for the metric (ISO8601 format).
	NextResetTime *time.Time `json:"nextResetTime,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource.
	ResourceName *string `json:"resourceName,omitempty" azure:"ro"`

	// READ-ONLY; The units of the metric.
	Unit *string `json:"unit,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerUsage.
func (s ServerUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentValue", s.CurrentValue)
	populate(objectMap, "displayName", s.DisplayName)
	populate(objectMap, "limit", s.Limit)
	populate(objectMap, "name", s.Name)
	populateTimeRFC3339(objectMap, "nextResetTime", s.NextResetTime)
	populate(objectMap, "resourceName", s.ResourceName)
	populate(objectMap, "unit", s.Unit)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerUsage.
func (s *ServerUsage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentValue":
			err = unpopulate(val, &s.CurrentValue)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &s.DisplayName)
			delete(rawMsg, key)
		case "limit":
			err = unpopulate(val, &s.Limit)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "nextResetTime":
			err = unpopulateTimeRFC3339(val, &s.NextResetTime)
			delete(rawMsg, key)
		case "resourceName":
			err = unpopulate(val, &s.ResourceName)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, &s.Unit)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServerUsageListResult - Represents the response to a list server metrics request.
type ServerUsageListResult struct {
	// REQUIRED; The list of server metrics for the server.
	Value []*ServerUsage `json:"value,omitempty"`

	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerUsageListResult.
func (s ServerUsageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServerVulnerabilityAssessment - A server vulnerability assessment.
type ServerVulnerabilityAssessment struct {
	ProxyResource
	// Resource properties.
	Properties *ServerVulnerabilityAssessmentProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerVulnerabilityAssessment.
func (s ServerVulnerabilityAssessment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServerVulnerabilityAssessment.
func (s *ServerVulnerabilityAssessment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ServerVulnerabilityAssessmentListResult - A list of the server's vulnerability assessments.
type ServerVulnerabilityAssessmentListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*ServerVulnerabilityAssessment `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ServerVulnerabilityAssessmentListResult.
func (s ServerVulnerabilityAssessmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServerVulnerabilityAssessmentProperties - Properties of a server Vulnerability Assessment.
type ServerVulnerabilityAssessmentProperties struct {
	// REQUIRED; A blob storage container path to hold the scan results (e.g. https://myStorage.blob.core.windows.net/VaScans/).
	StorageContainerPath *string `json:"storageContainerPath,omitempty"`

	// The recurring scans settings
	RecurringScans *VulnerabilityAssessmentRecurringScansProperties `json:"recurringScans,omitempty"`

	// Specifies the identifier key of the storage account for vulnerability assessment scan results. If 'StorageContainerSasKey' isn't specified, storageAccountAccessKey
	// is required.
	StorageAccountAccessKey *string `json:"storageAccountAccessKey,omitempty"`

	// A shared access signature (SAS Key) that has read and write access to the blob container specified in 'storageContainerPath' parameter. If 'storageAccountAccessKey'
	// isn't specified,
	// StorageContainerSasKey is required.
	StorageContainerSasKey *string `json:"storageContainerSasKey,omitempty"`
}

// SparkConfigProperties - SparkConfig Properties for a Big Data pool powered by Apache Spark
type SparkConfigProperties struct {
	// The type of the spark config properties file.
	ConfigurationType *ConfigurationType `json:"configurationType,omitempty"`

	// The spark config properties.
	Content *string `json:"content,omitempty"`

	// The filename of the spark config properties file.
	Filename *string `json:"filename,omitempty"`

	// READ-ONLY; The last update time of the spark config properties file.
	Time *time.Time `json:"time,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkConfigProperties.
func (s SparkConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "configurationType", s.ConfigurationType)
	populate(objectMap, "content", s.Content)
	populate(objectMap, "filename", s.Filename)
	populateTimeRFC3339(objectMap, "time", s.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkConfigProperties.
func (s *SparkConfigProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurationType":
			err = unpopulate(val, &s.ConfigurationType)
			delete(rawMsg, key)
		case "content":
			err = unpopulate(val, &s.Content)
			delete(rawMsg, key)
		case "filename":
			err = unpopulate(val, &s.Filename)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &s.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkConfigurationGetOptions contains the optional parameters for the SparkConfiguration.Get method.
type SparkConfigurationGetOptions struct {
	// placeholder for future optional parameters
}

// SparkConfigurationInfo - SparkConfiguration Artifact information
type SparkConfigurationInfo struct {
	// REQUIRED; SparkConfiguration configs.
	Configs map[string]*string `json:"configs,omitempty"`

	// Annotations for SparkConfiguration.
	Annotations []*string `json:"annotations,omitempty"`

	// The timestamp of resource creation.
	Created *time.Time `json:"created,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Description about the SparkConfiguration.
	Description *string `json:"description,omitempty"`

	// additional Notes.
	Notes *string `json:"notes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkConfigurationInfo.
func (s SparkConfigurationInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", s.Annotations)
	populate(objectMap, "configs", s.Configs)
	populateTimeRFC3339(objectMap, "created", s.Created)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "notes", s.Notes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkConfigurationInfo.
func (s *SparkConfigurationInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			err = unpopulate(val, &s.Annotations)
			delete(rawMsg, key)
		case "configs":
			err = unpopulate(val, &s.Configs)
			delete(rawMsg, key)
		case "created":
			err = unpopulateTimeRFC3339(val, &s.Created)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "notes":
			err = unpopulate(val, &s.Notes)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkConfigurationListResponse - A list of SparkConfiguration resources.
type SparkConfigurationListResponse struct {
	// REQUIRED; List of SparkConfiguration.
	Value []*SparkConfigurationResource `json:"value,omitempty"`

	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkConfigurationListResponse.
func (s SparkConfigurationListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SparkConfigurationResource - SparkConfiguration response details
type SparkConfigurationResource struct {
	SubResource
	// REQUIRED; SparkConfiguration properties.
	Properties *SparkConfigurationInfo `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkConfigurationResource.
func (s SparkConfigurationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SubResource.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkConfigurationResource.
func (s *SparkConfigurationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SubResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SparkConfigurationsListByWorkspaceOptions contains the optional parameters for the SparkConfigurations.ListByWorkspace method.
type SparkConfigurationsListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// SsisEnvironment - Ssis environment.
type SsisEnvironment struct {
	SsisObjectMetadata
	// Folder id which contains environment.
	FolderID *int64 `json:"folderId,omitempty"`

	// Variable in environment
	Variables []*SsisVariable `json:"variables,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SsisEnvironment.
func (s SsisEnvironment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SsisObjectMetadata.marshalInternal(objectMap, SsisObjectMetadataTypeEnvironment)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "variables", s.Variables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisEnvironment.
func (s *SsisEnvironment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "variables":
			err = unpopulate(val, &s.Variables)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SsisObjectMetadata.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SsisEnvironmentReference - Ssis environment reference.
type SsisEnvironmentReference struct {
	// Environment folder name.
	EnvironmentFolderName *string `json:"environmentFolderName,omitempty"`

	// Environment name.
	EnvironmentName *string `json:"environmentName,omitempty"`

	// Environment reference id.
	ID *int64 `json:"id,omitempty"`

	// Reference type
	ReferenceType *string `json:"referenceType,omitempty"`
}

// SsisFolder - Ssis folder.
type SsisFolder struct {
	SsisObjectMetadata
}

// MarshalJSON implements the json.Marshaller interface for type SsisFolder.
func (s SsisFolder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SsisObjectMetadata.marshalInternal(objectMap, SsisObjectMetadataTypeFolder)
	return json.Marshal(objectMap)
}

// SsisObjectMetadataClassification provides polymorphic access to related types.
// Call the interface's GetSsisObjectMetadata() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SsisEnvironment, *SsisFolder, *SsisObjectMetadata, *SsisPackage, *SsisProject
type SsisObjectMetadataClassification interface {
	// GetSsisObjectMetadata returns the SsisObjectMetadata content of the underlying type.
	GetSsisObjectMetadata() *SsisObjectMetadata
}

// SsisObjectMetadata - SSIS object metadata.
type SsisObjectMetadata struct {
	// REQUIRED; Type of metadata.
	Type *SsisObjectMetadataType `json:"type,omitempty"`

	// Metadata description.
	Description *string `json:"description,omitempty"`

	// Metadata id.
	ID *int64 `json:"id,omitempty"`

	// Metadata name.
	Name *string `json:"name,omitempty"`
}

// GetSsisObjectMetadata implements the SsisObjectMetadataClassification interface for type SsisObjectMetadata.
func (s *SsisObjectMetadata) GetSsisObjectMetadata() *SsisObjectMetadata { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadata.
func (s *SsisObjectMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SsisObjectMetadata) marshalInternal(objectMap map[string]interface{}, discValue SsisObjectMetadataType) {
	populate(objectMap, "description", s.Description)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	s.Type = &discValue
	objectMap["type"] = s.Type
}

func (s *SsisObjectMetadata) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, &s.Description)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisObjectMetadataListResponse - A list of SSIS object metadata.
type SsisObjectMetadataListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of SSIS object metadata.
	Value []SsisObjectMetadataClassification `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SsisObjectMetadataListResponse.
func (s SsisObjectMetadataListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisObjectMetadataListResponse.
func (s *SsisObjectMetadataListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, &s.NextLink)
			delete(rawMsg, key)
		case "value":
			s.Value, err = unmarshalSsisObjectMetadataClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SsisObjectMetadataStatusResponse - The status of the operation.
type SsisObjectMetadataStatusResponse struct {
	// The operation error message.
	Error *string `json:"error,omitempty"`

	// The operation name.
	Name *string `json:"name,omitempty"`

	// The operation properties.
	Properties *string `json:"properties,omitempty"`

	// The status of the operation.
	Status *string `json:"status,omitempty"`
}

// SsisPackage - Ssis Package.
type SsisPackage struct {
	SsisObjectMetadata
	// Folder id which contains package.
	FolderID *int64 `json:"folderId,omitempty"`

	// Parameters in package
	Parameters []*SsisParameter `json:"parameters,omitempty"`

	// Project id which contains package.
	ProjectID *int64 `json:"projectId,omitempty"`

	// Project version which contains package.
	ProjectVersion *int64 `json:"projectVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SsisPackage.
func (s SsisPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SsisObjectMetadata.marshalInternal(objectMap, SsisObjectMetadataTypePackage)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "projectId", s.ProjectID)
	populate(objectMap, "projectVersion", s.ProjectVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisPackage.
func (s *SsisPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "projectId":
			err = unpopulate(val, &s.ProjectID)
			delete(rawMsg, key)
		case "projectVersion":
			err = unpopulate(val, &s.ProjectVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SsisObjectMetadata.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SsisParameter - Ssis parameter.
type SsisParameter struct {
	// Parameter type.
	DataType *string `json:"dataType,omitempty"`

	// Default value of parameter.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Parameter description.
	Description *string `json:"description,omitempty"`

	// Design default value of parameter.
	DesignDefaultValue *string `json:"designDefaultValue,omitempty"`

	// Parameter id.
	ID *int64 `json:"id,omitempty"`

	// Parameter name.
	Name *string `json:"name,omitempty"`

	// Whether parameter is required.
	Required *bool `json:"required,omitempty"`

	// Whether parameter is sensitive.
	Sensitive *bool `json:"sensitive,omitempty"`

	// Default sensitive value of parameter.
	SensitiveDefaultValue *string `json:"sensitiveDefaultValue,omitempty"`

	// Parameter value set.
	ValueSet *bool `json:"valueSet,omitempty"`

	// Parameter value type.
	ValueType *string `json:"valueType,omitempty"`

	// Parameter reference variable.
	Variable *string `json:"variable,omitempty"`
}

// SsisProject - Ssis project.
type SsisProject struct {
	SsisObjectMetadata
	// Environment reference in project
	EnvironmentRefs []*SsisEnvironmentReference `json:"environmentRefs,omitempty"`

	// Folder id which contains project.
	FolderID *int64 `json:"folderId,omitempty"`

	// Parameters in project
	Parameters []*SsisParameter `json:"parameters,omitempty"`

	// Project version.
	Version *int64 `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SsisProject.
func (s SsisProject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.SsisObjectMetadata.marshalInternal(objectMap, SsisObjectMetadataTypeProject)
	populate(objectMap, "environmentRefs", s.EnvironmentRefs)
	populate(objectMap, "folderId", s.FolderID)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisProject.
func (s *SsisProject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "environmentRefs":
			err = unpopulate(val, &s.EnvironmentRefs)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, &s.FolderID)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, &s.Parameters)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.SsisObjectMetadata.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SsisVariable - Ssis variable.
type SsisVariable struct {
	// Variable type.
	DataType *string `json:"dataType,omitempty"`

	// Variable description.
	Description *string `json:"description,omitempty"`

	// Variable id.
	ID *int64 `json:"id,omitempty"`

	// Variable name.
	Name *string `json:"name,omitempty"`

	// Whether variable is sensitive.
	Sensitive *bool `json:"sensitive,omitempty"`

	// Variable sensitive value.
	SensitiveValue *string `json:"sensitiveValue,omitempty"`

	// Variable value.
	Value *string `json:"value,omitempty"`
}

// SubResource - Azure Synapse nested resource, which belongs to a workspace.
type SubResource struct {
	AzureEntityResource
}

func (s SubResource) marshalInternal(objectMap map[string]interface{}) {
	s.AzureEntityResource.marshalInternal(objectMap)
}

func (s *SubResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := s.AzureEntityResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TableLevelSharingProperties - Tables that will be included and excluded in the follower database
type TableLevelSharingProperties struct {
	// List of external tables exclude from the follower database
	ExternalTablesToExclude []*string `json:"externalTablesToExclude,omitempty"`

	// List of external tables to include in the follower database
	ExternalTablesToInclude []*string `json:"externalTablesToInclude,omitempty"`

	// List of materialized views exclude from the follower database
	MaterializedViewsToExclude []*string `json:"materializedViewsToExclude,omitempty"`

	// List of materialized views to include in the follower database
	MaterializedViewsToInclude []*string `json:"materializedViewsToInclude,omitempty"`

	// List of tables to exclude from the follower database
	TablesToExclude []*string `json:"tablesToExclude,omitempty"`

	// List of tables to include in the follower database
	TablesToInclude []*string `json:"tablesToInclude,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TableLevelSharingProperties.
func (t TableLevelSharingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "externalTablesToExclude", t.ExternalTablesToExclude)
	populate(objectMap, "externalTablesToInclude", t.ExternalTablesToInclude)
	populate(objectMap, "materializedViewsToExclude", t.MaterializedViewsToExclude)
	populate(objectMap, "materializedViewsToInclude", t.MaterializedViewsToInclude)
	populate(objectMap, "tablesToExclude", t.TablesToExclude)
	populate(objectMap, "tablesToInclude", t.TablesToInclude)
	return json.Marshal(objectMap)
}

// TopQueries - A database query.
type TopQueries struct {
	// READ-ONLY; The function that is used to aggregate each query's metrics.
	AggregationFunction *QueryAggregationFunction `json:"aggregationFunction,omitempty" azure:"ro"`

	// READ-ONLY; The execution type that is used to filter the query instances that are returned.
	ExecutionType *QueryExecutionType `json:"executionType,omitempty" azure:"ro"`

	// READ-ONLY; The duration of the interval (ISO8601 duration format).
	IntervalType *string `json:"intervalType,omitempty" azure:"ro"`

	// READ-ONLY; The number of requested queries.
	NumberOfTopQueries *int32 `json:"numberOfTopQueries,omitempty" azure:"ro"`

	// READ-ONLY; The end time for queries that are returned (ISO8601 format)
	ObservationEndTime *time.Time `json:"observationEndTime,omitempty" azure:"ro"`

	// READ-ONLY; The start time for queries that are returned (ISO8601 format)
	ObservationStartTime *time.Time `json:"observationStartTime,omitempty" azure:"ro"`

	// READ-ONLY; The type of metric to use for ordering the top metrics.
	ObservedMetric *QueryObservedMetricType `json:"observedMetric,omitempty" azure:"ro"`

	// READ-ONLY; The list of queries.
	Queries []*QueryStatistic `json:"queries,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TopQueries.
func (t TopQueries) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aggregationFunction", t.AggregationFunction)
	populate(objectMap, "executionType", t.ExecutionType)
	populate(objectMap, "intervalType", t.IntervalType)
	populate(objectMap, "numberOfTopQueries", t.NumberOfTopQueries)
	populateTimeRFC3339(objectMap, "observationEndTime", t.ObservationEndTime)
	populateTimeRFC3339(objectMap, "observationStartTime", t.ObservationStartTime)
	populate(objectMap, "observedMetric", t.ObservedMetric)
	populate(objectMap, "queries", t.Queries)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopQueries.
func (t *TopQueries) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aggregationFunction":
			err = unpopulate(val, &t.AggregationFunction)
			delete(rawMsg, key)
		case "executionType":
			err = unpopulate(val, &t.ExecutionType)
			delete(rawMsg, key)
		case "intervalType":
			err = unpopulate(val, &t.IntervalType)
			delete(rawMsg, key)
		case "numberOfTopQueries":
			err = unpopulate(val, &t.NumberOfTopQueries)
			delete(rawMsg, key)
		case "observationEndTime":
			err = unpopulateTimeRFC3339(val, &t.ObservationEndTime)
			delete(rawMsg, key)
		case "observationStartTime":
			err = unpopulateTimeRFC3339(val, &t.ObservationStartTime)
			delete(rawMsg, key)
		case "observedMetric":
			err = unpopulate(val, &t.ObservedMetric)
			delete(rawMsg, key)
		case "queries":
			err = unpopulate(val, &t.Queries)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopQueriesListResult - Represents the response to a get top queries request.
type TopQueriesListResult struct {
	// REQUIRED; The list of top queries.
	Value []*TopQueries `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopQueriesListResult.
func (t TopQueriesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TrackedResource - The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
type TrackedResource struct {
	Resource
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

func (t *TrackedResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &t.Location)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &t.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TransparentDataEncryption - Represents a Sql pool transparent data encryption configuration.
type TransparentDataEncryption struct {
	ProxyResource
	// Represents the properties of the resource.
	Properties *TransparentDataEncryptionProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource location.
	Location *string `json:"location,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TransparentDataEncryption.
func (t TransparentDataEncryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransparentDataEncryption.
func (t *TransparentDataEncryption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &t.Location)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TransparentDataEncryptionListResult - A list of transparent data encryption configurations.
type TransparentDataEncryptionListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*TransparentDataEncryption `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TransparentDataEncryptionListResult.
func (t TransparentDataEncryptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TransparentDataEncryptionProperties - Represents the properties of a database transparent data encryption.
type TransparentDataEncryptionProperties struct {
	// The status of the database transparent data encryption.
	Status *TransparentDataEncryptionStatus `json:"status,omitempty"`
}

// UpdateIntegrationRuntimeNodeRequest - Update integration runtime node request.
type UpdateIntegrationRuntimeNodeRequest struct {
	// The number of concurrent jobs permitted to run on the integration runtime node. Values between 1 and maxConcurrentJobs(inclusive) are allowed.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeNodeRequest.
func (u UpdateIntegrationRuntimeNodeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "concurrentJobsLimit", u.ConcurrentJobsLimit)
	return json.Marshal(objectMap)
}

// UpdateIntegrationRuntimeRequest - Update integration runtime request.
type UpdateIntegrationRuntimeRequest struct {
	// Enables or disables the auto-update feature of the self-hosted integration runtime. See https://go.microsoft.com/fwlink/?linkid=854189.
	AutoUpdate *IntegrationRuntimeAutoUpdate `json:"autoUpdate,omitempty"`

	// The time offset (in hours) in the day, e.g., PT03H is 3 hours. The integration runtime auto update will happen on that time.
	UpdateDelayOffset *string `json:"updateDelayOffset,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateIntegrationRuntimeRequest.
func (u UpdateIntegrationRuntimeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoUpdate", u.AutoUpdate)
	populate(objectMap, "updateDelayOffset", u.UpdateDelayOffset)
	return json.Marshal(objectMap)
}

// UserAssignedManagedIdentity - User Assigned Managed Identity
type UserAssignedManagedIdentity struct {
	// READ-ONLY; The client ID.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal ID.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// VirtualNetworkProfile - Virtual Network Profile
type VirtualNetworkProfile struct {
	// Subnet ID used for computes in workspace
	ComputeSubnetID *string `json:"computeSubnetId,omitempty"`
}

// VulnerabilityAssessmentRecurringScansProperties - Properties of a Vulnerability Assessment recurring scans.
type VulnerabilityAssessmentRecurringScansProperties struct {
	// Specifies that the schedule scan notification will be is sent to the subscription administrators.
	EmailSubscriptionAdmins *bool `json:"emailSubscriptionAdmins,omitempty"`

	// Specifies an array of e-mail addresses to which the scan notification is sent.
	Emails []*string `json:"emails,omitempty"`

	// Recurring scans state.
	IsEnabled *bool `json:"isEnabled,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VulnerabilityAssessmentRecurringScansProperties.
func (v VulnerabilityAssessmentRecurringScansProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "emailSubscriptionAdmins", v.EmailSubscriptionAdmins)
	populate(objectMap, "emails", v.Emails)
	populate(objectMap, "isEnabled", v.IsEnabled)
	return json.Marshal(objectMap)
}

// VulnerabilityAssessmentScanError - Properties of a vulnerability assessment scan error.
type VulnerabilityAssessmentScanError struct {
	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// VulnerabilityAssessmentScanRecord - A vulnerability assessment scan record.
type VulnerabilityAssessmentScanRecord struct {
	ProxyResource
	// Resource properties.
	Properties *VulnerabilityAssessmentScanRecordProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VulnerabilityAssessmentScanRecord.
func (v VulnerabilityAssessmentScanRecord) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VulnerabilityAssessmentScanRecord.
func (v *VulnerabilityAssessmentScanRecord) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VulnerabilityAssessmentScanRecordListResult - A list of vulnerability assessment scan records.
type VulnerabilityAssessmentScanRecordListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*VulnerabilityAssessmentScanRecord `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VulnerabilityAssessmentScanRecordListResult.
func (v VulnerabilityAssessmentScanRecordListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VulnerabilityAssessmentScanRecordProperties - Properties of a vulnerability assessment scan record.
type VulnerabilityAssessmentScanRecordProperties struct {
	// READ-ONLY; The scan end time (UTC).
	EndTime *time.Time `json:"endTime,omitempty" azure:"ro"`

	// READ-ONLY; The scan errors.
	Errors []*VulnerabilityAssessmentScanError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The number of failed security checks.
	NumberOfFailedSecurityChecks *int32 `json:"numberOfFailedSecurityChecks,omitempty" azure:"ro"`

	// READ-ONLY; The scan ID.
	ScanID *string `json:"scanId,omitempty" azure:"ro"`

	// READ-ONLY; The scan start time (UTC).
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The scan status.
	State *VulnerabilityAssessmentScanState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; The scan results storage container path.
	StorageContainerPath *string `json:"storageContainerPath,omitempty" azure:"ro"`

	// READ-ONLY; The scan trigger type.
	TriggerType *VulnerabilityAssessmentScanTriggerType `json:"triggerType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VulnerabilityAssessmentScanRecordProperties.
func (v VulnerabilityAssessmentScanRecordProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", v.EndTime)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "numberOfFailedSecurityChecks", v.NumberOfFailedSecurityChecks)
	populate(objectMap, "scanId", v.ScanID)
	populateTimeRFC3339(objectMap, "startTime", v.StartTime)
	populate(objectMap, "state", v.State)
	populate(objectMap, "storageContainerPath", v.StorageContainerPath)
	populate(objectMap, "triggerType", v.TriggerType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VulnerabilityAssessmentScanRecordProperties.
func (v *VulnerabilityAssessmentScanRecordProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &v.EndTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "numberOfFailedSecurityChecks":
			err = unpopulate(val, &v.NumberOfFailedSecurityChecks)
			delete(rawMsg, key)
		case "scanId":
			err = unpopulate(val, &v.ScanID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &v.StartTime)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "storageContainerPath":
			err = unpopulate(val, &v.StorageContainerPath)
			delete(rawMsg, key)
		case "triggerType":
			err = unpopulate(val, &v.TriggerType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WorkloadClassifier - Workload classifier operations for a data warehouse
type WorkloadClassifier struct {
	ProxyResource
	// Resource properties.
	Properties *WorkloadClassifierProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadClassifier.
func (w WorkloadClassifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadClassifier.
func (w *WorkloadClassifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WorkloadClassifierListResult - A list of workload classifiers for a workload group.
type WorkloadClassifierListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*WorkloadClassifier `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadClassifierListResult.
func (w WorkloadClassifierListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WorkloadClassifierProperties - Workload classifier definition. For more information look at sys.workloadmanagementworkload_classifiers (DMV).
type WorkloadClassifierProperties struct {
	// REQUIRED; The workload classifier member name.
	MemberName *string `json:"memberName,omitempty"`

	// The workload classifier context.
	Context *string `json:"context,omitempty"`

	// The workload classifier end time for classification.
	EndTime *string `json:"endTime,omitempty"`

	// The workload classifier importance.
	Importance *string `json:"importance,omitempty"`

	// The workload classifier label.
	Label *string `json:"label,omitempty"`

	// The workload classifier start time for classification.
	StartTime *string `json:"startTime,omitempty"`
}

// WorkloadGroup - Workload group operations for a sql pool
type WorkloadGroup struct {
	ProxyResource
	// Resource properties.
	Properties *WorkloadGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadGroup.
func (w WorkloadGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadGroup.
func (w *WorkloadGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WorkloadGroupListResult - A list of workload groups.
type WorkloadGroupListResult struct {
	// READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Array of results.
	Value []*WorkloadGroup `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadGroupListResult.
func (w WorkloadGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WorkloadGroupProperties - Workload group definition. For more information look at sys.workloadmanagementworkload_groups (DMV).
type WorkloadGroupProperties struct {
	// REQUIRED; The workload group cap percentage resource.
	MaxResourcePercent *int32 `json:"maxResourcePercent,omitempty"`

	// REQUIRED; The workload group minimum percentage resource.
	MinResourcePercent *int32 `json:"minResourcePercent,omitempty"`

	// REQUIRED; The workload group request minimum grant percentage.
	MinResourcePercentPerRequest *float64 `json:"minResourcePercentPerRequest,omitempty"`

	// The workload group importance level.
	Importance *string `json:"importance,omitempty"`

	// The workload group request maximum grant percentage.
	MaxResourcePercentPerRequest *float64 `json:"maxResourcePercentPerRequest,omitempty"`

	// The workload group query execution timeout.
	QueryExecutionTimeout *int32 `json:"queryExecutionTimeout,omitempty"`
}

// Workspace - A workspace
type Workspace struct {
	TrackedResource
	// Identity of the workspace
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// Workspace resource properties
	Properties *WorkspaceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Workspace.
func (w *Workspace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, &w.Identity)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WorkspaceAADAdminInfo - Workspace active directory administrator
type WorkspaceAADAdminInfo struct {
	ProxyResource
	// Workspace active directory administrator properties
	Properties *AADAdminProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceAADAdminInfo.
func (w WorkspaceAADAdminInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	w.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceAADAdminInfo.
func (w *WorkspaceAADAdminInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := w.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// WorkspaceAADAdminsBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceAADAdmins.BeginCreateOrUpdate method.
type WorkspaceAADAdminsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceAADAdminsBeginDeleteOptions contains the optional parameters for the WorkspaceAADAdmins.BeginDelete method.
type WorkspaceAADAdminsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceAADAdminsGetOptions contains the optional parameters for the WorkspaceAADAdmins.Get method.
type WorkspaceAADAdminsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceInfoListResult - List of workspaces
type WorkspaceInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of workspaces
	Value []*Workspace `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceInfoListResult.
func (w WorkspaceInfoListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// WorkspaceKeyDetails - Details of the customer managed key associated with the workspace
type WorkspaceKeyDetails struct {
	// Workspace Key sub-resource key vault url
	KeyVaultURL *string `json:"keyVaultUrl,omitempty"`

	// Workspace Key sub-resource name
	Name *string `json:"name,omitempty"`
}

// WorkspaceManagedIdentitySQLControlSettingsBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedIdentitySQLControlSettings.BeginCreateOrUpdate
// method.
type WorkspaceManagedIdentitySQLControlSettingsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedIdentitySQLControlSettingsGetOptions contains the optional parameters for the WorkspaceManagedIdentitySQLControlSettings.Get method.
type WorkspaceManagedIdentitySQLControlSettingsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedSQLServerBlobAuditingPolicies.BeginCreateOrUpdate
// method.
type WorkspaceManagedSQLServerBlobAuditingPoliciesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesGetOptions contains the optional parameters for the WorkspaceManagedSQLServerBlobAuditingPolicies.Get method.
type WorkspaceManagedSQLServerBlobAuditingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceOptions contains the optional parameters for the WorkspaceManagedSQLServerBlobAuditingPolicies.ListByWorkspace
// method.
type WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerEncryptionProtectorBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedSQLServerEncryptionProtector.BeginCreateOrUpdate
// method.
type WorkspaceManagedSQLServerEncryptionProtectorBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerEncryptionProtectorBeginRevalidateOptions contains the optional parameters for the WorkspaceManagedSQLServerEncryptionProtector.BeginRevalidate
// method.
type WorkspaceManagedSQLServerEncryptionProtectorBeginRevalidateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerEncryptionProtectorGetOptions contains the optional parameters for the WorkspaceManagedSQLServerEncryptionProtector.Get method.
type WorkspaceManagedSQLServerEncryptionProtectorGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerEncryptionProtectorListOptions contains the optional parameters for the WorkspaceManagedSQLServerEncryptionProtector.List method.
type WorkspaceManagedSQLServerEncryptionProtectorListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedSQLServerExtendedBlobAuditingPolicies.BeginCreateOrUpdate
// method.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesGetOptions contains the optional parameters for the WorkspaceManagedSQLServerExtendedBlobAuditingPolicies.Get
// method.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceOptions contains the optional parameters for the WorkspaceManagedSQLServerExtendedBlobAuditingPolicies.ListByWorkspace
// method.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerRecoverableSQLPoolsGetOptions contains the optional parameters for the WorkspaceManagedSQLServerRecoverableSQLPools.Get method.
type WorkspaceManagedSQLServerRecoverableSQLPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerRecoverableSQLPoolsListOptions contains the optional parameters for the WorkspaceManagedSQLServerRecoverableSQLPools.List method.
type WorkspaceManagedSQLServerRecoverableSQLPoolsListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerSecurityAlertPolicyBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedSQLServerSecurityAlertPolicy.BeginCreateOrUpdate
// method.
type WorkspaceManagedSQLServerSecurityAlertPolicyBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerSecurityAlertPolicyGetOptions contains the optional parameters for the WorkspaceManagedSQLServerSecurityAlertPolicy.Get method.
type WorkspaceManagedSQLServerSecurityAlertPolicyGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerSecurityAlertPolicyListOptions contains the optional parameters for the WorkspaceManagedSQLServerSecurityAlertPolicy.List method.
type WorkspaceManagedSQLServerSecurityAlertPolicyListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerUsagesListOptions contains the optional parameters for the WorkspaceManagedSQLServerUsages.List method.
type WorkspaceManagedSQLServerUsagesListOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsCreateOrUpdateOptions contains the optional parameters for the WorkspaceManagedSQLServerVulnerabilityAssessments.CreateOrUpdate
// method.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsDeleteOptions contains the optional parameters for the WorkspaceManagedSQLServerVulnerabilityAssessments.Delete
// method.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsGetOptions contains the optional parameters for the WorkspaceManagedSQLServerVulnerabilityAssessments.Get
// method.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsListOptions contains the optional parameters for the WorkspaceManagedSQLServerVulnerabilityAssessments.List
// method.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsListOptions struct {
	// placeholder for future optional parameters
}

// WorkspacePatchInfo - Workspace patch details
type WorkspacePatchInfo struct {
	// The identity of the workspace
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// Workspace patch properties
	Properties *WorkspacePatchProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspacePatchInfo.
func (w WorkspacePatchInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", w.Identity)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "tags", w.Tags)
	return json.Marshal(objectMap)
}

// WorkspacePatchProperties - Workspace patch properties
type WorkspacePatchProperties struct {
	// The encryption details of the workspace
	Encryption *EncryptionDetails `json:"encryption,omitempty"`

	// Managed Virtual Network Settings
	ManagedVirtualNetworkSettings *ManagedVirtualNetworkSettings `json:"managedVirtualNetworkSettings,omitempty"`

	// Enable or Disable public network access to workspace
	PublicNetworkAccess *WorkspacePublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purview Configuration
	PurviewConfiguration *PurviewConfiguration `json:"purviewConfiguration,omitempty"`

	// SQL administrator login password
	SQLAdministratorLoginPassword *string `json:"sqlAdministratorLoginPassword,omitempty"`

	// Git integration settings
	WorkspaceRepositoryConfiguration *WorkspaceRepositoryConfiguration `json:"workspaceRepositoryConfiguration,omitempty"`

	// READ-ONLY; Resource provisioning state
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// WorkspaceProperties - Workspace properties
type WorkspaceProperties struct {
	// Enable or Disable AzureADOnlyAuthentication on All Workspace subresource
	AzureADOnlyAuthentication *bool `json:"azureADOnlyAuthentication,omitempty"`

	// Connectivity endpoints
	ConnectivityEndpoints map[string]*string `json:"connectivityEndpoints,omitempty"`

	// Initial workspace AAD admin properties for a CSP subscription
	CspWorkspaceAdminProperties *CspWorkspaceAdminProperties `json:"cspWorkspaceAdminProperties,omitempty"`

	// Workspace default data lake storage account details
	DefaultDataLakeStorage *DataLakeStorageAccountDetails `json:"defaultDataLakeStorage,omitempty"`

	// The encryption details of the workspace
	Encryption *EncryptionDetails `json:"encryption,omitempty"`

	// Workspace managed resource group. The resource group name uniquely identifies the resource group within the user subscriptionId. The resource group name
	// must be no longer than 90 characters long, and
	// must be alphanumeric characters (Char.IsLetterOrDigit()) and '-', '_', '(', ')' and'.'. Note that the name cannot end with '.'
	ManagedResourceGroupName *string `json:"managedResourceGroupName,omitempty"`

	// Setting this to 'default' will ensure that all compute for this workspace is in a virtual network managed on behalf of the user.
	ManagedVirtualNetwork *string `json:"managedVirtualNetwork,omitempty"`

	// Managed Virtual Network Settings
	ManagedVirtualNetworkSettings *ManagedVirtualNetworkSettings `json:"managedVirtualNetworkSettings,omitempty"`

	// Private endpoint connections to the workspace
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`

	// Enable or Disable public network access to workspace
	PublicNetworkAccess *WorkspacePublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purview Configuration
	PurviewConfiguration *PurviewConfiguration `json:"purviewConfiguration,omitempty"`

	// Login for workspace SQL active directory administrator
	SQLAdministratorLogin *string `json:"sqlAdministratorLogin,omitempty"`

	// SQL administrator login password
	SQLAdministratorLoginPassword *string `json:"sqlAdministratorLoginPassword,omitempty"`

	// Virtual Network profile
	VirtualNetworkProfile *VirtualNetworkProfile `json:"virtualNetworkProfile,omitempty"`

	// Git integration settings
	WorkspaceRepositoryConfiguration *WorkspaceRepositoryConfiguration `json:"workspaceRepositoryConfiguration,omitempty"`

	// READ-ONLY; The ADLA resource ID.
	AdlaResourceID *string `json:"adlaResourceId,omitempty" azure:"ro"`

	// READ-ONLY; Workspace level configs and feature flags
	ExtraProperties map[string]map[string]interface{} `json:"extraProperties,omitempty" azure:"ro"`

	// READ-ONLY; Resource provisioning state
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Workspace settings
	Settings map[string]map[string]interface{} `json:"settings,omitempty" azure:"ro"`

	// READ-ONLY; The workspace unique identifier
	WorkspaceUID *string `json:"workspaceUID,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceProperties.
func (w WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adlaResourceId", w.AdlaResourceID)
	populate(objectMap, "azureADOnlyAuthentication", w.AzureADOnlyAuthentication)
	populate(objectMap, "connectivityEndpoints", w.ConnectivityEndpoints)
	populate(objectMap, "cspWorkspaceAdminProperties", w.CspWorkspaceAdminProperties)
	populate(objectMap, "defaultDataLakeStorage", w.DefaultDataLakeStorage)
	populate(objectMap, "encryption", w.Encryption)
	populate(objectMap, "extraProperties", w.ExtraProperties)
	populate(objectMap, "managedResourceGroupName", w.ManagedResourceGroupName)
	populate(objectMap, "managedVirtualNetwork", w.ManagedVirtualNetwork)
	populate(objectMap, "managedVirtualNetworkSettings", w.ManagedVirtualNetworkSettings)
	populate(objectMap, "privateEndpointConnections", w.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", w.PublicNetworkAccess)
	populate(objectMap, "purviewConfiguration", w.PurviewConfiguration)
	populate(objectMap, "sqlAdministratorLogin", w.SQLAdministratorLogin)
	populate(objectMap, "sqlAdministratorLoginPassword", w.SQLAdministratorLoginPassword)
	populate(objectMap, "settings", w.Settings)
	populate(objectMap, "virtualNetworkProfile", w.VirtualNetworkProfile)
	populate(objectMap, "workspaceRepositoryConfiguration", w.WorkspaceRepositoryConfiguration)
	populate(objectMap, "workspaceUID", w.WorkspaceUID)
	return json.Marshal(objectMap)
}

// WorkspaceRepositoryConfiguration - Git integration settings
type WorkspaceRepositoryConfiguration struct {
	// Account name
	AccountName *string `json:"accountName,omitempty"`

	// Collaboration branch
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// GitHub Enterprise host name. For example: https://github.mydomain.com
	HostName *string `json:"hostName,omitempty"`

	// The last commit ID
	LastCommitID *string `json:"lastCommitId,omitempty"`

	// VSTS project name
	ProjectName *string `json:"projectName,omitempty"`

	// Repository name
	RepositoryName *string `json:"repositoryName,omitempty"`

	// Root folder to use in the repository
	RootFolder *string `json:"rootFolder,omitempty"`

	// The VSTS tenant ID
	TenantID *string `json:"tenantId,omitempty"`

	// Type of workspace repositoryID configuration. Example WorkspaceVSTSConfiguration, WorkspaceGitHubConfiguration
	Type *string `json:"type,omitempty"`
}

// WorkspaceSQLAADAdminsBeginCreateOrUpdateOptions contains the optional parameters for the WorkspaceSQLAADAdmins.BeginCreateOrUpdate method.
type WorkspaceSQLAADAdminsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceSQLAADAdminsBeginDeleteOptions contains the optional parameters for the WorkspaceSQLAADAdmins.BeginDelete method.
type WorkspaceSQLAADAdminsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspaceSQLAADAdminsGetOptions contains the optional parameters for the WorkspaceSQLAADAdmins.Get method.
type WorkspaceSQLAADAdminsGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginCreateOrUpdateOptions contains the optional parameters for the Workspaces.BeginCreateOrUpdate method.
type WorkspacesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginDeleteOptions contains the optional parameters for the Workspaces.BeginDelete method.
type WorkspacesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesBeginUpdateOptions contains the optional parameters for the Workspaces.BeginUpdate method.
type WorkspacesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesGetOptions contains the optional parameters for the Workspaces.Get method.
type WorkspacesGetOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListByResourceGroupOptions contains the optional parameters for the Workspaces.ListByResourceGroup method.
type WorkspacesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// WorkspacesListOptions contains the optional parameters for the Workspaces.List method.
type WorkspacesListOptions struct {
	// placeholder for future optional parameters
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
