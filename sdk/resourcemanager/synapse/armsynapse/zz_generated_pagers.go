//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsynapse

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AzureADOnlyAuthenticationsClientListPager provides operations for iterating over paged responses.
type AzureADOnlyAuthenticationsClientListPager struct {
	client    *AzureADOnlyAuthenticationsClient
	current   AzureADOnlyAuthenticationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureADOnlyAuthenticationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureADOnlyAuthenticationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureADOnlyAuthenticationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureADOnlyAuthenticationListResult.NextLink == nil || len(*p.current.AzureADOnlyAuthenticationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureADOnlyAuthenticationsClientListResponse page.
func (p *AzureADOnlyAuthenticationsClientListPager) PageResponse() AzureADOnlyAuthenticationsClientListResponse {
	return p.current
}

// BigDataPoolsClientListByWorkspacePager provides operations for iterating over paged responses.
type BigDataPoolsClientListByWorkspacePager struct {
	client    *BigDataPoolsClient
	current   BigDataPoolsClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BigDataPoolsClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BigDataPoolsClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BigDataPoolsClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BigDataPoolResourceInfoListResult.NextLink == nil || len(*p.current.BigDataPoolResourceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BigDataPoolsClientListByWorkspaceResponse page.
func (p *BigDataPoolsClientListByWorkspacePager) PageResponse() BigDataPoolsClientListByWorkspaceResponse {
	return p.current
}

// ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolPager provides operations for iterating over paged responses.
type ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolPager struct {
	client    *ExtendedSQLPoolBlobAuditingPoliciesClient
	current   ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedSQLPoolBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedSQLPoolBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySQLPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse page.
func (p *ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) PageResponse() ExtendedSQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse {
	return p.current
}

// IPFirewallRulesClientListByWorkspacePager provides operations for iterating over paged responses.
type IPFirewallRulesClientListByWorkspacePager struct {
	client    *IPFirewallRulesClient
	current   IPFirewallRulesClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPFirewallRulesClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPFirewallRulesClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPFirewallRulesClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPFirewallRuleInfoListResult.NextLink == nil || len(*p.current.IPFirewallRuleInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPFirewallRulesClientListByWorkspaceResponse page.
func (p *IPFirewallRulesClientListByWorkspacePager) PageResponse() IPFirewallRulesClientListByWorkspaceResponse {
	return p.current
}

// IntegrationRuntimesClientListByWorkspacePager provides operations for iterating over paged responses.
type IntegrationRuntimesClientListByWorkspacePager struct {
	client    *IntegrationRuntimesClient
	current   IntegrationRuntimesClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationRuntimesClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationRuntimesClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationRuntimesClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationRuntimeListResponse.NextLink == nil || len(*p.current.IntegrationRuntimeListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationRuntimesClientListByWorkspaceResponse page.
func (p *IntegrationRuntimesClientListByWorkspacePager) PageResponse() IntegrationRuntimesClientListByWorkspaceResponse {
	return p.current
}

// KeysClientListByWorkspacePager provides operations for iterating over paged responses.
type KeysClientListByWorkspacePager struct {
	client    *KeysClient
	current   KeysClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KeysClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KeysClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KeysClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KeyInfoListResult.NextLink == nil || len(*p.current.KeyInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KeysClientListByWorkspaceResponse page.
func (p *KeysClientListByWorkspacePager) PageResponse() KeysClientListByWorkspaceResponse {
	return p.current
}

// KustoOperationsClientListPager provides operations for iterating over paged responses.
type KustoOperationsClientListPager struct {
	client    *KustoOperationsClient
	current   KustoOperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KustoOperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KustoOperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KustoOperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KustoOperationsClientListResponse page.
func (p *KustoOperationsClientListPager) PageResponse() KustoOperationsClientListResponse {
	return p.current
}

// LibrariesClientListByWorkspacePager provides operations for iterating over paged responses.
type LibrariesClientListByWorkspacePager struct {
	client    *LibrariesClient
	current   LibrariesClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LibrariesClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LibrariesClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LibrariesClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LibraryListResponse.NextLink == nil || len(*p.current.LibraryListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LibrariesClientListByWorkspaceResponse page.
func (p *LibrariesClientListByWorkspacePager) PageResponse() LibrariesClientListByWorkspaceResponse {
	return p.current
}

// PrivateEndpointConnectionsClientListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsClientListPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionList.NextLink == nil || len(*p.current.PrivateEndpointConnectionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsClientListResponse page.
func (p *PrivateEndpointConnectionsClientListPager) PageResponse() PrivateEndpointConnectionsClientListResponse {
	return p.current
}

// PrivateEndpointConnectionsPrivateLinkHubClientListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsPrivateLinkHubClientListPager struct {
	client    *PrivateEndpointConnectionsPrivateLinkHubClient
	current   PrivateEndpointConnectionsPrivateLinkHubClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsPrivateLinkHubClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsPrivateLinkHubClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsPrivateLinkHubClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse.NextLink == nil || len(*p.current.PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsPrivateLinkHubClientListResponse page.
func (p *PrivateEndpointConnectionsPrivateLinkHubClientListPager) PageResponse() PrivateEndpointConnectionsPrivateLinkHubClientListResponse {
	return p.current
}

// PrivateLinkHubPrivateLinkResourcesClientListPager provides operations for iterating over paged responses.
type PrivateLinkHubPrivateLinkResourcesClientListPager struct {
	client    *PrivateLinkHubPrivateLinkResourcesClient
	current   PrivateLinkHubPrivateLinkResourcesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubPrivateLinkResourcesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubPrivateLinkResourcesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubPrivateLinkResourcesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubPrivateLinkResourcesClientListResponse page.
func (p *PrivateLinkHubPrivateLinkResourcesClientListPager) PageResponse() PrivateLinkHubPrivateLinkResourcesClientListResponse {
	return p.current
}

// PrivateLinkHubsClientListByResourceGroupPager provides operations for iterating over paged responses.
type PrivateLinkHubsClientListByResourceGroupPager struct {
	client    *PrivateLinkHubsClient
	current   PrivateLinkHubsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkHubInfoListResult.NextLink == nil || len(*p.current.PrivateLinkHubInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubsClientListByResourceGroupResponse page.
func (p *PrivateLinkHubsClientListByResourceGroupPager) PageResponse() PrivateLinkHubsClientListByResourceGroupResponse {
	return p.current
}

// PrivateLinkHubsClientListPager provides operations for iterating over paged responses.
type PrivateLinkHubsClientListPager struct {
	client    *PrivateLinkHubsClient
	current   PrivateLinkHubsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkHubInfoListResult.NextLink == nil || len(*p.current.PrivateLinkHubInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubsClientListResponse page.
func (p *PrivateLinkHubsClientListPager) PageResponse() PrivateLinkHubsClientListResponse {
	return p.current
}

// PrivateLinkResourcesClientListPager provides operations for iterating over paged responses.
type PrivateLinkResourcesClientListPager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkResourcesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkResourcesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkResourcesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkResourcesClientListResponse page.
func (p *PrivateLinkResourcesClientListPager) PageResponse() PrivateLinkResourcesClientListResponse {
	return p.current
}

// SQLPoolBlobAuditingPoliciesClientListBySQLPoolPager provides operations for iterating over paged responses.
type SQLPoolBlobAuditingPoliciesClientListBySQLPoolPager struct {
	client    *SQLPoolBlobAuditingPoliciesClient
	current   SQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.SQLPoolBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySQLPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse page.
func (p *SQLPoolBlobAuditingPoliciesClientListBySQLPoolPager) PageResponse() SQLPoolBlobAuditingPoliciesClientListBySQLPoolResponse {
	return p.current
}

// SQLPoolOperationsClientListPager provides operations for iterating over paged responses.
type SQLPoolOperationsClientListPager struct {
	client    *SQLPoolOperationsClient
	current   SQLPoolOperationsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolOperationsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolOperationsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolOperationsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolBlobAuditingPolicySQLPoolOperationListResult.NextLink == nil || len(*p.current.SQLPoolBlobAuditingPolicySQLPoolOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolOperationsClientListResponse page.
func (p *SQLPoolOperationsClientListPager) PageResponse() SQLPoolOperationsClientListResponse {
	return p.current
}

// SQLPoolReplicationLinksClientListPager provides operations for iterating over paged responses.
type SQLPoolReplicationLinksClientListPager struct {
	client    *SQLPoolReplicationLinksClient
	current   SQLPoolReplicationLinksClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolReplicationLinksClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolReplicationLinksClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolReplicationLinksClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolReplicationLinksClientListResponse page.
func (p *SQLPoolReplicationLinksClientListPager) PageResponse() SQLPoolReplicationLinksClientListResponse {
	return p.current
}

// SQLPoolRestorePointsClientListPager provides operations for iterating over paged responses.
type SQLPoolRestorePointsClientListPager struct {
	client    *SQLPoolRestorePointsClient
	current   SQLPoolRestorePointsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolRestorePointsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolRestorePointsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolRestorePointsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointListResult.NextLink == nil || len(*p.current.RestorePointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolRestorePointsClientListResponse page.
func (p *SQLPoolRestorePointsClientListPager) PageResponse() SQLPoolRestorePointsClientListResponse {
	return p.current
}

// SQLPoolSchemasClientListPager provides operations for iterating over paged responses.
type SQLPoolSchemasClientListPager struct {
	client    *SQLPoolSchemasClient
	current   SQLPoolSchemasClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSchemasClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSchemasClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSchemasClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolSchemaListResult.NextLink == nil || len(*p.current.SQLPoolSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSchemasClientListResponse page.
func (p *SQLPoolSchemasClientListPager) PageResponse() SQLPoolSchemasClientListResponse {
	return p.current
}

// SQLPoolSecurityAlertPoliciesClientListPager provides operations for iterating over paged responses.
type SQLPoolSecurityAlertPoliciesClientListPager struct {
	client    *SQLPoolSecurityAlertPoliciesClient
	current   SQLPoolSecurityAlertPoliciesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSecurityAlertPoliciesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSecurityAlertPoliciesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSecurityAlertPoliciesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListSQLPoolSecurityAlertPolicies.NextLink == nil || len(*p.current.ListSQLPoolSecurityAlertPolicies.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSecurityAlertPoliciesClientListResponse page.
func (p *SQLPoolSecurityAlertPoliciesClientListPager) PageResponse() SQLPoolSecurityAlertPoliciesClientListResponse {
	return p.current
}

// SQLPoolSensitivityLabelsClientListCurrentPager provides operations for iterating over paged responses.
type SQLPoolSensitivityLabelsClientListCurrentPager struct {
	client    *SQLPoolSensitivityLabelsClient
	current   SQLPoolSensitivityLabelsClientListCurrentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSensitivityLabelsClientListCurrentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSensitivityLabelsClientListCurrentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSensitivityLabelsClientListCurrentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listCurrentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSensitivityLabelsClientListCurrentResponse page.
func (p *SQLPoolSensitivityLabelsClientListCurrentPager) PageResponse() SQLPoolSensitivityLabelsClientListCurrentResponse {
	return p.current
}

// SQLPoolSensitivityLabelsClientListRecommendedPager provides operations for iterating over paged responses.
type SQLPoolSensitivityLabelsClientListRecommendedPager struct {
	client    *SQLPoolSensitivityLabelsClient
	current   SQLPoolSensitivityLabelsClientListRecommendedResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSensitivityLabelsClientListRecommendedResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSensitivityLabelsClientListRecommendedPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSensitivityLabelsClientListRecommendedPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listRecommendedHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSensitivityLabelsClientListRecommendedResponse page.
func (p *SQLPoolSensitivityLabelsClientListRecommendedPager) PageResponse() SQLPoolSensitivityLabelsClientListRecommendedResponse {
	return p.current
}

// SQLPoolTableColumnsClientListByTableNamePager provides operations for iterating over paged responses.
type SQLPoolTableColumnsClientListByTableNamePager struct {
	client    *SQLPoolTableColumnsClient
	current   SQLPoolTableColumnsClientListByTableNameResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTableColumnsClientListByTableNameResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTableColumnsClientListByTableNamePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTableColumnsClientListByTableNamePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolColumnListResult.NextLink == nil || len(*p.current.SQLPoolColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByTableNameHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTableColumnsClientListByTableNameResponse page.
func (p *SQLPoolTableColumnsClientListByTableNamePager) PageResponse() SQLPoolTableColumnsClientListByTableNameResponse {
	return p.current
}

// SQLPoolTablesClientListBySchemaPager provides operations for iterating over paged responses.
type SQLPoolTablesClientListBySchemaPager struct {
	client    *SQLPoolTablesClient
	current   SQLPoolTablesClientListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTablesClientListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTablesClientListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTablesClientListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolTableListResult.NextLink == nil || len(*p.current.SQLPoolTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTablesClientListBySchemaResponse page.
func (p *SQLPoolTablesClientListBySchemaPager) PageResponse() SQLPoolTablesClientListBySchemaResponse {
	return p.current
}

// SQLPoolTransparentDataEncryptionsClientListPager provides operations for iterating over paged responses.
type SQLPoolTransparentDataEncryptionsClientListPager struct {
	client    *SQLPoolTransparentDataEncryptionsClient
	current   SQLPoolTransparentDataEncryptionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTransparentDataEncryptionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTransparentDataEncryptionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTransparentDataEncryptionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TransparentDataEncryptionListResult.NextLink == nil || len(*p.current.TransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTransparentDataEncryptionsClientListResponse page.
func (p *SQLPoolTransparentDataEncryptionsClientListPager) PageResponse() SQLPoolTransparentDataEncryptionsClientListResponse {
	return p.current
}

// SQLPoolUsagesClientListPager provides operations for iterating over paged responses.
type SQLPoolUsagesClientListPager struct {
	client    *SQLPoolUsagesClient
	current   SQLPoolUsagesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolUsagesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolUsagesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolUsagesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolUsageListResult.NextLink == nil || len(*p.current.SQLPoolUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolUsagesClientListResponse page.
func (p *SQLPoolUsagesClientListPager) PageResponse() SQLPoolUsagesClientListResponse {
	return p.current
}

// SQLPoolVulnerabilityAssessmentScansClientListPager provides operations for iterating over paged responses.
type SQLPoolVulnerabilityAssessmentScansClientListPager struct {
	client    *SQLPoolVulnerabilityAssessmentScansClient
	current   SQLPoolVulnerabilityAssessmentScansClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolVulnerabilityAssessmentScansClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolVulnerabilityAssessmentScansClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolVulnerabilityAssessmentScansClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolVulnerabilityAssessmentScansClientListResponse page.
func (p *SQLPoolVulnerabilityAssessmentScansClientListPager) PageResponse() SQLPoolVulnerabilityAssessmentScansClientListResponse {
	return p.current
}

// SQLPoolVulnerabilityAssessmentsClientListPager provides operations for iterating over paged responses.
type SQLPoolVulnerabilityAssessmentsClientListPager struct {
	client    *SQLPoolVulnerabilityAssessmentsClient
	current   SQLPoolVulnerabilityAssessmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolVulnerabilityAssessmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolVulnerabilityAssessmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolVulnerabilityAssessmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.SQLPoolVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolVulnerabilityAssessmentsClientListResponse page.
func (p *SQLPoolVulnerabilityAssessmentsClientListPager) PageResponse() SQLPoolVulnerabilityAssessmentsClientListResponse {
	return p.current
}

// SQLPoolWorkloadClassifierClientListPager provides operations for iterating over paged responses.
type SQLPoolWorkloadClassifierClientListPager struct {
	client    *SQLPoolWorkloadClassifierClient
	current   SQLPoolWorkloadClassifierClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolWorkloadClassifierClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolWorkloadClassifierClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolWorkloadClassifierClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadClassifierListResult.NextLink == nil || len(*p.current.WorkloadClassifierListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolWorkloadClassifierClientListResponse page.
func (p *SQLPoolWorkloadClassifierClientListPager) PageResponse() SQLPoolWorkloadClassifierClientListResponse {
	return p.current
}

// SQLPoolWorkloadGroupClientListPager provides operations for iterating over paged responses.
type SQLPoolWorkloadGroupClientListPager struct {
	client    *SQLPoolWorkloadGroupClient
	current   SQLPoolWorkloadGroupClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolWorkloadGroupClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolWorkloadGroupClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolWorkloadGroupClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadGroupListResult.NextLink == nil || len(*p.current.WorkloadGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolWorkloadGroupClientListResponse page.
func (p *SQLPoolWorkloadGroupClientListPager) PageResponse() SQLPoolWorkloadGroupClientListResponse {
	return p.current
}

// SQLPoolsClientListByWorkspacePager provides operations for iterating over paged responses.
type SQLPoolsClientListByWorkspacePager struct {
	client    *SQLPoolsClient
	current   SQLPoolsClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolsClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolsClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolsClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolInfoListResult.NextLink == nil || len(*p.current.SQLPoolInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolsClientListByWorkspaceResponse page.
func (p *SQLPoolsClientListByWorkspacePager) PageResponse() SQLPoolsClientListByWorkspaceResponse {
	return p.current
}

// SparkConfigurationsClientListByWorkspacePager provides operations for iterating over paged responses.
type SparkConfigurationsClientListByWorkspacePager struct {
	client    *SparkConfigurationsClient
	current   SparkConfigurationsClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SparkConfigurationsClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SparkConfigurationsClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SparkConfigurationsClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SparkConfigurationListResponse.NextLink == nil || len(*p.current.SparkConfigurationListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SparkConfigurationsClientListByWorkspaceResponse page.
func (p *SparkConfigurationsClientListByWorkspacePager) PageResponse() SparkConfigurationsClientListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspacePager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspacePager struct {
	client    *WorkspaceManagedSQLServerBlobAuditingPoliciesClient
	current   WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspaceResponse page.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspacePager) PageResponse() WorkspaceManagedSQLServerBlobAuditingPoliciesClientListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerEncryptionProtectorClientListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerEncryptionProtectorClientListPager struct {
	client    *WorkspaceManagedSQLServerEncryptionProtectorClient
	current   WorkspaceManagedSQLServerEncryptionProtectorClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerEncryptionProtectorClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EncryptionProtectorListResult.NextLink == nil || len(*p.current.EncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerEncryptionProtectorClientListResponse page.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientListPager) PageResponse() WorkspaceManagedSQLServerEncryptionProtectorClientListResponse {
	return p.current
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspacePager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspacePager struct {
	client    *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClient
	current   WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspaceResponse page.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspacePager) PageResponse() WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerRecoverableSQLPoolsClientListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerRecoverableSQLPoolsClientListPager struct {
	client    *WorkspaceManagedSQLServerRecoverableSQLPoolsClient
	current   WorkspaceManagedSQLServerRecoverableSQLPoolsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerRecoverableSQLPoolsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoverableSQLPoolListResult.NextLink == nil || len(*p.current.RecoverableSQLPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerRecoverableSQLPoolsClientListResponse page.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsClientListPager) PageResponse() WorkspaceManagedSQLServerRecoverableSQLPoolsClientListResponse {
	return p.current
}

// WorkspaceManagedSQLServerSecurityAlertPolicyClientListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerSecurityAlertPolicyClientListPager struct {
	client    *WorkspaceManagedSQLServerSecurityAlertPolicyClient
	current   WorkspaceManagedSQLServerSecurityAlertPolicyClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerSecurityAlertPolicyClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerSecurityAlertPolicyClientListResponse page.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientListPager) PageResponse() WorkspaceManagedSQLServerSecurityAlertPolicyClientListResponse {
	return p.current
}

// WorkspaceManagedSQLServerUsagesClientListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerUsagesClientListPager struct {
	client    *WorkspaceManagedSQLServerUsagesClient
	current   WorkspaceManagedSQLServerUsagesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerUsagesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerUsagesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerUsagesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerUsageListResult.NextLink == nil || len(*p.current.ServerUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerUsagesClientListResponse page.
func (p *WorkspaceManagedSQLServerUsagesClientListPager) PageResponse() WorkspaceManagedSQLServerUsagesClientListResponse {
	return p.current
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListPager struct {
	client    *WorkspaceManagedSQLServerVulnerabilityAssessmentsClient
	current   WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ServerVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListResponse page.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListPager) PageResponse() WorkspaceManagedSQLServerVulnerabilityAssessmentsClientListResponse {
	return p.current
}

// WorkspacesClientListByResourceGroupPager provides operations for iterating over paged responses.
type WorkspacesClientListByResourceGroupPager struct {
	client    *WorkspacesClient
	current   WorkspacesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspacesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspacesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspacesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceInfoListResult.NextLink == nil || len(*p.current.WorkspaceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspacesClientListByResourceGroupResponse page.
func (p *WorkspacesClientListByResourceGroupPager) PageResponse() WorkspacesClientListByResourceGroupResponse {
	return p.current
}

// WorkspacesClientListPager provides operations for iterating over paged responses.
type WorkspacesClientListPager struct {
	client    *WorkspacesClient
	current   WorkspacesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspacesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspacesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspacesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceInfoListResult.NextLink == nil || len(*p.current.WorkspaceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspacesClientListResponse page.
func (p *WorkspacesClientListPager) PageResponse() WorkspacesClientListResponse {
	return p.current
}
