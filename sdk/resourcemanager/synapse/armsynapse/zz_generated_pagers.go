//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsynapse

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AzureADOnlyAuthenticationsListPager provides operations for iterating over paged responses.
type AzureADOnlyAuthenticationsListPager struct {
	client    *AzureADOnlyAuthenticationsClient
	current   AzureADOnlyAuthenticationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureADOnlyAuthenticationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AzureADOnlyAuthenticationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AzureADOnlyAuthenticationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureADOnlyAuthenticationListResult.NextLink == nil || len(*p.current.AzureADOnlyAuthenticationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AzureADOnlyAuthenticationsListResponse page.
func (p *AzureADOnlyAuthenticationsListPager) PageResponse() AzureADOnlyAuthenticationsListResponse {
	return p.current
}

// BigDataPoolsListByWorkspacePager provides operations for iterating over paged responses.
type BigDataPoolsListByWorkspacePager struct {
	client    *BigDataPoolsClient
	current   BigDataPoolsListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BigDataPoolsListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *BigDataPoolsListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *BigDataPoolsListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BigDataPoolResourceInfoListResult.NextLink == nil || len(*p.current.BigDataPoolResourceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current BigDataPoolsListByWorkspaceResponse page.
func (p *BigDataPoolsListByWorkspacePager) PageResponse() BigDataPoolsListByWorkspaceResponse {
	return p.current
}

// ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolPager provides operations for iterating over paged responses.
type ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolPager struct {
	client    *ExtendedSQLPoolBlobAuditingPoliciesClient
	current   ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedSQLPoolBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedSQLPoolBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySQLPoolHandleError(resp)
		return false
	}
	result, err := p.client.listBySQLPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolResponse page.
func (p *ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolPager) PageResponse() ExtendedSQLPoolBlobAuditingPoliciesListBySQLPoolResponse {
	return p.current
}

// IPFirewallRulesListByWorkspacePager provides operations for iterating over paged responses.
type IPFirewallRulesListByWorkspacePager struct {
	client    *IPFirewallRulesClient
	current   IPFirewallRulesListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPFirewallRulesListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IPFirewallRulesListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IPFirewallRulesListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPFirewallRuleInfoListResult.NextLink == nil || len(*p.current.IPFirewallRuleInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IPFirewallRulesListByWorkspaceResponse page.
func (p *IPFirewallRulesListByWorkspacePager) PageResponse() IPFirewallRulesListByWorkspaceResponse {
	return p.current
}

// IntegrationRuntimesListByWorkspacePager provides operations for iterating over paged responses.
type IntegrationRuntimesListByWorkspacePager struct {
	client    *IntegrationRuntimesClient
	current   IntegrationRuntimesListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationRuntimesListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *IntegrationRuntimesListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *IntegrationRuntimesListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationRuntimeListResponse.NextLink == nil || len(*p.current.IntegrationRuntimeListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current IntegrationRuntimesListByWorkspaceResponse page.
func (p *IntegrationRuntimesListByWorkspacePager) PageResponse() IntegrationRuntimesListByWorkspaceResponse {
	return p.current
}

// KeysListByWorkspacePager provides operations for iterating over paged responses.
type KeysListByWorkspacePager struct {
	client    *KeysClient
	current   KeysListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KeysListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KeysListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KeysListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KeyInfoListResult.NextLink == nil || len(*p.current.KeyInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KeysListByWorkspaceResponse page.
func (p *KeysListByWorkspacePager) PageResponse() KeysListByWorkspaceResponse {
	return p.current
}

// KustoOperationsListPager provides operations for iterating over paged responses.
type KustoOperationsListPager struct {
	client    *KustoOperationsClient
	current   KustoOperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KustoOperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *KustoOperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *KustoOperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current KustoOperationsListResponse page.
func (p *KustoOperationsListPager) PageResponse() KustoOperationsListResponse {
	return p.current
}

// LibrariesListByWorkspacePager provides operations for iterating over paged responses.
type LibrariesListByWorkspacePager struct {
	client    *LibrariesClient
	current   LibrariesListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LibrariesListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *LibrariesListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *LibrariesListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LibraryListResponse.NextLink == nil || len(*p.current.LibraryListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current LibrariesListByWorkspaceResponse page.
func (p *LibrariesListByWorkspacePager) PageResponse() LibrariesListByWorkspaceResponse {
	return p.current
}

// PrivateEndpointConnectionsListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsListPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionList.NextLink == nil || len(*p.current.PrivateEndpointConnectionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsListResponse page.
func (p *PrivateEndpointConnectionsListPager) PageResponse() PrivateEndpointConnectionsListResponse {
	return p.current
}

// PrivateEndpointConnectionsPrivateLinkHubListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsPrivateLinkHubListPager struct {
	client    *PrivateEndpointConnectionsPrivateLinkHubClient
	current   PrivateEndpointConnectionsPrivateLinkHubListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsPrivateLinkHubListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateEndpointConnectionsPrivateLinkHubListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateEndpointConnectionsPrivateLinkHubListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse.NextLink == nil || len(*p.current.PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateEndpointConnectionsPrivateLinkHubListResponse page.
func (p *PrivateEndpointConnectionsPrivateLinkHubListPager) PageResponse() PrivateEndpointConnectionsPrivateLinkHubListResponse {
	return p.current
}

// PrivateLinkHubPrivateLinkResourcesListPager provides operations for iterating over paged responses.
type PrivateLinkHubPrivateLinkResourcesListPager struct {
	client    *PrivateLinkHubPrivateLinkResourcesClient
	current   PrivateLinkHubPrivateLinkResourcesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubPrivateLinkResourcesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubPrivateLinkResourcesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubPrivateLinkResourcesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubPrivateLinkResourcesListResponse page.
func (p *PrivateLinkHubPrivateLinkResourcesListPager) PageResponse() PrivateLinkHubPrivateLinkResourcesListResponse {
	return p.current
}

// PrivateLinkHubsListByResourceGroupPager provides operations for iterating over paged responses.
type PrivateLinkHubsListByResourceGroupPager struct {
	client    *PrivateLinkHubsClient
	current   PrivateLinkHubsListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubsListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubsListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubsListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkHubInfoListResult.NextLink == nil || len(*p.current.PrivateLinkHubInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubsListByResourceGroupResponse page.
func (p *PrivateLinkHubsListByResourceGroupPager) PageResponse() PrivateLinkHubsListByResourceGroupResponse {
	return p.current
}

// PrivateLinkHubsListPager provides operations for iterating over paged responses.
type PrivateLinkHubsListPager struct {
	client    *PrivateLinkHubsClient
	current   PrivateLinkHubsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkHubsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkHubsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkHubsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkHubInfoListResult.NextLink == nil || len(*p.current.PrivateLinkHubInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkHubsListResponse page.
func (p *PrivateLinkHubsListPager) PageResponse() PrivateLinkHubsListResponse {
	return p.current
}

// PrivateLinkResourcesListPager provides operations for iterating over paged responses.
type PrivateLinkResourcesListPager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkResourcesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *PrivateLinkResourcesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *PrivateLinkResourcesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourceListResult.NextLink == nil || len(*p.current.PrivateLinkResourceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current PrivateLinkResourcesListResponse page.
func (p *PrivateLinkResourcesListPager) PageResponse() PrivateLinkResourcesListResponse {
	return p.current
}

// SQLPoolBlobAuditingPoliciesListBySQLPoolPager provides operations for iterating over paged responses.
type SQLPoolBlobAuditingPoliciesListBySQLPoolPager struct {
	client    *SQLPoolBlobAuditingPoliciesClient
	current   SQLPoolBlobAuditingPoliciesListBySQLPoolResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolBlobAuditingPoliciesListBySQLPoolResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolBlobAuditingPoliciesListBySQLPoolPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolBlobAuditingPoliciesListBySQLPoolPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.SQLPoolBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySQLPoolHandleError(resp)
		return false
	}
	result, err := p.client.listBySQLPoolHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolBlobAuditingPoliciesListBySQLPoolResponse page.
func (p *SQLPoolBlobAuditingPoliciesListBySQLPoolPager) PageResponse() SQLPoolBlobAuditingPoliciesListBySQLPoolResponse {
	return p.current
}

// SQLPoolOperationsListPager provides operations for iterating over paged responses.
type SQLPoolOperationsListPager struct {
	client    *SQLPoolOperationsClient
	current   SQLPoolOperationsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolOperationsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolOperationsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolOperationsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolBlobAuditingPolicySQLPoolOperationListResult.NextLink == nil || len(*p.current.SQLPoolBlobAuditingPolicySQLPoolOperationListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolOperationsListResponse page.
func (p *SQLPoolOperationsListPager) PageResponse() SQLPoolOperationsListResponse {
	return p.current
}

// SQLPoolReplicationLinksListPager provides operations for iterating over paged responses.
type SQLPoolReplicationLinksListPager struct {
	client    *SQLPoolReplicationLinksClient
	current   SQLPoolReplicationLinksListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolReplicationLinksListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolReplicationLinksListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolReplicationLinksListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReplicationLinkListResult.NextLink == nil || len(*p.current.ReplicationLinkListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolReplicationLinksListResponse page.
func (p *SQLPoolReplicationLinksListPager) PageResponse() SQLPoolReplicationLinksListResponse {
	return p.current
}

// SQLPoolRestorePointsListPager provides operations for iterating over paged responses.
type SQLPoolRestorePointsListPager struct {
	client    *SQLPoolRestorePointsClient
	current   SQLPoolRestorePointsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolRestorePointsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolRestorePointsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolRestorePointsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointListResult.NextLink == nil || len(*p.current.RestorePointListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolRestorePointsListResponse page.
func (p *SQLPoolRestorePointsListPager) PageResponse() SQLPoolRestorePointsListResponse {
	return p.current
}

// SQLPoolSchemasListPager provides operations for iterating over paged responses.
type SQLPoolSchemasListPager struct {
	client    *SQLPoolSchemasClient
	current   SQLPoolSchemasListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSchemasListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSchemasListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSchemasListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolSchemaListResult.NextLink == nil || len(*p.current.SQLPoolSchemaListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSchemasListResponse page.
func (p *SQLPoolSchemasListPager) PageResponse() SQLPoolSchemasListResponse {
	return p.current
}

// SQLPoolSecurityAlertPoliciesListPager provides operations for iterating over paged responses.
type SQLPoolSecurityAlertPoliciesListPager struct {
	client    *SQLPoolSecurityAlertPoliciesClient
	current   SQLPoolSecurityAlertPoliciesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSecurityAlertPoliciesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSecurityAlertPoliciesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSecurityAlertPoliciesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListSQLPoolSecurityAlertPolicies.NextLink == nil || len(*p.current.ListSQLPoolSecurityAlertPolicies.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSecurityAlertPoliciesListResponse page.
func (p *SQLPoolSecurityAlertPoliciesListPager) PageResponse() SQLPoolSecurityAlertPoliciesListResponse {
	return p.current
}

// SQLPoolSensitivityLabelsListCurrentPager provides operations for iterating over paged responses.
type SQLPoolSensitivityLabelsListCurrentPager struct {
	client    *SQLPoolSensitivityLabelsClient
	current   SQLPoolSensitivityLabelsListCurrentResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSensitivityLabelsListCurrentResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSensitivityLabelsListCurrentPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSensitivityLabelsListCurrentPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listCurrentHandleError(resp)
		return false
	}
	result, err := p.client.listCurrentHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSensitivityLabelsListCurrentResponse page.
func (p *SQLPoolSensitivityLabelsListCurrentPager) PageResponse() SQLPoolSensitivityLabelsListCurrentResponse {
	return p.current
}

// SQLPoolSensitivityLabelsListRecommendedPager provides operations for iterating over paged responses.
type SQLPoolSensitivityLabelsListRecommendedPager struct {
	client    *SQLPoolSensitivityLabelsClient
	current   SQLPoolSensitivityLabelsListRecommendedResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolSensitivityLabelsListRecommendedResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolSensitivityLabelsListRecommendedPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolSensitivityLabelsListRecommendedPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SensitivityLabelListResult.NextLink == nil || len(*p.current.SensitivityLabelListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listRecommendedHandleError(resp)
		return false
	}
	result, err := p.client.listRecommendedHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolSensitivityLabelsListRecommendedResponse page.
func (p *SQLPoolSensitivityLabelsListRecommendedPager) PageResponse() SQLPoolSensitivityLabelsListRecommendedResponse {
	return p.current
}

// SQLPoolTableColumnsListByTableNamePager provides operations for iterating over paged responses.
type SQLPoolTableColumnsListByTableNamePager struct {
	client    *SQLPoolTableColumnsClient
	current   SQLPoolTableColumnsListByTableNameResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTableColumnsListByTableNameResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTableColumnsListByTableNamePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTableColumnsListByTableNamePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolColumnListResult.NextLink == nil || len(*p.current.SQLPoolColumnListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByTableNameHandleError(resp)
		return false
	}
	result, err := p.client.listByTableNameHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTableColumnsListByTableNameResponse page.
func (p *SQLPoolTableColumnsListByTableNamePager) PageResponse() SQLPoolTableColumnsListByTableNameResponse {
	return p.current
}

// SQLPoolTablesListBySchemaPager provides operations for iterating over paged responses.
type SQLPoolTablesListBySchemaPager struct {
	client    *SQLPoolTablesClient
	current   SQLPoolTablesListBySchemaResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTablesListBySchemaResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTablesListBySchemaPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTablesListBySchemaPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolTableListResult.NextLink == nil || len(*p.current.SQLPoolTableListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySchemaHandleError(resp)
		return false
	}
	result, err := p.client.listBySchemaHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTablesListBySchemaResponse page.
func (p *SQLPoolTablesListBySchemaPager) PageResponse() SQLPoolTablesListBySchemaResponse {
	return p.current
}

// SQLPoolTransparentDataEncryptionsListPager provides operations for iterating over paged responses.
type SQLPoolTransparentDataEncryptionsListPager struct {
	client    *SQLPoolTransparentDataEncryptionsClient
	current   SQLPoolTransparentDataEncryptionsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolTransparentDataEncryptionsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolTransparentDataEncryptionsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolTransparentDataEncryptionsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TransparentDataEncryptionListResult.NextLink == nil || len(*p.current.TransparentDataEncryptionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolTransparentDataEncryptionsListResponse page.
func (p *SQLPoolTransparentDataEncryptionsListPager) PageResponse() SQLPoolTransparentDataEncryptionsListResponse {
	return p.current
}

// SQLPoolUsagesListPager provides operations for iterating over paged responses.
type SQLPoolUsagesListPager struct {
	client    *SQLPoolUsagesClient
	current   SQLPoolUsagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolUsagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolUsagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolUsagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolUsageListResult.NextLink == nil || len(*p.current.SQLPoolUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolUsagesListResponse page.
func (p *SQLPoolUsagesListPager) PageResponse() SQLPoolUsagesListResponse {
	return p.current
}

// SQLPoolVulnerabilityAssessmentScansListPager provides operations for iterating over paged responses.
type SQLPoolVulnerabilityAssessmentScansListPager struct {
	client    *SQLPoolVulnerabilityAssessmentScansClient
	current   SQLPoolVulnerabilityAssessmentScansListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolVulnerabilityAssessmentScansListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolVulnerabilityAssessmentScansListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolVulnerabilityAssessmentScansListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VulnerabilityAssessmentScanRecordListResult.NextLink == nil || len(*p.current.VulnerabilityAssessmentScanRecordListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolVulnerabilityAssessmentScansListResponse page.
func (p *SQLPoolVulnerabilityAssessmentScansListPager) PageResponse() SQLPoolVulnerabilityAssessmentScansListResponse {
	return p.current
}

// SQLPoolVulnerabilityAssessmentsListPager provides operations for iterating over paged responses.
type SQLPoolVulnerabilityAssessmentsListPager struct {
	client    *SQLPoolVulnerabilityAssessmentsClient
	current   SQLPoolVulnerabilityAssessmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolVulnerabilityAssessmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolVulnerabilityAssessmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolVulnerabilityAssessmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.SQLPoolVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolVulnerabilityAssessmentsListResponse page.
func (p *SQLPoolVulnerabilityAssessmentsListPager) PageResponse() SQLPoolVulnerabilityAssessmentsListResponse {
	return p.current
}

// SQLPoolWorkloadClassifierListPager provides operations for iterating over paged responses.
type SQLPoolWorkloadClassifierListPager struct {
	client    *SQLPoolWorkloadClassifierClient
	current   SQLPoolWorkloadClassifierListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolWorkloadClassifierListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolWorkloadClassifierListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolWorkloadClassifierListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadClassifierListResult.NextLink == nil || len(*p.current.WorkloadClassifierListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolWorkloadClassifierListResponse page.
func (p *SQLPoolWorkloadClassifierListPager) PageResponse() SQLPoolWorkloadClassifierListResponse {
	return p.current
}

// SQLPoolWorkloadGroupListPager provides operations for iterating over paged responses.
type SQLPoolWorkloadGroupListPager struct {
	client    *SQLPoolWorkloadGroupClient
	current   SQLPoolWorkloadGroupListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolWorkloadGroupListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolWorkloadGroupListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolWorkloadGroupListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadGroupListResult.NextLink == nil || len(*p.current.WorkloadGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolWorkloadGroupListResponse page.
func (p *SQLPoolWorkloadGroupListPager) PageResponse() SQLPoolWorkloadGroupListResponse {
	return p.current
}

// SQLPoolsListByWorkspacePager provides operations for iterating over paged responses.
type SQLPoolsListByWorkspacePager struct {
	client    *SQLPoolsClient
	current   SQLPoolsListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SQLPoolsListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLPoolsListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLPoolsListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLPoolInfoListResult.NextLink == nil || len(*p.current.SQLPoolInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLPoolsListByWorkspaceResponse page.
func (p *SQLPoolsListByWorkspacePager) PageResponse() SQLPoolsListByWorkspaceResponse {
	return p.current
}

// SparkConfigurationsListByWorkspacePager provides operations for iterating over paged responses.
type SparkConfigurationsListByWorkspacePager struct {
	client    *SparkConfigurationsClient
	current   SparkConfigurationsListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SparkConfigurationsListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SparkConfigurationsListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SparkConfigurationsListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SparkConfigurationListResponse.NextLink == nil || len(*p.current.SparkConfigurationListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SparkConfigurationsListByWorkspaceResponse page.
func (p *SparkConfigurationsListByWorkspacePager) PageResponse() SparkConfigurationsListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspacePager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspacePager struct {
	client    *WorkspaceManagedSQLServerBlobAuditingPoliciesClient
	current   WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceResponse page.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspacePager) PageResponse() WorkspaceManagedSQLServerBlobAuditingPoliciesListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerEncryptionProtectorListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerEncryptionProtectorListPager struct {
	client    *WorkspaceManagedSQLServerEncryptionProtectorClient
	current   WorkspaceManagedSQLServerEncryptionProtectorListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerEncryptionProtectorListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerEncryptionProtectorListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerEncryptionProtectorListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EncryptionProtectorListResult.NextLink == nil || len(*p.current.EncryptionProtectorListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerEncryptionProtectorListResponse page.
func (p *WorkspaceManagedSQLServerEncryptionProtectorListPager) PageResponse() WorkspaceManagedSQLServerEncryptionProtectorListResponse {
	return p.current
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspacePager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspacePager struct {
	client    *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClient
	current   WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink == nil || len(*p.current.ExtendedServerBlobAuditingPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByWorkspaceHandleError(resp)
		return false
	}
	result, err := p.client.listByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceResponse page.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspacePager) PageResponse() WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesListByWorkspaceResponse {
	return p.current
}

// WorkspaceManagedSQLServerRecoverableSQLPoolsListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerRecoverableSQLPoolsListPager struct {
	client    *WorkspaceManagedSQLServerRecoverableSQLPoolsClient
	current   WorkspaceManagedSQLServerRecoverableSQLPoolsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerRecoverableSQLPoolsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoverableSQLPoolListResult.NextLink == nil || len(*p.current.RecoverableSQLPoolListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerRecoverableSQLPoolsListResponse page.
func (p *WorkspaceManagedSQLServerRecoverableSQLPoolsListPager) PageResponse() WorkspaceManagedSQLServerRecoverableSQLPoolsListResponse {
	return p.current
}

// WorkspaceManagedSQLServerSecurityAlertPolicyListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerSecurityAlertPolicyListPager struct {
	client    *WorkspaceManagedSQLServerSecurityAlertPolicyClient
	current   WorkspaceManagedSQLServerSecurityAlertPolicyListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerSecurityAlertPolicyListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerSecurityAlertPolicyListResult.NextLink == nil || len(*p.current.ServerSecurityAlertPolicyListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerSecurityAlertPolicyListResponse page.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyListPager) PageResponse() WorkspaceManagedSQLServerSecurityAlertPolicyListResponse {
	return p.current
}

// WorkspaceManagedSQLServerUsagesListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerUsagesListPager struct {
	client    *WorkspaceManagedSQLServerUsagesClient
	current   WorkspaceManagedSQLServerUsagesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerUsagesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerUsagesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerUsagesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerUsageListResult.NextLink == nil || len(*p.current.ServerUsageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerUsagesListResponse page.
func (p *WorkspaceManagedSQLServerUsagesListPager) PageResponse() WorkspaceManagedSQLServerUsagesListResponse {
	return p.current
}

// WorkspaceManagedSQLServerVulnerabilityAssessmentsListPager provides operations for iterating over paged responses.
type WorkspaceManagedSQLServerVulnerabilityAssessmentsListPager struct {
	client    *WorkspaceManagedSQLServerVulnerabilityAssessmentsClient
	current   WorkspaceManagedSQLServerVulnerabilityAssessmentsListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceManagedSQLServerVulnerabilityAssessmentsListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServerVulnerabilityAssessmentListResult.NextLink == nil || len(*p.current.ServerVulnerabilityAssessmentListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspaceManagedSQLServerVulnerabilityAssessmentsListResponse page.
func (p *WorkspaceManagedSQLServerVulnerabilityAssessmentsListPager) PageResponse() WorkspaceManagedSQLServerVulnerabilityAssessmentsListResponse {
	return p.current
}

// WorkspacesListByResourceGroupPager provides operations for iterating over paged responses.
type WorkspacesListByResourceGroupPager struct {
	client    *WorkspacesClient
	current   WorkspacesListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspacesListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspacesListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspacesListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceInfoListResult.NextLink == nil || len(*p.current.WorkspaceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspacesListByResourceGroupResponse page.
func (p *WorkspacesListByResourceGroupPager) PageResponse() WorkspacesListByResourceGroupResponse {
	return p.current
}

// WorkspacesListPager provides operations for iterating over paged responses.
type WorkspacesListPager struct {
	client    *WorkspacesClient
	current   WorkspacesListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspacesListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *WorkspacesListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *WorkspacesListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceInfoListResult.NextLink == nil || len(*p.current.WorkspaceInfoListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current WorkspacesListResponse page.
func (p *WorkspacesListPager) PageResponse() WorkspacesListResponse {
	return p.current
}
