//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsynapse

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// AzureADOnlyAuthenticationsCreatePoller provides polling facilities until the operation reaches a terminal state.
type AzureADOnlyAuthenticationsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureADOnlyAuthenticationsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AzureADOnlyAuthenticationsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AzureADOnlyAuthenticationsCreateResponse will be returned.
func (p *AzureADOnlyAuthenticationsCreatePoller) FinalResponse(ctx context.Context) (AzureADOnlyAuthenticationsCreateResponse, error) {
	respType := AzureADOnlyAuthenticationsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureADOnlyAuthentication)
	if err != nil {
		return AzureADOnlyAuthenticationsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AzureADOnlyAuthenticationsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BigDataPoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BigDataPoolsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BigDataPoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BigDataPoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BigDataPoolsCreateOrUpdateResponse will be returned.
func (p *BigDataPoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BigDataPoolsCreateOrUpdateResponse, error) {
	respType := BigDataPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BigDataPoolResourceInfo)
	if err != nil {
		return BigDataPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BigDataPoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BigDataPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BigDataPoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BigDataPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BigDataPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BigDataPoolsDeleteResponse will be returned.
func (p *BigDataPoolsDeletePoller) FinalResponse(ctx context.Context) (BigDataPoolsDeleteResponse, error) {
	respType := BigDataPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return BigDataPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BigDataPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesCreateOrUpdateResponse will be returned.
func (p *IPFirewallRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPFirewallRulesCreateOrUpdateResponse, error) {
	respType := IPFirewallRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPFirewallRuleInfo)
	if err != nil {
		return IPFirewallRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesDeleteResponse will be returned.
func (p *IPFirewallRulesDeletePoller) FinalResponse(ctx context.Context) (IPFirewallRulesDeleteResponse, error) {
	respType := IPFirewallRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return IPFirewallRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesReplaceAllPoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesReplaceAllPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesReplaceAllPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesReplaceAllPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesReplaceAllResponse will be returned.
func (p *IPFirewallRulesReplaceAllPoller) FinalResponse(ctx context.Context) (IPFirewallRulesReplaceAllResponse, error) {
	respType := IPFirewallRulesReplaceAllResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplaceAllFirewallRulesOperationResponse)
	if err != nil {
		return IPFirewallRulesReplaceAllResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesReplaceAllPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimeObjectMetadataRefreshPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimeObjectMetadataRefreshPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimeObjectMetadataRefreshPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimeObjectMetadataRefreshPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimeObjectMetadataRefreshResponse will be returned.
func (p *IntegrationRuntimeObjectMetadataRefreshPoller) FinalResponse(ctx context.Context) (IntegrationRuntimeObjectMetadataRefreshResponse, error) {
	respType := IntegrationRuntimeObjectMetadataRefreshResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SsisObjectMetadataStatusResponse)
	if err != nil {
		return IntegrationRuntimeObjectMetadataRefreshResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimeObjectMetadataRefreshPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesCreatePoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesCreateResponse will be returned.
func (p *IntegrationRuntimesCreatePoller) FinalResponse(ctx context.Context) (IntegrationRuntimesCreateResponse, error) {
	respType := IntegrationRuntimesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IntegrationRuntimeResource)
	if err != nil {
		return IntegrationRuntimesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesDeletePoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesDeleteResponse will be returned.
func (p *IntegrationRuntimesDeletePoller) FinalResponse(ctx context.Context) (IntegrationRuntimesDeleteResponse, error) {
	respType := IntegrationRuntimesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesDisableInteractiveQueryPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesDisableInteractiveQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesDisableInteractiveQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesDisableInteractiveQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesDisableInteractiveQueryResponse will be returned.
func (p *IntegrationRuntimesDisableInteractiveQueryPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesDisableInteractiveQueryResponse, error) {
	respType := IntegrationRuntimesDisableInteractiveQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesDisableInteractiveQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesDisableInteractiveQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesEnableInteractiveQueryPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesEnableInteractiveQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesEnableInteractiveQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesEnableInteractiveQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesEnableInteractiveQueryResponse will be returned.
func (p *IntegrationRuntimesEnableInteractiveQueryPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesEnableInteractiveQueryResponse, error) {
	respType := IntegrationRuntimesEnableInteractiveQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesEnableInteractiveQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesEnableInteractiveQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesStartPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesStartResponse will be returned.
func (p *IntegrationRuntimesStartPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesStartResponse, error) {
	respType := IntegrationRuntimesStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IntegrationRuntimeStatusResponse)
	if err != nil {
		return IntegrationRuntimesStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesStopPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesStopResponse will be returned.
func (p *IntegrationRuntimesStopPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesStopResponse, error) {
	respType := IntegrationRuntimesStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolAttachedDatabaseConfigurationsCreateOrUpdateResponse will be returned.
func (p *KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolAttachedDatabaseConfigurationsCreateOrUpdateResponse, error) {
	respType := KustoPoolAttachedDatabaseConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AttachedDatabaseConfiguration)
	if err != nil {
		return KustoPoolAttachedDatabaseConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolAttachedDatabaseConfigurationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolAttachedDatabaseConfigurationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolAttachedDatabaseConfigurationsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolAttachedDatabaseConfigurationsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolAttachedDatabaseConfigurationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolAttachedDatabaseConfigurationsDeleteResponse will be returned.
func (p *KustoPoolAttachedDatabaseConfigurationsDeletePoller) FinalResponse(ctx context.Context) (KustoPoolAttachedDatabaseConfigurationsDeleteResponse, error) {
	respType := KustoPoolAttachedDatabaseConfigurationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolAttachedDatabaseConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolAttachedDatabaseConfigurationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsCreateOrUpdateResponse will be returned.
func (p *KustoPoolDataConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsCreateOrUpdateResponse, error) {
	respType := KustoPoolDataConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataConnectionClassification)
	if err != nil {
		return KustoPoolDataConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsDataConnectionValidationPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsDataConnectionValidationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsDataConnectionValidationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsDataConnectionValidationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsDataConnectionValidationResponse will be returned.
func (p *KustoPoolDataConnectionsDataConnectionValidationPoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsDataConnectionValidationResponse, error) {
	respType := KustoPoolDataConnectionsDataConnectionValidationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataConnectionValidationListResult)
	if err != nil {
		return KustoPoolDataConnectionsDataConnectionValidationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsDataConnectionValidationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsDeleteResponse will be returned.
func (p *KustoPoolDataConnectionsDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsDeleteResponse, error) {
	respType := KustoPoolDataConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDataConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsUpdateResponse will be returned.
func (p *KustoPoolDataConnectionsUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsUpdateResponse, error) {
	respType := KustoPoolDataConnectionsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataConnectionClassification)
	if err != nil {
		return KustoPoolDataConnectionsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasePrincipalAssignmentsCreateOrUpdateResponse will be returned.
func (p *KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasePrincipalAssignmentsCreateOrUpdateResponse, error) {
	respType := KustoPoolDatabasePrincipalAssignmentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabasePrincipalAssignment)
	if err != nil {
		return KustoPoolDatabasePrincipalAssignmentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasePrincipalAssignmentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasePrincipalAssignmentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasePrincipalAssignmentsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasePrincipalAssignmentsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasePrincipalAssignmentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasePrincipalAssignmentsDeleteResponse will be returned.
func (p *KustoPoolDatabasePrincipalAssignmentsDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasePrincipalAssignmentsDeleteResponse, error) {
	respType := KustoPoolDatabasePrincipalAssignmentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDatabasePrincipalAssignmentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasePrincipalAssignmentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesCreateOrUpdateResponse will be returned.
func (p *KustoPoolDatabasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesCreateOrUpdateResponse, error) {
	respType := KustoPoolDatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseClassification)
	if err != nil {
		return KustoPoolDatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesDeleteResponse will be returned.
func (p *KustoPoolDatabasesDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesDeleteResponse, error) {
	respType := KustoPoolDatabasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesUpdateResponse will be returned.
func (p *KustoPoolDatabasesUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesUpdateResponse, error) {
	respType := KustoPoolDatabasesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabaseClassification)
	if err != nil {
		return KustoPoolDatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolPrincipalAssignmentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolPrincipalAssignmentsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolPrincipalAssignmentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolPrincipalAssignmentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolPrincipalAssignmentsCreateOrUpdateResponse will be returned.
func (p *KustoPoolPrincipalAssignmentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolPrincipalAssignmentsCreateOrUpdateResponse, error) {
	respType := KustoPoolPrincipalAssignmentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterPrincipalAssignment)
	if err != nil {
		return KustoPoolPrincipalAssignmentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolPrincipalAssignmentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolPrincipalAssignmentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolPrincipalAssignmentsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolPrincipalAssignmentsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolPrincipalAssignmentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolPrincipalAssignmentsDeleteResponse will be returned.
func (p *KustoPoolPrincipalAssignmentsDeletePoller) FinalResponse(ctx context.Context) (KustoPoolPrincipalAssignmentsDeleteResponse, error) {
	respType := KustoPoolPrincipalAssignmentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolPrincipalAssignmentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolPrincipalAssignmentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsAddLanguageExtensionsPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsAddLanguageExtensionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsAddLanguageExtensionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsAddLanguageExtensionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsAddLanguageExtensionsResponse will be returned.
func (p *KustoPoolsAddLanguageExtensionsPoller) FinalResponse(ctx context.Context) (KustoPoolsAddLanguageExtensionsResponse, error) {
	respType := KustoPoolsAddLanguageExtensionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsAddLanguageExtensionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsAddLanguageExtensionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsCreateOrUpdateResponse will be returned.
func (p *KustoPoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolsCreateOrUpdateResponse, error) {
	respType := KustoPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPool)
	if err != nil {
		return KustoPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsDeleteResponse will be returned.
func (p *KustoPoolsDeletePoller) FinalResponse(ctx context.Context) (KustoPoolsDeleteResponse, error) {
	respType := KustoPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsDetachFollowerDatabasesPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsDetachFollowerDatabasesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsDetachFollowerDatabasesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsDetachFollowerDatabasesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsDetachFollowerDatabasesResponse will be returned.
func (p *KustoPoolsDetachFollowerDatabasesPoller) FinalResponse(ctx context.Context) (KustoPoolsDetachFollowerDatabasesResponse, error) {
	respType := KustoPoolsDetachFollowerDatabasesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsDetachFollowerDatabasesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsDetachFollowerDatabasesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsRemoveLanguageExtensionsPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsRemoveLanguageExtensionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsRemoveLanguageExtensionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsRemoveLanguageExtensionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsRemoveLanguageExtensionsResponse will be returned.
func (p *KustoPoolsRemoveLanguageExtensionsPoller) FinalResponse(ctx context.Context) (KustoPoolsRemoveLanguageExtensionsResponse, error) {
	respType := KustoPoolsRemoveLanguageExtensionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsRemoveLanguageExtensionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsRemoveLanguageExtensionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsStartPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsStartResponse will be returned.
func (p *KustoPoolsStartPoller) FinalResponse(ctx context.Context) (KustoPoolsStartResponse, error) {
	respType := KustoPoolsStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsStopPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsStopResponse will be returned.
func (p *KustoPoolsStopPoller) FinalResponse(ctx context.Context) (KustoPoolsStopResponse, error) {
	respType := KustoPoolsStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsUpdateResponse will be returned.
func (p *KustoPoolsUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolsUpdateResponse, error) {
	respType := KustoPoolsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPool)
	if err != nil {
		return KustoPoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsCreatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsCreateResponse will be returned.
func (p *PrivateEndpointConnectionsCreatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateResponse, error) {
	respType := PrivateEndpointConnectionsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OperationResource)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkHubsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkHubsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkHubsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkHubsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkHubsDeleteResponse will be returned.
func (p *PrivateLinkHubsDeletePoller) FinalResponse(ctx context.Context) (PrivateLinkHubsDeleteResponse, error) {
	respType := PrivateLinkHubsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkHubsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkHubsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolRestorePointsCreatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolRestorePointsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolRestorePointsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolRestorePointsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolRestorePointsCreateResponse will be returned.
func (p *SQLPoolRestorePointsCreatePoller) FinalResponse(ctx context.Context) (SQLPoolRestorePointsCreateResponse, error) {
	respType := SQLPoolRestorePointsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RestorePoint)
	if err != nil {
		return SQLPoolRestorePointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolRestorePointsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolVulnerabilityAssessmentScansInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolVulnerabilityAssessmentScansInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolVulnerabilityAssessmentScansInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolVulnerabilityAssessmentScansInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolVulnerabilityAssessmentScansInitiateScanResponse will be returned.
func (p *SQLPoolVulnerabilityAssessmentScansInitiateScanPoller) FinalResponse(ctx context.Context) (SQLPoolVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := SQLPoolVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolVulnerabilityAssessmentScansInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadClassifierCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadClassifierCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadClassifierCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadClassifierCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadClassifierCreateOrUpdateResponse will be returned.
func (p *SQLPoolWorkloadClassifierCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadClassifierCreateOrUpdateResponse, error) {
	respType := SQLPoolWorkloadClassifierCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadClassifier)
	if err != nil {
		return SQLPoolWorkloadClassifierCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadClassifierCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadClassifierDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadClassifierDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadClassifierDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadClassifierDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadClassifierDeleteResponse will be returned.
func (p *SQLPoolWorkloadClassifierDeletePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadClassifierDeleteResponse, error) {
	respType := SQLPoolWorkloadClassifierDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolWorkloadClassifierDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadClassifierDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadGroupCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadGroupCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadGroupCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadGroupCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadGroupCreateOrUpdateResponse will be returned.
func (p *SQLPoolWorkloadGroupCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadGroupCreateOrUpdateResponse, error) {
	respType := SQLPoolWorkloadGroupCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadGroup)
	if err != nil {
		return SQLPoolWorkloadGroupCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadGroupCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadGroupDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadGroupDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadGroupDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadGroupDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadGroupDeleteResponse will be returned.
func (p *SQLPoolWorkloadGroupDeletePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadGroupDeleteResponse, error) {
	respType := SQLPoolWorkloadGroupDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolWorkloadGroupDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadGroupDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsCreatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsCreateResponse will be returned.
func (p *SQLPoolsCreatePoller) FinalResponse(ctx context.Context) (SQLPoolsCreateResponse, error) {
	respType := SQLPoolsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLPool)
	if err != nil {
		return SQLPoolsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsDeleteResponse will be returned.
func (p *SQLPoolsDeletePoller) FinalResponse(ctx context.Context) (SQLPoolsDeleteResponse, error) {
	respType := SQLPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsPausePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsPausePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsPausePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsPausePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsPauseResponse will be returned.
func (p *SQLPoolsPausePoller) FinalResponse(ctx context.Context) (SQLPoolsPauseResponse, error) {
	respType := SQLPoolsPauseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsPausePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsResumePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsResumePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsResumePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsResumeResponse will be returned.
func (p *SQLPoolsResumePoller) FinalResponse(ctx context.Context) (SQLPoolsResumeResponse, error) {
	respType := SQLPoolsResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceAADAdminsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceAADAdminsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceAADAdminsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceAADAdminsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceAADAdminsCreateOrUpdateResponse will be returned.
func (p *WorkspaceAADAdminsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceAADAdminsCreateOrUpdateResponse, error) {
	respType := WorkspaceAADAdminsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkspaceAADAdminInfo)
	if err != nil {
		return WorkspaceAADAdminsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceAADAdminsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceAADAdminsDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceAADAdminsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceAADAdminsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceAADAdminsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceAADAdminsDeleteResponse will be returned.
func (p *WorkspaceAADAdminsDeletePoller) FinalResponse(ctx context.Context) (WorkspaceAADAdminsDeleteResponse, error) {
	respType := WorkspaceAADAdminsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceAADAdminsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceAADAdminsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedIdentitySQLControlSettingsModel)
	if err != nil {
		return WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedIdentitySQLControlSettingsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EncryptionProtector)
	if err != nil {
		return WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerEncryptionProtectorCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerEncryptionProtectorRevalidateResponse will be returned.
func (p *WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerEncryptionProtectorRevalidateResponse, error) {
	respType := WorkspaceManagedSQLServerEncryptionProtectorRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceManagedSQLServerEncryptionProtectorRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerEncryptionProtectorRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceSQLAADAdminsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceSQLAADAdminsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceSQLAADAdminsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceSQLAADAdminsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceSQLAADAdminsCreateOrUpdateResponse will be returned.
func (p *WorkspaceSQLAADAdminsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceSQLAADAdminsCreateOrUpdateResponse, error) {
	respType := WorkspaceSQLAADAdminsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkspaceAADAdminInfo)
	if err != nil {
		return WorkspaceSQLAADAdminsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceSQLAADAdminsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceSQLAADAdminsDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceSQLAADAdminsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceSQLAADAdminsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceSQLAADAdminsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceSQLAADAdminsDeleteResponse will be returned.
func (p *WorkspaceSQLAADAdminsDeletePoller) FinalResponse(ctx context.Context) (WorkspaceSQLAADAdminsDeleteResponse, error) {
	respType := WorkspaceSQLAADAdminsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceSQLAADAdminsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceSQLAADAdminsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesCreateOrUpdateResponse will be returned.
func (p *WorkspacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspacesCreateOrUpdateResponse, error) {
	respType := WorkspacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Workspace)
	if err != nil {
		return WorkspacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesDeleteResponse will be returned.
func (p *WorkspacesDeletePoller) FinalResponse(ctx context.Context) (WorkspacesDeleteResponse, error) {
	respType := WorkspacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return WorkspacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesUpdateResponse will be returned.
func (p *WorkspacesUpdatePoller) FinalResponse(ctx context.Context) (WorkspacesUpdateResponse, error) {
	respType := WorkspacesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Workspace)
	if err != nil {
		return WorkspacesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
