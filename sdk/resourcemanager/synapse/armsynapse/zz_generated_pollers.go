//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsynapse

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// AzureADOnlyAuthenticationsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AzureADOnlyAuthenticationsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureADOnlyAuthenticationsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AzureADOnlyAuthenticationsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AzureADOnlyAuthenticationsClientCreateResponse will be returned.
func (p *AzureADOnlyAuthenticationsClientCreatePoller) FinalResponse(ctx context.Context) (AzureADOnlyAuthenticationsClientCreateResponse, error) {
	respType := AzureADOnlyAuthenticationsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureADOnlyAuthentication)
	if err != nil {
		return AzureADOnlyAuthenticationsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AzureADOnlyAuthenticationsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BigDataPoolsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BigDataPoolsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BigDataPoolsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BigDataPoolsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BigDataPoolsClientCreateOrUpdateResponse will be returned.
func (p *BigDataPoolsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BigDataPoolsClientCreateOrUpdateResponse, error) {
	respType := BigDataPoolsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BigDataPoolResourceInfo)
	if err != nil {
		return BigDataPoolsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BigDataPoolsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BigDataPoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type BigDataPoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BigDataPoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BigDataPoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BigDataPoolsClientDeleteResponse will be returned.
func (p *BigDataPoolsClientDeletePoller) FinalResponse(ctx context.Context) (BigDataPoolsClientDeleteResponse, error) {
	respType := BigDataPoolsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return BigDataPoolsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BigDataPoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesClientCreateOrUpdateResponse will be returned.
func (p *IPFirewallRulesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPFirewallRulesClientCreateOrUpdateResponse, error) {
	respType := IPFirewallRulesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPFirewallRuleInfo)
	if err != nil {
		return IPFirewallRulesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesClientDeleteResponse will be returned.
func (p *IPFirewallRulesClientDeletePoller) FinalResponse(ctx context.Context) (IPFirewallRulesClientDeleteResponse, error) {
	respType := IPFirewallRulesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return IPFirewallRulesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IPFirewallRulesClientReplaceAllPoller provides polling facilities until the operation reaches a terminal state.
type IPFirewallRulesClientReplaceAllPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPFirewallRulesClientReplaceAllPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IPFirewallRulesClientReplaceAllPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IPFirewallRulesClientReplaceAllResponse will be returned.
func (p *IPFirewallRulesClientReplaceAllPoller) FinalResponse(ctx context.Context) (IPFirewallRulesClientReplaceAllResponse, error) {
	respType := IPFirewallRulesClientReplaceAllResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ReplaceAllFirewallRulesOperationResponse)
	if err != nil {
		return IPFirewallRulesClientReplaceAllResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IPFirewallRulesClientReplaceAllPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimeObjectMetadataClientRefreshPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimeObjectMetadataClientRefreshPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimeObjectMetadataClientRefreshPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimeObjectMetadataClientRefreshPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimeObjectMetadataClientRefreshResponse will be returned.
func (p *IntegrationRuntimeObjectMetadataClientRefreshPoller) FinalResponse(ctx context.Context) (IntegrationRuntimeObjectMetadataClientRefreshResponse, error) {
	respType := IntegrationRuntimeObjectMetadataClientRefreshResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SsisObjectMetadataStatusResponse)
	if err != nil {
		return IntegrationRuntimeObjectMetadataClientRefreshResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimeObjectMetadataClientRefreshPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientCreateResponse will be returned.
func (p *IntegrationRuntimesClientCreatePoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientCreateResponse, error) {
	respType := IntegrationRuntimesClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IntegrationRuntimeResource)
	if err != nil {
		return IntegrationRuntimesClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientDeleteResponse will be returned.
func (p *IntegrationRuntimesClientDeletePoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientDeleteResponse, error) {
	respType := IntegrationRuntimesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientDisableInteractiveQueryPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientDisableInteractiveQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientDisableInteractiveQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientDisableInteractiveQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientDisableInteractiveQueryResponse will be returned.
func (p *IntegrationRuntimesClientDisableInteractiveQueryPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientDisableInteractiveQueryResponse, error) {
	respType := IntegrationRuntimesClientDisableInteractiveQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesClientDisableInteractiveQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientDisableInteractiveQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientEnableInteractiveQueryPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientEnableInteractiveQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientEnableInteractiveQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientEnableInteractiveQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientEnableInteractiveQueryResponse will be returned.
func (p *IntegrationRuntimesClientEnableInteractiveQueryPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientEnableInteractiveQueryResponse, error) {
	respType := IntegrationRuntimesClientEnableInteractiveQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesClientEnableInteractiveQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientEnableInteractiveQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientStartPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientStartResponse will be returned.
func (p *IntegrationRuntimesClientStartPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientStartResponse, error) {
	respType := IntegrationRuntimesClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IntegrationRuntimeStatusResponse)
	if err != nil {
		return IntegrationRuntimesClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// IntegrationRuntimesClientStopPoller provides polling facilities until the operation reaches a terminal state.
type IntegrationRuntimesClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IntegrationRuntimesClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *IntegrationRuntimesClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final IntegrationRuntimesClientStopResponse will be returned.
func (p *IntegrationRuntimesClientStopPoller) FinalResponse(ctx context.Context) (IntegrationRuntimesClientStopResponse, error) {
	respType := IntegrationRuntimesClientStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IntegrationRuntimesClientStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *IntegrationRuntimesClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdateResponse, error) {
	respType := KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AttachedDatabaseConfiguration)
	if err != nil {
		return KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolAttachedDatabaseConfigurationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolAttachedDatabaseConfigurationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolAttachedDatabaseConfigurationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolAttachedDatabaseConfigurationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolAttachedDatabaseConfigurationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolAttachedDatabaseConfigurationsClientDeleteResponse will be returned.
func (p *KustoPoolAttachedDatabaseConfigurationsClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolAttachedDatabaseConfigurationsClientDeleteResponse, error) {
	respType := KustoPoolAttachedDatabaseConfigurationsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolAttachedDatabaseConfigurationsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolAttachedDatabaseConfigurationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolDataConnectionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsClientCreateOrUpdateResponse, error) {
	respType := KustoPoolDataConnectionsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPoolDataConnectionsClientCreateOrUpdateResult)
	if err != nil {
		return KustoPoolDataConnectionsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsClientDataConnectionValidationPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsClientDataConnectionValidationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsClientDataConnectionValidationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsClientDataConnectionValidationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsClientDataConnectionValidationResponse will be returned.
func (p *KustoPoolDataConnectionsClientDataConnectionValidationPoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsClientDataConnectionValidationResponse, error) {
	respType := KustoPoolDataConnectionsClientDataConnectionValidationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataConnectionValidationListResult)
	if err != nil {
		return KustoPoolDataConnectionsClientDataConnectionValidationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsClientDataConnectionValidationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsClientDeleteResponse will be returned.
func (p *KustoPoolDataConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsClientDeleteResponse, error) {
	respType := KustoPoolDataConnectionsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDataConnectionsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDataConnectionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDataConnectionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDataConnectionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDataConnectionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDataConnectionsClientUpdateResponse will be returned.
func (p *KustoPoolDataConnectionsClientUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDataConnectionsClientUpdateResponse, error) {
	respType := KustoPoolDataConnectionsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPoolDataConnectionsClientUpdateResult)
	if err != nil {
		return KustoPoolDataConnectionsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDataConnectionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdateResponse, error) {
	respType := KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatabasePrincipalAssignment)
	if err != nil {
		return KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasePrincipalAssignmentsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasePrincipalAssignmentsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasePrincipalAssignmentsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasePrincipalAssignmentsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasePrincipalAssignmentsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasePrincipalAssignmentsClientDeleteResponse will be returned.
func (p *KustoPoolDatabasePrincipalAssignmentsClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasePrincipalAssignmentsClientDeleteResponse, error) {
	respType := KustoPoolDatabasePrincipalAssignmentsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDatabasePrincipalAssignmentsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasePrincipalAssignmentsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolDatabasesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesClientCreateOrUpdateResponse, error) {
	respType := KustoPoolDatabasesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPoolDatabasesClientCreateOrUpdateResult)
	if err != nil {
		return KustoPoolDatabasesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesClientDeleteResponse will be returned.
func (p *KustoPoolDatabasesClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesClientDeleteResponse, error) {
	respType := KustoPoolDatabasesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolDatabasesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolDatabasesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolDatabasesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolDatabasesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolDatabasesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolDatabasesClientUpdateResponse will be returned.
func (p *KustoPoolDatabasesClientUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolDatabasesClientUpdateResponse, error) {
	respType := KustoPoolDatabasesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPoolDatabasesClientUpdateResult)
	if err != nil {
		return KustoPoolDatabasesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolDatabasesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolPrincipalAssignmentsClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolPrincipalAssignmentsClientCreateOrUpdateResponse, error) {
	respType := KustoPoolPrincipalAssignmentsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ClusterPrincipalAssignment)
	if err != nil {
		return KustoPoolPrincipalAssignmentsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolPrincipalAssignmentsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolPrincipalAssignmentsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolPrincipalAssignmentsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolPrincipalAssignmentsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolPrincipalAssignmentsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolPrincipalAssignmentsClientDeleteResponse will be returned.
func (p *KustoPoolPrincipalAssignmentsClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolPrincipalAssignmentsClientDeleteResponse, error) {
	respType := KustoPoolPrincipalAssignmentsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolPrincipalAssignmentsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolPrincipalAssignmentsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientAddLanguageExtensionsPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientAddLanguageExtensionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientAddLanguageExtensionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientAddLanguageExtensionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientAddLanguageExtensionsResponse will be returned.
func (p *KustoPoolsClientAddLanguageExtensionsPoller) FinalResponse(ctx context.Context) (KustoPoolsClientAddLanguageExtensionsResponse, error) {
	respType := KustoPoolsClientAddLanguageExtensionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientAddLanguageExtensionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientAddLanguageExtensionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientCreateOrUpdateResponse will be returned.
func (p *KustoPoolsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolsClientCreateOrUpdateResponse, error) {
	respType := KustoPoolsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPool)
	if err != nil {
		return KustoPoolsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientDeleteResponse will be returned.
func (p *KustoPoolsClientDeletePoller) FinalResponse(ctx context.Context) (KustoPoolsClientDeleteResponse, error) {
	respType := KustoPoolsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientDetachFollowerDatabasesPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientDetachFollowerDatabasesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientDetachFollowerDatabasesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientDetachFollowerDatabasesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientDetachFollowerDatabasesResponse will be returned.
func (p *KustoPoolsClientDetachFollowerDatabasesPoller) FinalResponse(ctx context.Context) (KustoPoolsClientDetachFollowerDatabasesResponse, error) {
	respType := KustoPoolsClientDetachFollowerDatabasesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientDetachFollowerDatabasesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientDetachFollowerDatabasesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientRemoveLanguageExtensionsPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientRemoveLanguageExtensionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientRemoveLanguageExtensionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientRemoveLanguageExtensionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientRemoveLanguageExtensionsResponse will be returned.
func (p *KustoPoolsClientRemoveLanguageExtensionsPoller) FinalResponse(ctx context.Context) (KustoPoolsClientRemoveLanguageExtensionsResponse, error) {
	respType := KustoPoolsClientRemoveLanguageExtensionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientRemoveLanguageExtensionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientRemoveLanguageExtensionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientStartResponse will be returned.
func (p *KustoPoolsClientStartPoller) FinalResponse(ctx context.Context) (KustoPoolsClientStartResponse, error) {
	respType := KustoPoolsClientStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientStopPoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientStopResponse will be returned.
func (p *KustoPoolsClientStopPoller) FinalResponse(ctx context.Context) (KustoPoolsClientStopResponse, error) {
	respType := KustoPoolsClientStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return KustoPoolsClientStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// KustoPoolsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type KustoPoolsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *KustoPoolsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *KustoPoolsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final KustoPoolsClientUpdateResponse will be returned.
func (p *KustoPoolsClientUpdatePoller) FinalResponse(ctx context.Context) (KustoPoolsClientUpdateResponse, error) {
	respType := KustoPoolsClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.KustoPool)
	if err != nil {
		return KustoPoolsClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *KustoPoolsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientCreateResponse will be returned.
func (p *PrivateEndpointConnectionsClientCreatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientCreateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OperationResource)
	if err != nil {
		return PrivateEndpointConnectionsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateLinkHubsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkHubsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkHubsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateLinkHubsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateLinkHubsClientDeleteResponse will be returned.
func (p *PrivateLinkHubsClientDeletePoller) FinalResponse(ctx context.Context) (PrivateLinkHubsClientDeleteResponse, error) {
	respType := PrivateLinkHubsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkHubsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateLinkHubsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolRestorePointsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolRestorePointsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolRestorePointsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolRestorePointsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolRestorePointsClientCreateResponse will be returned.
func (p *SQLPoolRestorePointsClientCreatePoller) FinalResponse(ctx context.Context) (SQLPoolRestorePointsClientCreateResponse, error) {
	respType := SQLPoolRestorePointsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RestorePoint)
	if err != nil {
		return SQLPoolRestorePointsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolRestorePointsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolVulnerabilityAssessmentScansClientInitiateScanResponse will be returned.
func (p *SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller) FinalResponse(ctx context.Context) (SQLPoolVulnerabilityAssessmentScansClientInitiateScanResponse, error) {
	respType := SQLPoolVulnerabilityAssessmentScansClientInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolVulnerabilityAssessmentScansClientInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolVulnerabilityAssessmentScansClientInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadClassifierClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadClassifierClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadClassifierClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadClassifierClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadClassifierClientCreateOrUpdateResponse will be returned.
func (p *SQLPoolWorkloadClassifierClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadClassifierClientCreateOrUpdateResponse, error) {
	respType := SQLPoolWorkloadClassifierClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadClassifier)
	if err != nil {
		return SQLPoolWorkloadClassifierClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadClassifierClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadClassifierClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadClassifierClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadClassifierClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadClassifierClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadClassifierClientDeleteResponse will be returned.
func (p *SQLPoolWorkloadClassifierClientDeletePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadClassifierClientDeleteResponse, error) {
	respType := SQLPoolWorkloadClassifierClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolWorkloadClassifierClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadClassifierClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadGroupClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadGroupClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadGroupClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadGroupClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadGroupClientCreateOrUpdateResponse will be returned.
func (p *SQLPoolWorkloadGroupClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadGroupClientCreateOrUpdateResponse, error) {
	respType := SQLPoolWorkloadGroupClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadGroup)
	if err != nil {
		return SQLPoolWorkloadGroupClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadGroupClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolWorkloadGroupClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolWorkloadGroupClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolWorkloadGroupClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolWorkloadGroupClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolWorkloadGroupClientDeleteResponse will be returned.
func (p *SQLPoolWorkloadGroupClientDeletePoller) FinalResponse(ctx context.Context) (SQLPoolWorkloadGroupClientDeleteResponse, error) {
	respType := SQLPoolWorkloadGroupClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLPoolWorkloadGroupClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolWorkloadGroupClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsClientCreateResponse will be returned.
func (p *SQLPoolsClientCreatePoller) FinalResponse(ctx context.Context) (SQLPoolsClientCreateResponse, error) {
	respType := SQLPoolsClientCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLPool)
	if err != nil {
		return SQLPoolsClientCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsClientDeleteResponse will be returned.
func (p *SQLPoolsClientDeletePoller) FinalResponse(ctx context.Context) (SQLPoolsClientDeleteResponse, error) {
	respType := SQLPoolsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsClientPausePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsClientPausePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsClientPausePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsClientPausePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsClientPauseResponse will be returned.
func (p *SQLPoolsClientPausePoller) FinalResponse(ctx context.Context) (SQLPoolsClientPauseResponse, error) {
	respType := SQLPoolsClientPauseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsClientPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsClientPausePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLPoolsClientResumePoller provides polling facilities until the operation reaches a terminal state.
type SQLPoolsClientResumePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLPoolsClientResumePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLPoolsClientResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLPoolsClientResumeResponse will be returned.
func (p *SQLPoolsClientResumePoller) FinalResponse(ctx context.Context) (SQLPoolsClientResumeResponse, error) {
	respType := SQLPoolsClientResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return SQLPoolsClientResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLPoolsClientResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceAADAdminsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceAADAdminsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceAADAdminsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceAADAdminsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceAADAdminsClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceAADAdminsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceAADAdminsClientCreateOrUpdateResponse, error) {
	respType := WorkspaceAADAdminsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkspaceAADAdminInfo)
	if err != nil {
		return WorkspaceAADAdminsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceAADAdminsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceAADAdminsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceAADAdminsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceAADAdminsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceAADAdminsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceAADAdminsClientDeleteResponse will be returned.
func (p *WorkspaceAADAdminsClientDeletePoller) FinalResponse(ctx context.Context) (WorkspaceAADAdminsClientDeleteResponse, error) {
	respType := WorkspaceAADAdminsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceAADAdminsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceAADAdminsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedIdentitySQLControlSettingsModel)
	if err != nil {
		return WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedIdentitySQLControlSettingsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerBlobAuditingPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EncryptionProtector)
	if err != nil {
		return WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerEncryptionProtectorClientRevalidateResponse will be returned.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerEncryptionProtectorClientRevalidateResponse, error) {
	respType := WorkspaceManagedSQLServerEncryptionProtectorClientRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceManagedSQLServerEncryptionProtectorClientRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerEncryptionProtectorClientRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerExtendedBlobAuditingPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdateResponse, error) {
	respType := WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceManagedSQLServerSecurityAlertPolicyClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceSQLAADAdminsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceSQLAADAdminsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceSQLAADAdminsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceSQLAADAdminsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceSQLAADAdminsClientCreateOrUpdateResponse will be returned.
func (p *WorkspaceSQLAADAdminsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspaceSQLAADAdminsClientCreateOrUpdateResponse, error) {
	respType := WorkspaceSQLAADAdminsClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkspaceAADAdminInfo)
	if err != nil {
		return WorkspaceSQLAADAdminsClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceSQLAADAdminsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspaceSQLAADAdminsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspaceSQLAADAdminsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspaceSQLAADAdminsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspaceSQLAADAdminsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspaceSQLAADAdminsClientDeleteResponse will be returned.
func (p *WorkspaceSQLAADAdminsClientDeletePoller) FinalResponse(ctx context.Context) (WorkspaceSQLAADAdminsClientDeleteResponse, error) {
	respType := WorkspaceSQLAADAdminsClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkspaceSQLAADAdminsClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspaceSQLAADAdminsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesClientCreateOrUpdateResponse will be returned.
func (p *WorkspacesClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkspacesClientCreateOrUpdateResponse, error) {
	respType := WorkspacesClientCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Workspace)
	if err != nil {
		return WorkspacesClientCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesClientDeleteResponse will be returned.
func (p *WorkspacesClientDeletePoller) FinalResponse(ctx context.Context) (WorkspacesClientDeleteResponse, error) {
	respType := WorkspacesClientDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Object)
	if err != nil {
		return WorkspacesClientDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WorkspacesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkspacesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WorkspacesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WorkspacesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WorkspacesClientUpdateResponse will be returned.
func (p *WorkspacesClientUpdatePoller) FinalResponse(ctx context.Context) (WorkspacesClientUpdateResponse, error) {
	respType := WorkspacesClientUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Workspace)
	if err != nil {
		return WorkspacesClientUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WorkspacesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
