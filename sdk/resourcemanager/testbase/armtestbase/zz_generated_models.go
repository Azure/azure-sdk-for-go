//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armtestbase

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccountListResult - A list of Test Base Accounts.
type AccountListResult struct {
	// The list of Test Base Accounts.
	Value []*AccountResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountListResult.
func (a AccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccountResource - The Test Base Account resource.
type AccountResource struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Properties of a Test Base Account.
	Properties *AccountResourceProperties `json:"properties,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResource.
func (a AccountResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", a.Etag)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AccountResourceProperties - The properties of a Test Base Account resource.
type AccountResourceProperties struct {
	// REQUIRED; The SKU of the Test Base Account.
	SKU *AccountSKU `json:"sku,omitempty"`

	// READ-ONLY; The access level of the Test Base Account.
	AccessLevel *string `json:"accessLevel,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// AccountSKU - Describes a Test Base Account SKU.
type AccountSKU struct {
	// REQUIRED; The name of the SKU. This is typically a letter + number code, such as B0 or S0.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The tier of this particular SKU.
	Tier *Tier `json:"tier,omitempty"`

	// The locations that the SKU is available.
	Locations []*string `json:"locations,omitempty"`

	// The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`

	// READ-ONLY; The capabilities of a SKU.
	Capabilities []*AccountSKUCapability `json:"capabilities,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountSKU.
func (a AccountSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capabilities", a.Capabilities)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "resourceType", a.ResourceType)
	populate(objectMap, "tier", a.Tier)
	return json.Marshal(objectMap)
}

// AccountSKUCapability - Properties of the Test Base Account SKU Capability.
type AccountSKUCapability struct {
	// REQUIRED; An invariant to describe the feature, such as 'SLA'.
	Name *string `json:"name,omitempty"`

	// REQUIRED; An invariant if the feature is measured by quantity, such as 99.9%.
	Value *string `json:"value,omitempty"`
}

// AccountSKUListResult - A list of Test Base Account SKUs.
type AccountSKUListResult struct {
	// The list of Test Base Account SKUs.
	Value []*AccountSKU `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountSKUListResult.
func (a AccountSKUListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccountUpdateParameterProperties - Parameters supplied to update a Test Base Account.
type AccountUpdateParameterProperties struct {
	// The SKU of the Test Base Account.
	SKU *AccountSKU `json:"sku,omitempty"`
}

// AccountUpdateParameters - Parameters supplied to update a Test Base Account.
type AccountUpdateParameters struct {
	// Test Base Account update parameters.
	Properties *AccountUpdateParameterProperties `json:"properties,omitempty"`

	// The tags of the Test Base Account.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountUpdateParameters.
func (a AccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// AccountUsageData - The usage data of a Test Base Account.
type AccountUsageData struct {
	// Current value for the usage quota.
	CurrentValue *int64 `json:"currentValue,omitempty"`

	// Fully qualified ARM resource id
	ID *string `json:"id,omitempty"`

	// The maximum permitted value for the usage quota. If there is no limit, this value will be -1.
	Limit *int64 `json:"limit,omitempty"`

	// Localizable String object containing the name and a localized value.
	Name *AccountUsageName `json:"name,omitempty"`

	// Representing the units of the usage quota. Possible values are: Count, Bytes, Seconds, Percent, CountPerSecond, BytesPerSecond.
	Unit *string `json:"unit,omitempty"`
}

// AccountUsageDataList - A list of Test Base Account usage data.
type AccountUsageDataList struct {
	// The list of Test Base Account usage data.
	Value []*AccountUsageData `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountUsageDataList.
func (a AccountUsageDataList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccountUsageName - Localizable String object containing the name and a localized value.
type AccountUsageName struct {
	// Localized name of the usage.
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// The identifier of the usage.
	Value *string `json:"value,omitempty"`
}

// AccountsClientBeginCreateOptions contains the optional parameters for the AccountsClient.BeginCreate method.
type AccountsClientBeginCreateOptions struct {
	// The flag indicating if we would like to restore the Test Base Accounts which were soft deleted before.
	Restore *bool
}

// AccountsClientBeginDeleteOptions contains the optional parameters for the AccountsClient.BeginDelete method.
type AccountsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccountsClientBeginOffboardOptions contains the optional parameters for the AccountsClient.BeginOffboard method.
type AccountsClientBeginOffboardOptions struct {
	// placeholder for future optional parameters
}

// AccountsClientBeginUpdateOptions contains the optional parameters for the AccountsClient.BeginUpdate method.
type AccountsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountsClientCheckPackageNameAvailabilityOptions contains the optional parameters for the AccountsClient.CheckPackageNameAvailability
// method.
type AccountsClientCheckPackageNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// AccountsClientGetFileUploadURLOptions contains the optional parameters for the AccountsClient.GetFileUploadURL method.
type AccountsClientGetFileUploadURLOptions struct {
	// Parameters supplied to the Test Base Account GetFileUploadURL operation.
	Parameters *GetFileUploadURLParameters
}

// AccountsClientGetOptions contains the optional parameters for the AccountsClient.Get method.
type AccountsClientGetOptions struct {
	// placeholder for future optional parameters
}

// AccountsClientListByResourceGroupOptions contains the optional parameters for the AccountsClient.ListByResourceGroup method.
type AccountsClientListByResourceGroupOptions struct {
	// The flag indicating if we need to include the Test Base Accounts which were soft deleted before.
	GetDeleted *bool
}

// AccountsClientListBySubscriptionOptions contains the optional parameters for the AccountsClient.ListBySubscription method.
type AccountsClientListBySubscriptionOptions struct {
	// The flag indicating if we need to include the Test Base Accounts which were soft deleted before.
	GetDeleted *bool
}

// AnalysisResultListResult - A list of Analysis Results. It will only contain one element as all the data will be nested
// in a singleton object.
type AnalysisResultListResult struct {
	// The list of Analysis Results.
	Value []*AnalysisResultSingletonResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AnalysisResultListResult.
func (a AnalysisResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AnalysisResultSingletonResource - The Analysis Result Singleton Resource.
type AnalysisResultSingletonResource struct {
	// Properties of an Analysis Result.
	Properties AnalysisResultSingletonResourcePropertiesClassification `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AnalysisResultSingletonResource.
func (a AnalysisResultSingletonResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalysisResultSingletonResource.
func (a *AnalysisResultSingletonResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &a.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAnalysisResultSingletonResourcePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &a.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AnalysisResultSingletonResourcePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetAnalysisResultSingletonResourceProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AnalysisResultSingletonResourceProperties, *CPURegressionResultSingletonResourceProperties, *CPUUtilizationResultSingletonResourceProperties,
// - *MemoryRegressionResultSingletonResourceProperties, *MemoryUtilizationResultSingletonResourceProperties, *ReliabilityResultSingletonResourceProperties,
// - *ScriptExecutionResultSingletonResourceProperties, *TestAnalysisResultSingletonResourceProperties
type AnalysisResultSingletonResourcePropertiesClassification interface {
	// GetAnalysisResultSingletonResourceProperties returns the AnalysisResultSingletonResourceProperties content of the underlying type.
	GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties
}

// AnalysisResultSingletonResourceProperties - The properties of Analysis Result resource.
type AnalysisResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type AnalysisResultSingletonResourceProperties.
func (a *AnalysisResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return a
}

// AnalysisResultsClientGetOptions contains the optional parameters for the AnalysisResultsClient.Get method.
type AnalysisResultsClientGetOptions struct {
	// placeholder for future optional parameters
}

// AnalysisResultsClientListOptions contains the optional parameters for the AnalysisResultsClient.List method.
type AnalysisResultsClientListOptions struct {
	// placeholder for future optional parameters
}

// AvailableOSClientGetOptions contains the optional parameters for the AvailableOSClient.Get method.
type AvailableOSClientGetOptions struct {
	// placeholder for future optional parameters
}

// AvailableOSClientListOptions contains the optional parameters for the AvailableOSClient.List method.
type AvailableOSClientListOptions struct {
	// placeholder for future optional parameters
}

// AvailableOSListResult - A list of available OSs.
type AvailableOSListResult struct {
	// The list of available OSs.
	Value []*AvailableOSResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableOSListResult.
func (a AvailableOSListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AvailableOSProperties - The Available OS properties.
type AvailableOSProperties struct {
	// The insider channel of an Available OS of a Test Base Account.
	InsiderChannel *string `json:"insiderChannel,omitempty"`

	// The Id of an Available OS of a Test Base Account.
	OSID *string `json:"osId,omitempty"`

	// The name of an Available OS of a Test Base Account.
	OSName *string `json:"osName,omitempty"`

	// The Platform of an Available OS of a Test Base Account.
	OSPlatform *string `json:"osPlatform,omitempty"`

	// The OS update type of an Available OS of a Test Base Account.
	OSUpdateType *string `json:"osUpdateType,omitempty"`

	// The version of an Available OS of a Test Base Account.
	OSVersion *string `json:"osVersion,omitempty"`
}

// AvailableOSResource - The Available OS resource.
type AvailableOSResource struct {
	// Available OS properties.
	Properties *AvailableOSProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// CPURegressionResultSingletonResourceProperties - The properties of CPU Regression Result.
type CPURegressionResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The result array data.
	CPURegressionResults []*RegressionResult `json:"cpuRegressionResults,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type CPURegressionResultSingletonResourceProperties.
func (c *CPURegressionResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              c.Grade,
		AnalysisResultType: c.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CPURegressionResultSingletonResourceProperties.
func (c CPURegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeCPURegression
	populate(objectMap, "cpuRegressionResults", c.CPURegressionResults)
	populate(objectMap, "grade", c.Grade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CPURegressionResultSingletonResourceProperties.
func (c *CPURegressionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &c.AnalysisResultType)
			delete(rawMsg, key)
		case "cpuRegressionResults":
			err = unpopulate(val, &c.CPURegressionResults)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &c.Grade)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CPUUtilizationResultSingletonResourceProperties - The properties of CPU Utilization Result.
type CPUUtilizationResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The result array data.
	CPUUtilizationResults []*UtilizationResult `json:"cpuUtilizationResults,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type CPUUtilizationResultSingletonResourceProperties.
func (c *CPUUtilizationResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              c.Grade,
		AnalysisResultType: c.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CPUUtilizationResultSingletonResourceProperties.
func (c CPUUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeCPUUtilization
	populate(objectMap, "cpuUtilizationResults", c.CPUUtilizationResults)
	populate(objectMap, "grade", c.Grade)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CPUUtilizationResultSingletonResourceProperties.
func (c *CPUUtilizationResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &c.AnalysisResultType)
			delete(rawMsg, key)
		case "cpuUtilizationResults":
			err = unpopulate(val, &c.CPUUtilizationResults)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &c.Grade)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CheckNameAvailabilityResult - Description of a Check Name availability response properties.
type CheckNameAvailabilityResult struct {
	// Value indicating the availability of the name: true if the name is available; otherwise, false.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason for unavailability of a name. Required if nameAvailable == false.
	Reason *Reason `json:"reason,omitempty"`

	// READ-ONLY; The detailed info regarding the reason associated with the name. Required if nameAvailable == false.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// Command - The command used in the test
type Command struct {
	// REQUIRED; The action of the command.
	Action *Action `json:"action,omitempty"`

	// REQUIRED; The content of the command. The content depends on source type.
	Content *string `json:"content,omitempty"`

	// REQUIRED; The type of command content.
	ContentType *ContentType `json:"contentType,omitempty"`

	// REQUIRED; The name of the command.
	Name *string `json:"name,omitempty"`

	// Specifies whether to run the command even if a previous command is failed.
	AlwaysRun *bool `json:"alwaysRun,omitempty"`

	// Specifies whether to apply update before the command.
	ApplyUpdateBefore *bool `json:"applyUpdateBefore,omitempty"`

	// Specifies the max run time of the command.
	MaxRunTime *int32 `json:"maxRunTime,omitempty"`

	// Specifies whether to restart the VM after the command executed.
	RestartAfter *bool `json:"restartAfter,omitempty"`

	// Specifies whether to run the command in interactive mode.
	RunAsInteractive *bool `json:"runAsInteractive,omitempty"`

	// Specifies whether to run the command as administrator.
	RunElevated *bool `json:"runElevated,omitempty"`
}

// CustomerEventListResult - A list of Test Base Customer Events.
type CustomerEventListResult struct {
	// The list of Test Base Customer Events.
	Value []*CustomerEventResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEventListResult.
func (c CustomerEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CustomerEventProperties - A notification events subscribed to be received by customer.
type CustomerEventProperties struct {
	// REQUIRED; The name of the event subscribed to.
	EventName *string `json:"eventName,omitempty"`

	// REQUIRED; The notification event receivers.
	Receivers []*NotificationEventReceiver `json:"receivers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomerEventProperties.
func (c CustomerEventProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eventName", c.EventName)
	populate(objectMap, "receivers", c.Receivers)
	return json.Marshal(objectMap)
}

// CustomerEventResource - The Customer Notification Event resource.
type CustomerEventResource struct {
	// Customer Notification Event properties.
	Properties *CustomerEventProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// CustomerEventsClientBeginCreateOptions contains the optional parameters for the CustomerEventsClient.BeginCreate method.
type CustomerEventsClientBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// CustomerEventsClientBeginDeleteOptions contains the optional parameters for the CustomerEventsClient.BeginDelete method.
type CustomerEventsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// CustomerEventsClientGetOptions contains the optional parameters for the CustomerEventsClient.Get method.
type CustomerEventsClientGetOptions struct {
	// placeholder for future optional parameters
}

// CustomerEventsClientListByTestBaseAccountOptions contains the optional parameters for the CustomerEventsClient.ListByTestBaseAccount
// method.
type CustomerEventsClientListByTestBaseAccountOptions struct {
	// placeholder for future optional parameters
}

// DistributionGroupListReceiverValue - The user object receiver value.
type DistributionGroupListReceiverValue struct {
	// The list of distribution groups.
	DistributionGroups []*string `json:"distributionGroups,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DistributionGroupListReceiverValue.
func (d DistributionGroupListReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "distributionGroups", d.DistributionGroups)
	return json.Marshal(objectMap)
}

// DownloadURLResponse - The response of getting a download URL.
type DownloadURLResponse struct {
	// READ-ONLY; The download URL.
	DownloadURL *string `json:"downloadUrl,omitempty" azure:"ro"`

	// READ-ONLY; Expiry date of the download URL.
	ExpirationTime *time.Time `json:"expirationTime,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DownloadURLResponse.
func (d DownloadURLResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "downloadUrl", d.DownloadURL)
	populateTimeRFC3339(objectMap, "expirationTime", d.ExpirationTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DownloadURLResponse.
func (d *DownloadURLResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "downloadUrl":
			err = unpopulate(val, &d.DownloadURL)
			delete(rawMsg, key)
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, &d.ExpirationTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EmailEventListResult - A list of email events.
type EmailEventListResult struct {
	// The list of email events.
	Value []*EmailEventResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EmailEventListResult.
func (e EmailEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EmailEventProperties - The Email Event properties.
type EmailEventProperties struct {
	// The display name of the email event.
	DisplayName *string `json:"displayName,omitempty"`

	// The identifier of the email event.
	EventID *string `json:"eventId,omitempty"`

	// The name of the email event.
	EventName *string `json:"eventName,omitempty"`
}

// EmailEventResource - The email event resource.
type EmailEventResource struct {
	// Email Event properties.
	Properties *EmailEventProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// EmailEventsClientGetOptions contains the optional parameters for the EmailEventsClient.Get method.
type EmailEventsClientGetOptions struct {
	// placeholder for future optional parameters
}

// EmailEventsClientListOptions contains the optional parameters for the EmailEventsClient.List method.
type EmailEventsClientListOptions struct {
	// placeholder for future optional parameters
}

// ErrorDefinition - Error definition.
type ErrorDefinition struct {
	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDefinition `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDefinition.
func (e ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - The error response send when an operation fails.
type ErrorResponse struct {
	// The error details.
	Error *ErrorDefinition `json:"error,omitempty"`
}

// FavoriteProcessListResult - A list of favorite processes for a package.
type FavoriteProcessListResult struct {
	// The list of favorite processes for a package.
	Value []*FavoriteProcessResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FavoriteProcessListResult.
func (f FavoriteProcessListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FavoriteProcessProperties - Properties of a favorite process identifier.
type FavoriteProcessProperties struct {
	// REQUIRED; The actual name of the favorite process. It will be equal to resource name except for the scenario that the process
	// name contains characters that are not allowed in the resource name.
	ActualProcessName *string `json:"actualProcessName,omitempty"`
}

// FavoriteProcessResource - A favorite process identifier.
type FavoriteProcessResource struct {
	// Properties of a favorite process identifier.
	Properties *FavoriteProcessProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// FavoriteProcessesClientCreateOptions contains the optional parameters for the FavoriteProcessesClient.Create method.
type FavoriteProcessesClientCreateOptions struct {
	// placeholder for future optional parameters
}

// FavoriteProcessesClientDeleteOptions contains the optional parameters for the FavoriteProcessesClient.Delete method.
type FavoriteProcessesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// FavoriteProcessesClientGetOptions contains the optional parameters for the FavoriteProcessesClient.Get method.
type FavoriteProcessesClientGetOptions struct {
	// placeholder for future optional parameters
}

// FavoriteProcessesClientListOptions contains the optional parameters for the FavoriteProcessesClient.List method.
type FavoriteProcessesClientListOptions struct {
	// placeholder for future optional parameters
}

// FileUploadURLResponse - The URL response
type FileUploadURLResponse struct {
	// READ-ONLY; The blob path of the uploaded package. It will be used as the 'blobPath' property of PackageResource.
	BlobPath *string `json:"blobPath,omitempty" azure:"ro"`

	// READ-ONLY; The URL used for uploading the package.
	UploadURL *string `json:"uploadUrl,omitempty" azure:"ro"`
}

// FlightingRingListResult - A list of flighting rings.
type FlightingRingListResult struct {
	// The list of flighting rings.
	Value []*FlightingRingResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FlightingRingListResult.
func (f FlightingRingListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FlightingRingProperties - The Flighting Ring properties.
type FlightingRingProperties struct {
	// The actual name of a flighting ring of a Test Base Account.
	ActualFlightingRingName *string `json:"actualFlightingRingName,omitempty"`
}

// FlightingRingResource - The flighting ring resource.
type FlightingRingResource struct {
	// Flighting Ring properties.
	Properties *FlightingRingProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// FlightingRingsClientGetOptions contains the optional parameters for the FlightingRingsClient.Get method.
type FlightingRingsClientGetOptions struct {
	// placeholder for future optional parameters
}

// FlightingRingsClientListOptions contains the optional parameters for the FlightingRingsClient.List method.
type FlightingRingsClientListOptions struct {
	// placeholder for future optional parameters
}

// GetFileUploadURLParameters - The parameters supplied to the Test Base Account GetFileUploadURL action.
type GetFileUploadURLParameters struct {
	// The custom file name of the uploaded blob.
	BlobName *string `json:"blobName,omitempty"`
}

// IdentifiedFailure - The failure identified.
type IdentifiedFailure struct {
	// The category of the failure.
	Category *Category `json:"category,omitempty"`

	// Message that shows information about the failure.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// The Failure Id.
	FailureID *string `json:"failureId,omitempty"`

	// Guidance that shows what the customer needs to do for this failure.
	Guidance *string `json:"guidance,omitempty"`
}

// MemoryRegressionResultSingletonResourceProperties - The properties of Memory Regression Result.
type MemoryRegressionResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The result array data.
	MemoryRegressionResults []*RegressionResult `json:"memoryRegressionResults,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type MemoryRegressionResultSingletonResourceProperties.
func (m *MemoryRegressionResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              m.Grade,
		AnalysisResultType: m.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MemoryRegressionResultSingletonResourceProperties.
func (m MemoryRegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeMemoryRegression
	populate(objectMap, "grade", m.Grade)
	populate(objectMap, "memoryRegressionResults", m.MemoryRegressionResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MemoryRegressionResultSingletonResourceProperties.
func (m *MemoryRegressionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &m.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &m.Grade)
			delete(rawMsg, key)
		case "memoryRegressionResults":
			err = unpopulate(val, &m.MemoryRegressionResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MemoryUtilizationResultSingletonResourceProperties - The properties of Memory Utilization Result.
type MemoryUtilizationResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The result array data.
	MemoryUtilizationResults []*UtilizationResult `json:"memoryUtilizationResults,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type MemoryUtilizationResultSingletonResourceProperties.
func (m *MemoryUtilizationResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              m.Grade,
		AnalysisResultType: m.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MemoryUtilizationResultSingletonResourceProperties.
func (m MemoryUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeMemoryUtilization
	populate(objectMap, "grade", m.Grade)
	populate(objectMap, "memoryUtilizationResults", m.MemoryUtilizationResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MemoryUtilizationResultSingletonResourceProperties.
func (m *MemoryUtilizationResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &m.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &m.Grade)
			delete(rawMsg, key)
		case "memoryUtilizationResults":
			err = unpopulate(val, &m.MemoryUtilizationResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NotificationEventReceiver - A notification event receivers.
type NotificationEventReceiver struct {
	// The type of the notification event receiver.
	ReceiverType *string `json:"receiverType,omitempty"`

	// The notification event receiver value.
	ReceiverValue *NotificationReceiverValue `json:"receiverValue,omitempty"`
}

// NotificationReceiverValue - A notification event receiver value.
type NotificationReceiverValue struct {
	// The user object receiver value.
	DistributionGroupListReceiverValue *DistributionGroupListReceiverValue `json:"distributionGroupListReceiverValue,omitempty"`

	// The user object receiver value.
	SubscriptionReceiverValue *SubscriptionReceiverValue `json:"subscriptionReceiverValue,omitempty"`

	// The user object receiver value.
	UserObjectReceiverValue *UserObjectReceiverValue `json:"userObjectReceiverValue,omitempty"`
}

// OSUpdateListResult - A list of OS Updates.
type OSUpdateListResult struct {
	// The list of OS Updates.
	Value []*OSUpdateResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateListResult.
func (o OSUpdateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OSUpdateProperties - Properties of an OS Update.
type OSUpdateProperties struct {
	// The build revision of the tested release (OS update)
	BuildRevision *string `json:"buildRevision,omitempty"`

	// The build version of the tested release (OS update).
	BuildVersion *string `json:"buildVersion,omitempty"`

	// The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`

	// The name of the OS.
	OSName *string `json:"osName,omitempty"`

	// The name of tested release.
	Release *string `json:"release,omitempty"`

	// The release version date the tested release (OS update)
	ReleaseVersionDate *time.Time `json:"releaseVersionDate,omitempty"`

	// The type of this release (OS update).
	Type *Type `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateProperties.
func (o OSUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "buildRevision", o.BuildRevision)
	populate(objectMap, "buildVersion", o.BuildVersion)
	populate(objectMap, "flightingRing", o.FlightingRing)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "release", o.Release)
	populateTimeRFC3339(objectMap, "releaseVersionDate", o.ReleaseVersionDate)
	populate(objectMap, "type", o.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateProperties.
func (o *OSUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "buildRevision":
			err = unpopulate(val, &o.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, &o.BuildVersion)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, &o.FlightingRing)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, &o.OSName)
			delete(rawMsg, key)
		case "release":
			err = unpopulate(val, &o.Release)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, &o.ReleaseVersionDate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OSUpdateResource - An OS Update.
type OSUpdateResource struct {
	// Properties of an OS Update.
	Properties *OSUpdateProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// OSUpdateTestSummary - The summary of a test.
type OSUpdateTestSummary struct {
	// The build revision of the tested release (OS update)
	BuildRevision *string `json:"buildRevision,omitempty"`

	// The build version of the tested release (OS update)
	BuildVersion *string `json:"buildVersion,omitempty"`

	// The execution status of the test.
	ExecutionStatus *ExecutionStatus `json:"executionStatus,omitempty"`

	// The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The operating system name. e.g. Windows 10 1809.
	OSName *string `json:"osName,omitempty"`

	// The name of the tested release (OS update).
	ReleaseName *string `json:"releaseName,omitempty"`

	// The release version date.
	ReleaseVersionDate *time.Time `json:"releaseVersionDate,omitempty"`

	// The run time of the test.
	TestRunTime *string `json:"testRunTime,omitempty"`

	// The status of the test.
	TestStatus *TestStatus `json:"testStatus,omitempty"`

	// The test type of the package
	TestType *string `json:"testType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdateTestSummary.
func (o OSUpdateTestSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "buildRevision", o.BuildRevision)
	populate(objectMap, "buildVersion", o.BuildVersion)
	populate(objectMap, "executionStatus", o.ExecutionStatus)
	populate(objectMap, "flightingRing", o.FlightingRing)
	populate(objectMap, "grade", o.Grade)
	populate(objectMap, "osName", o.OSName)
	populate(objectMap, "releaseName", o.ReleaseName)
	populateTimeRFC3339(objectMap, "releaseVersionDate", o.ReleaseVersionDate)
	populate(objectMap, "testRunTime", o.TestRunTime)
	populate(objectMap, "testStatus", o.TestStatus)
	populate(objectMap, "testType", o.TestType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSUpdateTestSummary.
func (o *OSUpdateTestSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "buildRevision":
			err = unpopulate(val, &o.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, &o.BuildVersion)
			delete(rawMsg, key)
		case "executionStatus":
			err = unpopulate(val, &o.ExecutionStatus)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, &o.FlightingRing)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &o.Grade)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, &o.OSName)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, &o.ReleaseName)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, &o.ReleaseVersionDate)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, &o.TestRunTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, &o.TestStatus)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, &o.TestType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OSUpdatesClientGetOptions contains the optional parameters for the OSUpdatesClient.Get method.
type OSUpdatesClientGetOptions struct {
	// placeholder for future optional parameters
}

// OSUpdatesClientListOptions contains the optional parameters for the OSUpdatesClient.List method.
type OSUpdatesClientListOptions struct {
	// placeholder for future optional parameters
}

// OSUpdatesTestSummary - The summary of some tests.
type OSUpdatesTestSummary struct {
	// The status of the last test.
	ExecutionStatus *ExecutionStatus `json:"executionStatus,omitempty"`

	// The grade of last test.
	Grade *Grade `json:"grade,omitempty"`

	// Detailed summary for each OS update
	OSUpdateTestSummaries []*OSUpdateTestSummary `json:"osUpdateTestSummaries,omitempty"`

	// The run time of the last test.
	TestRunTime *string `json:"testRunTime,omitempty"`

	// The status of last test.
	TestStatus *TestStatus `json:"testStatus,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OSUpdatesTestSummary.
func (o OSUpdatesTestSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "executionStatus", o.ExecutionStatus)
	populate(objectMap, "grade", o.Grade)
	populate(objectMap, "osUpdateTestSummaries", o.OSUpdateTestSummaries)
	populate(objectMap, "testRunTime", o.TestRunTime)
	populate(objectMap, "testStatus", o.TestStatus)
	return json.Marshal(objectMap)
}

// Operation - REST API operation
type Operation struct {
	// The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// Extra properties of the operation.
	Properties map[string]interface{} `json:"properties,omitempty"`

	// READ-ONLY; Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty" azure:"ro"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Origin of the operation
	Origin *string `json:"origin,omitempty" azure:"ro"`
}

// OperationDisplay - The object that describes the operation.
type OperationDisplay struct {
	// READ-ONLY; Friendly name of the operation.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Operation type: read, write, delete, listPackages, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; The resource provider name: Microsoft.TestBase.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - A list of operations supported by the resource provider.
type OperationListResult struct {
	// List of operations supported by the Test Base resource provider.
	Value []*Operation `json:"value,omitempty"`

	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// PackageCheckNameAvailabilityParameters - Parameters body to pass for Test Base Package name availability check.
type PackageCheckNameAvailabilityParameters struct {
	// REQUIRED; Application name to verify.
	ApplicationName *string `json:"applicationName,omitempty"`

	// REQUIRED; Resource name to verify.
	Name *string `json:"name,omitempty"`

	// REQUIRED; fully qualified resource type which includes provider namespace.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Version name to verify.
	Version *string `json:"version,omitempty"`
}

// PackageListResult - A list of Test Base Packages.
type PackageListResult struct {
	// The list of Test Base Packages.
	Value []*PackageResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageListResult.
func (p PackageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PackageProperties - The properties of the Test Base Package.
type PackageProperties struct {
	// REQUIRED; Application name
	ApplicationName *string `json:"applicationName,omitempty"`

	// REQUIRED; The file path of the package.
	BlobPath *string `json:"blobPath,omitempty"`

	// REQUIRED; The flighting ring for feature update.
	FlightingRing *string `json:"flightingRing,omitempty"`

	// REQUIRED; Specifies the target OSs of specific OS Update types.
	TargetOSList []*TargetOSInfo `json:"targetOSList,omitempty"`

	// REQUIRED; The detailed test information.
	Tests []*Test `json:"tests,omitempty"`

	// REQUIRED; Application version
	Version *string `json:"version,omitempty"`

	// READ-ONLY; Flag showing that whether the package is enabled. It doesn't schedule test for package which is not enabled.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the package was last modified.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; The status of the package.
	PackageStatus *PackageStatus `json:"packageStatus,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the resource.
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; OOB, functional or both. Mapped to the data in 'tests' property.
	TestTypes []*TestType `json:"testTypes,omitempty" azure:"ro"`

	// READ-ONLY; The validation results. There's validation on package when it's created or updated.
	ValidationResults []*PackageValidationResult `json:"validationResults,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageProperties.
func (p PackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationName", p.ApplicationName)
	populate(objectMap, "blobPath", p.BlobPath)
	populate(objectMap, "flightingRing", p.FlightingRing)
	populate(objectMap, "isEnabled", p.IsEnabled)
	populateTimeRFC3339(objectMap, "lastModifiedTime", p.LastModifiedTime)
	populate(objectMap, "packageStatus", p.PackageStatus)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "targetOSList", p.TargetOSList)
	populate(objectMap, "testTypes", p.TestTypes)
	populate(objectMap, "tests", p.Tests)
	populate(objectMap, "validationResults", p.ValidationResults)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PackageProperties.
func (p *PackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationName":
			err = unpopulate(val, &p.ApplicationName)
			delete(rawMsg, key)
		case "blobPath":
			err = unpopulate(val, &p.BlobPath)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, &p.FlightingRing)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &p.IsEnabled)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &p.LastModifiedTime)
			delete(rawMsg, key)
		case "packageStatus":
			err = unpopulate(val, &p.PackageStatus)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &p.ProvisioningState)
			delete(rawMsg, key)
		case "targetOSList":
			err = unpopulate(val, &p.TargetOSList)
			delete(rawMsg, key)
		case "testTypes":
			err = unpopulate(val, &p.TestTypes)
			delete(rawMsg, key)
		case "tests":
			err = unpopulate(val, &p.Tests)
			delete(rawMsg, key)
		case "validationResults":
			err = unpopulate(val, &p.ValidationResults)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &p.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PackageResource - The Test Base Package resource.
type PackageResource struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Test Base Package properties.
	Properties *PackageProperties `json:"properties,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageResource.
func (p PackageResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// PackageUpdateParameterProperties - Parameters supplied to update a Test Base Package.
type PackageUpdateParameterProperties struct {
	// The file name of the package.
	BlobPath *string `json:"blobPath,omitempty"`

	// The flighting ring for feature update.
	FlightingRing *string `json:"flightingRing,omitempty"`

	// Specifies whether the package is enabled. It doesn't schedule test for package which is not enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Specifies the target OSs of specific OS Update types.
	TargetOSList []*TargetOSInfo `json:"targetOSList,omitempty"`

	// The detailed test information.
	Tests []*Test `json:"tests,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageUpdateParameterProperties.
func (p PackageUpdateParameterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobPath", p.BlobPath)
	populate(objectMap, "flightingRing", p.FlightingRing)
	populate(objectMap, "isEnabled", p.IsEnabled)
	populate(objectMap, "targetOSList", p.TargetOSList)
	populate(objectMap, "tests", p.Tests)
	return json.Marshal(objectMap)
}

// PackageUpdateParameters - Parameters supplied to update a Test Base Package.
type PackageUpdateParameters struct {
	// Test Base Package update parameters.
	Properties *PackageUpdateParameterProperties `json:"properties,omitempty"`

	// The tags of the Package.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageUpdateParameters.
func (p PackageUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// PackageValidationResult - The validation results. There's validation on package when it's created or updated.
type PackageValidationResult struct {
	// READ-ONLY; Error information.
	Errors []*string `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether the package passed the validation.
	IsValid *bool `json:"isValid,omitempty" azure:"ro"`

	// READ-ONLY; Validation name.
	ValidationName *string `json:"validationName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PackageValidationResult.
func (p PackageValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", p.Errors)
	populate(objectMap, "isValid", p.IsValid)
	populate(objectMap, "validationName", p.ValidationName)
	return json.Marshal(objectMap)
}

// PackagesClientBeginCreateOptions contains the optional parameters for the PackagesClient.BeginCreate method.
type PackagesClientBeginCreateOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientBeginDeleteOptions contains the optional parameters for the PackagesClient.BeginDelete method.
type PackagesClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientBeginHardDeleteOptions contains the optional parameters for the PackagesClient.BeginHardDelete method.
type PackagesClientBeginHardDeleteOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientBeginUpdateOptions contains the optional parameters for the PackagesClient.BeginUpdate method.
type PackagesClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientGetDownloadURLOptions contains the optional parameters for the PackagesClient.GetDownloadURL method.
type PackagesClientGetDownloadURLOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientGetOptions contains the optional parameters for the PackagesClient.Get method.
type PackagesClientGetOptions struct {
	// placeholder for future optional parameters
}

// PackagesClientListByTestBaseAccountOptions contains the optional parameters for the PackagesClient.ListByTestBaseAccount
// method.
type PackagesClientListByTestBaseAccountOptions struct {
	// placeholder for future optional parameters
}

// ProxyResource - The resource model definition for an ARM proxy resource. It will have everything other than required location
// and tags
type ProxyResource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RegressionResult - The regression result.
type RegressionResult struct {
	// Message that facilitates debugging a particular regression, if any was inferred.
	Details *string `json:"details,omitempty"`

	// Difference between the two datasets being analyzed.
	Diff *float64 `json:"diff,omitempty"`

	// FileName of the binary being analyzed.
	FileName *string `json:"fileName,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// Indicates if a regression was inferred.
	IsRegressed *bool `json:"isRegressed,omitempty"`
}

// RegressionTestDetails - The details of a regression test.
type RegressionTestDetails struct {
	// Difference between the two datasets being analyzed.
	Diff *float64 `json:"diff,omitempty"`

	// Indicates if a regression was inferred.
	IsRegressed *bool `json:"isRegressed,omitempty"`
}

// ReliabilityResult - The Reliability Result.
type ReliabilityResult struct {
	// Count of number of crashes.
	CrashCount *int32 `json:"crashCount,omitempty"`

	// The statistic regression grade for crash signal.
	CrashRegressionGrade *Grade `json:"crashRegressionGrade,omitempty"`

	// Details related to the crash regression analysis.
	CrashRegressionTestDetails *RegressionTestDetails `json:"crashRegressionTestDetails,omitempty"`

	// File name.
	FileName *string `json:"fileName,omitempty"`

	// Count of number of hangs.
	HangCount *int32 `json:"hangCount,omitempty"`

	// The statistic regression grade for hang signal.
	HangRegressionGrade *Grade `json:"hangRegressionGrade,omitempty"`

	// Details related to the hang regression analysis.
	HangRegressionTestDetails *RegressionTestDetails `json:"hangRegressionTestDetails,omitempty"`

	// Count of number of launches.
	LaunchCount *int32 `json:"launchCount,omitempty"`

	// The regression grade.
	RegressionGrade *Grade `json:"regressionGrade,omitempty"`
}

// ReliabilityResultSingletonResourceProperties - The properties of Reliability Result.
type ReliabilityResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The result array data.
	ReliabilityResults []*ReliabilityResult `json:"reliabilityResults,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type ReliabilityResultSingletonResourceProperties.
func (r *ReliabilityResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              r.Grade,
		AnalysisResultType: r.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ReliabilityResultSingletonResourceProperties.
func (r ReliabilityResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeReliability
	populate(objectMap, "grade", r.Grade)
	populate(objectMap, "reliabilityResults", r.ReliabilityResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReliabilityResultSingletonResourceProperties.
func (r *ReliabilityResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &r.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &r.Grade)
			delete(rawMsg, key)
		case "reliabilityResults":
			err = unpopulate(val, &r.ReliabilityResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Resource - The Resource definition.
type Resource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SKUsClientListOptions contains the optional parameters for the SKUsClient.List method.
type SKUsClientListOptions struct {
	// placeholder for future optional parameters
}

// ScriptExecutionResult - The Script Execution Result.
type ScriptExecutionResult struct {
	// End time of script execution.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Exit code.
	ExitCode *int32 `json:"exitCode,omitempty"`

	// Name of script.
	ScriptName *string `json:"scriptName,omitempty"`

	// Start time of script execution.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Whether the script execution is timed out.
	TimedOut *bool `json:"timedOut,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionResult.
func (s ScriptExecutionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populate(objectMap, "exitCode", s.ExitCode)
	populate(objectMap, "scriptName", s.ScriptName)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	populate(objectMap, "timedOut", s.TimedOut)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionResult.
func (s *ScriptExecutionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &s.EndTime)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, &s.ExitCode)
			delete(rawMsg, key)
		case "scriptName":
			err = unpopulate(val, &s.ScriptName)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &s.StartTime)
			delete(rawMsg, key)
		case "timedOut":
			err = unpopulate(val, &s.TimedOut)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ScriptExecutionResultSingletonResourceProperties - The properties of Script Execution Result.
type ScriptExecutionResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The result array data.
	ScriptExecutionResults []*ScriptExecutionResult `json:"scriptExecutionResults,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type ScriptExecutionResultSingletonResourceProperties.
func (s *ScriptExecutionResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              s.Grade,
		AnalysisResultType: s.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionResultSingletonResourceProperties.
func (s ScriptExecutionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeScriptExecution
	populate(objectMap, "grade", s.Grade)
	populate(objectMap, "scriptExecutionResults", s.ScriptExecutionResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionResultSingletonResourceProperties.
func (s *ScriptExecutionResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &s.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &s.Grade)
			delete(rawMsg, key)
		case "scriptExecutionResults":
			err = unpopulate(val, &s.ScriptExecutionResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubscriptionReceiverValue - The subscription role receiver value.
type SubscriptionReceiverValue struct {
	// The role of the notification receiver.
	Role *string `json:"role,omitempty"`

	// The subscription id of the notification receiver.
	SubscriptionID *string `json:"subscriptionId,omitempty"`

	// The subscription name of the notification receiver.
	SubscriptionName *string `json:"subscriptionName,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TargetOSInfo - The information of the target OS to be tested.
type TargetOSInfo struct {
	// REQUIRED; Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
	OSUpdateType *string `json:"osUpdateType,omitempty"`

	// REQUIRED; Specifies the target OSs to be tested.
	TargetOSs []*string `json:"targetOSs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TargetOSInfo.
func (t TargetOSInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "osUpdateType", t.OSUpdateType)
	populate(objectMap, "targetOSs", t.TargetOSs)
	return json.Marshal(objectMap)
}

// Test - The definition of a Test.
type Test struct {
	// REQUIRED; The commands used in the test.
	Commands []*Command `json:"commands,omitempty"`

	// REQUIRED; The type of the test.
	TestType *TestType `json:"testType,omitempty"`

	// Indicates if this test is active.It doesn't schedule test for not active Test.
	IsActive *bool `json:"isActive,omitempty"`

	// READ-ONLY; The status of the validation run of the package.
	ValidationRunStatus *ValidationRunStatus `json:"validationRunStatus,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Test.
func (t Test) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commands", t.Commands)
	populate(objectMap, "isActive", t.IsActive)
	populate(objectMap, "testType", t.TestType)
	populate(objectMap, "validationRunStatus", t.ValidationRunStatus)
	return json.Marshal(objectMap)
}

// TestAnalysisResult - The test analysis result.
type TestAnalysisResult struct {
	// The data to provide more failure analysis information.
	BlobData *string `json:"blobData,omitempty"`

	// The array of identified failures.
	IdentifiedFailures []*IdentifiedFailure `json:"identifiedFailures,omitempty"`

	// The status of the analysis.
	TestAnalysisStatus *TestAnalysisStatus `json:"testAnalysisStatus,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TestAnalysisResult.
func (t TestAnalysisResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "blobData", t.BlobData)
	populate(objectMap, "identifiedFailures", t.IdentifiedFailures)
	populate(objectMap, "testAnalysisStatus", t.TestAnalysisStatus)
	return json.Marshal(objectMap)
}

// TestAnalysisResultSingletonResourceProperties - The properties of Test Analysis Result.
type TestAnalysisResultSingletonResourceProperties struct {
	// REQUIRED; Type of the Analysis Result.
	AnalysisResultType *AnalysisResultType `json:"analysisResultType,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The result of test analysis.
	TestAnalysisResult *TestAnalysisResult `json:"testAnalysisResult,omitempty"`
}

// GetAnalysisResultSingletonResourceProperties implements the AnalysisResultSingletonResourcePropertiesClassification interface
// for type TestAnalysisResultSingletonResourceProperties.
func (t *TestAnalysisResultSingletonResourceProperties) GetAnalysisResultSingletonResourceProperties() *AnalysisResultSingletonResourceProperties {
	return &AnalysisResultSingletonResourceProperties{
		Grade:              t.Grade,
		AnalysisResultType: t.AnalysisResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type TestAnalysisResultSingletonResourceProperties.
func (t TestAnalysisResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["analysisResultType"] = AnalysisResultTypeTestAnalysis
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "testAnalysisResult", t.TestAnalysisResult)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestAnalysisResultSingletonResourceProperties.
func (t *TestAnalysisResultSingletonResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisResultType":
			err = unpopulate(val, &t.AnalysisResultType)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &t.Grade)
			delete(rawMsg, key)
		case "testAnalysisResult":
			err = unpopulate(val, &t.TestAnalysisResult)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TestResultAnalysisSummary - The summary of a Test Analysis Result.
type TestResultAnalysisSummary struct {
	// The analysis status.
	AnalysisStatus *AnalysisStatus `json:"analysisStatus,omitempty"`

	// The grade of the test result.
	Grade *Grade `json:"grade,omitempty"`

	// Metric name
	Name *string `json:"name,omitempty"`
}

// TestResultListResult - A list of Test Results.
type TestResultListResult struct {
	// The list of Test Results.
	Value []*TestResultResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TestResultListResult.
func (t TestResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TestResultProperties - The properties of a Test Result.
type TestResultProperties struct {
	// List of analysis summaries.
	AnalysisSummaries []*TestResultAnalysisSummary `json:"analysisSummaries,omitempty"`

	// Application name.
	ApplicationName *string `json:"applicationName,omitempty"`

	// Application version.
	ApplicationVersion *string `json:"applicationVersion,omitempty"`

	// Azure Id of the baseline test result.
	BaselineTestResultID *string `json:"baselineTestResultId,omitempty"`

	// The build revision of the tested release (OS update).
	BuildRevision *string `json:"buildRevision,omitempty"`

	// The build version of the tested release (OS update).
	BuildVersion *string `json:"buildVersion,omitempty"`

	// The execution status of the test.
	ExecutionStatus *ExecutionStatus `json:"executionStatus,omitempty"`

	// The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// Whether download data is available.
	IsDownloadDataAvailable *bool `json:"isDownloadDataAvailable,omitempty"`

	// Whether video data is available.
	IsVideoAvailable *bool `json:"isVideoAvailable,omitempty"`

	// KB number.
	KbNumber *string `json:"kbNumber,omitempty"`

	// The operating system name, e.g. Windows 10 1809.
	OSName *string `json:"osName,omitempty"`

	// Resource Id of the package.
	PackageID *string `json:"packageId,omitempty"`

	// The version of the Windows update package.
	PackageVersion *string `json:"packageVersion,omitempty"`

	// The name of the tested release (OS update).
	ReleaseName *string `json:"releaseName,omitempty"`

	// The release version date of the tested release.
	ReleaseVersionDate *time.Time `json:"releaseVersionDate,omitempty"`

	// The run time of the test.
	TestRunTime *string `json:"testRunTime,omitempty"`

	// The status of the test.
	TestStatus *TestStatus `json:"testStatus,omitempty"`

	// Test type. E.g. 'Out of box test' or 'Functional test'.
	TestType *string `json:"testType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TestResultProperties.
func (t TestResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "analysisSummaries", t.AnalysisSummaries)
	populate(objectMap, "applicationName", t.ApplicationName)
	populate(objectMap, "applicationVersion", t.ApplicationVersion)
	populate(objectMap, "baselineTestResultId", t.BaselineTestResultID)
	populate(objectMap, "buildRevision", t.BuildRevision)
	populate(objectMap, "buildVersion", t.BuildVersion)
	populate(objectMap, "executionStatus", t.ExecutionStatus)
	populate(objectMap, "flightingRing", t.FlightingRing)
	populate(objectMap, "grade", t.Grade)
	populate(objectMap, "isDownloadDataAvailable", t.IsDownloadDataAvailable)
	populate(objectMap, "isVideoAvailable", t.IsVideoAvailable)
	populate(objectMap, "kbNumber", t.KbNumber)
	populate(objectMap, "osName", t.OSName)
	populate(objectMap, "packageId", t.PackageID)
	populate(objectMap, "packageVersion", t.PackageVersion)
	populate(objectMap, "releaseName", t.ReleaseName)
	populateTimeRFC3339(objectMap, "releaseVersionDate", t.ReleaseVersionDate)
	populate(objectMap, "testRunTime", t.TestRunTime)
	populate(objectMap, "testStatus", t.TestStatus)
	populate(objectMap, "testType", t.TestType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TestResultProperties.
func (t *TestResultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analysisSummaries":
			err = unpopulate(val, &t.AnalysisSummaries)
			delete(rawMsg, key)
		case "applicationName":
			err = unpopulate(val, &t.ApplicationName)
			delete(rawMsg, key)
		case "applicationVersion":
			err = unpopulate(val, &t.ApplicationVersion)
			delete(rawMsg, key)
		case "baselineTestResultId":
			err = unpopulate(val, &t.BaselineTestResultID)
			delete(rawMsg, key)
		case "buildRevision":
			err = unpopulate(val, &t.BuildRevision)
			delete(rawMsg, key)
		case "buildVersion":
			err = unpopulate(val, &t.BuildVersion)
			delete(rawMsg, key)
		case "executionStatus":
			err = unpopulate(val, &t.ExecutionStatus)
			delete(rawMsg, key)
		case "flightingRing":
			err = unpopulate(val, &t.FlightingRing)
			delete(rawMsg, key)
		case "grade":
			err = unpopulate(val, &t.Grade)
			delete(rawMsg, key)
		case "isDownloadDataAvailable":
			err = unpopulate(val, &t.IsDownloadDataAvailable)
			delete(rawMsg, key)
		case "isVideoAvailable":
			err = unpopulate(val, &t.IsVideoAvailable)
			delete(rawMsg, key)
		case "kbNumber":
			err = unpopulate(val, &t.KbNumber)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, &t.OSName)
			delete(rawMsg, key)
		case "packageId":
			err = unpopulate(val, &t.PackageID)
			delete(rawMsg, key)
		case "packageVersion":
			err = unpopulate(val, &t.PackageVersion)
			delete(rawMsg, key)
		case "releaseName":
			err = unpopulate(val, &t.ReleaseName)
			delete(rawMsg, key)
		case "releaseVersionDate":
			err = unpopulateTimeRFC3339(val, &t.ReleaseVersionDate)
			delete(rawMsg, key)
		case "testRunTime":
			err = unpopulate(val, &t.TestRunTime)
			delete(rawMsg, key)
		case "testStatus":
			err = unpopulate(val, &t.TestStatus)
			delete(rawMsg, key)
		case "testType":
			err = unpopulate(val, &t.TestType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TestResultResource - The Test Result Resource.
type TestResultResource struct {
	// The properties of a Test Result.
	Properties *TestResultProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// TestResultsClientGetDownloadURLOptions contains the optional parameters for the TestResultsClient.GetDownloadURL method.
type TestResultsClientGetDownloadURLOptions struct {
	// placeholder for future optional parameters
}

// TestResultsClientGetOptions contains the optional parameters for the TestResultsClient.Get method.
type TestResultsClientGetOptions struct {
	// placeholder for future optional parameters
}

// TestResultsClientGetVideoDownloadURLOptions contains the optional parameters for the TestResultsClient.GetVideoDownloadURL
// method.
type TestResultsClientGetVideoDownloadURLOptions struct {
	// placeholder for future optional parameters
}

// TestResultsClientListOptions contains the optional parameters for the TestResultsClient.List method.
type TestResultsClientListOptions struct {
	// Odata filter
	Filter *string
}

// TestSummariesClientGetOptions contains the optional parameters for the TestSummariesClient.Get method.
type TestSummariesClientGetOptions struct {
	// placeholder for future optional parameters
}

// TestSummariesClientListOptions contains the optional parameters for the TestSummariesClient.List method.
type TestSummariesClientListOptions struct {
	// placeholder for future optional parameters
}

// TestSummaryListResult - A list of Test Summaries.
type TestSummaryListResult struct {
	// The list of Test Summaries.
	Value []*TestSummaryResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TestSummaryListResult.
func (t TestSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TestSummaryProperties - Properties of a Test Summary.
type TestSummaryProperties struct {
	// Application name.
	ApplicationName *string `json:"applicationName,omitempty"`

	// Application version.
	ApplicationVersion *string `json:"applicationVersion,omitempty"`

	// The execution status of last test.
	ExecutionStatus *ExecutionStatus `json:"executionStatus,omitempty"`

	// The result summary of tests triggered by feature updates
	FeatureUpdatesTestSummary *OSUpdatesTestSummary `json:"featureUpdatesTestSummary,omitempty"`

	// The grade of the test.
	Grade *Grade `json:"grade,omitempty"`

	// The Azure resource Id of package.
	PackageID *string `json:"packageId,omitempty"`

	// The result summary of tests triggered by security updates
	SecurityUpdatesTestSummary *OSUpdatesTestSummary `json:"securityUpdatesTestSummary,omitempty"`

	// The run time of the last test.
	TestRunTime *string `json:"testRunTime,omitempty"`

	// The status of last test.
	TestStatus *TestStatus `json:"testStatus,omitempty"`

	// The Id of the current Test Summary.
	TestSummaryID *string `json:"testSummaryId,omitempty"`
}

// TestSummaryResource - Summary of a Test.
type TestSummaryResource struct {
	// Properties of a Test Summary.
	Properties *TestSummaryProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// TestTypeListResult - A list of test types.
type TestTypeListResult struct {
	// The list of test types.
	Value []*TestTypeResource `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TestTypeListResult.
func (t TestTypeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TestTypeProperties - The Test Type properties.
type TestTypeProperties struct {
	// The actual name of a test type of a Test Base Account.
	ActualTestTypeName *string `json:"actualTestTypeName,omitempty"`
}

// TestTypeResource - The test type resource.
type TestTypeResource struct {
	// Test Type properties.
	Properties *TestTypeProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// TestTypesClientGetOptions contains the optional parameters for the TestTypesClient.Get method.
type TestTypesClientGetOptions struct {
	// placeholder for future optional parameters
}

// TestTypesClientListOptions contains the optional parameters for the TestTypesClient.List method.
type TestTypesClientListOptions struct {
	// placeholder for future optional parameters
}

// TrackedResource - The resource model definition for an ARM tracked top level resource
type TrackedResource struct {
	// REQUIRED; The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The tags of the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", t.Etag)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UsageClientListOptions contains the optional parameters for the UsageClient.List method.
type UsageClientListOptions struct {
	// Odata filter
	Filter *string
}

// UserObjectReceiverValue - The user object receiver value.
type UserObjectReceiverValue struct {
	// user object ids.
	UserObjectIDs []*string `json:"userObjectIds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UserObjectReceiverValue.
func (u UserObjectReceiverValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "userObjectIds", u.UserObjectIDs)
	return json.Marshal(objectMap)
}

// UtilizationBound - The bound of a utilization result.
type UtilizationBound struct {
	// The percentile of the bound.
	Percentile *float64 `json:"percentile,omitempty"`

	// The value of the bound.
	Value *float64 `json:"value,omitempty"`
}

// UtilizationEntry - The utilization entry.
type UtilizationEntry struct {
	// The timestamp.
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// The value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationEntry.
func (u UtilizationEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "timestamp", u.Timestamp)
	populate(objectMap, "value", u.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UtilizationEntry.
func (u *UtilizationEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "timestamp":
			err = unpopulateTimeRFC3339(val, &u.Timestamp)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &u.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UtilizationResult - The Utilization Result.
type UtilizationResult struct {
	// Lower bound
	LowerBound *UtilizationBound `json:"lowerBound,omitempty"`

	// Process name, or '_total' for all processes
	Process *string `json:"process,omitempty"`

	// Upper bound
	UpperBound *UtilizationBound `json:"upperBound,omitempty"`

	// Utilization data
	Utilization []*UtilizationEntry `json:"utilization,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UtilizationResult.
func (u UtilizationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "lowerBound", u.LowerBound)
	populate(objectMap, "process", u.Process)
	populate(objectMap, "upperBound", u.UpperBound)
	populate(objectMap, "utilization", u.Utilization)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
