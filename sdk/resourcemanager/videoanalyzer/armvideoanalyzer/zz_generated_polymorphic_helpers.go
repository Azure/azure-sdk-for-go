//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armvideoanalyzer

import "encoding/json"

func unmarshalAudioEncoderBaseClassification(rawMsg json.RawMessage) (AudioEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AudioEncoderBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.AudioEncoderAac":
		b = &AudioEncoderAac{}
	default:
		b = &AudioEncoderBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAudioEncoderBaseClassificationArray(rawMsg json.RawMessage) ([]AudioEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AudioEncoderBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAudioEncoderBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAudioEncoderBaseClassificationMap(rawMsg json.RawMessage) (map[string]AudioEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AudioEncoderBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAudioEncoderBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalAuthenticationBaseClassification(rawMsg json.RawMessage) (AuthenticationBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b AuthenticationBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.JwtAuthentication":
		b = &JwtAuthentication{}
	default:
		b = &AuthenticationBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalAuthenticationBaseClassificationArray(rawMsg json.RawMessage) ([]AuthenticationBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]AuthenticationBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalAuthenticationBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalAuthenticationBaseClassificationMap(rawMsg json.RawMessage) (map[string]AuthenticationBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]AuthenticationBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalAuthenticationBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalCertificateSourceClassification(rawMsg json.RawMessage) (CertificateSourceClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b CertificateSourceClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.PemCertificateList":
		b = &PemCertificateList{}
	default:
		b = &CertificateSource{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalCertificateSourceClassificationArray(rawMsg json.RawMessage) ([]CertificateSourceClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CertificateSourceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCertificateSourceClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalCertificateSourceClassificationMap(rawMsg json.RawMessage) (map[string]CertificateSourceClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]CertificateSourceClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalCertificateSourceClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalCredentialsBaseClassification(rawMsg json.RawMessage) (CredentialsBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b CredentialsBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.UsernamePasswordCredentials":
		b = &UsernamePasswordCredentials{}
	default:
		b = &CredentialsBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalCredentialsBaseClassificationArray(rawMsg json.RawMessage) ([]CredentialsBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CredentialsBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCredentialsBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalCredentialsBaseClassificationMap(rawMsg json.RawMessage) (map[string]CredentialsBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]CredentialsBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalCredentialsBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalEncoderPresetBaseClassification(rawMsg json.RawMessage) (EncoderPresetBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b EncoderPresetBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.EncoderCustomPreset":
		b = &EncoderCustomPreset{}
	case "#Microsoft.VideoAnalyzer.EncoderSystemPreset":
		b = &EncoderSystemPreset{}
	default:
		b = &EncoderPresetBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalEncoderPresetBaseClassificationArray(rawMsg json.RawMessage) ([]EncoderPresetBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]EncoderPresetBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalEncoderPresetBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalEncoderPresetBaseClassificationMap(rawMsg json.RawMessage) (map[string]EncoderPresetBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]EncoderPresetBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalEncoderPresetBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalEndpointBaseClassification(rawMsg json.RawMessage) (EndpointBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b EndpointBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.TlsEndpoint":
		b = &TLSEndpoint{}
	case "#Microsoft.VideoAnalyzer.UnsecuredEndpoint":
		b = &UnsecuredEndpoint{}
	default:
		b = &EndpointBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalEndpointBaseClassificationArray(rawMsg json.RawMessage) ([]EndpointBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]EndpointBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalEndpointBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalEndpointBaseClassificationMap(rawMsg json.RawMessage) (map[string]EndpointBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]EndpointBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalEndpointBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalNodeBaseClassification(rawMsg json.RawMessage) (NodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b NodeBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.EncoderProcessor":
		b = &EncoderProcessor{}
	case "#Microsoft.VideoAnalyzer.ProcessorNodeBase":
		b = &ProcessorNodeBase{}
	case "#Microsoft.VideoAnalyzer.RtspSource":
		b = &RtspSource{}
	case "#Microsoft.VideoAnalyzer.SinkNodeBase":
		b = &SinkNodeBase{}
	case "#Microsoft.VideoAnalyzer.SourceNodeBase":
		b = &SourceNodeBase{}
	case "#Microsoft.VideoAnalyzer.VideoSink":
		b = &VideoSink{}
	case "#Microsoft.VideoAnalyzer.VideoSource":
		b = &VideoSource{}
	default:
		b = &NodeBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalNodeBaseClassificationArray(rawMsg json.RawMessage) ([]NodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]NodeBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalNodeBaseClassificationMap(rawMsg json.RawMessage) (map[string]NodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]NodeBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalProcessorNodeBaseClassification(rawMsg json.RawMessage) (ProcessorNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ProcessorNodeBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.EncoderProcessor":
		b = &EncoderProcessor{}
	default:
		b = &ProcessorNodeBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalProcessorNodeBaseClassificationArray(rawMsg json.RawMessage) ([]ProcessorNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ProcessorNodeBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalProcessorNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalProcessorNodeBaseClassificationMap(rawMsg json.RawMessage) (map[string]ProcessorNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]ProcessorNodeBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalProcessorNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalSinkNodeBaseClassification(rawMsg json.RawMessage) (SinkNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SinkNodeBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.VideoSink":
		b = &VideoSink{}
	default:
		b = &SinkNodeBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalSinkNodeBaseClassificationArray(rawMsg json.RawMessage) ([]SinkNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SinkNodeBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSinkNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSinkNodeBaseClassificationMap(rawMsg json.RawMessage) (map[string]SinkNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]SinkNodeBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalSinkNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalSourceNodeBaseClassification(rawMsg json.RawMessage) (SourceNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SourceNodeBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.RtspSource":
		b = &RtspSource{}
	case "#Microsoft.VideoAnalyzer.VideoSource":
		b = &VideoSource{}
	default:
		b = &SourceNodeBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalSourceNodeBaseClassificationArray(rawMsg json.RawMessage) ([]SourceNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SourceNodeBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSourceNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSourceNodeBaseClassificationMap(rawMsg json.RawMessage) (map[string]SourceNodeBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]SourceNodeBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalSourceNodeBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalTimeSequenceBaseClassification(rawMsg json.RawMessage) (TimeSequenceBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b TimeSequenceBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers":
		b = &VideoSequenceAbsoluteTimeMarkers{}
	default:
		b = &TimeSequenceBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalTimeSequenceBaseClassificationArray(rawMsg json.RawMessage) ([]TimeSequenceBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TimeSequenceBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTimeSequenceBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalTimeSequenceBaseClassificationMap(rawMsg json.RawMessage) (map[string]TimeSequenceBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]TimeSequenceBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalTimeSequenceBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalTokenKeyClassification(rawMsg json.RawMessage) (TokenKeyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b TokenKeyClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.EccTokenKey":
		b = &EccTokenKey{}
	case "#Microsoft.VideoAnalyzer.RsaTokenKey":
		b = &RsaTokenKey{}
	default:
		b = &TokenKey{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalTokenKeyClassificationArray(rawMsg json.RawMessage) ([]TokenKeyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TokenKeyClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTokenKeyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalTokenKeyClassificationMap(rawMsg json.RawMessage) (map[string]TokenKeyClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]TokenKeyClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalTokenKeyClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalTunnelBaseClassification(rawMsg json.RawMessage) (TunnelBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b TunnelBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel":
		b = &SecureIotDeviceRemoteTunnel{}
	default:
		b = &TunnelBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalTunnelBaseClassificationArray(rawMsg json.RawMessage) ([]TunnelBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TunnelBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTunnelBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalTunnelBaseClassificationMap(rawMsg json.RawMessage) (map[string]TunnelBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]TunnelBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalTunnelBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}

func unmarshalVideoEncoderBaseClassification(rawMsg json.RawMessage) (VideoEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var m map[string]interface{}
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b VideoEncoderBaseClassification
	switch m["@type"] {
	case "#Microsoft.VideoAnalyzer.VideoEncoderH264":
		b = &VideoEncoderH264{}
	default:
		b = &VideoEncoderBase{}
	}
	return b, json.Unmarshal(rawMsg, b)
}

func unmarshalVideoEncoderBaseClassificationArray(rawMsg json.RawMessage) ([]VideoEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]VideoEncoderBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalVideoEncoderBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalVideoEncoderBaseClassificationMap(rawMsg json.RawMessage) (map[string]VideoEncoderBaseClassification, error) {
	if rawMsg == nil {
		return nil, nil
	}
	var rawMessages map[string]json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fMap := make(map[string]VideoEncoderBaseClassification, len(rawMessages))
	for key, rawMessage := range rawMessages {
		f, err := unmarshalVideoEncoderBaseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fMap[key] = f
	}
	return fMap, nil
}
