//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// AppServiceEnvironmentsClient contains the methods for the AppServiceEnvironments group.
// Don't use this type directly, use NewAppServiceEnvironmentsClient() instead.
type AppServiceEnvironmentsClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewAppServiceEnvironmentsClient creates a new instance of AppServiceEnvironmentsClient with the specified values.
func NewAppServiceEnvironmentsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *AppServiceEnvironmentsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &AppServiceEnvironmentsClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *AppServiceEnvironmentsBeginApproveOrRejectPrivateEndpointConnectionOptions) (AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result := AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.ApproveOrRejectPrivateEndpointConnection", "", resp, client.pl, client.approveOrRejectPrivateEndpointConnectionHandleError)
	if err != nil {
		return AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsApproveOrRejectPrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *AppServiceEnvironmentsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *AppServiceEnvironmentsClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *AppServiceEnvironmentsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionHandleError handles the ApproveOrRejectPrivateEndpointConnection error response.
func (client *AppServiceEnvironmentsClient) approveOrRejectPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginChangeVnet - Description for Move an App Service Environment to a different VNET.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginChangeVnet(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *AppServiceEnvironmentsBeginChangeVnetOptions) (AppServiceEnvironmentsChangeVnetPollerResponse, error) {
	resp, err := client.changeVnet(ctx, resourceGroupName, name, vnetInfo, options)
	if err != nil {
		return AppServiceEnvironmentsChangeVnetPollerResponse{}, err
	}
	result := AppServiceEnvironmentsChangeVnetPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.ChangeVnet", "", resp, client.pl, client.changeVnetHandleError)
	if err != nil {
		return AppServiceEnvironmentsChangeVnetPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsChangeVnetPoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// ChangeVnet - Description for Move an App Service Environment to a different VNET.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) changeVnet(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *AppServiceEnvironmentsBeginChangeVnetOptions) (*http.Response, error) {
	req, err := client.changeVnetCreateRequest(ctx, resourceGroupName, name, vnetInfo, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.changeVnetHandleError(resp)
	}
	return resp, nil
}

// changeVnetCreateRequest creates the ChangeVnet request.
func (client *AppServiceEnvironmentsClient) changeVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetInfo VirtualNetworkProfile, options *AppServiceEnvironmentsBeginChangeVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/changeVirtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, vnetInfo)
}

// changeVnetHandleResponse handles the ChangeVnet response.
func (client *AppServiceEnvironmentsClient) changeVnetHandleResponse(resp *http.Response) (AppServiceEnvironmentsChangeVnetResponse, error) {
	result := AppServiceEnvironmentsChangeVnetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return AppServiceEnvironmentsChangeVnetResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// changeVnetHandleError handles the ChangeVnet error response.
func (client *AppServiceEnvironmentsClient) changeVnetHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdate - Description for Create or update an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope AppServiceEnvironmentResource, options *AppServiceEnvironmentsBeginCreateOrUpdateOptions) (AppServiceEnvironmentsCreateOrUpdatePollerResponse, error) {
	resp, err := client.createOrUpdate(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdatePollerResponse{}, err
	}
	result := AppServiceEnvironmentsCreateOrUpdatePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.CreateOrUpdate", "", resp, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdatePollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsCreateOrUpdatePoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdate - Description for Create or update an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope AppServiceEnvironmentResource, options *AppServiceEnvironmentsBeginCreateOrUpdateOptions) (*http.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *AppServiceEnvironmentsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope AppServiceEnvironmentResource, options *AppServiceEnvironmentsBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostingEnvironmentEnvelope)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *AppServiceEnvironmentsClient) createOrUpdateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginCreateOrUpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateMultiRolePoolOptions) (AppServiceEnvironmentsCreateOrUpdateMultiRolePoolPollerResponse, error) {
	resp, err := client.createOrUpdateMultiRolePool(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdateMultiRolePoolPollerResponse{}, err
	}
	result := AppServiceEnvironmentsCreateOrUpdateMultiRolePoolPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.CreateOrUpdateMultiRolePool", "", resp, client.pl, client.createOrUpdateMultiRolePoolHandleError)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdateMultiRolePoolPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsCreateOrUpdateMultiRolePoolPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) createOrUpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateMultiRolePoolOptions) (*http.Response, error) {
	req, err := client.createOrUpdateMultiRolePoolCreateRequest(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateMultiRolePoolHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateMultiRolePoolCreateRequest creates the CreateOrUpdateMultiRolePool request.
func (client *AppServiceEnvironmentsClient) createOrUpdateMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, multiRolePoolEnvelope)
}

// createOrUpdateMultiRolePoolHandleError handles the CreateOrUpdateMultiRolePool error response.
func (client *AppServiceEnvironmentsClient) createOrUpdateMultiRolePoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginCreateOrUpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateWorkerPoolOptions) (AppServiceEnvironmentsCreateOrUpdateWorkerPoolPollerResponse, error) {
	resp, err := client.createOrUpdateWorkerPool(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdateWorkerPoolPollerResponse{}, err
	}
	result := AppServiceEnvironmentsCreateOrUpdateWorkerPoolPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.CreateOrUpdateWorkerPool", "", resp, client.pl, client.createOrUpdateWorkerPoolHandleError)
	if err != nil {
		return AppServiceEnvironmentsCreateOrUpdateWorkerPoolPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsCreateOrUpdateWorkerPoolPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) createOrUpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateWorkerPoolOptions) (*http.Response, error) {
	req, err := client.createOrUpdateWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateWorkerPoolHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateWorkerPoolCreateRequest creates the CreateOrUpdateWorkerPool request.
func (client *AppServiceEnvironmentsClient) createOrUpdateWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsBeginCreateOrUpdateWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workerPoolEnvelope)
}

// createOrUpdateWorkerPoolHandleError handles the CreateOrUpdateWorkerPool error response.
func (client *AppServiceEnvironmentsClient) createOrUpdateWorkerPoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDelete - Description for Delete an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginDelete(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginDeleteOptions) (AppServiceEnvironmentsDeletePollerResponse, error) {
	resp, err := client.deleteOperation(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsDeletePollerResponse{}, err
	}
	result := AppServiceEnvironmentsDeletePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.Delete", "", resp, client.pl, client.deleteHandleError)
	if err != nil {
		return AppServiceEnvironmentsDeletePollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsDeletePoller{
		pt: pt,
	}
	return result, nil
}

// Delete - Description for Delete an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) deleteOperation(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginDeleteOptions) (*http.Response, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *AppServiceEnvironmentsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ForceDelete != nil {
		reqQP.Set("forceDelete", strconv.FormatBool(*options.ForceDelete))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *AppServiceEnvironmentsClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *AppServiceEnvironmentsBeginDeletePrivateEndpointConnectionOptions) (AppServiceEnvironmentsDeletePrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return AppServiceEnvironmentsDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result := AppServiceEnvironmentsDeletePrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.DeletePrivateEndpointConnection", "", resp, client.pl, client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return AppServiceEnvironmentsDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *AppServiceEnvironmentsBeginDeletePrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *AppServiceEnvironmentsClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *AppServiceEnvironmentsBeginDeletePrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionHandleError handles the DeletePrivateEndpointConnection error response.
func (client *AppServiceEnvironmentsClient) deletePrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Get - Description for Get the properties of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) Get(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetOptions) (AppServiceEnvironmentsGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *AppServiceEnvironmentsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *AppServiceEnvironmentsClient) getHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetResponse, error) {
	result := AppServiceEnvironmentsGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServiceEnvironmentResource); err != nil {
		return AppServiceEnvironmentsGetResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *AppServiceEnvironmentsClient) getHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAseV3NetworkingConfiguration - Description for Get networking configuration of an App Service Environment
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetAseV3NetworkingConfiguration(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetAseV3NetworkingConfigurationOptions) (AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse, error) {
	req, err := client.getAseV3NetworkingConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse{}, client.getAseV3NetworkingConfigurationHandleError(resp)
	}
	return client.getAseV3NetworkingConfigurationHandleResponse(resp)
}

// getAseV3NetworkingConfigurationCreateRequest creates the GetAseV3NetworkingConfiguration request.
func (client *AppServiceEnvironmentsClient) getAseV3NetworkingConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetAseV3NetworkingConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAseV3NetworkingConfigurationHandleResponse handles the GetAseV3NetworkingConfiguration response.
func (client *AppServiceEnvironmentsClient) getAseV3NetworkingConfigurationHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse, error) {
	result := AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseV3NetworkingConfiguration); err != nil {
		return AppServiceEnvironmentsGetAseV3NetworkingConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAseV3NetworkingConfigurationHandleError handles the GetAseV3NetworkingConfiguration error response.
func (client *AppServiceEnvironmentsClient) getAseV3NetworkingConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDiagnosticsItem - Description for Get a diagnostics item for an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetDiagnosticsItem(ctx context.Context, resourceGroupName string, name string, diagnosticsName string, options *AppServiceEnvironmentsGetDiagnosticsItemOptions) (AppServiceEnvironmentsGetDiagnosticsItemResponse, error) {
	req, err := client.getDiagnosticsItemCreateRequest(ctx, resourceGroupName, name, diagnosticsName, options)
	if err != nil {
		return AppServiceEnvironmentsGetDiagnosticsItemResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetDiagnosticsItemResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetDiagnosticsItemResponse{}, client.getDiagnosticsItemHandleError(resp)
	}
	return client.getDiagnosticsItemHandleResponse(resp)
}

// getDiagnosticsItemCreateRequest creates the GetDiagnosticsItem request.
func (client *AppServiceEnvironmentsClient) getDiagnosticsItemCreateRequest(ctx context.Context, resourceGroupName string, name string, diagnosticsName string, options *AppServiceEnvironmentsGetDiagnosticsItemOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics/{diagnosticsName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if diagnosticsName == "" {
		return nil, errors.New("parameter diagnosticsName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticsName}", url.PathEscape(diagnosticsName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticsItemHandleResponse handles the GetDiagnosticsItem response.
func (client *AppServiceEnvironmentsClient) getDiagnosticsItemHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetDiagnosticsItemResponse, error) {
	result := AppServiceEnvironmentsGetDiagnosticsItemResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostingEnvironmentDiagnostics); err != nil {
		return AppServiceEnvironmentsGetDiagnosticsItemResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDiagnosticsItemHandleError handles the GetDiagnosticsItem error response.
func (client *AppServiceEnvironmentsClient) getDiagnosticsItemHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInboundNetworkDependenciesEndpoints - Description for Get the network endpoints of all inbound dependencies of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetInboundNetworkDependenciesEndpoints(resourceGroupName string, name string, options *AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsOptions) *AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsPager {
	return &AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getInboundNetworkDependenciesEndpointsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.InboundEnvironmentEndpointCollection.NextLink)
		},
	}
}

// getInboundNetworkDependenciesEndpointsCreateRequest creates the GetInboundNetworkDependenciesEndpoints request.
func (client *AppServiceEnvironmentsClient) getInboundNetworkDependenciesEndpointsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/inboundNetworkDependenciesEndpoints"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInboundNetworkDependenciesEndpointsHandleResponse handles the GetInboundNetworkDependenciesEndpoints response.
func (client *AppServiceEnvironmentsClient) getInboundNetworkDependenciesEndpointsHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsResponse, error) {
	result := AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.InboundEnvironmentEndpointCollection); err != nil {
		return AppServiceEnvironmentsGetInboundNetworkDependenciesEndpointsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInboundNetworkDependenciesEndpointsHandleError handles the GetInboundNetworkDependenciesEndpoints error response.
func (client *AppServiceEnvironmentsClient) getInboundNetworkDependenciesEndpointsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetMultiRolePool - Description for Get properties of a multi-role pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetMultiRolePool(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetMultiRolePoolOptions) (AppServiceEnvironmentsGetMultiRolePoolResponse, error) {
	req, err := client.getMultiRolePoolCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsGetMultiRolePoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetMultiRolePoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetMultiRolePoolResponse{}, client.getMultiRolePoolHandleError(resp)
	}
	return client.getMultiRolePoolHandleResponse(resp)
}

// getMultiRolePoolCreateRequest creates the GetMultiRolePool request.
func (client *AppServiceEnvironmentsClient) getMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiRolePoolHandleResponse handles the GetMultiRolePool response.
func (client *AppServiceEnvironmentsClient) getMultiRolePoolHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetMultiRolePoolResponse, error) {
	result := AppServiceEnvironmentsGetMultiRolePoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return AppServiceEnvironmentsGetMultiRolePoolResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMultiRolePoolHandleError handles the GetMultiRolePool error response.
func (client *AppServiceEnvironmentsClient) getMultiRolePoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetOutboundNetworkDependenciesEndpoints - Description for Get the network endpoints of all outbound dependencies of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetOutboundNetworkDependenciesEndpoints(resourceGroupName string, name string, options *AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsOptions) *AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsPager {
	return &AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getOutboundNetworkDependenciesEndpointsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.OutboundEnvironmentEndpointCollection.NextLink)
		},
	}
}

// getOutboundNetworkDependenciesEndpointsCreateRequest creates the GetOutboundNetworkDependenciesEndpoints request.
func (client *AppServiceEnvironmentsClient) getOutboundNetworkDependenciesEndpointsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/outboundNetworkDependenciesEndpoints"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOutboundNetworkDependenciesEndpointsHandleResponse handles the GetOutboundNetworkDependenciesEndpoints response.
func (client *AppServiceEnvironmentsClient) getOutboundNetworkDependenciesEndpointsHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsResponse, error) {
	result := AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.OutboundEnvironmentEndpointCollection); err != nil {
		return AppServiceEnvironmentsGetOutboundNetworkDependenciesEndpointsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getOutboundNetworkDependenciesEndpointsHandleError handles the GetOutboundNetworkDependenciesEndpoints error response.
func (client *AppServiceEnvironmentsClient) getOutboundNetworkDependenciesEndpointsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *AppServiceEnvironmentsGetPrivateEndpointConnectionOptions) (AppServiceEnvironmentsGetPrivateEndpointConnectionResponse, error) {
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return AppServiceEnvironmentsGetPrivateEndpointConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetPrivateEndpointConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetPrivateEndpointConnectionResponse{}, client.getPrivateEndpointConnectionHandleError(resp)
	}
	return client.getPrivateEndpointConnectionHandleResponse(resp)
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *AppServiceEnvironmentsGetPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetPrivateEndpointConnectionResponse, error) {
	result := AppServiceEnvironmentsGetPrivateEndpointConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return AppServiceEnvironmentsGetPrivateEndpointConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionHandleError handles the GetPrivateEndpointConnection error response.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnectionList - Description for Gets the list of private endpoints associated with a hosting environment
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetPrivateEndpointConnectionList(resourceGroupName string, name string, options *AppServiceEnvironmentsGetPrivateEndpointConnectionListOptions) *AppServiceEnvironmentsGetPrivateEndpointConnectionListPager {
	return &AppServiceEnvironmentsGetPrivateEndpointConnectionListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsGetPrivateEndpointConnectionListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
	}
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetPrivateEndpointConnectionListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionListHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetPrivateEndpointConnectionListResponse, error) {
	result := AppServiceEnvironmentsGetPrivateEndpointConnectionListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return AppServiceEnvironmentsGetPrivateEndpointConnectionListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionListHandleError handles the GetPrivateEndpointConnectionList error response.
func (client *AppServiceEnvironmentsClient) getPrivateEndpointConnectionListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetPrivateLinkResourcesOptions) (AppServiceEnvironmentsGetPrivateLinkResourcesResponse, error) {
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsGetPrivateLinkResourcesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetPrivateLinkResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetPrivateLinkResourcesResponse{}, client.getPrivateLinkResourcesHandleError(resp)
	}
	return client.getPrivateLinkResourcesHandleResponse(resp)
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *AppServiceEnvironmentsClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetPrivateLinkResourcesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *AppServiceEnvironmentsClient) getPrivateLinkResourcesHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetPrivateLinkResourcesResponse, error) {
	result := AppServiceEnvironmentsGetPrivateLinkResourcesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return AppServiceEnvironmentsGetPrivateLinkResourcesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateLinkResourcesHandleError handles the GetPrivateLinkResources error response.
func (client *AppServiceEnvironmentsClient) getPrivateLinkResourcesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetVipInfo - Description for Get IP addresses assigned to an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetVipInfo(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetVipInfoOptions) (AppServiceEnvironmentsGetVipInfoResponse, error) {
	req, err := client.getVipInfoCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsGetVipInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetVipInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetVipInfoResponse{}, client.getVipInfoHandleError(resp)
	}
	return client.getVipInfoHandleResponse(resp)
}

// getVipInfoCreateRequest creates the GetVipInfo request.
func (client *AppServiceEnvironmentsClient) getVipInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsGetVipInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/virtualip"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVipInfoHandleResponse handles the GetVipInfo response.
func (client *AppServiceEnvironmentsClient) getVipInfoHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetVipInfoResponse, error) {
	result := AppServiceEnvironmentsGetVipInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddressResponse); err != nil {
		return AppServiceEnvironmentsGetVipInfoResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVipInfoHandleError handles the GetVipInfo error response.
func (client *AppServiceEnvironmentsClient) getVipInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetWorkerPool - Description for Get properties of a worker pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) GetWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsGetWorkerPoolOptions) (AppServiceEnvironmentsGetWorkerPoolResponse, error) {
	req, err := client.getWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
	if err != nil {
		return AppServiceEnvironmentsGetWorkerPoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsGetWorkerPoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsGetWorkerPoolResponse{}, client.getWorkerPoolHandleError(resp)
	}
	return client.getWorkerPoolHandleResponse(resp)
}

// getWorkerPoolCreateRequest creates the GetWorkerPool request.
func (client *AppServiceEnvironmentsClient) getWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsGetWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWorkerPoolHandleResponse handles the GetWorkerPool response.
func (client *AppServiceEnvironmentsClient) getWorkerPoolHandleResponse(resp *http.Response) (AppServiceEnvironmentsGetWorkerPoolResponse, error) {
	result := AppServiceEnvironmentsGetWorkerPoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return AppServiceEnvironmentsGetWorkerPoolResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getWorkerPoolHandleError handles the GetWorkerPool error response.
func (client *AppServiceEnvironmentsClient) getWorkerPoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// List - Description for Get all App Service Environments for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) List(options *AppServiceEnvironmentsListOptions) *AppServiceEnvironmentsListPager {
	return &AppServiceEnvironmentsListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.AppServiceEnvironmentCollection.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *AppServiceEnvironmentsClient) listCreateRequest(ctx context.Context, options *AppServiceEnvironmentsListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/hostingEnvironments"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *AppServiceEnvironmentsClient) listHandleResponse(resp *http.Response) (AppServiceEnvironmentsListResponse, error) {
	result := AppServiceEnvironmentsListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServiceEnvironmentCollection); err != nil {
		return AppServiceEnvironmentsListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *AppServiceEnvironmentsClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAppServicePlans - Description for Get all App Service plans in an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListAppServicePlans(resourceGroupName string, name string, options *AppServiceEnvironmentsListAppServicePlansOptions) *AppServiceEnvironmentsListAppServicePlansPager {
	return &AppServiceEnvironmentsListAppServicePlansPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listAppServicePlansCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListAppServicePlansResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.AppServicePlanCollection.NextLink)
		},
	}
}

// listAppServicePlansCreateRequest creates the ListAppServicePlans request.
func (client *AppServiceEnvironmentsClient) listAppServicePlansCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListAppServicePlansOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/serverfarms"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAppServicePlansHandleResponse handles the ListAppServicePlans response.
func (client *AppServiceEnvironmentsClient) listAppServicePlansHandleResponse(resp *http.Response) (AppServiceEnvironmentsListAppServicePlansResponse, error) {
	result := AppServiceEnvironmentsListAppServicePlansResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServicePlanCollection); err != nil {
		return AppServiceEnvironmentsListAppServicePlansResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAppServicePlansHandleError handles the ListAppServicePlans error response.
func (client *AppServiceEnvironmentsClient) listAppServicePlansHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByResourceGroup - Description for Get all App Service Environments in a resource group.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListByResourceGroup(resourceGroupName string, options *AppServiceEnvironmentsListByResourceGroupOptions) *AppServiceEnvironmentsListByResourceGroupPager {
	return &AppServiceEnvironmentsListByResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListByResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.AppServiceEnvironmentCollection.NextLink)
		},
	}
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *AppServiceEnvironmentsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *AppServiceEnvironmentsListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *AppServiceEnvironmentsClient) listByResourceGroupHandleResponse(resp *http.Response) (AppServiceEnvironmentsListByResourceGroupResponse, error) {
	result := AppServiceEnvironmentsListByResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServiceEnvironmentCollection); err != nil {
		return AppServiceEnvironmentsListByResourceGroupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *AppServiceEnvironmentsClient) listByResourceGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListCapacities - Description for Get the used, available, and total worker capacity an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListCapacities(resourceGroupName string, name string, options *AppServiceEnvironmentsListCapacitiesOptions) *AppServiceEnvironmentsListCapacitiesPager {
	return &AppServiceEnvironmentsListCapacitiesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCapacitiesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListCapacitiesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StampCapacityCollection.NextLink)
		},
	}
}

// listCapacitiesCreateRequest creates the ListCapacities request.
func (client *AppServiceEnvironmentsClient) listCapacitiesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListCapacitiesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/compute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listCapacitiesHandleResponse handles the ListCapacities response.
func (client *AppServiceEnvironmentsClient) listCapacitiesHandleResponse(resp *http.Response) (AppServiceEnvironmentsListCapacitiesResponse, error) {
	result := AppServiceEnvironmentsListCapacitiesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StampCapacityCollection); err != nil {
		return AppServiceEnvironmentsListCapacitiesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listCapacitiesHandleError handles the ListCapacities error response.
func (client *AppServiceEnvironmentsClient) listCapacitiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDiagnostics - Description for Get diagnostic information for an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListDiagnostics(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListDiagnosticsOptions) (AppServiceEnvironmentsListDiagnosticsResponse, error) {
	req, err := client.listDiagnosticsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsListDiagnosticsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsListDiagnosticsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsListDiagnosticsResponse{}, client.listDiagnosticsHandleError(resp)
	}
	return client.listDiagnosticsHandleResponse(resp)
}

// listDiagnosticsCreateRequest creates the ListDiagnostics request.
func (client *AppServiceEnvironmentsClient) listDiagnosticsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListDiagnosticsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDiagnosticsHandleResponse handles the ListDiagnostics response.
func (client *AppServiceEnvironmentsClient) listDiagnosticsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListDiagnosticsResponse, error) {
	result := AppServiceEnvironmentsListDiagnosticsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostingEnvironmentDiagnosticsArray); err != nil {
		return AppServiceEnvironmentsListDiagnosticsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDiagnosticsHandleError handles the ListDiagnostics error response.
func (client *AppServiceEnvironmentsClient) listDiagnosticsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMultiRoleMetricDefinitions - Description for Get metric definitions for a multi-role pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListMultiRoleMetricDefinitions(resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRoleMetricDefinitionsOptions) *AppServiceEnvironmentsListMultiRoleMetricDefinitionsPager {
	return &AppServiceEnvironmentsListMultiRoleMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRoleMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListMultiRoleMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listMultiRoleMetricDefinitionsCreateRequest creates the ListMultiRoleMetricDefinitions request.
func (client *AppServiceEnvironmentsClient) listMultiRoleMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRoleMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRoleMetricDefinitionsHandleResponse handles the ListMultiRoleMetricDefinitions response.
func (client *AppServiceEnvironmentsClient) listMultiRoleMetricDefinitionsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListMultiRoleMetricDefinitionsResponse, error) {
	result := AppServiceEnvironmentsListMultiRoleMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppServiceEnvironmentsListMultiRoleMetricDefinitionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMultiRoleMetricDefinitionsHandleError handles the ListMultiRoleMetricDefinitions error response.
func (client *AppServiceEnvironmentsClient) listMultiRoleMetricDefinitionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMultiRolePoolInstanceMetricDefinitions - Description for Get metric definitions for a specific instance of a multi-role pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListMultiRolePoolInstanceMetricDefinitions(resourceGroupName string, name string, instance string, options *AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsOptions) *AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsPager {
	return &AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolInstanceMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, instance, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listMultiRolePoolInstanceMetricDefinitionsCreateRequest creates the ListMultiRolePoolInstanceMetricDefinitions request.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolInstanceMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, instance string, options *AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/instances/{instance}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instance == "" {
		return nil, errors.New("parameter instance cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instance}", url.PathEscape(instance))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolInstanceMetricDefinitionsHandleResponse handles the ListMultiRolePoolInstanceMetricDefinitions response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolInstanceMetricDefinitionsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsResponse, error) {
	result := AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppServiceEnvironmentsListMultiRolePoolInstanceMetricDefinitionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMultiRolePoolInstanceMetricDefinitionsHandleError handles the ListMultiRolePoolInstanceMetricDefinitions error response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolInstanceMetricDefinitionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMultiRolePoolSKUs - Description for Get available SKUs for scaling a multi-role pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListMultiRolePoolSKUs(resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRolePoolSKUsOptions) *AppServiceEnvironmentsListMultiRolePoolSKUsPager {
	return &AppServiceEnvironmentsListMultiRolePoolSKUsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolSKUsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListMultiRolePoolSKUsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SKUInfoCollection.NextLink)
		},
	}
}

// listMultiRolePoolSKUsCreateRequest creates the ListMultiRolePoolSKUs request.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolSKUsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRolePoolSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/skus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolSKUsHandleResponse handles the ListMultiRolePoolSKUs response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolSKUsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListMultiRolePoolSKUsResponse, error) {
	result := AppServiceEnvironmentsListMultiRolePoolSKUsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfoCollection); err != nil {
		return AppServiceEnvironmentsListMultiRolePoolSKUsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMultiRolePoolSKUsHandleError handles the ListMultiRolePoolSKUs error response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolSKUsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMultiRolePools - Description for Get all multi-role pools.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListMultiRolePools(resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRolePoolsOptions) *AppServiceEnvironmentsListMultiRolePoolsPager {
	return &AppServiceEnvironmentsListMultiRolePoolsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRolePoolsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListMultiRolePoolsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkerPoolCollection.NextLink)
		},
	}
}

// listMultiRolePoolsCreateRequest creates the ListMultiRolePools request.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRolePoolsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRolePoolsHandleResponse handles the ListMultiRolePools response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListMultiRolePoolsResponse, error) {
	result := AppServiceEnvironmentsListMultiRolePoolsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolCollection); err != nil {
		return AppServiceEnvironmentsListMultiRolePoolsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMultiRolePoolsHandleError handles the ListMultiRolePools error response.
func (client *AppServiceEnvironmentsClient) listMultiRolePoolsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMultiRoleUsages - Description for Get usage metrics for a multi-role pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListMultiRoleUsages(resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRoleUsagesOptions) *AppServiceEnvironmentsListMultiRoleUsagesPager {
	return &AppServiceEnvironmentsListMultiRoleUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMultiRoleUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListMultiRoleUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.UsageCollection.NextLink)
		},
	}
}

// listMultiRoleUsagesCreateRequest creates the ListMultiRoleUsages request.
func (client *AppServiceEnvironmentsClient) listMultiRoleUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListMultiRoleUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMultiRoleUsagesHandleResponse handles the ListMultiRoleUsages response.
func (client *AppServiceEnvironmentsClient) listMultiRoleUsagesHandleResponse(resp *http.Response) (AppServiceEnvironmentsListMultiRoleUsagesResponse, error) {
	result := AppServiceEnvironmentsListMultiRoleUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.UsageCollection); err != nil {
		return AppServiceEnvironmentsListMultiRoleUsagesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMultiRoleUsagesHandleError handles the ListMultiRoleUsages error response.
func (client *AppServiceEnvironmentsClient) listMultiRoleUsagesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListOperations - Description for List all currently running operations on the App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListOperations(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListOperationsOptions) (AppServiceEnvironmentsListOperationsResponse, error) {
	req, err := client.listOperationsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsListOperationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsListOperationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsListOperationsResponse{}, client.listOperationsHandleError(resp)
	}
	return client.listOperationsHandleResponse(resp)
}

// listOperationsCreateRequest creates the ListOperations request.
func (client *AppServiceEnvironmentsClient) listOperationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListOperationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/operations"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listOperationsHandleResponse handles the ListOperations response.
func (client *AppServiceEnvironmentsClient) listOperationsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListOperationsResponse, error) {
	result := AppServiceEnvironmentsListOperationsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.OperationArray); err != nil {
		return AppServiceEnvironmentsListOperationsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listOperationsHandleError handles the ListOperations error response.
func (client *AppServiceEnvironmentsClient) listOperationsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListUsages - Description for Get global usage metrics of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListUsages(resourceGroupName string, name string, options *AppServiceEnvironmentsListUsagesOptions) *AppServiceEnvironmentsListUsagesPager {
	return &AppServiceEnvironmentsListUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
	}
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *AppServiceEnvironmentsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *AppServiceEnvironmentsClient) listUsagesHandleResponse(resp *http.Response) (AppServiceEnvironmentsListUsagesResponse, error) {
	result := AppServiceEnvironmentsListUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return AppServiceEnvironmentsListUsagesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listUsagesHandleError handles the ListUsages error response.
func (client *AppServiceEnvironmentsClient) listUsagesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWebApps - Description for Get all apps in an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWebApps(resourceGroupName string, name string, options *AppServiceEnvironmentsListWebAppsOptions) *AppServiceEnvironmentsListWebAppsPager {
	return &AppServiceEnvironmentsListWebAppsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebAppsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWebAppsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
	}
}

// listWebAppsCreateRequest creates the ListWebApps request.
func (client *AppServiceEnvironmentsClient) listWebAppsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListWebAppsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PropertiesToInclude != nil {
		reqQP.Set("propertiesToInclude", *options.PropertiesToInclude)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebAppsHandleResponse handles the ListWebApps response.
func (client *AppServiceEnvironmentsClient) listWebAppsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWebAppsResponse, error) {
	result := AppServiceEnvironmentsListWebAppsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return AppServiceEnvironmentsListWebAppsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWebAppsHandleError handles the ListWebApps error response.
func (client *AppServiceEnvironmentsClient) listWebAppsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWebWorkerMetricDefinitions - Description for Get metric definitions for a worker pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWebWorkerMetricDefinitions(resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWebWorkerMetricDefinitionsOptions) *AppServiceEnvironmentsListWebWorkerMetricDefinitionsPager {
	return &AppServiceEnvironmentsListWebWorkerMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebWorkerMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWebWorkerMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listWebWorkerMetricDefinitionsCreateRequest creates the ListWebWorkerMetricDefinitions request.
func (client *AppServiceEnvironmentsClient) listWebWorkerMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWebWorkerMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebWorkerMetricDefinitionsHandleResponse handles the ListWebWorkerMetricDefinitions response.
func (client *AppServiceEnvironmentsClient) listWebWorkerMetricDefinitionsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWebWorkerMetricDefinitionsResponse, error) {
	result := AppServiceEnvironmentsListWebWorkerMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppServiceEnvironmentsListWebWorkerMetricDefinitionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWebWorkerMetricDefinitionsHandleError handles the ListWebWorkerMetricDefinitions error response.
func (client *AppServiceEnvironmentsClient) listWebWorkerMetricDefinitionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWebWorkerUsages - Description for Get usage metrics for a worker pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWebWorkerUsages(resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWebWorkerUsagesOptions) *AppServiceEnvironmentsListWebWorkerUsagesPager {
	return &AppServiceEnvironmentsListWebWorkerUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebWorkerUsagesCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWebWorkerUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.UsageCollection.NextLink)
		},
	}
}

// listWebWorkerUsagesCreateRequest creates the ListWebWorkerUsages request.
func (client *AppServiceEnvironmentsClient) listWebWorkerUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWebWorkerUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebWorkerUsagesHandleResponse handles the ListWebWorkerUsages response.
func (client *AppServiceEnvironmentsClient) listWebWorkerUsagesHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWebWorkerUsagesResponse, error) {
	result := AppServiceEnvironmentsListWebWorkerUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.UsageCollection); err != nil {
		return AppServiceEnvironmentsListWebWorkerUsagesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWebWorkerUsagesHandleError handles the ListWebWorkerUsages error response.
func (client *AppServiceEnvironmentsClient) listWebWorkerUsagesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWorkerPoolInstanceMetricDefinitions - Description for Get metric definitions for a specific instance of a worker pool of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWorkerPoolInstanceMetricDefinitions(resourceGroupName string, name string, workerPoolName string, instance string, options *AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsOptions) *AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsPager {
	return &AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolInstanceMetricDefinitionsCreateRequest(ctx, resourceGroupName, name, workerPoolName, instance, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ResourceMetricDefinitionCollection.NextLink)
		},
	}
}

// listWorkerPoolInstanceMetricDefinitionsCreateRequest creates the ListWorkerPoolInstanceMetricDefinitions request.
func (client *AppServiceEnvironmentsClient) listWorkerPoolInstanceMetricDefinitionsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, instance string, options *AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/instances/{instance}/metricdefinitions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if instance == "" {
		return nil, errors.New("parameter instance cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instance}", url.PathEscape(instance))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolInstanceMetricDefinitionsHandleResponse handles the ListWorkerPoolInstanceMetricDefinitions response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolInstanceMetricDefinitionsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsResponse, error) {
	result := AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceMetricDefinitionCollection); err != nil {
		return AppServiceEnvironmentsListWorkerPoolInstanceMetricDefinitionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWorkerPoolInstanceMetricDefinitionsHandleError handles the ListWorkerPoolInstanceMetricDefinitions error response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolInstanceMetricDefinitionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWorkerPoolSKUs - Description for Get available SKUs for scaling a worker pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWorkerPoolSKUs(resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWorkerPoolSKUsOptions) *AppServiceEnvironmentsListWorkerPoolSKUsPager {
	return &AppServiceEnvironmentsListWorkerPoolSKUsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolSKUsCreateRequest(ctx, resourceGroupName, name, workerPoolName, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWorkerPoolSKUsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SKUInfoCollection.NextLink)
		},
	}
}

// listWorkerPoolSKUsCreateRequest creates the ListWorkerPoolSKUs request.
func (client *AppServiceEnvironmentsClient) listWorkerPoolSKUsCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, options *AppServiceEnvironmentsListWorkerPoolSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/skus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolSKUsHandleResponse handles the ListWorkerPoolSKUs response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolSKUsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWorkerPoolSKUsResponse, error) {
	result := AppServiceEnvironmentsListWorkerPoolSKUsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfoCollection); err != nil {
		return AppServiceEnvironmentsListWorkerPoolSKUsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWorkerPoolSKUsHandleError handles the ListWorkerPoolSKUs error response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolSKUsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWorkerPools - Description for Get all worker pools of an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) ListWorkerPools(resourceGroupName string, name string, options *AppServiceEnvironmentsListWorkerPoolsOptions) *AppServiceEnvironmentsListWorkerPoolsPager {
	return &AppServiceEnvironmentsListWorkerPoolsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWorkerPoolsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp AppServiceEnvironmentsListWorkerPoolsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WorkerPoolCollection.NextLink)
		},
	}
}

// listWorkerPoolsCreateRequest creates the ListWorkerPools request.
func (client *AppServiceEnvironmentsClient) listWorkerPoolsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsListWorkerPoolsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkerPoolsHandleResponse handles the ListWorkerPools response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolsHandleResponse(resp *http.Response) (AppServiceEnvironmentsListWorkerPoolsResponse, error) {
	result := AppServiceEnvironmentsListWorkerPoolsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolCollection); err != nil {
		return AppServiceEnvironmentsListWorkerPoolsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWorkerPoolsHandleError handles the ListWorkerPools error response.
func (client *AppServiceEnvironmentsClient) listWorkerPoolsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Reboot - Description for Reboot all machines in an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) Reboot(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsRebootOptions) (AppServiceEnvironmentsRebootResponse, error) {
	req, err := client.rebootCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsRebootResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsRebootResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return AppServiceEnvironmentsRebootResponse{}, client.rebootHandleError(resp)
	}
	return AppServiceEnvironmentsRebootResponse{RawResponse: resp}, nil
}

// rebootCreateRequest creates the Reboot request.
func (client *AppServiceEnvironmentsClient) rebootCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsRebootOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/reboot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// rebootHandleError handles the Reboot error response.
func (client *AppServiceEnvironmentsClient) rebootHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginResume - Description for Resume an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginResume(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginResumeOptions) (AppServiceEnvironmentsResumePollerResponse, error) {
	resp, err := client.resume(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsResumePollerResponse{}, err
	}
	result := AppServiceEnvironmentsResumePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.Resume", "", resp, client.pl, client.resumeHandleError)
	if err != nil {
		return AppServiceEnvironmentsResumePollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsResumePoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// Resume - Description for Resume an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) resume(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginResumeOptions) (*http.Response, error) {
	req, err := client.resumeCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.resumeHandleError(resp)
	}
	return resp, nil
}

// resumeCreateRequest creates the Resume request.
func (client *AppServiceEnvironmentsClient) resumeCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginResumeOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/resume"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resumeHandleResponse handles the Resume response.
func (client *AppServiceEnvironmentsClient) resumeHandleResponse(resp *http.Response) (AppServiceEnvironmentsResumeResponse, error) {
	result := AppServiceEnvironmentsResumeResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return AppServiceEnvironmentsResumeResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// resumeHandleError handles the Resume error response.
func (client *AppServiceEnvironmentsClient) resumeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginSuspend - Description for Suspend an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) BeginSuspend(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginSuspendOptions) (AppServiceEnvironmentsSuspendPollerResponse, error) {
	resp, err := client.suspend(ctx, resourceGroupName, name, options)
	if err != nil {
		return AppServiceEnvironmentsSuspendPollerResponse{}, err
	}
	result := AppServiceEnvironmentsSuspendPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("AppServiceEnvironmentsClient.Suspend", "", resp, client.pl, client.suspendHandleError)
	if err != nil {
		return AppServiceEnvironmentsSuspendPollerResponse{}, err
	}
	result.Poller = &AppServiceEnvironmentsSuspendPoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// Suspend - Description for Suspend an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) suspend(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginSuspendOptions) (*http.Response, error) {
	req, err := client.suspendCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.suspendHandleError(resp)
	}
	return resp, nil
}

// suspendCreateRequest creates the Suspend request.
func (client *AppServiceEnvironmentsClient) suspendCreateRequest(ctx context.Context, resourceGroupName string, name string, options *AppServiceEnvironmentsBeginSuspendOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/suspend"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// suspendHandleResponse handles the Suspend response.
func (client *AppServiceEnvironmentsClient) suspendHandleResponse(resp *http.Response) (AppServiceEnvironmentsSuspendResponse, error) {
	result := AppServiceEnvironmentsSuspendResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return AppServiceEnvironmentsSuspendResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// suspendHandleError handles the Suspend error response.
func (client *AppServiceEnvironmentsClient) suspendHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Update - Description for Create or update an App Service Environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) Update(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope AppServiceEnvironmentPatchResource, options *AppServiceEnvironmentsUpdateOptions) (AppServiceEnvironmentsUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, hostingEnvironmentEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return AppServiceEnvironmentsUpdateResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *AppServiceEnvironmentsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, hostingEnvironmentEnvelope AppServiceEnvironmentPatchResource, options *AppServiceEnvironmentsUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostingEnvironmentEnvelope)
}

// updateHandleResponse handles the Update response.
func (client *AppServiceEnvironmentsClient) updateHandleResponse(resp *http.Response) (AppServiceEnvironmentsUpdateResponse, error) {
	result := AppServiceEnvironmentsUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AppServiceEnvironmentResource); err != nil {
		return AppServiceEnvironmentsUpdateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateHandleError handles the Update error response.
func (client *AppServiceEnvironmentsClient) updateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAseNetworkingConfiguration - Description for Update networking configuration of an App Service Environment
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) UpdateAseNetworkingConfiguration(ctx context.Context, resourceGroupName string, name string, aseNetworkingConfiguration AseV3NetworkingConfiguration, options *AppServiceEnvironmentsUpdateAseNetworkingConfigurationOptions) (AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse, error) {
	req, err := client.updateAseNetworkingConfigurationCreateRequest(ctx, resourceGroupName, name, aseNetworkingConfiguration, options)
	if err != nil {
		return AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse{}, client.updateAseNetworkingConfigurationHandleError(resp)
	}
	return client.updateAseNetworkingConfigurationHandleResponse(resp)
}

// updateAseNetworkingConfigurationCreateRequest creates the UpdateAseNetworkingConfiguration request.
func (client *AppServiceEnvironmentsClient) updateAseNetworkingConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, aseNetworkingConfiguration AseV3NetworkingConfiguration, options *AppServiceEnvironmentsUpdateAseNetworkingConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, aseNetworkingConfiguration)
}

// updateAseNetworkingConfigurationHandleResponse handles the UpdateAseNetworkingConfiguration response.
func (client *AppServiceEnvironmentsClient) updateAseNetworkingConfigurationHandleResponse(resp *http.Response) (AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse, error) {
	result := AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseV3NetworkingConfiguration); err != nil {
		return AppServiceEnvironmentsUpdateAseNetworkingConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAseNetworkingConfigurationHandleError handles the UpdateAseNetworkingConfiguration error response.
func (client *AppServiceEnvironmentsClient) updateAseNetworkingConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateMultiRolePool - Description for Create or update a multi-role pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) UpdateMultiRolePool(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsUpdateMultiRolePoolOptions) (AppServiceEnvironmentsUpdateMultiRolePoolResponse, error) {
	req, err := client.updateMultiRolePoolCreateRequest(ctx, resourceGroupName, name, multiRolePoolEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsUpdateMultiRolePoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsUpdateMultiRolePoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppServiceEnvironmentsUpdateMultiRolePoolResponse{}, client.updateMultiRolePoolHandleError(resp)
	}
	return client.updateMultiRolePoolHandleResponse(resp)
}

// updateMultiRolePoolCreateRequest creates the UpdateMultiRolePool request.
func (client *AppServiceEnvironmentsClient) updateMultiRolePoolCreateRequest(ctx context.Context, resourceGroupName string, name string, multiRolePoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsUpdateMultiRolePoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, multiRolePoolEnvelope)
}

// updateMultiRolePoolHandleResponse handles the UpdateMultiRolePool response.
func (client *AppServiceEnvironmentsClient) updateMultiRolePoolHandleResponse(resp *http.Response) (AppServiceEnvironmentsUpdateMultiRolePoolResponse, error) {
	result := AppServiceEnvironmentsUpdateMultiRolePoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return AppServiceEnvironmentsUpdateMultiRolePoolResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateMultiRolePoolHandleError handles the UpdateMultiRolePool error response.
func (client *AppServiceEnvironmentsClient) updateMultiRolePoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateWorkerPool - Description for Create or update a worker pool.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *AppServiceEnvironmentsClient) UpdateWorkerPool(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsUpdateWorkerPoolOptions) (AppServiceEnvironmentsUpdateWorkerPoolResponse, error) {
	req, err := client.updateWorkerPoolCreateRequest(ctx, resourceGroupName, name, workerPoolName, workerPoolEnvelope, options)
	if err != nil {
		return AppServiceEnvironmentsUpdateWorkerPoolResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return AppServiceEnvironmentsUpdateWorkerPoolResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return AppServiceEnvironmentsUpdateWorkerPoolResponse{}, client.updateWorkerPoolHandleError(resp)
	}
	return client.updateWorkerPoolHandleResponse(resp)
}

// updateWorkerPoolCreateRequest creates the UpdateWorkerPool request.
func (client *AppServiceEnvironmentsClient) updateWorkerPoolCreateRequest(ctx context.Context, resourceGroupName string, name string, workerPoolName string, workerPoolEnvelope WorkerPoolResource, options *AppServiceEnvironmentsUpdateWorkerPoolOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if workerPoolName == "" {
		return nil, errors.New("parameter workerPoolName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerPoolName}", url.PathEscape(workerPoolName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, workerPoolEnvelope)
}

// updateWorkerPoolHandleResponse handles the UpdateWorkerPool response.
func (client *AppServiceEnvironmentsClient) updateWorkerPoolHandleResponse(resp *http.Response) (AppServiceEnvironmentsUpdateWorkerPoolResponse, error) {
	result := AppServiceEnvironmentsUpdateWorkerPoolResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkerPoolResource); err != nil {
		return AppServiceEnvironmentsUpdateWorkerPoolResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateWorkerPoolHandleError handles the UpdateWorkerPool error response.
func (client *AppServiceEnvironmentsClient) updateWorkerPoolHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
