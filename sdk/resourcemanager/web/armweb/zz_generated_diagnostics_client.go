//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// DiagnosticsClient contains the methods for the Diagnostics group.
// Don't use this type directly, use NewDiagnosticsClient() instead.
type DiagnosticsClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewDiagnosticsClient creates a new instance of DiagnosticsClient with the specified values.
func NewDiagnosticsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *DiagnosticsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &DiagnosticsClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// ExecuteSiteAnalysis - Description for Execute Analysis
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ExecuteSiteAnalysis(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, options *DiagnosticsExecuteSiteAnalysisOptions) (DiagnosticsExecuteSiteAnalysisResponse, error) {
	req, err := client.executeSiteAnalysisCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, analysisName, options)
	if err != nil {
		return DiagnosticsExecuteSiteAnalysisResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsExecuteSiteAnalysisResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsExecuteSiteAnalysisResponse{}, client.executeSiteAnalysisHandleError(resp)
	}
	return client.executeSiteAnalysisHandleResponse(resp)
}

// executeSiteAnalysisCreateRequest creates the ExecuteSiteAnalysis request.
func (client *DiagnosticsClient) executeSiteAnalysisCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, options *DiagnosticsExecuteSiteAnalysisOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if analysisName == "" {
		return nil, errors.New("parameter analysisName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{analysisName}", url.PathEscape(analysisName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// executeSiteAnalysisHandleResponse handles the ExecuteSiteAnalysis response.
func (client *DiagnosticsClient) executeSiteAnalysisHandleResponse(resp *http.Response) (DiagnosticsExecuteSiteAnalysisResponse, error) {
	result := DiagnosticsExecuteSiteAnalysisResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticAnalysis); err != nil {
		return DiagnosticsExecuteSiteAnalysisResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// executeSiteAnalysisHandleError handles the ExecuteSiteAnalysis error response.
func (client *DiagnosticsClient) executeSiteAnalysisHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ExecuteSiteAnalysisSlot - Description for Execute Analysis
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ExecuteSiteAnalysisSlot(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, slot string, options *DiagnosticsExecuteSiteAnalysisSlotOptions) (DiagnosticsExecuteSiteAnalysisSlotResponse, error) {
	req, err := client.executeSiteAnalysisSlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options)
	if err != nil {
		return DiagnosticsExecuteSiteAnalysisSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsExecuteSiteAnalysisSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsExecuteSiteAnalysisSlotResponse{}, client.executeSiteAnalysisSlotHandleError(resp)
	}
	return client.executeSiteAnalysisSlotHandleResponse(resp)
}

// executeSiteAnalysisSlotCreateRequest creates the ExecuteSiteAnalysisSlot request.
func (client *DiagnosticsClient) executeSiteAnalysisSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, slot string, options *DiagnosticsExecuteSiteAnalysisSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if analysisName == "" {
		return nil, errors.New("parameter analysisName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{analysisName}", url.PathEscape(analysisName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// executeSiteAnalysisSlotHandleResponse handles the ExecuteSiteAnalysisSlot response.
func (client *DiagnosticsClient) executeSiteAnalysisSlotHandleResponse(resp *http.Response) (DiagnosticsExecuteSiteAnalysisSlotResponse, error) {
	result := DiagnosticsExecuteSiteAnalysisSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticAnalysis); err != nil {
		return DiagnosticsExecuteSiteAnalysisSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// executeSiteAnalysisSlotHandleError handles the ExecuteSiteAnalysisSlot error response.
func (client *DiagnosticsClient) executeSiteAnalysisSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ExecuteSiteDetector - Description for Execute Detector
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ExecuteSiteDetector(ctx context.Context, resourceGroupName string, siteName string, detectorName string, diagnosticCategory string, options *DiagnosticsExecuteSiteDetectorOptions) (DiagnosticsExecuteSiteDetectorResponse, error) {
	req, err := client.executeSiteDetectorCreateRequest(ctx, resourceGroupName, siteName, detectorName, diagnosticCategory, options)
	if err != nil {
		return DiagnosticsExecuteSiteDetectorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsExecuteSiteDetectorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsExecuteSiteDetectorResponse{}, client.executeSiteDetectorHandleError(resp)
	}
	return client.executeSiteDetectorHandleResponse(resp)
}

// executeSiteDetectorCreateRequest creates the ExecuteSiteDetector request.
func (client *DiagnosticsClient) executeSiteDetectorCreateRequest(ctx context.Context, resourceGroupName string, siteName string, detectorName string, diagnosticCategory string, options *DiagnosticsExecuteSiteDetectorOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// executeSiteDetectorHandleResponse handles the ExecuteSiteDetector response.
func (client *DiagnosticsClient) executeSiteDetectorHandleResponse(resp *http.Response) (DiagnosticsExecuteSiteDetectorResponse, error) {
	result := DiagnosticsExecuteSiteDetectorResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticDetectorResponse); err != nil {
		return DiagnosticsExecuteSiteDetectorResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// executeSiteDetectorHandleError handles the ExecuteSiteDetector error response.
func (client *DiagnosticsClient) executeSiteDetectorHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ExecuteSiteDetectorSlot - Description for Execute Detector
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ExecuteSiteDetectorSlot(ctx context.Context, resourceGroupName string, siteName string, detectorName string, diagnosticCategory string, slot string, options *DiagnosticsExecuteSiteDetectorSlotOptions) (DiagnosticsExecuteSiteDetectorSlotResponse, error) {
	req, err := client.executeSiteDetectorSlotCreateRequest(ctx, resourceGroupName, siteName, detectorName, diagnosticCategory, slot, options)
	if err != nil {
		return DiagnosticsExecuteSiteDetectorSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsExecuteSiteDetectorSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsExecuteSiteDetectorSlotResponse{}, client.executeSiteDetectorSlotHandleError(resp)
	}
	return client.executeSiteDetectorSlotHandleResponse(resp)
}

// executeSiteDetectorSlotCreateRequest creates the ExecuteSiteDetectorSlot request.
func (client *DiagnosticsClient) executeSiteDetectorSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, detectorName string, diagnosticCategory string, slot string, options *DiagnosticsExecuteSiteDetectorSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// executeSiteDetectorSlotHandleResponse handles the ExecuteSiteDetectorSlot response.
func (client *DiagnosticsClient) executeSiteDetectorSlotHandleResponse(resp *http.Response) (DiagnosticsExecuteSiteDetectorSlotResponse, error) {
	result := DiagnosticsExecuteSiteDetectorSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticDetectorResponse); err != nil {
		return DiagnosticsExecuteSiteDetectorSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// executeSiteDetectorSlotHandleError handles the ExecuteSiteDetectorSlot error response.
func (client *DiagnosticsClient) executeSiteDetectorSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetHostingEnvironmentDetectorResponse - Description for Get Hosting Environment Detector Response
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetHostingEnvironmentDetectorResponse(ctx context.Context, resourceGroupName string, name string, detectorName string, options *DiagnosticsGetHostingEnvironmentDetectorResponseOptions) (DiagnosticsGetHostingEnvironmentDetectorResponseResponse, error) {
	req, err := client.getHostingEnvironmentDetectorResponseCreateRequest(ctx, resourceGroupName, name, detectorName, options)
	if err != nil {
		return DiagnosticsGetHostingEnvironmentDetectorResponseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetHostingEnvironmentDetectorResponseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetHostingEnvironmentDetectorResponseResponse{}, client.getHostingEnvironmentDetectorResponseHandleError(resp)
	}
	return client.getHostingEnvironmentDetectorResponseHandleResponse(resp)
}

// getHostingEnvironmentDetectorResponseCreateRequest creates the GetHostingEnvironmentDetectorResponse request.
func (client *DiagnosticsClient) getHostingEnvironmentDetectorResponseCreateRequest(ctx context.Context, resourceGroupName string, name string, detectorName string, options *DiagnosticsGetHostingEnvironmentDetectorResponseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors/{detectorName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHostingEnvironmentDetectorResponseHandleResponse handles the GetHostingEnvironmentDetectorResponse response.
func (client *DiagnosticsClient) getHostingEnvironmentDetectorResponseHandleResponse(resp *http.Response) (DiagnosticsGetHostingEnvironmentDetectorResponseResponse, error) {
	result := DiagnosticsGetHostingEnvironmentDetectorResponseResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponse); err != nil {
		return DiagnosticsGetHostingEnvironmentDetectorResponseResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHostingEnvironmentDetectorResponseHandleError handles the GetHostingEnvironmentDetectorResponse error response.
func (client *DiagnosticsClient) getHostingEnvironmentDetectorResponseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteAnalysis - Description for Get Site Analysis
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteAnalysis(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, options *DiagnosticsGetSiteAnalysisOptions) (DiagnosticsGetSiteAnalysisResponse, error) {
	req, err := client.getSiteAnalysisCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, analysisName, options)
	if err != nil {
		return DiagnosticsGetSiteAnalysisResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteAnalysisResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteAnalysisResponse{}, client.getSiteAnalysisHandleError(resp)
	}
	return client.getSiteAnalysisHandleResponse(resp)
}

// getSiteAnalysisCreateRequest creates the GetSiteAnalysis request.
func (client *DiagnosticsClient) getSiteAnalysisCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, options *DiagnosticsGetSiteAnalysisOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if analysisName == "" {
		return nil, errors.New("parameter analysisName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{analysisName}", url.PathEscape(analysisName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteAnalysisHandleResponse handles the GetSiteAnalysis response.
func (client *DiagnosticsClient) getSiteAnalysisHandleResponse(resp *http.Response) (DiagnosticsGetSiteAnalysisResponse, error) {
	result := DiagnosticsGetSiteAnalysisResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalysisDefinition); err != nil {
		return DiagnosticsGetSiteAnalysisResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteAnalysisHandleError handles the GetSiteAnalysis error response.
func (client *DiagnosticsClient) getSiteAnalysisHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteAnalysisSlot - Description for Get Site Analysis
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteAnalysisSlot(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, slot string, options *DiagnosticsGetSiteAnalysisSlotOptions) (DiagnosticsGetSiteAnalysisSlotResponse, error) {
	req, err := client.getSiteAnalysisSlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options)
	if err != nil {
		return DiagnosticsGetSiteAnalysisSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteAnalysisSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteAnalysisSlotResponse{}, client.getSiteAnalysisSlotHandleError(resp)
	}
	return client.getSiteAnalysisSlotHandleResponse(resp)
}

// getSiteAnalysisSlotCreateRequest creates the GetSiteAnalysisSlot request.
func (client *DiagnosticsClient) getSiteAnalysisSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, analysisName string, slot string, options *DiagnosticsGetSiteAnalysisSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if analysisName == "" {
		return nil, errors.New("parameter analysisName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{analysisName}", url.PathEscape(analysisName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteAnalysisSlotHandleResponse handles the GetSiteAnalysisSlot response.
func (client *DiagnosticsClient) getSiteAnalysisSlotHandleResponse(resp *http.Response) (DiagnosticsGetSiteAnalysisSlotResponse, error) {
	result := DiagnosticsGetSiteAnalysisSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalysisDefinition); err != nil {
		return DiagnosticsGetSiteAnalysisSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteAnalysisSlotHandleError handles the GetSiteAnalysisSlot error response.
func (client *DiagnosticsClient) getSiteAnalysisSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDetector - Description for Get Detector
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDetector(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, detectorName string, options *DiagnosticsGetSiteDetectorOptions) (DiagnosticsGetSiteDetectorResponse, error) {
	req, err := client.getSiteDetectorCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, detectorName, options)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDetectorResponse{}, client.getSiteDetectorHandleError(resp)
	}
	return client.getSiteDetectorHandleResponse(resp)
}

// getSiteDetectorCreateRequest creates the GetSiteDetector request.
func (client *DiagnosticsClient) getSiteDetectorCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, detectorName string, options *DiagnosticsGetSiteDetectorOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDetectorHandleResponse handles the GetSiteDetector response.
func (client *DiagnosticsClient) getSiteDetectorHandleResponse(resp *http.Response) (DiagnosticsGetSiteDetectorResponse, error) {
	result := DiagnosticsGetSiteDetectorResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorDefinitionResource); err != nil {
		return DiagnosticsGetSiteDetectorResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDetectorHandleError handles the GetSiteDetector error response.
func (client *DiagnosticsClient) getSiteDetectorHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDetectorResponse - Description for Get site detector response
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDetectorResponse(ctx context.Context, resourceGroupName string, siteName string, detectorName string, options *DiagnosticsGetSiteDetectorResponseOptions) (DiagnosticsGetSiteDetectorResponseResponse, error) {
	req, err := client.getSiteDetectorResponseCreateRequest(ctx, resourceGroupName, siteName, detectorName, options)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDetectorResponseResponse{}, client.getSiteDetectorResponseHandleError(resp)
	}
	return client.getSiteDetectorResponseHandleResponse(resp)
}

// getSiteDetectorResponseCreateRequest creates the GetSiteDetectorResponse request.
func (client *DiagnosticsClient) getSiteDetectorResponseCreateRequest(ctx context.Context, resourceGroupName string, siteName string, detectorName string, options *DiagnosticsGetSiteDetectorResponseOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors/{detectorName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDetectorResponseHandleResponse handles the GetSiteDetectorResponse response.
func (client *DiagnosticsClient) getSiteDetectorResponseHandleResponse(resp *http.Response) (DiagnosticsGetSiteDetectorResponseResponse, error) {
	result := DiagnosticsGetSiteDetectorResponseResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponse); err != nil {
		return DiagnosticsGetSiteDetectorResponseResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDetectorResponseHandleError handles the GetSiteDetectorResponse error response.
func (client *DiagnosticsClient) getSiteDetectorResponseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDetectorResponseSlot - Description for Get site detector response
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDetectorResponseSlot(ctx context.Context, resourceGroupName string, siteName string, detectorName string, slot string, options *DiagnosticsGetSiteDetectorResponseSlotOptions) (DiagnosticsGetSiteDetectorResponseSlotResponse, error) {
	req, err := client.getSiteDetectorResponseSlotCreateRequest(ctx, resourceGroupName, siteName, detectorName, slot, options)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponseSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDetectorResponseSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDetectorResponseSlotResponse{}, client.getSiteDetectorResponseSlotHandleError(resp)
	}
	return client.getSiteDetectorResponseSlotHandleResponse(resp)
}

// getSiteDetectorResponseSlotCreateRequest creates the GetSiteDetectorResponseSlot request.
func (client *DiagnosticsClient) getSiteDetectorResponseSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, detectorName string, slot string, options *DiagnosticsGetSiteDetectorResponseSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors/{detectorName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StartTime != nil {
		reqQP.Set("startTime", options.StartTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndTime != nil {
		reqQP.Set("endTime", options.EndTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeGrain != nil {
		reqQP.Set("timeGrain", *options.TimeGrain)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDetectorResponseSlotHandleResponse handles the GetSiteDetectorResponseSlot response.
func (client *DiagnosticsClient) getSiteDetectorResponseSlotHandleResponse(resp *http.Response) (DiagnosticsGetSiteDetectorResponseSlotResponse, error) {
	result := DiagnosticsGetSiteDetectorResponseSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponse); err != nil {
		return DiagnosticsGetSiteDetectorResponseSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDetectorResponseSlotHandleError handles the GetSiteDetectorResponseSlot error response.
func (client *DiagnosticsClient) getSiteDetectorResponseSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDetectorSlot - Description for Get Detector
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDetectorSlot(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, detectorName string, slot string, options *DiagnosticsGetSiteDetectorSlotOptions) (DiagnosticsGetSiteDetectorSlotResponse, error) {
	req, err := client.getSiteDetectorSlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, detectorName, slot, options)
	if err != nil {
		return DiagnosticsGetSiteDetectorSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDetectorSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDetectorSlotResponse{}, client.getSiteDetectorSlotHandleError(resp)
	}
	return client.getSiteDetectorSlotHandleResponse(resp)
}

// getSiteDetectorSlotCreateRequest creates the GetSiteDetectorSlot request.
func (client *DiagnosticsClient) getSiteDetectorSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, detectorName string, slot string, options *DiagnosticsGetSiteDetectorSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if detectorName == "" {
		return nil, errors.New("parameter detectorName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{detectorName}", url.PathEscape(detectorName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDetectorSlotHandleResponse handles the GetSiteDetectorSlot response.
func (client *DiagnosticsClient) getSiteDetectorSlotHandleResponse(resp *http.Response) (DiagnosticsGetSiteDetectorSlotResponse, error) {
	result := DiagnosticsGetSiteDetectorSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorDefinitionResource); err != nil {
		return DiagnosticsGetSiteDetectorSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDetectorSlotHandleError handles the GetSiteDetectorSlot error response.
func (client *DiagnosticsClient) getSiteDetectorSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDiagnosticCategory - Description for Get Diagnostics Category
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDiagnosticCategory(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsGetSiteDiagnosticCategoryOptions) (DiagnosticsGetSiteDiagnosticCategoryResponse, error) {
	req, err := client.getSiteDiagnosticCategoryCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, options)
	if err != nil {
		return DiagnosticsGetSiteDiagnosticCategoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDiagnosticCategoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDiagnosticCategoryResponse{}, client.getSiteDiagnosticCategoryHandleError(resp)
	}
	return client.getSiteDiagnosticCategoryHandleResponse(resp)
}

// getSiteDiagnosticCategoryCreateRequest creates the GetSiteDiagnosticCategory request.
func (client *DiagnosticsClient) getSiteDiagnosticCategoryCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsGetSiteDiagnosticCategoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDiagnosticCategoryHandleResponse handles the GetSiteDiagnosticCategory response.
func (client *DiagnosticsClient) getSiteDiagnosticCategoryHandleResponse(resp *http.Response) (DiagnosticsGetSiteDiagnosticCategoryResponse, error) {
	result := DiagnosticsGetSiteDiagnosticCategoryResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticCategory); err != nil {
		return DiagnosticsGetSiteDiagnosticCategoryResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDiagnosticCategoryHandleError handles the GetSiteDiagnosticCategory error response.
func (client *DiagnosticsClient) getSiteDiagnosticCategoryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteDiagnosticCategorySlot - Description for Get Diagnostics Category
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) GetSiteDiagnosticCategorySlot(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsGetSiteDiagnosticCategorySlotOptions) (DiagnosticsGetSiteDiagnosticCategorySlotResponse, error) {
	req, err := client.getSiteDiagnosticCategorySlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, slot, options)
	if err != nil {
		return DiagnosticsGetSiteDiagnosticCategorySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DiagnosticsGetSiteDiagnosticCategorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DiagnosticsGetSiteDiagnosticCategorySlotResponse{}, client.getSiteDiagnosticCategorySlotHandleError(resp)
	}
	return client.getSiteDiagnosticCategorySlotHandleResponse(resp)
}

// getSiteDiagnosticCategorySlotCreateRequest creates the GetSiteDiagnosticCategorySlot request.
func (client *DiagnosticsClient) getSiteDiagnosticCategorySlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsGetSiteDiagnosticCategorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteDiagnosticCategorySlotHandleResponse handles the GetSiteDiagnosticCategorySlot response.
func (client *DiagnosticsClient) getSiteDiagnosticCategorySlotHandleResponse(resp *http.Response) (DiagnosticsGetSiteDiagnosticCategorySlotResponse, error) {
	result := DiagnosticsGetSiteDiagnosticCategorySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticCategory); err != nil {
		return DiagnosticsGetSiteDiagnosticCategorySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteDiagnosticCategorySlotHandleError handles the GetSiteDiagnosticCategorySlot error response.
func (client *DiagnosticsClient) getSiteDiagnosticCategorySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHostingEnvironmentDetectorResponses - Description for List Hosting Environment Detector Responses
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListHostingEnvironmentDetectorResponses(resourceGroupName string, name string, options *DiagnosticsListHostingEnvironmentDetectorResponsesOptions) *DiagnosticsListHostingEnvironmentDetectorResponsesPager {
	return &DiagnosticsListHostingEnvironmentDetectorResponsesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listHostingEnvironmentDetectorResponsesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListHostingEnvironmentDetectorResponsesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DetectorResponseCollection.NextLink)
		},
	}
}

// listHostingEnvironmentDetectorResponsesCreateRequest creates the ListHostingEnvironmentDetectorResponses request.
func (client *DiagnosticsClient) listHostingEnvironmentDetectorResponsesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *DiagnosticsListHostingEnvironmentDetectorResponsesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHostingEnvironmentDetectorResponsesHandleResponse handles the ListHostingEnvironmentDetectorResponses response.
func (client *DiagnosticsClient) listHostingEnvironmentDetectorResponsesHandleResponse(resp *http.Response) (DiagnosticsListHostingEnvironmentDetectorResponsesResponse, error) {
	result := DiagnosticsListHostingEnvironmentDetectorResponsesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponseCollection); err != nil {
		return DiagnosticsListHostingEnvironmentDetectorResponsesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHostingEnvironmentDetectorResponsesHandleError handles the ListHostingEnvironmentDetectorResponses error response.
func (client *DiagnosticsClient) listHostingEnvironmentDetectorResponsesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteAnalyses - Description for Get Site Analyses
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteAnalyses(resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsListSiteAnalysesOptions) *DiagnosticsListSiteAnalysesPager {
	return &DiagnosticsListSiteAnalysesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteAnalysesCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteAnalysesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticAnalysisCollection.NextLink)
		},
	}
}

// listSiteAnalysesCreateRequest creates the ListSiteAnalyses request.
func (client *DiagnosticsClient) listSiteAnalysesCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsListSiteAnalysesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteAnalysesHandleResponse handles the ListSiteAnalyses response.
func (client *DiagnosticsClient) listSiteAnalysesHandleResponse(resp *http.Response) (DiagnosticsListSiteAnalysesResponse, error) {
	result := DiagnosticsListSiteAnalysesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticAnalysisCollection); err != nil {
		return DiagnosticsListSiteAnalysesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteAnalysesHandleError handles the ListSiteAnalyses error response.
func (client *DiagnosticsClient) listSiteAnalysesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteAnalysesSlot - Description for Get Site Analyses
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteAnalysesSlot(resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsListSiteAnalysesSlotOptions) *DiagnosticsListSiteAnalysesSlotPager {
	return &DiagnosticsListSiteAnalysesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteAnalysesSlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, slot, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteAnalysesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticAnalysisCollection.NextLink)
		},
	}
}

// listSiteAnalysesSlotCreateRequest creates the ListSiteAnalysesSlot request.
func (client *DiagnosticsClient) listSiteAnalysesSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsListSiteAnalysesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteAnalysesSlotHandleResponse handles the ListSiteAnalysesSlot response.
func (client *DiagnosticsClient) listSiteAnalysesSlotHandleResponse(resp *http.Response) (DiagnosticsListSiteAnalysesSlotResponse, error) {
	result := DiagnosticsListSiteAnalysesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticAnalysisCollection); err != nil {
		return DiagnosticsListSiteAnalysesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteAnalysesSlotHandleError handles the ListSiteAnalysesSlot error response.
func (client *DiagnosticsClient) listSiteAnalysesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDetectorResponses - Description for List Site Detector Responses
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDetectorResponses(resourceGroupName string, siteName string, options *DiagnosticsListSiteDetectorResponsesOptions) *DiagnosticsListSiteDetectorResponsesPager {
	return &DiagnosticsListSiteDetectorResponsesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDetectorResponsesCreateRequest(ctx, resourceGroupName, siteName, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDetectorResponsesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DetectorResponseCollection.NextLink)
		},
	}
}

// listSiteDetectorResponsesCreateRequest creates the ListSiteDetectorResponses request.
func (client *DiagnosticsClient) listSiteDetectorResponsesCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *DiagnosticsListSiteDetectorResponsesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDetectorResponsesHandleResponse handles the ListSiteDetectorResponses response.
func (client *DiagnosticsClient) listSiteDetectorResponsesHandleResponse(resp *http.Response) (DiagnosticsListSiteDetectorResponsesResponse, error) {
	result := DiagnosticsListSiteDetectorResponsesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponseCollection); err != nil {
		return DiagnosticsListSiteDetectorResponsesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDetectorResponsesHandleError handles the ListSiteDetectorResponses error response.
func (client *DiagnosticsClient) listSiteDetectorResponsesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDetectorResponsesSlot - Description for List Site Detector Responses
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDetectorResponsesSlot(resourceGroupName string, siteName string, slot string, options *DiagnosticsListSiteDetectorResponsesSlotOptions) *DiagnosticsListSiteDetectorResponsesSlotPager {
	return &DiagnosticsListSiteDetectorResponsesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDetectorResponsesSlotCreateRequest(ctx, resourceGroupName, siteName, slot, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDetectorResponsesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DetectorResponseCollection.NextLink)
		},
	}
}

// listSiteDetectorResponsesSlotCreateRequest creates the ListSiteDetectorResponsesSlot request.
func (client *DiagnosticsClient) listSiteDetectorResponsesSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, slot string, options *DiagnosticsListSiteDetectorResponsesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDetectorResponsesSlotHandleResponse handles the ListSiteDetectorResponsesSlot response.
func (client *DiagnosticsClient) listSiteDetectorResponsesSlotHandleResponse(resp *http.Response) (DiagnosticsListSiteDetectorResponsesSlotResponse, error) {
	result := DiagnosticsListSiteDetectorResponsesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectorResponseCollection); err != nil {
		return DiagnosticsListSiteDetectorResponsesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDetectorResponsesSlotHandleError handles the ListSiteDetectorResponsesSlot error response.
func (client *DiagnosticsClient) listSiteDetectorResponsesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDetectors - Description for Get Detectors
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDetectors(resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsListSiteDetectorsOptions) *DiagnosticsListSiteDetectorsPager {
	return &DiagnosticsListSiteDetectorsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDetectorsCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDetectorsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticDetectorCollection.NextLink)
		},
	}
}

// listSiteDetectorsCreateRequest creates the ListSiteDetectors request.
func (client *DiagnosticsClient) listSiteDetectorsCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, options *DiagnosticsListSiteDetectorsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDetectorsHandleResponse handles the ListSiteDetectors response.
func (client *DiagnosticsClient) listSiteDetectorsHandleResponse(resp *http.Response) (DiagnosticsListSiteDetectorsResponse, error) {
	result := DiagnosticsListSiteDetectorsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticDetectorCollection); err != nil {
		return DiagnosticsListSiteDetectorsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDetectorsHandleError handles the ListSiteDetectors error response.
func (client *DiagnosticsClient) listSiteDetectorsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDetectorsSlot - Description for Get Detectors
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDetectorsSlot(resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsListSiteDetectorsSlotOptions) *DiagnosticsListSiteDetectorsSlotPager {
	return &DiagnosticsListSiteDetectorsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDetectorsSlotCreateRequest(ctx, resourceGroupName, siteName, diagnosticCategory, slot, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDetectorsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticDetectorCollection.NextLink)
		},
	}
}

// listSiteDetectorsSlotCreateRequest creates the ListSiteDetectorsSlot request.
func (client *DiagnosticsClient) listSiteDetectorsSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, diagnosticCategory string, slot string, options *DiagnosticsListSiteDetectorsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if diagnosticCategory == "" {
		return nil, errors.New("parameter diagnosticCategory cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{diagnosticCategory}", url.PathEscape(diagnosticCategory))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDetectorsSlotHandleResponse handles the ListSiteDetectorsSlot response.
func (client *DiagnosticsClient) listSiteDetectorsSlotHandleResponse(resp *http.Response) (DiagnosticsListSiteDetectorsSlotResponse, error) {
	result := DiagnosticsListSiteDetectorsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticDetectorCollection); err != nil {
		return DiagnosticsListSiteDetectorsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDetectorsSlotHandleError handles the ListSiteDetectorsSlot error response.
func (client *DiagnosticsClient) listSiteDetectorsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDiagnosticCategories - Description for Get Diagnostics Categories
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDiagnosticCategories(resourceGroupName string, siteName string, options *DiagnosticsListSiteDiagnosticCategoriesOptions) *DiagnosticsListSiteDiagnosticCategoriesPager {
	return &DiagnosticsListSiteDiagnosticCategoriesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDiagnosticCategoriesCreateRequest(ctx, resourceGroupName, siteName, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDiagnosticCategoriesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticCategoryCollection.NextLink)
		},
	}
}

// listSiteDiagnosticCategoriesCreateRequest creates the ListSiteDiagnosticCategories request.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *DiagnosticsListSiteDiagnosticCategoriesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDiagnosticCategoriesHandleResponse handles the ListSiteDiagnosticCategories response.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesHandleResponse(resp *http.Response) (DiagnosticsListSiteDiagnosticCategoriesResponse, error) {
	result := DiagnosticsListSiteDiagnosticCategoriesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticCategoryCollection); err != nil {
		return DiagnosticsListSiteDiagnosticCategoriesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDiagnosticCategoriesHandleError handles the ListSiteDiagnosticCategories error response.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteDiagnosticCategoriesSlot - Description for Get Diagnostics Categories
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *DiagnosticsClient) ListSiteDiagnosticCategoriesSlot(resourceGroupName string, siteName string, slot string, options *DiagnosticsListSiteDiagnosticCategoriesSlotOptions) *DiagnosticsListSiteDiagnosticCategoriesSlotPager {
	return &DiagnosticsListSiteDiagnosticCategoriesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteDiagnosticCategoriesSlotCreateRequest(ctx, resourceGroupName, siteName, slot, options)
		},
		advancer: func(ctx context.Context, resp DiagnosticsListSiteDiagnosticCategoriesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DiagnosticCategoryCollection.NextLink)
		},
	}
}

// listSiteDiagnosticCategoriesSlotCreateRequest creates the ListSiteDiagnosticCategoriesSlot request.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesSlotCreateRequest(ctx context.Context, resourceGroupName string, siteName string, slot string, options *DiagnosticsListSiteDiagnosticCategoriesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteDiagnosticCategoriesSlotHandleResponse handles the ListSiteDiagnosticCategoriesSlot response.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesSlotHandleResponse(resp *http.Response) (DiagnosticsListSiteDiagnosticCategoriesSlotResponse, error) {
	result := DiagnosticsListSiteDiagnosticCategoriesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DiagnosticCategoryCollection); err != nil {
		return DiagnosticsListSiteDiagnosticCategoriesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteDiagnosticCategoriesSlotHandleError handles the ListSiteDiagnosticCategoriesSlot error response.
func (client *DiagnosticsClient) listSiteDiagnosticCategoriesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
