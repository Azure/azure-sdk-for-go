//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// RecommendationsClient contains the methods for the Recommendations group.
// Don't use this type directly, use NewRecommendationsClient() instead.
type RecommendationsClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewRecommendationsClient creates a new instance of RecommendationsClient with the specified values.
func NewRecommendationsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *RecommendationsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &RecommendationsClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// DisableAllForHostingEnvironment - Description for Disable all recommendations for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) DisableAllForHostingEnvironment(ctx context.Context, resourceGroupName string, environmentName string, hostingEnvironmentName string, options *RecommendationsDisableAllForHostingEnvironmentOptions) (RecommendationsDisableAllForHostingEnvironmentResponse, error) {
	req, err := client.disableAllForHostingEnvironmentCreateRequest(ctx, resourceGroupName, environmentName, hostingEnvironmentName, options)
	if err != nil {
		return RecommendationsDisableAllForHostingEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsDisableAllForHostingEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return RecommendationsDisableAllForHostingEnvironmentResponse{}, client.disableAllForHostingEnvironmentHandleError(resp)
	}
	return RecommendationsDisableAllForHostingEnvironmentResponse{RawResponse: resp}, nil
}

// disableAllForHostingEnvironmentCreateRequest creates the DisableAllForHostingEnvironment request.
func (client *RecommendationsClient) disableAllForHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, environmentName string, hostingEnvironmentName string, options *RecommendationsDisableAllForHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/disable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("environmentName", environmentName)
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// disableAllForHostingEnvironmentHandleError handles the DisableAllForHostingEnvironment error response.
func (client *RecommendationsClient) disableAllForHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DisableAllForWebApp - Description for Disable all recommendations for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) DisableAllForWebApp(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsDisableAllForWebAppOptions) (RecommendationsDisableAllForWebAppResponse, error) {
	req, err := client.disableAllForWebAppCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return RecommendationsDisableAllForWebAppResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsDisableAllForWebAppResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return RecommendationsDisableAllForWebAppResponse{}, client.disableAllForWebAppHandleError(resp)
	}
	return RecommendationsDisableAllForWebAppResponse{RawResponse: resp}, nil
}

// disableAllForWebAppCreateRequest creates the DisableAllForWebApp request.
func (client *RecommendationsClient) disableAllForWebAppCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsDisableAllForWebAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/disable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// disableAllForWebAppHandleError handles the DisableAllForWebApp error response.
func (client *RecommendationsClient) disableAllForWebAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DisableRecommendationForHostingEnvironment - Description for Disables the specific rule for a web site permanently.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) DisableRecommendationForHostingEnvironment(ctx context.Context, resourceGroupName string, environmentName string, name string, hostingEnvironmentName string, options *RecommendationsDisableRecommendationForHostingEnvironmentOptions) (RecommendationsDisableRecommendationForHostingEnvironmentResponse, error) {
	req, err := client.disableRecommendationForHostingEnvironmentCreateRequest(ctx, resourceGroupName, environmentName, name, hostingEnvironmentName, options)
	if err != nil {
		return RecommendationsDisableRecommendationForHostingEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsDisableRecommendationForHostingEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RecommendationsDisableRecommendationForHostingEnvironmentResponse{}, client.disableRecommendationForHostingEnvironmentHandleError(resp)
	}
	return RecommendationsDisableRecommendationForHostingEnvironmentResponse{RawResponse: resp}, nil
}

// disableRecommendationForHostingEnvironmentCreateRequest creates the DisableRecommendationForHostingEnvironment request.
func (client *RecommendationsClient) disableRecommendationForHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, environmentName string, name string, hostingEnvironmentName string, options *RecommendationsDisableRecommendationForHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}/disable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("environmentName", environmentName)
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// disableRecommendationForHostingEnvironmentHandleError handles the DisableRecommendationForHostingEnvironment error response.
func (client *RecommendationsClient) disableRecommendationForHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DisableRecommendationForSite - Description for Disables the specific rule for a web site permanently.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) DisableRecommendationForSite(ctx context.Context, resourceGroupName string, siteName string, name string, options *RecommendationsDisableRecommendationForSiteOptions) (RecommendationsDisableRecommendationForSiteResponse, error) {
	req, err := client.disableRecommendationForSiteCreateRequest(ctx, resourceGroupName, siteName, name, options)
	if err != nil {
		return RecommendationsDisableRecommendationForSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsDisableRecommendationForSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RecommendationsDisableRecommendationForSiteResponse{}, client.disableRecommendationForSiteHandleError(resp)
	}
	return RecommendationsDisableRecommendationForSiteResponse{RawResponse: resp}, nil
}

// disableRecommendationForSiteCreateRequest creates the DisableRecommendationForSite request.
func (client *RecommendationsClient) disableRecommendationForSiteCreateRequest(ctx context.Context, resourceGroupName string, siteName string, name string, options *RecommendationsDisableRecommendationForSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}/disable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// disableRecommendationForSiteHandleError handles the DisableRecommendationForSite error response.
func (client *RecommendationsClient) disableRecommendationForSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DisableRecommendationForSubscription - Description for Disables the specified rule so it will not apply to a subscription in the future.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) DisableRecommendationForSubscription(ctx context.Context, name string, options *RecommendationsDisableRecommendationForSubscriptionOptions) (RecommendationsDisableRecommendationForSubscriptionResponse, error) {
	req, err := client.disableRecommendationForSubscriptionCreateRequest(ctx, name, options)
	if err != nil {
		return RecommendationsDisableRecommendationForSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsDisableRecommendationForSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RecommendationsDisableRecommendationForSubscriptionResponse{}, client.disableRecommendationForSubscriptionHandleError(resp)
	}
	return RecommendationsDisableRecommendationForSubscriptionResponse{RawResponse: resp}, nil
}

// disableRecommendationForSubscriptionCreateRequest creates the DisableRecommendationForSubscription request.
func (client *RecommendationsClient) disableRecommendationForSubscriptionCreateRequest(ctx context.Context, name string, options *RecommendationsDisableRecommendationForSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/{name}/disable"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// disableRecommendationForSubscriptionHandleError handles the DisableRecommendationForSubscription error response.
func (client *RecommendationsClient) disableRecommendationForSubscriptionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRuleDetailsByHostingEnvironment - Description for Get a recommendation rule for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) GetRuleDetailsByHostingEnvironment(ctx context.Context, resourceGroupName string, hostingEnvironmentName string, name string, options *RecommendationsGetRuleDetailsByHostingEnvironmentOptions) (RecommendationsGetRuleDetailsByHostingEnvironmentResponse, error) {
	req, err := client.getRuleDetailsByHostingEnvironmentCreateRequest(ctx, resourceGroupName, hostingEnvironmentName, name, options)
	if err != nil {
		return RecommendationsGetRuleDetailsByHostingEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsGetRuleDetailsByHostingEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RecommendationsGetRuleDetailsByHostingEnvironmentResponse{}, client.getRuleDetailsByHostingEnvironmentHandleError(resp)
	}
	return client.getRuleDetailsByHostingEnvironmentHandleResponse(resp)
}

// getRuleDetailsByHostingEnvironmentCreateRequest creates the GetRuleDetailsByHostingEnvironment request.
func (client *RecommendationsClient) getRuleDetailsByHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, hostingEnvironmentName string, name string, options *RecommendationsGetRuleDetailsByHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.UpdateSeen != nil {
		reqQP.Set("updateSeen", strconv.FormatBool(*options.UpdateSeen))
	}
	if options != nil && options.RecommendationID != nil {
		reqQP.Set("recommendationId", *options.RecommendationID)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getRuleDetailsByHostingEnvironmentHandleResponse handles the GetRuleDetailsByHostingEnvironment response.
func (client *RecommendationsClient) getRuleDetailsByHostingEnvironmentHandleResponse(resp *http.Response) (RecommendationsGetRuleDetailsByHostingEnvironmentResponse, error) {
	result := RecommendationsGetRuleDetailsByHostingEnvironmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationRule); err != nil {
		return RecommendationsGetRuleDetailsByHostingEnvironmentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getRuleDetailsByHostingEnvironmentHandleError handles the GetRuleDetailsByHostingEnvironment error response.
func (client *RecommendationsClient) getRuleDetailsByHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRuleDetailsByWebApp - Description for Get a recommendation rule for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) GetRuleDetailsByWebApp(ctx context.Context, resourceGroupName string, siteName string, name string, options *RecommendationsGetRuleDetailsByWebAppOptions) (RecommendationsGetRuleDetailsByWebAppResponse, error) {
	req, err := client.getRuleDetailsByWebAppCreateRequest(ctx, resourceGroupName, siteName, name, options)
	if err != nil {
		return RecommendationsGetRuleDetailsByWebAppResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsGetRuleDetailsByWebAppResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return RecommendationsGetRuleDetailsByWebAppResponse{}, client.getRuleDetailsByWebAppHandleError(resp)
	}
	return client.getRuleDetailsByWebAppHandleResponse(resp)
}

// getRuleDetailsByWebAppCreateRequest creates the GetRuleDetailsByWebApp request.
func (client *RecommendationsClient) getRuleDetailsByWebAppCreateRequest(ctx context.Context, resourceGroupName string, siteName string, name string, options *RecommendationsGetRuleDetailsByWebAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.UpdateSeen != nil {
		reqQP.Set("updateSeen", strconv.FormatBool(*options.UpdateSeen))
	}
	if options != nil && options.RecommendationID != nil {
		reqQP.Set("recommendationId", *options.RecommendationID)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getRuleDetailsByWebAppHandleResponse handles the GetRuleDetailsByWebApp response.
func (client *RecommendationsClient) getRuleDetailsByWebAppHandleResponse(resp *http.Response) (RecommendationsGetRuleDetailsByWebAppResponse, error) {
	result := RecommendationsGetRuleDetailsByWebAppResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationRule); err != nil {
		return RecommendationsGetRuleDetailsByWebAppResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getRuleDetailsByWebAppHandleError handles the GetRuleDetailsByWebApp error response.
func (client *RecommendationsClient) getRuleDetailsByWebAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// List - Description for List all recommendations for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) List(options *RecommendationsListOptions) *RecommendationsListPager {
	return &RecommendationsListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp RecommendationsListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RecommendationCollection.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *RecommendationsClient) listCreateRequest(ctx context.Context, options *RecommendationsListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Featured != nil {
		reqQP.Set("featured", strconv.FormatBool(*options.Featured))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *RecommendationsClient) listHandleResponse(resp *http.Response) (RecommendationsListResponse, error) {
	result := RecommendationsListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationCollection); err != nil {
		return RecommendationsListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *RecommendationsClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHistoryForHostingEnvironment - Description for Get past recommendations for an app, optionally specified by the time range.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ListHistoryForHostingEnvironment(resourceGroupName string, hostingEnvironmentName string, options *RecommendationsListHistoryForHostingEnvironmentOptions) *RecommendationsListHistoryForHostingEnvironmentPager {
	return &RecommendationsListHistoryForHostingEnvironmentPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listHistoryForHostingEnvironmentCreateRequest(ctx, resourceGroupName, hostingEnvironmentName, options)
		},
		advancer: func(ctx context.Context, resp RecommendationsListHistoryForHostingEnvironmentResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RecommendationCollection.NextLink)
		},
	}
}

// listHistoryForHostingEnvironmentCreateRequest creates the ListHistoryForHostingEnvironment request.
func (client *RecommendationsClient) listHistoryForHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, hostingEnvironmentName string, options *RecommendationsListHistoryForHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendationHistory"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ExpiredOnly != nil {
		reqQP.Set("expiredOnly", strconv.FormatBool(*options.ExpiredOnly))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHistoryForHostingEnvironmentHandleResponse handles the ListHistoryForHostingEnvironment response.
func (client *RecommendationsClient) listHistoryForHostingEnvironmentHandleResponse(resp *http.Response) (RecommendationsListHistoryForHostingEnvironmentResponse, error) {
	result := RecommendationsListHistoryForHostingEnvironmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationCollection); err != nil {
		return RecommendationsListHistoryForHostingEnvironmentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHistoryForHostingEnvironmentHandleError handles the ListHistoryForHostingEnvironment error response.
func (client *RecommendationsClient) listHistoryForHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHistoryForWebApp - Description for Get past recommendations for an app, optionally specified by the time range.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ListHistoryForWebApp(resourceGroupName string, siteName string, options *RecommendationsListHistoryForWebAppOptions) *RecommendationsListHistoryForWebAppPager {
	return &RecommendationsListHistoryForWebAppPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listHistoryForWebAppCreateRequest(ctx, resourceGroupName, siteName, options)
		},
		advancer: func(ctx context.Context, resp RecommendationsListHistoryForWebAppResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RecommendationCollection.NextLink)
		},
	}
}

// listHistoryForWebAppCreateRequest creates the ListHistoryForWebApp request.
func (client *RecommendationsClient) listHistoryForWebAppCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsListHistoryForWebAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendationHistory"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ExpiredOnly != nil {
		reqQP.Set("expiredOnly", strconv.FormatBool(*options.ExpiredOnly))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHistoryForWebAppHandleResponse handles the ListHistoryForWebApp response.
func (client *RecommendationsClient) listHistoryForWebAppHandleResponse(resp *http.Response) (RecommendationsListHistoryForWebAppResponse, error) {
	result := RecommendationsListHistoryForWebAppResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationCollection); err != nil {
		return RecommendationsListHistoryForWebAppResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHistoryForWebAppHandleError handles the ListHistoryForWebApp error response.
func (client *RecommendationsClient) listHistoryForWebAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListRecommendedRulesForHostingEnvironment - Description for Get all recommendations for a hosting environment.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ListRecommendedRulesForHostingEnvironment(resourceGroupName string, hostingEnvironmentName string, options *RecommendationsListRecommendedRulesForHostingEnvironmentOptions) *RecommendationsListRecommendedRulesForHostingEnvironmentPager {
	return &RecommendationsListRecommendedRulesForHostingEnvironmentPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listRecommendedRulesForHostingEnvironmentCreateRequest(ctx, resourceGroupName, hostingEnvironmentName, options)
		},
		advancer: func(ctx context.Context, resp RecommendationsListRecommendedRulesForHostingEnvironmentResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RecommendationCollection.NextLink)
		},
	}
}

// listRecommendedRulesForHostingEnvironmentCreateRequest creates the ListRecommendedRulesForHostingEnvironment request.
func (client *RecommendationsClient) listRecommendedRulesForHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, hostingEnvironmentName string, options *RecommendationsListRecommendedRulesForHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Featured != nil {
		reqQP.Set("featured", strconv.FormatBool(*options.Featured))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listRecommendedRulesForHostingEnvironmentHandleResponse handles the ListRecommendedRulesForHostingEnvironment response.
func (client *RecommendationsClient) listRecommendedRulesForHostingEnvironmentHandleResponse(resp *http.Response) (RecommendationsListRecommendedRulesForHostingEnvironmentResponse, error) {
	result := RecommendationsListRecommendedRulesForHostingEnvironmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationCollection); err != nil {
		return RecommendationsListRecommendedRulesForHostingEnvironmentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listRecommendedRulesForHostingEnvironmentHandleError handles the ListRecommendedRulesForHostingEnvironment error response.
func (client *RecommendationsClient) listRecommendedRulesForHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListRecommendedRulesForWebApp - Description for Get all recommendations for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ListRecommendedRulesForWebApp(resourceGroupName string, siteName string, options *RecommendationsListRecommendedRulesForWebAppOptions) *RecommendationsListRecommendedRulesForWebAppPager {
	return &RecommendationsListRecommendedRulesForWebAppPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listRecommendedRulesForWebAppCreateRequest(ctx, resourceGroupName, siteName, options)
		},
		advancer: func(ctx context.Context, resp RecommendationsListRecommendedRulesForWebAppResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.RecommendationCollection.NextLink)
		},
	}
}

// listRecommendedRulesForWebAppCreateRequest creates the ListRecommendedRulesForWebApp request.
func (client *RecommendationsClient) listRecommendedRulesForWebAppCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsListRecommendedRulesForWebAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Featured != nil {
		reqQP.Set("featured", strconv.FormatBool(*options.Featured))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listRecommendedRulesForWebAppHandleResponse handles the ListRecommendedRulesForWebApp response.
func (client *RecommendationsClient) listRecommendedRulesForWebAppHandleResponse(resp *http.Response) (RecommendationsListRecommendedRulesForWebAppResponse, error) {
	result := RecommendationsListRecommendedRulesForWebAppResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RecommendationCollection); err != nil {
		return RecommendationsListRecommendedRulesForWebAppResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listRecommendedRulesForWebAppHandleError handles the ListRecommendedRulesForWebApp error response.
func (client *RecommendationsClient) listRecommendedRulesForWebAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetAllFilters - Description for Reset all recommendation opt-out settings for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ResetAllFilters(ctx context.Context, options *RecommendationsResetAllFiltersOptions) (RecommendationsResetAllFiltersResponse, error) {
	req, err := client.resetAllFiltersCreateRequest(ctx, options)
	if err != nil {
		return RecommendationsResetAllFiltersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsResetAllFiltersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return RecommendationsResetAllFiltersResponse{}, client.resetAllFiltersHandleError(resp)
	}
	return RecommendationsResetAllFiltersResponse{RawResponse: resp}, nil
}

// resetAllFiltersCreateRequest creates the ResetAllFilters request.
func (client *RecommendationsClient) resetAllFiltersCreateRequest(ctx context.Context, options *RecommendationsResetAllFiltersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/reset"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resetAllFiltersHandleError handles the ResetAllFilters error response.
func (client *RecommendationsClient) resetAllFiltersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetAllFiltersForHostingEnvironment - Description for Reset all recommendation opt-out settings for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ResetAllFiltersForHostingEnvironment(ctx context.Context, resourceGroupName string, environmentName string, hostingEnvironmentName string, options *RecommendationsResetAllFiltersForHostingEnvironmentOptions) (RecommendationsResetAllFiltersForHostingEnvironmentResponse, error) {
	req, err := client.resetAllFiltersForHostingEnvironmentCreateRequest(ctx, resourceGroupName, environmentName, hostingEnvironmentName, options)
	if err != nil {
		return RecommendationsResetAllFiltersForHostingEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsResetAllFiltersForHostingEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return RecommendationsResetAllFiltersForHostingEnvironmentResponse{}, client.resetAllFiltersForHostingEnvironmentHandleError(resp)
	}
	return RecommendationsResetAllFiltersForHostingEnvironmentResponse{RawResponse: resp}, nil
}

// resetAllFiltersForHostingEnvironmentCreateRequest creates the ResetAllFiltersForHostingEnvironment request.
func (client *RecommendationsClient) resetAllFiltersForHostingEnvironmentCreateRequest(ctx context.Context, resourceGroupName string, environmentName string, hostingEnvironmentName string, options *RecommendationsResetAllFiltersForHostingEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/reset"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if hostingEnvironmentName == "" {
		return nil, errors.New("parameter hostingEnvironmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostingEnvironmentName}", url.PathEscape(hostingEnvironmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("environmentName", environmentName)
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resetAllFiltersForHostingEnvironmentHandleError handles the ResetAllFiltersForHostingEnvironment error response.
func (client *RecommendationsClient) resetAllFiltersForHostingEnvironmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetAllFiltersForWebApp - Description for Reset all recommendation opt-out settings for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *RecommendationsClient) ResetAllFiltersForWebApp(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsResetAllFiltersForWebAppOptions) (RecommendationsResetAllFiltersForWebAppResponse, error) {
	req, err := client.resetAllFiltersForWebAppCreateRequest(ctx, resourceGroupName, siteName, options)
	if err != nil {
		return RecommendationsResetAllFiltersForWebAppResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return RecommendationsResetAllFiltersForWebAppResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return RecommendationsResetAllFiltersForWebAppResponse{}, client.resetAllFiltersForWebAppHandleError(resp)
	}
	return RecommendationsResetAllFiltersForWebAppResponse{RawResponse: resp}, nil
}

// resetAllFiltersForWebAppCreateRequest creates the ResetAllFiltersForWebApp request.
func (client *RecommendationsClient) resetAllFiltersForWebAppCreateRequest(ctx context.Context, resourceGroupName string, siteName string, options *RecommendationsResetAllFiltersForWebAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/reset"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if siteName == "" {
		return nil, errors.New("parameter siteName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteName}", url.PathEscape(siteName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resetAllFiltersForWebAppHandleError handles the ResetAllFiltersForWebApp error response.
func (client *RecommendationsClient) resetAllFiltersForWebAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
