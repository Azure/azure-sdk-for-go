//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// StaticSitesClient contains the methods for the StaticSites group.
// Don't use this type directly, use NewStaticSitesClient() instead.
type StaticSitesClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewStaticSitesClient creates a new instance of StaticSitesClient with the specified values.
func NewStaticSitesClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *StaticSitesClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &StaticSitesClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *StaticSitesBeginApproveOrRejectPrivateEndpointConnectionOptions) (StaticSitesApproveOrRejectPrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return StaticSitesApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result := StaticSitesApproveOrRejectPrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.ApproveOrRejectPrivateEndpointConnection", "", resp, client.pl, client.approveOrRejectPrivateEndpointConnectionHandleError)
	if err != nil {
		return StaticSitesApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &StaticSitesApproveOrRejectPrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *StaticSitesBeginApproveOrRejectPrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *StaticSitesClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *StaticSitesBeginApproveOrRejectPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionHandleError handles the ApproveOrRejectPrivateEndpointConnection error response.
func (client *StaticSitesClient) approveOrRejectPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateStaticSite - Description for Creates a new static site in an existing resource group, or updates an existing static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginCreateOrUpdateStaticSite(ctx context.Context, resourceGroupName string, name string, staticSiteEnvelope StaticSiteARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteOptions) (StaticSitesCreateOrUpdateStaticSitePollerResponse, error) {
	resp, err := client.createOrUpdateStaticSite(ctx, resourceGroupName, name, staticSiteEnvelope, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSitePollerResponse{}, err
	}
	result := StaticSitesCreateOrUpdateStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.CreateOrUpdateStaticSite", "", resp, client.pl, client.createOrUpdateStaticSiteHandleError)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesCreateOrUpdateStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateStaticSite - Description for Creates a new static site in an existing resource group, or updates an existing static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) createOrUpdateStaticSite(ctx context.Context, resourceGroupName string, name string, staticSiteEnvelope StaticSiteARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteOptions) (*http.Response, error) {
	req, err := client.createOrUpdateStaticSiteCreateRequest(ctx, resourceGroupName, name, staticSiteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateStaticSiteHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateStaticSiteCreateRequest creates the CreateOrUpdateStaticSite request.
func (client *StaticSitesClient) createOrUpdateStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, staticSiteEnvelope StaticSiteARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteEnvelope)
}

// createOrUpdateStaticSiteHandleError handles the CreateOrUpdateStaticSite error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateStaticSiteAppSettings - Description for Creates or updates the app settings of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) CreateOrUpdateStaticSiteAppSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteAppSettingsOptions) (StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse, error) {
	req, err := client.createOrUpdateStaticSiteAppSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse{}, client.createOrUpdateStaticSiteAppSettingsHandleError(resp)
	}
	return client.createOrUpdateStaticSiteAppSettingsHandleResponse(resp)
}

// createOrUpdateStaticSiteAppSettingsCreateRequest creates the CreateOrUpdateStaticSiteAppSettings request.
func (client *StaticSitesClient) createOrUpdateStaticSiteAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// createOrUpdateStaticSiteAppSettingsHandleResponse handles the CreateOrUpdateStaticSiteAppSettings response.
func (client *StaticSitesClient) createOrUpdateStaticSiteAppSettingsHandleResponse(resp *http.Response) (StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse, error) {
	result := StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesCreateOrUpdateStaticSiteAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateStaticSiteAppSettingsHandleError handles the CreateOrUpdateStaticSiteAppSettings error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateStaticSiteBuildAppSettings - Description for Creates or updates the app settings of a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) CreateOrUpdateStaticSiteBuildAppSettings(ctx context.Context, resourceGroupName string, name string, environmentName string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsOptions) (StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse, error) {
	req, err := client.createOrUpdateStaticSiteBuildAppSettingsCreateRequest(ctx, resourceGroupName, name, environmentName, appSettings, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse{}, client.createOrUpdateStaticSiteBuildAppSettingsHandleError(resp)
	}
	return client.createOrUpdateStaticSiteBuildAppSettingsHandleResponse(resp)
}

// createOrUpdateStaticSiteBuildAppSettingsCreateRequest creates the CreateOrUpdateStaticSiteBuildAppSettings request.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// createOrUpdateStaticSiteBuildAppSettingsHandleResponse handles the CreateOrUpdateStaticSiteBuildAppSettings response.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildAppSettingsHandleResponse(resp *http.Response) (StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse, error) {
	result := StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateStaticSiteBuildAppSettingsHandleError handles the CreateOrUpdateStaticSiteBuildAppSettings error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateStaticSiteBuildFunctionAppSettings - Description for Creates or updates the function app settings of a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) CreateOrUpdateStaticSiteBuildFunctionAppSettings(ctx context.Context, resourceGroupName string, name string, environmentName string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsOptions) (StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse, error) {
	req, err := client.createOrUpdateStaticSiteBuildFunctionAppSettingsCreateRequest(ctx, resourceGroupName, name, environmentName, appSettings, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse{}, client.createOrUpdateStaticSiteBuildFunctionAppSettingsHandleError(resp)
	}
	return client.createOrUpdateStaticSiteBuildFunctionAppSettingsHandleResponse(resp)
}

// createOrUpdateStaticSiteBuildFunctionAppSettingsCreateRequest creates the CreateOrUpdateStaticSiteBuildFunctionAppSettings request.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildFunctionAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/functionappsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// createOrUpdateStaticSiteBuildFunctionAppSettingsHandleResponse handles the CreateOrUpdateStaticSiteBuildFunctionAppSettings response.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildFunctionAppSettingsHandleResponse(resp *http.Response) (StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse, error) {
	result := StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesCreateOrUpdateStaticSiteBuildFunctionAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateStaticSiteBuildFunctionAppSettingsHandleError handles the CreateOrUpdateStaticSiteBuildFunctionAppSettings error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteBuildFunctionAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateStaticSiteCustomDomain - Description for Creates a new static site custom domain in an existing resource group and static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginCreateOrUpdateStaticSiteCustomDomain(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteCustomDomainOptions) (StaticSitesCreateOrUpdateStaticSiteCustomDomainPollerResponse, error) {
	resp, err := client.createOrUpdateStaticSiteCustomDomain(ctx, resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteCustomDomainPollerResponse{}, err
	}
	result := StaticSitesCreateOrUpdateStaticSiteCustomDomainPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.CreateOrUpdateStaticSiteCustomDomain", "", resp, client.pl, client.createOrUpdateStaticSiteCustomDomainHandleError)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteCustomDomainPollerResponse{}, err
	}
	result.Poller = &StaticSitesCreateOrUpdateStaticSiteCustomDomainPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateStaticSiteCustomDomain - Description for Creates a new static site custom domain in an existing resource group and static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) createOrUpdateStaticSiteCustomDomain(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteCustomDomainOptions) (*http.Response, error) {
	req, err := client.createOrUpdateStaticSiteCustomDomainCreateRequest(ctx, resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateStaticSiteCustomDomainHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateStaticSiteCustomDomainCreateRequest creates the CreateOrUpdateStaticSiteCustomDomain request.
func (client *StaticSitesClient) createOrUpdateStaticSiteCustomDomainCreateRequest(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginCreateOrUpdateStaticSiteCustomDomainOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainName == "" {
		return nil, errors.New("parameter domainName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainName}", url.PathEscape(domainName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteCustomDomainRequestPropertiesEnvelope)
}

// createOrUpdateStaticSiteCustomDomainHandleError handles the CreateOrUpdateStaticSiteCustomDomain error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteCustomDomainHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateStaticSiteFunctionAppSettings - Description for Creates or updates the function app settings of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) CreateOrUpdateStaticSiteFunctionAppSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsOptions) (StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse, error) {
	req, err := client.createOrUpdateStaticSiteFunctionAppSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse{}, client.createOrUpdateStaticSiteFunctionAppSettingsHandleError(resp)
	}
	return client.createOrUpdateStaticSiteFunctionAppSettingsHandleResponse(resp)
}

// createOrUpdateStaticSiteFunctionAppSettingsCreateRequest creates the CreateOrUpdateStaticSiteFunctionAppSettings request.
func (client *StaticSitesClient) createOrUpdateStaticSiteFunctionAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/functionappsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// createOrUpdateStaticSiteFunctionAppSettingsHandleResponse handles the CreateOrUpdateStaticSiteFunctionAppSettings response.
func (client *StaticSitesClient) createOrUpdateStaticSiteFunctionAppSettingsHandleResponse(resp *http.Response) (StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse, error) {
	result := StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesCreateOrUpdateStaticSiteFunctionAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateStaticSiteFunctionAppSettingsHandleError handles the CreateOrUpdateStaticSiteFunctionAppSettings error response.
func (client *StaticSitesClient) createOrUpdateStaticSiteFunctionAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateUserRolesInvitationLink - Description for Creates an invitation link for a user with the role
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) CreateUserRolesInvitationLink(ctx context.Context, resourceGroupName string, name string, staticSiteUserRolesInvitationEnvelope StaticSiteUserInvitationRequestResource, options *StaticSitesCreateUserRolesInvitationLinkOptions) (StaticSitesCreateUserRolesInvitationLinkResponse, error) {
	req, err := client.createUserRolesInvitationLinkCreateRequest(ctx, resourceGroupName, name, staticSiteUserRolesInvitationEnvelope, options)
	if err != nil {
		return StaticSitesCreateUserRolesInvitationLinkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesCreateUserRolesInvitationLinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesCreateUserRolesInvitationLinkResponse{}, client.createUserRolesInvitationLinkHandleError(resp)
	}
	return client.createUserRolesInvitationLinkHandleResponse(resp)
}

// createUserRolesInvitationLinkCreateRequest creates the CreateUserRolesInvitationLink request.
func (client *StaticSitesClient) createUserRolesInvitationLinkCreateRequest(ctx context.Context, resourceGroupName string, name string, staticSiteUserRolesInvitationEnvelope StaticSiteUserInvitationRequestResource, options *StaticSitesCreateUserRolesInvitationLinkOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/createUserInvitation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteUserRolesInvitationEnvelope)
}

// createUserRolesInvitationLinkHandleResponse handles the CreateUserRolesInvitationLink response.
func (client *StaticSitesClient) createUserRolesInvitationLinkHandleResponse(resp *http.Response) (StaticSitesCreateUserRolesInvitationLinkResponse, error) {
	result := StaticSitesCreateUserRolesInvitationLinkResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserInvitationResponseResource); err != nil {
		return StaticSitesCreateUserRolesInvitationLinkResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createUserRolesInvitationLinkHandleError handles the CreateUserRolesInvitationLink error response.
func (client *StaticSitesClient) createUserRolesInvitationLinkHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateZipDeploymentForStaticSite - Description for Deploys zipped content to a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginCreateZipDeploymentForStaticSite(ctx context.Context, resourceGroupName string, name string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteOptions) (StaticSitesCreateZipDeploymentForStaticSitePollerResponse, error) {
	resp, err := client.createZipDeploymentForStaticSite(ctx, resourceGroupName, name, staticSiteZipDeploymentEnvelope, options)
	if err != nil {
		return StaticSitesCreateZipDeploymentForStaticSitePollerResponse{}, err
	}
	result := StaticSitesCreateZipDeploymentForStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.CreateZipDeploymentForStaticSite", "", resp, client.pl, client.createZipDeploymentForStaticSiteHandleError)
	if err != nil {
		return StaticSitesCreateZipDeploymentForStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesCreateZipDeploymentForStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// CreateZipDeploymentForStaticSite - Description for Deploys zipped content to a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) createZipDeploymentForStaticSite(ctx context.Context, resourceGroupName string, name string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteOptions) (*http.Response, error) {
	req, err := client.createZipDeploymentForStaticSiteCreateRequest(ctx, resourceGroupName, name, staticSiteZipDeploymentEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createZipDeploymentForStaticSiteHandleError(resp)
	}
	return resp, nil
}

// createZipDeploymentForStaticSiteCreateRequest creates the CreateZipDeploymentForStaticSite request.
func (client *StaticSitesClient) createZipDeploymentForStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/zipdeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteZipDeploymentEnvelope)
}

// createZipDeploymentForStaticSiteHandleError handles the CreateZipDeploymentForStaticSite error response.
func (client *StaticSitesClient) createZipDeploymentForStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateZipDeploymentForStaticSiteBuild - Description for Deploys zipped content to a specific environment of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginCreateZipDeploymentForStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteBuildOptions) (StaticSitesCreateZipDeploymentForStaticSiteBuildPollerResponse, error) {
	resp, err := client.createZipDeploymentForStaticSiteBuild(ctx, resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options)
	if err != nil {
		return StaticSitesCreateZipDeploymentForStaticSiteBuildPollerResponse{}, err
	}
	result := StaticSitesCreateZipDeploymentForStaticSiteBuildPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.CreateZipDeploymentForStaticSiteBuild", "", resp, client.pl, client.createZipDeploymentForStaticSiteBuildHandleError)
	if err != nil {
		return StaticSitesCreateZipDeploymentForStaticSiteBuildPollerResponse{}, err
	}
	result.Poller = &StaticSitesCreateZipDeploymentForStaticSiteBuildPoller{
		pt: pt,
	}
	return result, nil
}

// CreateZipDeploymentForStaticSiteBuild - Description for Deploys zipped content to a specific environment of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) createZipDeploymentForStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteBuildOptions) (*http.Response, error) {
	req, err := client.createZipDeploymentForStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createZipDeploymentForStaticSiteBuildHandleError(resp)
	}
	return resp, nil
}

// createZipDeploymentForStaticSiteBuildCreateRequest creates the CreateZipDeploymentForStaticSiteBuild request.
func (client *StaticSitesClient) createZipDeploymentForStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, staticSiteZipDeploymentEnvelope StaticSiteZipDeploymentARMResource, options *StaticSitesBeginCreateZipDeploymentForStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/zipdeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteZipDeploymentEnvelope)
}

// createZipDeploymentForStaticSiteBuildHandleError handles the CreateZipDeploymentForStaticSiteBuild error response.
func (client *StaticSitesClient) createZipDeploymentForStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *StaticSitesBeginDeletePrivateEndpointConnectionOptions) (StaticSitesDeletePrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return StaticSitesDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result := StaticSitesDeletePrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.DeletePrivateEndpointConnection", "", resp, client.pl, client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return StaticSitesDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &StaticSitesDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *StaticSitesBeginDeletePrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *StaticSitesClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *StaticSitesBeginDeletePrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionHandleError handles the DeletePrivateEndpointConnection error response.
func (client *StaticSitesClient) deletePrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteStaticSite - Description for Deletes a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginDeleteStaticSite(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDeleteStaticSiteOptions) (StaticSitesDeleteStaticSitePollerResponse, error) {
	resp, err := client.deleteStaticSite(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesDeleteStaticSitePollerResponse{}, err
	}
	result := StaticSitesDeleteStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.DeleteStaticSite", "", resp, client.pl, client.deleteStaticSiteHandleError)
	if err != nil {
		return StaticSitesDeleteStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesDeleteStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// DeleteStaticSite - Description for Deletes a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) deleteStaticSite(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDeleteStaticSiteOptions) (*http.Response, error) {
	req, err := client.deleteStaticSiteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteStaticSiteHandleError(resp)
	}
	return resp, nil
}

// deleteStaticSiteCreateRequest creates the DeleteStaticSite request.
func (client *StaticSitesClient) deleteStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDeleteStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStaticSiteHandleError handles the DeleteStaticSite error response.
func (client *StaticSitesClient) deleteStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteStaticSiteBuild - Description for Deletes a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginDeleteStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesBeginDeleteStaticSiteBuildOptions) (StaticSitesDeleteStaticSiteBuildPollerResponse, error) {
	resp, err := client.deleteStaticSiteBuild(ctx, resourceGroupName, name, environmentName, options)
	if err != nil {
		return StaticSitesDeleteStaticSiteBuildPollerResponse{}, err
	}
	result := StaticSitesDeleteStaticSiteBuildPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.DeleteStaticSiteBuild", "", resp, client.pl, client.deleteStaticSiteBuildHandleError)
	if err != nil {
		return StaticSitesDeleteStaticSiteBuildPollerResponse{}, err
	}
	result.Poller = &StaticSitesDeleteStaticSiteBuildPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteStaticSiteBuild - Description for Deletes a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) deleteStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesBeginDeleteStaticSiteBuildOptions) (*http.Response, error) {
	req, err := client.deleteStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteStaticSiteBuildHandleError(resp)
	}
	return resp, nil
}

// deleteStaticSiteBuildCreateRequest creates the DeleteStaticSiteBuild request.
func (client *StaticSitesClient) deleteStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesBeginDeleteStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStaticSiteBuildHandleError handles the DeleteStaticSiteBuild error response.
func (client *StaticSitesClient) deleteStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeleteStaticSiteCustomDomain - Description for Deletes a custom domain.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginDeleteStaticSiteCustomDomain(ctx context.Context, resourceGroupName string, name string, domainName string, options *StaticSitesBeginDeleteStaticSiteCustomDomainOptions) (StaticSitesDeleteStaticSiteCustomDomainPollerResponse, error) {
	resp, err := client.deleteStaticSiteCustomDomain(ctx, resourceGroupName, name, domainName, options)
	if err != nil {
		return StaticSitesDeleteStaticSiteCustomDomainPollerResponse{}, err
	}
	result := StaticSitesDeleteStaticSiteCustomDomainPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.DeleteStaticSiteCustomDomain", "", resp, client.pl, client.deleteStaticSiteCustomDomainHandleError)
	if err != nil {
		return StaticSitesDeleteStaticSiteCustomDomainPollerResponse{}, err
	}
	result.Poller = &StaticSitesDeleteStaticSiteCustomDomainPoller{
		pt: pt,
	}
	return result, nil
}

// DeleteStaticSiteCustomDomain - Description for Deletes a custom domain.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) deleteStaticSiteCustomDomain(ctx context.Context, resourceGroupName string, name string, domainName string, options *StaticSitesBeginDeleteStaticSiteCustomDomainOptions) (*http.Response, error) {
	req, err := client.deleteStaticSiteCustomDomainCreateRequest(ctx, resourceGroupName, name, domainName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteStaticSiteCustomDomainHandleError(resp)
	}
	return resp, nil
}

// deleteStaticSiteCustomDomainCreateRequest creates the DeleteStaticSiteCustomDomain request.
func (client *StaticSitesClient) deleteStaticSiteCustomDomainCreateRequest(ctx context.Context, resourceGroupName string, name string, domainName string, options *StaticSitesBeginDeleteStaticSiteCustomDomainOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainName == "" {
		return nil, errors.New("parameter domainName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainName}", url.PathEscape(domainName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStaticSiteCustomDomainHandleError handles the DeleteStaticSiteCustomDomain error response.
func (client *StaticSitesClient) deleteStaticSiteCustomDomainHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteStaticSiteUser - Description for Deletes the user entry from the static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) DeleteStaticSiteUser(ctx context.Context, resourceGroupName string, name string, authprovider string, userid string, options *StaticSitesDeleteStaticSiteUserOptions) (StaticSitesDeleteStaticSiteUserResponse, error) {
	req, err := client.deleteStaticSiteUserCreateRequest(ctx, resourceGroupName, name, authprovider, userid, options)
	if err != nil {
		return StaticSitesDeleteStaticSiteUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesDeleteStaticSiteUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesDeleteStaticSiteUserResponse{}, client.deleteStaticSiteUserHandleError(resp)
	}
	return StaticSitesDeleteStaticSiteUserResponse{RawResponse: resp}, nil
}

// deleteStaticSiteUserCreateRequest creates the DeleteStaticSiteUser request.
func (client *StaticSitesClient) deleteStaticSiteUserCreateRequest(ctx context.Context, resourceGroupName string, name string, authprovider string, userid string, options *StaticSitesDeleteStaticSiteUserOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if authprovider == "" {
		return nil, errors.New("parameter authprovider cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authprovider}", url.PathEscape(authprovider))
	if userid == "" {
		return nil, errors.New("parameter userid cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userid}", url.PathEscape(userid))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStaticSiteUserHandleError handles the DeleteStaticSiteUser error response.
func (client *StaticSitesClient) deleteStaticSiteUserHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDetachStaticSite - Description for Detaches a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginDetachStaticSite(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDetachStaticSiteOptions) (StaticSitesDetachStaticSitePollerResponse, error) {
	resp, err := client.detachStaticSite(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesDetachStaticSitePollerResponse{}, err
	}
	result := StaticSitesDetachStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.DetachStaticSite", "", resp, client.pl, client.detachStaticSiteHandleError)
	if err != nil {
		return StaticSitesDetachStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesDetachStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// DetachStaticSite - Description for Detaches a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) detachStaticSite(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDetachStaticSiteOptions) (*http.Response, error) {
	req, err := client.detachStaticSiteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.detachStaticSiteHandleError(resp)
	}
	return resp, nil
}

// detachStaticSiteCreateRequest creates the DetachStaticSite request.
func (client *StaticSitesClient) detachStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesBeginDetachStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/detach"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// detachStaticSiteHandleError handles the DetachStaticSite error response.
func (client *StaticSitesClient) detachStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DetachUserProvidedFunctionAppFromStaticSite - Description for Detach the user provided function app from the static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) DetachUserProvidedFunctionAppFromStaticSite(ctx context.Context, resourceGroupName string, name string, functionAppName string, options *StaticSitesDetachUserProvidedFunctionAppFromStaticSiteOptions) (StaticSitesDetachUserProvidedFunctionAppFromStaticSiteResponse, error) {
	req, err := client.detachUserProvidedFunctionAppFromStaticSiteCreateRequest(ctx, resourceGroupName, name, functionAppName, options)
	if err != nil {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteResponse{}, client.detachUserProvidedFunctionAppFromStaticSiteHandleError(resp)
	}
	return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteResponse{RawResponse: resp}, nil
}

// detachUserProvidedFunctionAppFromStaticSiteCreateRequest creates the DetachUserProvidedFunctionAppFromStaticSite request.
func (client *StaticSitesClient) detachUserProvidedFunctionAppFromStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, functionAppName string, options *StaticSitesDetachUserProvidedFunctionAppFromStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// detachUserProvidedFunctionAppFromStaticSiteHandleError handles the DetachUserProvidedFunctionAppFromStaticSite error response.
func (client *StaticSitesClient) detachUserProvidedFunctionAppFromStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DetachUserProvidedFunctionAppFromStaticSiteBuild - Description for Detach the user provided function app from the static site build
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) DetachUserProvidedFunctionAppFromStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, options *StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildOptions) (StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildResponse, error) {
	req, err := client.detachUserProvidedFunctionAppFromStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, functionAppName, options)
	if err != nil {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildResponse{}, client.detachUserProvidedFunctionAppFromStaticSiteBuildHandleError(resp)
	}
	return StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildResponse{RawResponse: resp}, nil
}

// detachUserProvidedFunctionAppFromStaticSiteBuildCreateRequest creates the DetachUserProvidedFunctionAppFromStaticSiteBuild request.
func (client *StaticSitesClient) detachUserProvidedFunctionAppFromStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, options *StaticSitesDetachUserProvidedFunctionAppFromStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// detachUserProvidedFunctionAppFromStaticSiteBuildHandleError handles the DetachUserProvidedFunctionAppFromStaticSiteBuild error response.
func (client *StaticSitesClient) detachUserProvidedFunctionAppFromStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *StaticSitesGetPrivateEndpointConnectionOptions) (StaticSitesGetPrivateEndpointConnectionResponse, error) {
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return StaticSitesGetPrivateEndpointConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetPrivateEndpointConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetPrivateEndpointConnectionResponse{}, client.getPrivateEndpointConnectionHandleError(resp)
	}
	return client.getPrivateEndpointConnectionHandleResponse(resp)
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *StaticSitesClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *StaticSitesGetPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *StaticSitesClient) getPrivateEndpointConnectionHandleResponse(resp *http.Response) (StaticSitesGetPrivateEndpointConnectionResponse, error) {
	result := StaticSitesGetPrivateEndpointConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return StaticSitesGetPrivateEndpointConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionHandleError handles the GetPrivateEndpointConnection error response.
func (client *StaticSitesClient) getPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnectionList - Description for Gets the list of private endpoint connections associated with a static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetPrivateEndpointConnectionList(resourceGroupName string, name string, options *StaticSitesGetPrivateEndpointConnectionListOptions) *StaticSitesGetPrivateEndpointConnectionListPager {
	return &StaticSitesGetPrivateEndpointConnectionListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesGetPrivateEndpointConnectionListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
	}
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *StaticSitesClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetPrivateEndpointConnectionListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *StaticSitesClient) getPrivateEndpointConnectionListHandleResponse(resp *http.Response) (StaticSitesGetPrivateEndpointConnectionListResponse, error) {
	result := StaticSitesGetPrivateEndpointConnectionListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return StaticSitesGetPrivateEndpointConnectionListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionListHandleError handles the GetPrivateEndpointConnectionList error response.
func (client *StaticSitesClient) getPrivateEndpointConnectionListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetPrivateLinkResourcesOptions) (StaticSitesGetPrivateLinkResourcesResponse, error) {
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesGetPrivateLinkResourcesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetPrivateLinkResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetPrivateLinkResourcesResponse{}, client.getPrivateLinkResourcesHandleError(resp)
	}
	return client.getPrivateLinkResourcesHandleResponse(resp)
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *StaticSitesClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetPrivateLinkResourcesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *StaticSitesClient) getPrivateLinkResourcesHandleResponse(resp *http.Response) (StaticSitesGetPrivateLinkResourcesResponse, error) {
	result := StaticSitesGetPrivateLinkResourcesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return StaticSitesGetPrivateLinkResourcesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateLinkResourcesHandleError handles the GetPrivateLinkResources error response.
func (client *StaticSitesClient) getPrivateLinkResourcesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStaticSite - Description for Gets the details of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetStaticSite(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetStaticSiteOptions) (StaticSitesGetStaticSiteResponse, error) {
	req, err := client.getStaticSiteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesGetStaticSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetStaticSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetStaticSiteResponse{}, client.getStaticSiteHandleError(resp)
	}
	return client.getStaticSiteHandleResponse(resp)
}

// getStaticSiteCreateRequest creates the GetStaticSite request.
func (client *StaticSitesClient) getStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStaticSiteHandleResponse handles the GetStaticSite response.
func (client *StaticSitesClient) getStaticSiteHandleResponse(resp *http.Response) (StaticSitesGetStaticSiteResponse, error) {
	result := StaticSitesGetStaticSiteResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteARMResource); err != nil {
		return StaticSitesGetStaticSiteResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStaticSiteHandleError handles the GetStaticSite error response.
func (client *StaticSitesClient) getStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStaticSiteBuild - Description for Gets the details of a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesGetStaticSiteBuildOptions) (StaticSitesGetStaticSiteBuildResponse, error) {
	req, err := client.getStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, options)
	if err != nil {
		return StaticSitesGetStaticSiteBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetStaticSiteBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetStaticSiteBuildResponse{}, client.getStaticSiteBuildHandleError(resp)
	}
	return client.getStaticSiteBuildHandleResponse(resp)
}

// getStaticSiteBuildCreateRequest creates the GetStaticSiteBuild request.
func (client *StaticSitesClient) getStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesGetStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStaticSiteBuildHandleResponse handles the GetStaticSiteBuild response.
func (client *StaticSitesClient) getStaticSiteBuildHandleResponse(resp *http.Response) (StaticSitesGetStaticSiteBuildResponse, error) {
	result := StaticSitesGetStaticSiteBuildResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteBuildARMResource); err != nil {
		return StaticSitesGetStaticSiteBuildResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStaticSiteBuildHandleError handles the GetStaticSiteBuild error response.
func (client *StaticSitesClient) getStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStaticSiteBuilds - Description for Gets all static site builds for a particular static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetStaticSiteBuilds(resourceGroupName string, name string, options *StaticSitesGetStaticSiteBuildsOptions) *StaticSitesGetStaticSiteBuildsPager {
	return &StaticSitesGetStaticSiteBuildsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getStaticSiteBuildsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesGetStaticSiteBuildsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteBuildCollection.NextLink)
		},
	}
}

// getStaticSiteBuildsCreateRequest creates the GetStaticSiteBuilds request.
func (client *StaticSitesClient) getStaticSiteBuildsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetStaticSiteBuildsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStaticSiteBuildsHandleResponse handles the GetStaticSiteBuilds response.
func (client *StaticSitesClient) getStaticSiteBuildsHandleResponse(resp *http.Response) (StaticSitesGetStaticSiteBuildsResponse, error) {
	result := StaticSitesGetStaticSiteBuildsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteBuildCollection); err != nil {
		return StaticSitesGetStaticSiteBuildsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStaticSiteBuildsHandleError handles the GetStaticSiteBuilds error response.
func (client *StaticSitesClient) getStaticSiteBuildsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStaticSiteCustomDomain - Description for Gets an existing custom domain for a particular static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetStaticSiteCustomDomain(ctx context.Context, resourceGroupName string, name string, domainName string, options *StaticSitesGetStaticSiteCustomDomainOptions) (StaticSitesGetStaticSiteCustomDomainResponse, error) {
	req, err := client.getStaticSiteCustomDomainCreateRequest(ctx, resourceGroupName, name, domainName, options)
	if err != nil {
		return StaticSitesGetStaticSiteCustomDomainResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetStaticSiteCustomDomainResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetStaticSiteCustomDomainResponse{}, client.getStaticSiteCustomDomainHandleError(resp)
	}
	return client.getStaticSiteCustomDomainHandleResponse(resp)
}

// getStaticSiteCustomDomainCreateRequest creates the GetStaticSiteCustomDomain request.
func (client *StaticSitesClient) getStaticSiteCustomDomainCreateRequest(ctx context.Context, resourceGroupName string, name string, domainName string, options *StaticSitesGetStaticSiteCustomDomainOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainName == "" {
		return nil, errors.New("parameter domainName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainName}", url.PathEscape(domainName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStaticSiteCustomDomainHandleResponse handles the GetStaticSiteCustomDomain response.
func (client *StaticSitesClient) getStaticSiteCustomDomainHandleResponse(resp *http.Response) (StaticSitesGetStaticSiteCustomDomainResponse, error) {
	result := StaticSitesGetStaticSiteCustomDomainResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteCustomDomainOverviewARMResource); err != nil {
		return StaticSitesGetStaticSiteCustomDomainResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStaticSiteCustomDomainHandleError handles the GetStaticSiteCustomDomain error response.
func (client *StaticSitesClient) getStaticSiteCustomDomainHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStaticSitesByResourceGroup - Description for Gets all static sites in the specified resource group.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetStaticSitesByResourceGroup(resourceGroupName string, options *StaticSitesGetStaticSitesByResourceGroupOptions) *StaticSitesGetStaticSitesByResourceGroupPager {
	return &StaticSitesGetStaticSitesByResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getStaticSitesByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesGetStaticSitesByResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteCollection.NextLink)
		},
	}
}

// getStaticSitesByResourceGroupCreateRequest creates the GetStaticSitesByResourceGroup request.
func (client *StaticSitesClient) getStaticSitesByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *StaticSitesGetStaticSitesByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStaticSitesByResourceGroupHandleResponse handles the GetStaticSitesByResourceGroup response.
func (client *StaticSitesClient) getStaticSitesByResourceGroupHandleResponse(resp *http.Response) (StaticSitesGetStaticSitesByResourceGroupResponse, error) {
	result := StaticSitesGetStaticSitesByResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteCollection); err != nil {
		return StaticSitesGetStaticSitesByResourceGroupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getStaticSitesByResourceGroupHandleError handles the GetStaticSitesByResourceGroup error response.
func (client *StaticSitesClient) getStaticSitesByResourceGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetUserProvidedFunctionAppForStaticSite - Description for Gets the details of the user provided function app registered with a static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetUserProvidedFunctionAppForStaticSite(ctx context.Context, resourceGroupName string, name string, functionAppName string, options *StaticSitesGetUserProvidedFunctionAppForStaticSiteOptions) (StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse, error) {
	req, err := client.getUserProvidedFunctionAppForStaticSiteCreateRequest(ctx, resourceGroupName, name, functionAppName, options)
	if err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse{}, client.getUserProvidedFunctionAppForStaticSiteHandleError(resp)
	}
	return client.getUserProvidedFunctionAppForStaticSiteHandleResponse(resp)
}

// getUserProvidedFunctionAppForStaticSiteCreateRequest creates the GetUserProvidedFunctionAppForStaticSite request.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, functionAppName string, options *StaticSitesGetUserProvidedFunctionAppForStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProvidedFunctionAppForStaticSiteHandleResponse handles the GetUserProvidedFunctionAppForStaticSite response.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteHandleResponse(resp *http.Response) (StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse, error) {
	result := StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserProvidedFunctionAppARMResource); err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getUserProvidedFunctionAppForStaticSiteHandleError handles the GetUserProvidedFunctionAppForStaticSite error response.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetUserProvidedFunctionAppForStaticSiteBuild - Description for Gets the details of the user provided function app registered with a static site build
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetUserProvidedFunctionAppForStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, options *StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildOptions) (StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse, error) {
	req, err := client.getUserProvidedFunctionAppForStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, functionAppName, options)
	if err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse{}, client.getUserProvidedFunctionAppForStaticSiteBuildHandleError(resp)
	}
	return client.getUserProvidedFunctionAppForStaticSiteBuildHandleResponse(resp)
}

// getUserProvidedFunctionAppForStaticSiteBuildCreateRequest creates the GetUserProvidedFunctionAppForStaticSiteBuild request.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, options *StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProvidedFunctionAppForStaticSiteBuildHandleResponse handles the GetUserProvidedFunctionAppForStaticSiteBuild response.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteBuildHandleResponse(resp *http.Response) (StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse, error) {
	result := StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserProvidedFunctionAppARMResource); err != nil {
		return StaticSitesGetUserProvidedFunctionAppForStaticSiteBuildResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getUserProvidedFunctionAppForStaticSiteBuildHandleError handles the GetUserProvidedFunctionAppForStaticSiteBuild error response.
func (client *StaticSitesClient) getUserProvidedFunctionAppForStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetUserProvidedFunctionAppsForStaticSite - Description for Gets the details of the user provided function apps registered with a static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetUserProvidedFunctionAppsForStaticSite(resourceGroupName string, name string, options *StaticSitesGetUserProvidedFunctionAppsForStaticSiteOptions) *StaticSitesGetUserProvidedFunctionAppsForStaticSitePager {
	return &StaticSitesGetUserProvidedFunctionAppsForStaticSitePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getUserProvidedFunctionAppsForStaticSiteCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesGetUserProvidedFunctionAppsForStaticSiteResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteUserProvidedFunctionAppsCollection.NextLink)
		},
	}
}

// getUserProvidedFunctionAppsForStaticSiteCreateRequest creates the GetUserProvidedFunctionAppsForStaticSite request.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesGetUserProvidedFunctionAppsForStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProvidedFunctionAppsForStaticSiteHandleResponse handles the GetUserProvidedFunctionAppsForStaticSite response.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteHandleResponse(resp *http.Response) (StaticSitesGetUserProvidedFunctionAppsForStaticSiteResponse, error) {
	result := StaticSitesGetUserProvidedFunctionAppsForStaticSiteResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserProvidedFunctionAppsCollection); err != nil {
		return StaticSitesGetUserProvidedFunctionAppsForStaticSiteResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getUserProvidedFunctionAppsForStaticSiteHandleError handles the GetUserProvidedFunctionAppsForStaticSite error response.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetUserProvidedFunctionAppsForStaticSiteBuild - Description for Gets the details of the user provided function apps registered with a static site build
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) GetUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName string, name string, environmentName string, options *StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildOptions) *StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildPager {
	return &StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getUserProvidedFunctionAppsForStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteUserProvidedFunctionAppsCollection.NextLink)
		},
	}
}

// getUserProvidedFunctionAppsForStaticSiteBuildCreateRequest creates the GetUserProvidedFunctionAppsForStaticSiteBuild request.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProvidedFunctionAppsForStaticSiteBuildHandleResponse handles the GetUserProvidedFunctionAppsForStaticSiteBuild response.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteBuildHandleResponse(resp *http.Response) (StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildResponse, error) {
	result := StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserProvidedFunctionAppsCollection); err != nil {
		return StaticSitesGetUserProvidedFunctionAppsForStaticSiteBuildResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getUserProvidedFunctionAppsForStaticSiteBuildHandleError handles the GetUserProvidedFunctionAppsForStaticSiteBuild error response.
func (client *StaticSitesClient) getUserProvidedFunctionAppsForStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// List - Description for Get all Static Sites for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) List(options *StaticSitesListOptions) *StaticSitesListPager {
	return &StaticSitesListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteCollection.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *StaticSitesClient) listCreateRequest(ctx context.Context, options *StaticSitesListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/staticSites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *StaticSitesClient) listHandleResponse(resp *http.Response) (StaticSitesListResponse, error) {
	result := StaticSitesListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteCollection); err != nil {
		return StaticSitesListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *StaticSitesClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteAppSettings - Description for Gets the application settings of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteAppSettings(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteAppSettingsOptions) (StaticSitesListStaticSiteAppSettingsResponse, error) {
	req, err := client.listStaticSiteAppSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesListStaticSiteAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteAppSettingsResponse{}, client.listStaticSiteAppSettingsHandleError(resp)
	}
	return client.listStaticSiteAppSettingsHandleResponse(resp)
}

// listStaticSiteAppSettingsCreateRequest creates the ListStaticSiteAppSettings request.
func (client *StaticSitesClient) listStaticSiteAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listAppSettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteAppSettingsHandleResponse handles the ListStaticSiteAppSettings response.
func (client *StaticSitesClient) listStaticSiteAppSettingsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteAppSettingsResponse, error) {
	result := StaticSitesListStaticSiteAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesListStaticSiteAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteAppSettingsHandleError handles the ListStaticSiteAppSettings error response.
func (client *StaticSitesClient) listStaticSiteAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteBuildAppSettings - Description for Gets the application settings of a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteBuildAppSettings(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildAppSettingsOptions) (StaticSitesListStaticSiteBuildAppSettingsResponse, error) {
	req, err := client.listStaticSiteBuildAppSettingsCreateRequest(ctx, resourceGroupName, name, environmentName, options)
	if err != nil {
		return StaticSitesListStaticSiteBuildAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteBuildAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteBuildAppSettingsResponse{}, client.listStaticSiteBuildAppSettingsHandleError(resp)
	}
	return client.listStaticSiteBuildAppSettingsHandleResponse(resp)
}

// listStaticSiteBuildAppSettingsCreateRequest creates the ListStaticSiteBuildAppSettings request.
func (client *StaticSitesClient) listStaticSiteBuildAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listAppSettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteBuildAppSettingsHandleResponse handles the ListStaticSiteBuildAppSettings response.
func (client *StaticSitesClient) listStaticSiteBuildAppSettingsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteBuildAppSettingsResponse, error) {
	result := StaticSitesListStaticSiteBuildAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesListStaticSiteBuildAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteBuildAppSettingsHandleError handles the ListStaticSiteBuildAppSettings error response.
func (client *StaticSitesClient) listStaticSiteBuildAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteBuildFunctionAppSettings - Description for Gets the application settings of a static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteBuildFunctionAppSettings(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildFunctionAppSettingsOptions) (StaticSitesListStaticSiteBuildFunctionAppSettingsResponse, error) {
	req, err := client.listStaticSiteBuildFunctionAppSettingsCreateRequest(ctx, resourceGroupName, name, environmentName, options)
	if err != nil {
		return StaticSitesListStaticSiteBuildFunctionAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteBuildFunctionAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteBuildFunctionAppSettingsResponse{}, client.listStaticSiteBuildFunctionAppSettingsHandleError(resp)
	}
	return client.listStaticSiteBuildFunctionAppSettingsHandleResponse(resp)
}

// listStaticSiteBuildFunctionAppSettingsCreateRequest creates the ListStaticSiteBuildFunctionAppSettings request.
func (client *StaticSitesClient) listStaticSiteBuildFunctionAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildFunctionAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listFunctionAppSettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteBuildFunctionAppSettingsHandleResponse handles the ListStaticSiteBuildFunctionAppSettings response.
func (client *StaticSitesClient) listStaticSiteBuildFunctionAppSettingsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteBuildFunctionAppSettingsResponse, error) {
	result := StaticSitesListStaticSiteBuildFunctionAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesListStaticSiteBuildFunctionAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteBuildFunctionAppSettingsHandleError handles the ListStaticSiteBuildFunctionAppSettings error response.
func (client *StaticSitesClient) listStaticSiteBuildFunctionAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteBuildFunctions - Description for Gets the functions of a particular static site build.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteBuildFunctions(resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildFunctionsOptions) *StaticSitesListStaticSiteBuildFunctionsPager {
	return &StaticSitesListStaticSiteBuildFunctionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listStaticSiteBuildFunctionsCreateRequest(ctx, resourceGroupName, name, environmentName, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesListStaticSiteBuildFunctionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteFunctionOverviewCollection.NextLink)
		},
	}
}

// listStaticSiteBuildFunctionsCreateRequest creates the ListStaticSiteBuildFunctions request.
func (client *StaticSitesClient) listStaticSiteBuildFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, options *StaticSitesListStaticSiteBuildFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteBuildFunctionsHandleResponse handles the ListStaticSiteBuildFunctions response.
func (client *StaticSitesClient) listStaticSiteBuildFunctionsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteBuildFunctionsResponse, error) {
	result := StaticSitesListStaticSiteBuildFunctionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteFunctionOverviewCollection); err != nil {
		return StaticSitesListStaticSiteBuildFunctionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteBuildFunctionsHandleError handles the ListStaticSiteBuildFunctions error response.
func (client *StaticSitesClient) listStaticSiteBuildFunctionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteConfiguredRoles - Description for Lists the roles configured for the static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteConfiguredRoles(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteConfiguredRolesOptions) (StaticSitesListStaticSiteConfiguredRolesResponse, error) {
	req, err := client.listStaticSiteConfiguredRolesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesListStaticSiteConfiguredRolesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteConfiguredRolesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteConfiguredRolesResponse{}, client.listStaticSiteConfiguredRolesHandleError(resp)
	}
	return client.listStaticSiteConfiguredRolesHandleResponse(resp)
}

// listStaticSiteConfiguredRolesCreateRequest creates the ListStaticSiteConfiguredRoles request.
func (client *StaticSitesClient) listStaticSiteConfiguredRolesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteConfiguredRolesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listConfiguredRoles"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteConfiguredRolesHandleResponse handles the ListStaticSiteConfiguredRoles response.
func (client *StaticSitesClient) listStaticSiteConfiguredRolesHandleResponse(resp *http.Response) (StaticSitesListStaticSiteConfiguredRolesResponse, error) {
	result := StaticSitesListStaticSiteConfiguredRolesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringList); err != nil {
		return StaticSitesListStaticSiteConfiguredRolesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteConfiguredRolesHandleError handles the ListStaticSiteConfiguredRoles error response.
func (client *StaticSitesClient) listStaticSiteConfiguredRolesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteCustomDomains - Description for Gets all static site custom domains for a particular static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteCustomDomains(resourceGroupName string, name string, options *StaticSitesListStaticSiteCustomDomainsOptions) *StaticSitesListStaticSiteCustomDomainsPager {
	return &StaticSitesListStaticSiteCustomDomainsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listStaticSiteCustomDomainsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesListStaticSiteCustomDomainsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteCustomDomainOverviewCollection.NextLink)
		},
	}
}

// listStaticSiteCustomDomainsCreateRequest creates the ListStaticSiteCustomDomains request.
func (client *StaticSitesClient) listStaticSiteCustomDomainsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteCustomDomainsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteCustomDomainsHandleResponse handles the ListStaticSiteCustomDomains response.
func (client *StaticSitesClient) listStaticSiteCustomDomainsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteCustomDomainsResponse, error) {
	result := StaticSitesListStaticSiteCustomDomainsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteCustomDomainOverviewCollection); err != nil {
		return StaticSitesListStaticSiteCustomDomainsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteCustomDomainsHandleError handles the ListStaticSiteCustomDomains error response.
func (client *StaticSitesClient) listStaticSiteCustomDomainsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteFunctionAppSettings - Description for Gets the application settings of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteFunctionAppSettings(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteFunctionAppSettingsOptions) (StaticSitesListStaticSiteFunctionAppSettingsResponse, error) {
	req, err := client.listStaticSiteFunctionAppSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesListStaticSiteFunctionAppSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteFunctionAppSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteFunctionAppSettingsResponse{}, client.listStaticSiteFunctionAppSettingsHandleError(resp)
	}
	return client.listStaticSiteFunctionAppSettingsHandleResponse(resp)
}

// listStaticSiteFunctionAppSettingsCreateRequest creates the ListStaticSiteFunctionAppSettings request.
func (client *StaticSitesClient) listStaticSiteFunctionAppSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteFunctionAppSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listFunctionAppSettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteFunctionAppSettingsHandleResponse handles the ListStaticSiteFunctionAppSettings response.
func (client *StaticSitesClient) listStaticSiteFunctionAppSettingsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteFunctionAppSettingsResponse, error) {
	result := StaticSitesListStaticSiteFunctionAppSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesListStaticSiteFunctionAppSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteFunctionAppSettingsHandleError handles the ListStaticSiteFunctionAppSettings error response.
func (client *StaticSitesClient) listStaticSiteFunctionAppSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteFunctions - Description for Gets the functions of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteFunctions(resourceGroupName string, name string, options *StaticSitesListStaticSiteFunctionsOptions) *StaticSitesListStaticSiteFunctionsPager {
	return &StaticSitesListStaticSiteFunctionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listStaticSiteFunctionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesListStaticSiteFunctionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteFunctionOverviewCollection.NextLink)
		},
	}
}

// listStaticSiteFunctionsCreateRequest creates the ListStaticSiteFunctions request.
func (client *StaticSitesClient) listStaticSiteFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteFunctionsHandleResponse handles the ListStaticSiteFunctions response.
func (client *StaticSitesClient) listStaticSiteFunctionsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteFunctionsResponse, error) {
	result := StaticSitesListStaticSiteFunctionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteFunctionOverviewCollection); err != nil {
		return StaticSitesListStaticSiteFunctionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteFunctionsHandleError handles the ListStaticSiteFunctions error response.
func (client *StaticSitesClient) listStaticSiteFunctionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteSecrets - Description for Lists the secrets for an existing static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteSecrets(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteSecretsOptions) (StaticSitesListStaticSiteSecretsResponse, error) {
	req, err := client.listStaticSiteSecretsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StaticSitesListStaticSiteSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesListStaticSiteSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesListStaticSiteSecretsResponse{}, client.listStaticSiteSecretsHandleError(resp)
	}
	return client.listStaticSiteSecretsHandleResponse(resp)
}

// listStaticSiteSecretsCreateRequest creates the ListStaticSiteSecrets request.
func (client *StaticSitesClient) listStaticSiteSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *StaticSitesListStaticSiteSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listSecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteSecretsHandleResponse handles the ListStaticSiteSecrets response.
func (client *StaticSitesClient) listStaticSiteSecretsHandleResponse(resp *http.Response) (StaticSitesListStaticSiteSecretsResponse, error) {
	result := StaticSitesListStaticSiteSecretsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return StaticSitesListStaticSiteSecretsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteSecretsHandleError handles the ListStaticSiteSecrets error response.
func (client *StaticSitesClient) listStaticSiteSecretsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListStaticSiteUsers - Description for Gets the list of users of a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ListStaticSiteUsers(resourceGroupName string, name string, authprovider string, options *StaticSitesListStaticSiteUsersOptions) *StaticSitesListStaticSiteUsersPager {
	return &StaticSitesListStaticSiteUsersPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listStaticSiteUsersCreateRequest(ctx, resourceGroupName, name, authprovider, options)
		},
		advancer: func(ctx context.Context, resp StaticSitesListStaticSiteUsersResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.StaticSiteUserCollection.NextLink)
		},
	}
}

// listStaticSiteUsersCreateRequest creates the ListStaticSiteUsers request.
func (client *StaticSitesClient) listStaticSiteUsersCreateRequest(ctx context.Context, resourceGroupName string, name string, authprovider string, options *StaticSitesListStaticSiteUsersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/listUsers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if authprovider == "" {
		return nil, errors.New("parameter authprovider cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authprovider}", url.PathEscape(authprovider))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listStaticSiteUsersHandleResponse handles the ListStaticSiteUsers response.
func (client *StaticSitesClient) listStaticSiteUsersHandleResponse(resp *http.Response) (StaticSitesListStaticSiteUsersResponse, error) {
	result := StaticSitesListStaticSiteUsersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserCollection); err != nil {
		return StaticSitesListStaticSiteUsersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listStaticSiteUsersHandleError handles the ListStaticSiteUsers error response.
func (client *StaticSitesClient) listStaticSiteUsersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PreviewWorkflow - Description for Generates a preview workflow file for the static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) PreviewWorkflow(ctx context.Context, location string, staticSitesWorkflowPreviewRequest StaticSitesWorkflowPreviewRequest, options *StaticSitesPreviewWorkflowOptions) (StaticSitesPreviewWorkflowResponse, error) {
	req, err := client.previewWorkflowCreateRequest(ctx, location, staticSitesWorkflowPreviewRequest, options)
	if err != nil {
		return StaticSitesPreviewWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesPreviewWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesPreviewWorkflowResponse{}, client.previewWorkflowHandleError(resp)
	}
	return client.previewWorkflowHandleResponse(resp)
}

// previewWorkflowCreateRequest creates the PreviewWorkflow request.
func (client *StaticSitesClient) previewWorkflowCreateRequest(ctx context.Context, location string, staticSitesWorkflowPreviewRequest StaticSitesWorkflowPreviewRequest, options *StaticSitesPreviewWorkflowOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/previewStaticSiteWorkflowFile"
	if location == "" {
		return nil, errors.New("parameter location cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{location}", url.PathEscape(location))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSitesWorkflowPreviewRequest)
}

// previewWorkflowHandleResponse handles the PreviewWorkflow response.
func (client *StaticSitesClient) previewWorkflowHandleResponse(resp *http.Response) (StaticSitesPreviewWorkflowResponse, error) {
	result := StaticSitesPreviewWorkflowResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSitesWorkflowPreview); err != nil {
		return StaticSitesPreviewWorkflowResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// previewWorkflowHandleError handles the PreviewWorkflow error response.
func (client *StaticSitesClient) previewWorkflowHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRegisterUserProvidedFunctionAppWithStaticSite - Description for Register a user provided function app with a static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginRegisterUserProvidedFunctionAppWithStaticSite(ctx context.Context, resourceGroupName string, name string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteOptions) (StaticSitesRegisterUserProvidedFunctionAppWithStaticSitePollerResponse, error) {
	resp, err := client.registerUserProvidedFunctionAppWithStaticSite(ctx, resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options)
	if err != nil {
		return StaticSitesRegisterUserProvidedFunctionAppWithStaticSitePollerResponse{}, err
	}
	result := StaticSitesRegisterUserProvidedFunctionAppWithStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.RegisterUserProvidedFunctionAppWithStaticSite", "", resp, client.pl, client.registerUserProvidedFunctionAppWithStaticSiteHandleError)
	if err != nil {
		return StaticSitesRegisterUserProvidedFunctionAppWithStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesRegisterUserProvidedFunctionAppWithStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// RegisterUserProvidedFunctionAppWithStaticSite - Description for Register a user provided function app with a static site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSite(ctx context.Context, resourceGroupName string, name string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteOptions) (*http.Response, error) {
	req, err := client.registerUserProvidedFunctionAppWithStaticSiteCreateRequest(ctx, resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.registerUserProvidedFunctionAppWithStaticSiteHandleError(resp)
	}
	return resp, nil
}

// registerUserProvidedFunctionAppWithStaticSiteCreateRequest creates the RegisterUserProvidedFunctionAppWithStaticSite request.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IsForced != nil {
		reqQP.Set("isForced", strconv.FormatBool(*options.IsForced))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteUserProvidedFunctionEnvelope)
}

// registerUserProvidedFunctionAppWithStaticSiteHandleError handles the RegisterUserProvidedFunctionAppWithStaticSite error response.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRegisterUserProvidedFunctionAppWithStaticSiteBuild - Description for Register a user provided function app with a static site build
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginRegisterUserProvidedFunctionAppWithStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteBuildOptions) (StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildPollerResponse, error) {
	resp, err := client.registerUserProvidedFunctionAppWithStaticSiteBuild(ctx, resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options)
	if err != nil {
		return StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildPollerResponse{}, err
	}
	result := StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.RegisterUserProvidedFunctionAppWithStaticSiteBuild", "", resp, client.pl, client.registerUserProvidedFunctionAppWithStaticSiteBuildHandleError)
	if err != nil {
		return StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildPollerResponse{}, err
	}
	result.Poller = &StaticSitesRegisterUserProvidedFunctionAppWithStaticSiteBuildPoller{
		pt: pt,
	}
	return result, nil
}

// RegisterUserProvidedFunctionAppWithStaticSiteBuild - Description for Register a user provided function app with a static site build
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSiteBuild(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteBuildOptions) (*http.Response, error) {
	req, err := client.registerUserProvidedFunctionAppWithStaticSiteBuildCreateRequest(ctx, resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.registerUserProvidedFunctionAppWithStaticSiteBuildHandleError(resp)
	}
	return resp, nil
}

// registerUserProvidedFunctionAppWithStaticSiteBuildCreateRequest creates the RegisterUserProvidedFunctionAppWithStaticSiteBuild request.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSiteBuildCreateRequest(ctx context.Context, resourceGroupName string, name string, environmentName string, functionAppName string, staticSiteUserProvidedFunctionEnvelope StaticSiteUserProvidedFunctionAppARMResource, options *StaticSitesBeginRegisterUserProvidedFunctionAppWithStaticSiteBuildOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if environmentName == "" {
		return nil, errors.New("parameter environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environmentName}", url.PathEscape(environmentName))
	if functionAppName == "" {
		return nil, errors.New("parameter functionAppName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionAppName}", url.PathEscape(functionAppName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IsForced != nil {
		reqQP.Set("isForced", strconv.FormatBool(*options.IsForced))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteUserProvidedFunctionEnvelope)
}

// registerUserProvidedFunctionAppWithStaticSiteBuildHandleError handles the RegisterUserProvidedFunctionAppWithStaticSiteBuild error response.
func (client *StaticSitesClient) registerUserProvidedFunctionAppWithStaticSiteBuildHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetStaticSiteAPIKey - Description for Resets the api key for an existing static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) ResetStaticSiteAPIKey(ctx context.Context, resourceGroupName string, name string, resetPropertiesEnvelope StaticSiteResetPropertiesARMResource, options *StaticSitesResetStaticSiteAPIKeyOptions) (StaticSitesResetStaticSiteAPIKeyResponse, error) {
	req, err := client.resetStaticSiteAPIKeyCreateRequest(ctx, resourceGroupName, name, resetPropertiesEnvelope, options)
	if err != nil {
		return StaticSitesResetStaticSiteAPIKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesResetStaticSiteAPIKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesResetStaticSiteAPIKeyResponse{}, client.resetStaticSiteAPIKeyHandleError(resp)
	}
	return StaticSitesResetStaticSiteAPIKeyResponse{RawResponse: resp}, nil
}

// resetStaticSiteAPIKeyCreateRequest creates the ResetStaticSiteAPIKey request.
func (client *StaticSitesClient) resetStaticSiteAPIKeyCreateRequest(ctx context.Context, resourceGroupName string, name string, resetPropertiesEnvelope StaticSiteResetPropertiesARMResource, options *StaticSitesResetStaticSiteAPIKeyOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/resetapikey"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, resetPropertiesEnvelope)
}

// resetStaticSiteAPIKeyHandleError handles the ResetStaticSiteAPIKey error response.
func (client *StaticSitesClient) resetStaticSiteAPIKeyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateStaticSite - Description for Creates a new static site in an existing resource group, or updates an existing static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) UpdateStaticSite(ctx context.Context, resourceGroupName string, name string, staticSiteEnvelope StaticSitePatchResource, options *StaticSitesUpdateStaticSiteOptions) (StaticSitesUpdateStaticSiteResponse, error) {
	req, err := client.updateStaticSiteCreateRequest(ctx, resourceGroupName, name, staticSiteEnvelope, options)
	if err != nil {
		return StaticSitesUpdateStaticSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesUpdateStaticSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return StaticSitesUpdateStaticSiteResponse{}, client.updateStaticSiteHandleError(resp)
	}
	return client.updateStaticSiteHandleResponse(resp)
}

// updateStaticSiteCreateRequest creates the UpdateStaticSite request.
func (client *StaticSitesClient) updateStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, staticSiteEnvelope StaticSitePatchResource, options *StaticSitesUpdateStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteEnvelope)
}

// updateStaticSiteHandleResponse handles the UpdateStaticSite response.
func (client *StaticSitesClient) updateStaticSiteHandleResponse(resp *http.Response) (StaticSitesUpdateStaticSiteResponse, error) {
	result := StaticSitesUpdateStaticSiteResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteARMResource); err != nil {
		return StaticSitesUpdateStaticSiteResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateStaticSiteHandleError handles the UpdateStaticSite error response.
func (client *StaticSitesClient) updateStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateStaticSiteUser - Description for Updates a user entry with the listed roles
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) UpdateStaticSiteUser(ctx context.Context, resourceGroupName string, name string, authprovider string, userid string, staticSiteUserEnvelope StaticSiteUserARMResource, options *StaticSitesUpdateStaticSiteUserOptions) (StaticSitesUpdateStaticSiteUserResponse, error) {
	req, err := client.updateStaticSiteUserCreateRequest(ctx, resourceGroupName, name, authprovider, userid, staticSiteUserEnvelope, options)
	if err != nil {
		return StaticSitesUpdateStaticSiteUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return StaticSitesUpdateStaticSiteUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return StaticSitesUpdateStaticSiteUserResponse{}, client.updateStaticSiteUserHandleError(resp)
	}
	return client.updateStaticSiteUserHandleResponse(resp)
}

// updateStaticSiteUserCreateRequest creates the UpdateStaticSiteUser request.
func (client *StaticSitesClient) updateStaticSiteUserCreateRequest(ctx context.Context, resourceGroupName string, name string, authprovider string, userid string, staticSiteUserEnvelope StaticSiteUserARMResource, options *StaticSitesUpdateStaticSiteUserOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if authprovider == "" {
		return nil, errors.New("parameter authprovider cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authprovider}", url.PathEscape(authprovider))
	if userid == "" {
		return nil, errors.New("parameter userid cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userid}", url.PathEscape(userid))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteUserEnvelope)
}

// updateStaticSiteUserHandleResponse handles the UpdateStaticSiteUser response.
func (client *StaticSitesClient) updateStaticSiteUserHandleResponse(resp *http.Response) (StaticSitesUpdateStaticSiteUserResponse, error) {
	result := StaticSitesUpdateStaticSiteUserResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StaticSiteUserARMResource); err != nil {
		return StaticSitesUpdateStaticSiteUserResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateStaticSiteUserHandleError handles the UpdateStaticSiteUser error response.
func (client *StaticSitesClient) updateStaticSiteUserHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginValidateCustomDomainCanBeAddedToStaticSite - Description for Validates a particular custom domain can be added to a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) BeginValidateCustomDomainCanBeAddedToStaticSite(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginValidateCustomDomainCanBeAddedToStaticSiteOptions) (StaticSitesValidateCustomDomainCanBeAddedToStaticSitePollerResponse, error) {
	resp, err := client.validateCustomDomainCanBeAddedToStaticSite(ctx, resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options)
	if err != nil {
		return StaticSitesValidateCustomDomainCanBeAddedToStaticSitePollerResponse{}, err
	}
	result := StaticSitesValidateCustomDomainCanBeAddedToStaticSitePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("StaticSitesClient.ValidateCustomDomainCanBeAddedToStaticSite", "", resp, client.pl, client.validateCustomDomainCanBeAddedToStaticSiteHandleError)
	if err != nil {
		return StaticSitesValidateCustomDomainCanBeAddedToStaticSitePollerResponse{}, err
	}
	result.Poller = &StaticSitesValidateCustomDomainCanBeAddedToStaticSitePoller{
		pt: pt,
	}
	return result, nil
}

// ValidateCustomDomainCanBeAddedToStaticSite - Description for Validates a particular custom domain can be added to a static site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *StaticSitesClient) validateCustomDomainCanBeAddedToStaticSite(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginValidateCustomDomainCanBeAddedToStaticSiteOptions) (*http.Response, error) {
	req, err := client.validateCustomDomainCanBeAddedToStaticSiteCreateRequest(ctx, resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.validateCustomDomainCanBeAddedToStaticSiteHandleError(resp)
	}
	return resp, nil
}

// validateCustomDomainCanBeAddedToStaticSiteCreateRequest creates the ValidateCustomDomainCanBeAddedToStaticSite request.
func (client *StaticSitesClient) validateCustomDomainCanBeAddedToStaticSiteCreateRequest(ctx context.Context, resourceGroupName string, name string, domainName string, staticSiteCustomDomainRequestPropertiesEnvelope StaticSiteCustomDomainRequestPropertiesARMResource, options *StaticSitesBeginValidateCustomDomainCanBeAddedToStaticSiteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainName == "" {
		return nil, errors.New("parameter domainName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainName}", url.PathEscape(domainName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, staticSiteCustomDomainRequestPropertiesEnvelope)
}

// validateCustomDomainCanBeAddedToStaticSiteHandleError handles the ValidateCustomDomainCanBeAddedToStaticSite error response.
func (client *StaticSitesClient) validateCustomDomainCanBeAddedToStaticSiteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
